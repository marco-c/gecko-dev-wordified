<
!
-
-
Any
copyright
is
dedicated
to
the
Public
Domain
.
-
http
:
/
/
creativecommons
.
org
/
publicdomain
/
zero
/
1
.
0
/
-
-
>
<
!
DOCTYPE
HTML
>
<
html
>
<
head
>
<
meta
charset
=
"
utf
-
8
"
>
<
title
>
Test
the
IOUtils
file
I
/
O
API
<
/
title
>
<
script
src
=
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
SimpleTest
.
js
"
>
<
/
script
>
<
!
-
-
-
This
implementation
is
compared
against
an
already
well
-
tested
reference
implementation
of
File
I
/
0
.
-
-
>
<
script
src
=
"
resource
:
/
/
gre
/
modules
/
FileTestUtils
.
jsm
"
>
<
/
script
>
<
link
rel
=
"
stylesheet
"
href
=
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
test
.
css
"
/
>
<
script
>
"
use
strict
"
;
const
{
Assert
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
Assert
.
jsm
"
)
;
const
{
ObjectUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
jsm
"
)
;
/
/
TODO
:
Remove
this
import
for
OS
.
File
.
It
is
currently
being
used
as
a
/
/
stop
gap
for
missing
IOUtils
functionality
.
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
const
tmpDir
=
OS
.
Constants
.
Path
.
tmpDir
;
add_task
(
async
function
test_api_is_available_on_window
(
)
{
ok
(
window
.
IOUtils
"
IOUtils
is
present
on
the
window
"
)
;
}
)
;
add_task
(
async
function
test_read_failure
(
)
{
/
/
TODO
:
Stop
using
relative
paths
.
await
Assert
.
rejects
(
window
.
IOUtils
.
read
(
"
does_not_exist
.
txt
"
)
/
Could
not
open
file
/
"
IOUtils
:
:
read
rejects
when
file
does
not
exist
"
)
;
}
)
;
add_task
(
async
function
test_write_no_overwrite
(
)
{
/
/
TODO
:
Stop
using
relative
paths
.
/
/
Make
a
new
file
and
try
to
write
to
it
with
overwrites
disabled
.
const
tmpFileName
=
"
test_ioutils_overwrite
.
tmp
"
;
const
untouchableContents
=
new
TextEncoder
(
)
.
encode
(
"
Can
'
t
touch
this
!
\
n
"
)
;
await
window
.
IOUtils
.
writeAtomic
(
tmpFileName
untouchableContents
)
;
const
newContents
=
new
TextEncoder
(
)
.
encode
(
"
Nah
nah
nah
!
\
n
"
)
;
await
Assert
.
rejects
(
window
.
IOUtils
.
writeAtomic
(
tmpFileName
newContents
{
noOverwrite
:
true
}
)
/
Refusing
to
overwrite
file
/
"
IOUtils
:
:
writeAtomic
rejects
writing
to
existing
file
if
overwrites
are
disabled
"
)
;
const
bytesWritten
=
await
window
.
IOUtils
.
writeAtomic
(
tmpFileName
newContents
{
noOverwrite
:
false
/
*
Default
.
*
/
}
)
;
is
(
bytesWritten
newContents
.
length
"
IOUtils
:
:
writeAtomic
can
overwrite
files
if
specified
"
)
;
await
cleanup
(
tmpFileName
)
;
}
)
;
add_task
(
async
function
test_partial_read
(
)
{
/
/
TODO
:
Stop
using
relative
paths
.
const
tmpFileName
=
"
test_ioutils_partial_read
.
tmp
"
;
const
bytes
=
Uint8Array
.
of
(
.
.
.
new
Array
(
50
)
.
keys
(
)
)
;
const
bytesWritten
=
await
window
.
IOUtils
.
writeAtomic
(
tmpFileName
bytes
)
;
is
(
bytesWritten
50
"
IOUtils
:
:
writeAtomic
can
write
entire
byte
array
to
file
"
)
;
/
/
Read
just
the
first
10
bytes
.
const
first10
=
bytes
.
slice
(
0
10
)
;
const
bytes10
=
await
window
.
IOUtils
.
read
(
tmpFileName
10
)
;
ok
(
ObjectUtils
.
deepEqual
(
bytes10
first10
)
"
IOUtils
:
:
read
can
read
part
of
a
file
up
to
specified
max
bytes
"
)
;
/
/
Trying
to
explicitly
read
nothing
isn
'
t
useful
but
it
should
still
/
/
succeed
.
const
bytes0
=
await
window
.
IOUtils
.
read
(
tmpFileName
0
)
;
is
(
bytes0
.
length
0
"
IOUtils
:
:
read
can
read
0
bytes
"
)
;
await
cleanup
(
tmpFileName
)
;
}
)
;
add_task
(
async
function
test_empty_read_and_write
(
)
{
/
/
TODO
:
Stop
using
relative
paths
.
/
/
Trying
to
write
an
empty
file
isn
'
t
very
useful
but
it
should
still
/
/
succeed
.
const
tmpFileName
=
"
test_ioutils_empty
.
tmp
"
;
const
emptyByteArray
=
new
Uint8Array
(
0
)
;
const
bytesWritten
=
await
window
.
IOUtils
.
writeAtomic
(
tmpFileName
emptyByteArray
)
;
is
(
bytesWritten
0
"
IOUtils
:
:
writeAtomic
can
create
an
empty
file
"
)
;
/
/
Trying
to
explicitly
read
nothing
isn
'
t
useful
but
it
should
still
/
/
succeed
.
const
bytes0
=
await
window
.
IOUtils
.
read
(
tmpFileName
0
)
;
is
(
bytes0
.
length
0
"
IOUtils
:
:
read
can
read
0
bytes
"
)
;
/
/
Implicitly
try
to
read
nothing
.
const
nothing
=
await
window
.
IOUtils
.
read
(
tmpFileName
)
;
is
(
nothing
.
length
0
"
IOUtils
:
:
read
can
read
empty
files
"
)
;
await
cleanup
(
tmpFileName
)
;
}
)
;
add_task
(
async
function
test_full_read_and_write
(
)
{
/
/
TODO
:
Stop
using
relative
paths
.
/
/
Write
a
file
.
info
(
"
Test
writing
to
a
new
binary
file
"
)
;
const
tmpFileName
=
"
test_ioutils_numbers
.
tmp
"
;
const
bytes
=
Uint8Array
.
of
(
.
.
.
new
Array
(
50
)
.
keys
(
)
)
;
const
bytesWritten
=
await
window
.
IOUtils
.
writeAtomic
(
tmpFileName
bytes
)
;
is
(
bytesWritten
50
"
IOUtils
:
:
writeAtomic
can
write
entire
byte
array
to
file
"
)
;
/
/
Read
it
back
.
info
(
"
Test
reading
a
binary
file
"
)
;
let
fileContents
=
await
window
.
IOUtils
.
read
(
tmpFileName
)
;
ok
(
ObjectUtils
.
deepEqual
(
bytes
fileContents
)
&
&
bytes
.
length
=
=
fileContents
.
length
"
IOUtils
:
:
read
can
read
back
entire
file
"
)
;
const
tooManyBytes
=
bytes
.
length
+
1
;
fileContents
=
await
window
.
IOUtils
.
read
(
tmpFileName
tooManyBytes
)
;
ok
(
ObjectUtils
.
deepEqual
(
bytes
fileContents
)
&
&
fileContents
.
length
=
=
bytes
.
length
"
IOUtils
:
:
read
can
read
entire
file
when
requested
maxBytes
is
too
large
"
)
;
/
/
Clean
up
.
await
cleanup
(
tmpFileName
)
;
}
)
;
add_task
(
async
function
test_move_relative_path
(
)
{
const
tmpFileName
=
OS
.
Path
.
join
(
tmpDir
"
test_ioutils_move_relative_path
.
tmp
"
)
;
const
dest
=
"
relative_to_cwd
.
tmp
"
;
await
createFile
(
tmpFileName
"
source
"
)
;
info
(
"
Test
moving
a
file
to
a
relative
destination
"
)
;
await
Assert
.
rejects
(
window
.
IOUtils
.
move
(
tmpFileName
dest
)
/
Only
absolute
file
paths
are
permitted
/
"
IOUtils
:
:
move
only
works
with
absolute
paths
"
)
;
ok
(
await
fileHasTextContents
(
tmpFileName
"
source
"
)
"
IOUtils
:
:
move
doesn
'
t
change
source
file
when
move
fails
"
)
;
cleanup
(
tmpFileName
)
;
}
)
;
add_task
(
async
function
test_move_rename
(
)
{
/
/
Set
up
.
const
tmpFileName
=
OS
.
Path
.
join
(
tmpDir
"
test_ioutils_move_src
.
tmp
"
)
;
const
destFileName
=
OS
.
Path
.
join
(
tmpDir
"
test_ioutils_move_dest
.
tmp
"
)
;
await
createFile
(
tmpFileName
"
dest
"
)
;
/
/
Test
.
info
(
"
Test
move
to
new
file
in
same
directory
"
)
;
await
window
.
IOUtils
.
move
(
tmpFileName
destFileName
)
;
info
(
moved
{
tmpFileName
}
to
{
destFileName
}
)
;
ok
(
!
await
fileExists
(
tmpFileName
)
&
&
await
fileHasTextContents
(
destFileName
"
dest
"
)
"
IOUtils
:
:
move
can
move
source
to
dest
in
same
directory
"
)
/
/
Set
up
.
info
(
"
Test
move
to
existing
file
with
no
overwrite
"
)
;
await
createFile
(
tmpFileName
"
source
"
)
;
/
/
Test
.
await
Assert
.
rejects
(
window
.
IOUtils
.
move
(
tmpFileName
destFileName
{
noOverwrite
:
true
}
)
/
Destination
file
exists
and
overwrites
are
not
allowed
/
"
IOUtils
:
:
move
will
refuse
to
move
a
file
if
overwrites
are
disabled
"
)
;
ok
(
await
fileExists
(
tmpFileName
)
&
&
await
fileHasTextContents
(
destFileName
"
dest
"
)
"
Failed
IOUtils
:
:
move
doesn
'
t
move
the
source
file
"
)
;
/
/
Test
.
info
(
"
Test
move
to
existing
file
with
overwrite
"
)
;
await
window
.
IOUtils
.
move
(
tmpFileName
destFileName
{
noOverwrite
:
false
}
)
;
ok
(
!
await
fileExists
(
tmpFileName
)
"
IOUtils
:
:
move
moved
source
"
)
;
ok
(
await
fileHasTextContents
(
destFileName
"
source
"
)
"
IOUtils
:
:
move
overwrote
the
destination
with
the
source
"
)
;
/
/
Clean
up
.
await
cleanup
(
tmpFileName
destFileName
)
;
}
)
;
add_task
(
async
function
test_move_to_dir
(
)
{
/
/
Set
up
.
info
(
"
Test
move
and
rename
to
non
-
existing
directory
"
)
;
const
tmpFileName
=
OS
.
Path
.
join
(
tmpDir
"
test_move_to_dir
.
tmp
"
)
;
const
destDir
=
OS
.
Path
.
join
(
tmpDir
"
test_move_to_dir
.
tmp
.
d
"
)
;
const
dest
=
OS
.
Path
.
join
(
destDir
"
dest
.
tmp
"
)
;
await
createFile
(
tmpFileName
)
;
/
/
Test
.
ok
(
!
await
OS
.
File
.
exists
(
destDir
)
"
Expected
path
not
to
exist
"
)
;
await
window
.
IOUtils
.
move
(
tmpFileName
dest
)
;
ok
(
!
await
fileExists
(
tmpFileName
)
&
&
await
fileExists
(
dest
)
"
IOUtils
:
:
move
creates
non
-
existing
parents
if
needed
"
)
;
/
/
Set
up
.
info
(
"
Test
move
and
rename
to
existing
directory
.
"
)
await
createFile
(
tmpFileName
)
;
/
/
Test
.
ok
(
await
OS
.
File
.
exists
(
destDir
)
"
Expected
path
to
exist
"
)
;
await
window
.
IOUtils
.
move
(
tmpFileName
dest
)
;
ok
(
!
await
fileExists
(
tmpFileName
)
&
&
await
fileExists
(
dest
)
"
IOUtils
:
:
move
can
move
/
rename
a
file
into
an
existing
dir
"
)
;
/
/
Set
up
.
info
(
"
Test
move
to
existing
directory
without
specifying
leaf
name
.
"
)
await
createFile
(
tmpFileName
)
;
/
/
Test
.
await
window
.
IOUtils
.
move
(
tmpFileName
destDir
)
;
ok
(
await
OS
.
File
.
exists
(
destDir
)
"
Expected
path
to
exist
"
)
;
ok
(
!
await
fileExists
(
tmpFileName
)
&
&
await
fileExists
(
OS
.
Path
.
join
(
destDir
OS
.
Path
.
basename
(
tmpFileName
)
)
)
"
IOUtils
:
:
move
can
move
a
file
into
an
existing
dir
"
)
;
/
/
Clean
up
.
await
OS
.
File
.
removeDir
(
destDir
)
;
}
)
;
add_task
(
async
function
test_move_dir
(
)
{
/
/
Set
up
.
info
(
"
Test
rename
an
empty
directory
"
)
;
const
srcDir
=
OS
.
Path
.
join
(
tmpDir
"
test_move_dir
.
tmp
.
d
"
)
;
const
destDir
=
OS
.
Path
.
join
(
tmpDir
"
test_move_dir_dest
.
tmp
.
d
"
)
;
await
OS
.
File
.
makeDir
(
srcDir
)
;
/
/
Test
.
await
window
.
IOUtils
.
move
(
srcDir
destDir
)
;
ok
(
!
await
OS
.
File
.
exists
(
srcDir
)
&
&
await
OS
.
File
.
exists
(
destDir
)
"
IOUtils
:
:
move
can
rename
directories
"
)
;
/
/
Set
up
.
info
(
"
Test
move
directory
and
its
content
into
another
directory
"
)
;
await
OS
.
File
.
makeDir
(
srcDir
)
;
await
createFile
(
OS
.
Path
.
join
(
srcDir
"
file
.
tmp
"
)
"
foo
"
)
;
/
/
Test
.
await
window
.
IOUtils
.
move
(
srcDir
destDir
)
;
const
destFile
=
OS
.
Path
.
join
(
destDir
OS
.
Path
.
basename
(
srcDir
)
"
file
.
tmp
"
)
;
ok
(
!
await
OS
.
File
.
exists
(
srcDir
)
&
&
await
OS
.
File
.
exists
(
destDir
)
&
&
await
OS
.
File
.
exists
(
OS
.
Path
.
join
(
destDir
OS
.
Path
.
basename
(
srcDir
)
)
)
&
&
await
fileHasTextContents
(
destFile
"
foo
"
)
"
IOUtils
:
:
move
can
move
a
directory
and
its
contents
into
another
one
"
)
/
/
Clean
up
.
await
OS
.
File
.
removeDir
(
destDir
)
;
}
)
;
add_task
(
async
function
test_move_failures
(
)
{
/
/
Set
up
.
info
(
"
Test
attempt
to
rename
a
non
-
existent
source
file
"
)
;
const
notExistsSrc
=
OS
.
Path
.
join
(
tmpDir
"
not_exists_src
.
tmp
"
)
;
const
notExistsDest
=
OS
.
Path
.
join
(
tmpDir
"
not_exists_dest
.
tmp
"
)
;
/
/
Test
.
await
Assert
.
rejects
(
window
.
IOUtils
.
move
(
notExistsSrc
notExistsDest
)
/
Source
file
does
not
exist
/
"
IOUtils
:
:
move
throws
if
source
file
does
not
exist
"
)
;
ok
(
!
await
fileExists
(
notExistsSrc
)
&
&
!
await
fileExists
(
notExistsDest
)
"
IOUtils
:
:
move
fails
if
source
file
does
not
exist
"
)
;
/
/
Set
up
.
info
(
"
Test
attempt
to
move
a
directory
to
a
file
"
)
;
const
destFile
=
OS
.
Path
.
join
(
tmpDir
"
test_move_failures_file_dest
.
tmp
"
)
;
const
srcDir
=
OS
.
Path
.
join
(
tmpDir
"
test_move_failure_src
.
tmp
.
d
"
)
;
await
createFile
(
destFile
)
;
await
OS
.
File
.
makeDir
(
srcDir
)
;
/
/
Test
.
await
Assert
.
rejects
(
window
.
IOUtils
.
move
(
srcDir
destFile
)
/
Source
is
a
directory
but
destination
is
not
/
"
IOUtils
:
:
move
throws
if
try
to
move
dir
into
an
existing
file
"
)
;
/
/
Clean
up
.
await
cleanup
(
destFile
)
;
await
OS
.
File
.
removeDir
(
srcDir
)
;
}
)
;
/
/
Utility
functions
.
async
function
createFile
(
location
contents
=
"
"
)
{
if
(
typeof
contents
=
=
=
"
string
"
)
{
contents
=
new
TextEncoder
(
)
.
encode
(
contents
)
;
}
await
window
.
IOUtils
.
writeAtomic
(
location
contents
)
;
const
exists
=
await
fileExists
(
location
)
;
ok
(
exists
Created
temporary
file
at
:
{
location
}
)
;
}
async
function
fileHasTextContents
(
location
expectedContents
)
{
if
(
typeof
expectedContents
!
=
=
"
string
"
)
{
throw
new
TypeError
(
"
expectedContents
must
be
a
string
"
)
;
}
info
(
opening
{
location
}
for
reading
)
;
const
bytes
=
await
window
.
IOUtils
.
read
(
location
)
;
const
contents
=
new
TextDecoder
(
)
.
decode
(
bytes
)
;
return
contents
=
=
=
expectedContents
;
}
async
function
fileExists
(
file
)
{
try
{
await
window
.
IOUtils
.
read
(
file
)
;
}
catch
(
ex
)
{
return
false
;
}
return
true
;
}
async
function
cleanup
(
.
.
.
files
)
{
for
(
const
file
of
files
)
{
await
OS
.
File
.
remove
(
file
)
;
const
exists
=
await
fileExists
(
file
)
;
ok
(
!
exists
Removed
temporary
file
:
{
file
}
)
;
}
}
<
/
script
>
<
/
head
>
<
body
>
<
p
id
=
"
display
"
>
<
/
p
>
<
div
id
=
"
content
"
style
=
"
display
:
none
"
>
<
/
div
>
<
pre
id
=
"
test
"
>
<
/
pre
>
<
/
body
>
<
/
html
>
