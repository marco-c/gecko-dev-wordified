<
!
-
-
Any
copyright
is
dedicated
to
the
Public
Domain
.
-
http
:
/
/
creativecommons
.
org
/
publicdomain
/
zero
/
1
.
0
/
-
-
>
<
!
DOCTYPE
HTML
>
<
html
>
<
head
>
<
meta
charset
=
"
utf
-
8
"
>
<
title
>
Test
the
IOUtils
file
I
/
O
API
<
/
title
>
<
script
src
=
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
SimpleTest
.
js
"
>
<
/
script
>
<
link
rel
=
"
stylesheet
"
href
=
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
test
.
css
"
/
>
<
script
src
=
"
file_ioutils_test_fixtures
.
js
"
>
<
/
script
>
<
script
>
"
use
strict
"
;
const
{
Assert
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
Assert
.
jsm
"
)
;
const
{
ObjectUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
jsm
"
)
;
/
/
TODO
:
Remove
this
import
for
OS
.
File
.
It
is
currently
being
used
as
a
/
/
stop
gap
for
missing
IOUtils
functionality
.
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
const
tmpDir
=
OS
.
Constants
.
Path
.
tmpDir
;
/
/
This
is
an
impossible
sequence
of
bytes
in
an
UTF
-
8
encoded
file
.
/
/
See
section
3
.
5
.
3
of
this
text
:
/
/
https
:
/
/
www
.
cl
.
cam
.
ac
.
uk
/
~
mgk25
/
ucs
/
examples
/
UTF
-
8
-
test
.
txt
const
invalidUTF8
=
Uint8Array
.
of
(
0xfe
0xfe
0xff
0xff
)
;
add_task
(
async
function
test_read_utf8_failure
(
)
{
info
(
"
Test
attempt
to
read
non
-
existent
file
(
UTF8
)
"
)
;
const
doesNotExist
=
OS
.
Path
.
join
(
tmpDir
"
does_not_exist
.
tmp
"
)
;
await
Assert
.
rejects
(
IOUtils
.
readUTF8
(
doesNotExist
)
/
Could
not
open
the
file
at
.
*
/
"
IOUtils
:
:
readUTF8
rejects
when
file
does
not
exist
"
)
;
info
(
"
Test
attempt
to
read
invalid
UTF
-
8
"
)
;
const
invalidUTF8File
=
OS
.
Path
.
join
(
tmpDir
"
invalid_utf8
.
tmp
"
)
;
/
/
Deliberately
write
the
invalid
byte
sequence
to
file
.
await
IOUtils
.
writeAtomic
(
invalidUTF8File
invalidUTF8
)
;
await
Assert
.
rejects
(
IOUtils
.
readUTF8
(
invalidUTF8File
)
/
Could
not
read
file
\
(
.
*
\
)
because
it
is
not
UTF
-
8
encoded
/
"
IOUtils
:
:
readUTF8
will
reject
when
reading
a
file
that
is
not
valid
UTF
-
8
"
)
;
await
cleanup
(
invalidUTF8File
)
;
}
)
;
add_task
(
async
function
test_write_utf8_no_overwrite
(
)
{
/
/
Make
a
new
file
and
try
to
write
to
it
with
overwrites
disabled
.
const
tmpFileName
=
OS
.
Path
.
join
(
tmpDir
"
test_ioutils_write_utf8_overwrite
.
tmp
"
)
;
const
untouchableContents
=
"
Can
'
t
touch
this
!
\
n
"
;
await
IOUtils
.
writeAtomicUTF8
(
tmpFileName
untouchableContents
)
;
const
newContents
=
"
Nah
nah
nah
!
\
n
"
;
await
Assert
.
rejects
(
IOUtils
.
writeAtomicUTF8
(
tmpFileName
newContents
{
noOverwrite
:
true
}
)
/
Refusing
to
overwrite
the
file
at
*
/
"
IOUtils
:
:
writeAtomicUTF8
rejects
writing
to
existing
file
if
overwrites
are
disabled
"
)
;
ok
(
await
fileHasTextContents
(
tmpFileName
untouchableContents
)
"
IOUtils
:
:
writeAtomicUTF8
doesn
'
t
change
target
file
when
overwrite
is
refused
"
)
;
const
bytesWritten
=
await
IOUtils
.
writeAtomicUTF8
(
tmpFileName
newContents
{
noOverwrite
:
false
/
*
Default
.
*
/
}
)
;
is
(
bytesWritten
newContents
.
length
"
IOUtils
:
:
writeAtomicUTF8
can
overwrite
files
if
specified
"
)
;
ok
(
await
fileHasTextContents
(
tmpFileName
newContents
)
"
IOUtils
:
:
writeAtomicUTF8
overwrites
with
the
expected
contents
"
)
;
await
cleanup
(
tmpFileName
)
;
}
)
;
add_task
(
async
function
test_write_with_backup
(
)
{
info
(
"
Test
backup
file
option
with
non
-
existing
file
"
)
;
let
fileContents
=
"
Original
file
contents
"
;
let
destFileName
=
OS
.
Path
.
join
(
tmpDir
"
test_write_utf8_with_backup_option
.
tmp
"
)
;
let
backupFileName
=
destFileName
+
"
.
backup
"
;
let
bytesWritten
=
await
IOUtils
.
writeAtomicUTF8
(
destFileName
fileContents
{
backupFile
:
backupFileName
}
)
;
ok
(
await
fileHasTextContents
(
destFileName
"
Original
file
contents
"
)
"
IOUtils
:
:
writeAtomicUTF8
creates
a
new
file
with
the
correct
contents
"
)
;
ok
(
!
await
fileExists
(
backupFileName
)
"
IOUtils
:
:
writeAtomicUTF8
does
not
create
a
backup
if
the
target
file
does
not
exist
"
)
;
is
(
bytesWritten
fileContents
.
length
"
IOUtils
:
:
writeAtomic
correctly
writes
to
a
new
file
without
performing
a
backup
"
)
;
info
(
"
Test
backup
file
option
with
existing
destination
"
)
;
let
newFileContents
=
"
New
file
contents
"
;
ok
(
await
fileExists
(
destFileName
)
Expected
{
destFileName
}
to
exist
)
;
bytesWritten
=
await
IOUtils
.
writeAtomicUTF8
(
destFileName
newFileContents
{
backupFile
:
backupFileName
}
)
;
ok
(
await
fileHasTextContents
(
backupFileName
"
Original
file
contents
"
)
"
IOUtils
:
:
writeAtomicUTF8
can
backup
an
existing
file
before
writing
"
)
;
ok
(
await
fileHasTextContents
(
destFileName
"
New
file
contents
"
)
"
IOUtils
:
:
writeAtomicUTF8
can
create
the
target
with
the
correct
contents
"
)
;
is
(
bytesWritten
newFileContents
.
length
"
IOUtils
:
:
writeAtomicUTF8
correctly
writes
to
the
target
after
taking
a
backup
"
)
;
await
cleanup
(
destFileName
backupFileName
)
;
}
)
;
add_task
(
async
function
test_write_with_backup_and_tmp
(
)
{
info
(
"
Test
backup
with
tmp
and
backup
file
options
non
-
existing
destination
"
)
;
let
fileContents
=
"
Original
file
contents
"
;
let
destFileName
=
OS
.
Path
.
join
(
tmpDir
"
test_write_utf8_with_backup_and_tmp_options
.
tmp
"
)
;
let
backupFileName
=
destFileName
+
"
.
backup
"
;
let
tmpFileName
=
OS
.
Path
.
join
(
tmpDir
"
temp_file
.
tmp
"
)
;
let
bytesWritten
=
await
IOUtils
.
writeAtomicUTF8
(
destFileName
fileContents
{
backupFile
:
backupFileName
tmpPath
:
tmpFileName
}
)
;
ok
(
!
await
fileExists
(
tmpFileName
)
"
IOUtils
:
:
writeAtomicUTF8
cleans
up
the
tmpFile
"
)
;
ok
(
!
await
fileExists
(
backupFileName
)
"
IOUtils
:
:
writeAtomicUTF8
does
not
create
a
backup
if
the
target
file
does
not
exist
"
)
;
ok
(
await
fileHasTextContents
(
destFileName
"
Original
file
contents
"
)
"
IOUtils
:
:
writeAtomicUTF8
can
write
to
the
destination
when
a
temporary
file
is
used
"
)
;
is
(
bytesWritten
fileContents
.
length
"
IOUtils
:
:
writeAtomicUTF8
can
copy
tmp
file
to
destination
without
performing
a
backup
"
)
;
info
(
"
Test
backup
with
tmp
and
backup
file
options
existing
destination
"
)
;
let
newFileContents
=
"
New
file
contents
"
;
bytesWritten
=
await
IOUtils
.
writeAtomicUTF8
(
destFileName
newFileContents
{
backupFile
:
backupFileName
tmpPath
:
tmpFileName
}
)
;
ok
(
!
await
fileExists
(
tmpFileName
)
"
IOUtils
:
:
writeAtomicUTF8
cleans
up
the
tmpFile
"
)
;
ok
(
await
fileHasTextContents
(
backupFileName
"
Original
file
contents
"
)
"
IOUtils
:
:
writeAtomicUTF8
can
create
a
backup
if
the
target
file
exists
"
)
;
ok
(
await
fileHasTextContents
(
destFileName
"
New
file
contents
"
)
"
IOUtils
:
:
writeAtomicUTF8
can
write
to
the
destination
when
a
temporary
file
is
used
"
)
;
is
(
bytesWritten
newFileContents
.
length
"
IOUtils
:
:
writeAtomicUTF8
can
move
tmp
file
to
destination
after
performing
a
backup
"
)
;
await
cleanup
(
destFileName
backupFileName
)
;
}
)
;
add_task
(
async
function
test_empty_read_and_write_utf8
(
)
{
const
tmpFileName
=
OS
.
Path
.
join
(
tmpDir
"
test_ioutils_empty_utf8
.
tmp
"
)
;
const
emptyString
=
"
"
const
bytesWritten
=
await
IOUtils
.
writeAtomicUTF8
(
tmpFileName
emptyString
)
;
is
(
bytesWritten
0
"
IOUtils
:
:
writeAtomicUTF8
can
create
an
empty
file
"
)
;
const
nothing
=
await
IOUtils
.
readUTF8
(
tmpFileName
)
;
is
(
nothing
.
length
0
"
IOUtils
:
:
readUTF8
can
read
empty
files
"
)
;
await
cleanup
(
tmpFileName
)
;
}
)
;
add_task
(
async
function
test_full_read_and_write_utf8
(
)
{
/
/
Write
a
file
.
info
(
"
Test
writing
emoji
file
"
)
;
const
tmpFileName
=
OS
.
Path
.
join
(
tmpDir
"
test_ioutils_emoji
.
tmp
"
)
;
/
/
Make
sure
non
-
ASCII
text
is
supported
for
writing
and
reading
back
.
/
/
For
fun
a
sampling
of
space
-
separated
emoji
characters
from
different
/
/
Unicode
versions
including
multi
-
byte
glyphs
that
are
rendered
using
/
/
ZWJ
sequences
.
const
emoji
=
"
"
;
const
expectedBytes
=
71
;
const
bytesWritten
=
await
IOUtils
.
writeAtomicUTF8
(
tmpFileName
emoji
)
;
is
(
bytesWritten
expectedBytes
"
IOUtils
:
:
writeAtomicUTF8
can
write
emoji
to
file
"
)
;
/
/
Read
it
back
.
info
(
"
Test
reading
emoji
from
file
"
)
;
let
fileContents
=
await
IOUtils
.
readUTF8
(
tmpFileName
)
;
ok
(
emoji
=
=
fileContents
&
&
emoji
.
length
=
=
fileContents
.
length
"
IOUtils
:
:
readUTF8
can
read
back
entire
file
"
)
;
/
/
Clean
up
.
await
cleanup
(
tmpFileName
)
;
}
)
;
add_task
(
async
function
test_write_utf8_relative_path
(
)
{
const
tmpFileName
=
"
test_ioutils_write_utf8_relative_path
.
tmp
"
;
info
(
"
Test
writing
a
file
at
a
relative
destination
"
)
;
await
Assert
.
rejects
(
IOUtils
.
writeAtomicUTF8
(
tmpFileName
"
foo
"
)
/
Refusing
to
work
with
path
\
(
.
*
\
)
because
only
absolute
file
paths
are
permitted
/
"
IOUtils
:
:
writeAtomicUTF8
only
works
with
absolute
paths
"
)
;
}
)
;
add_task
(
async
function
test_read_utf8_relative_path
(
)
{
const
tmpFileName
=
"
test_ioutils_read_utf8_relative_path
.
tmp
"
;
info
(
"
Test
reading
a
file
at
a
relative
destination
"
)
;
await
Assert
.
rejects
(
IOUtils
.
readUTF8
(
tmpFileName
)
/
Refusing
to
work
with
path
\
(
.
*
\
)
because
only
absolute
file
paths
are
permitted
/
"
IOUtils
:
:
readUTF8
only
works
with
absolute
paths
"
)
;
}
)
;
<
/
script
>
<
/
head
>
<
body
>
<
p
id
=
"
display
"
>
<
/
p
>
<
div
id
=
"
content
"
style
=
"
display
:
none
"
>
<
/
div
>
<
pre
id
=
"
test
"
>
<
/
pre
>
<
/
body
>
<
/
html
>
