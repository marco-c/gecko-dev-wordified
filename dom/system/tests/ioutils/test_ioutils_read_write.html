<
!
-
-
Any
copyright
is
dedicated
to
the
Public
Domain
.
-
http
:
/
/
creativecommons
.
org
/
publicdomain
/
zero
/
1
.
0
/
-
-
>
<
!
DOCTYPE
HTML
>
<
html
>
<
head
>
<
meta
charset
=
"
utf
-
8
"
>
<
title
>
Test
the
IOUtils
file
I
/
O
API
<
/
title
>
<
script
src
=
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
SimpleTest
.
js
"
>
<
/
script
>
<
link
rel
=
"
stylesheet
"
href
=
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
test
.
css
"
/
>
<
script
src
=
"
file_ioutils_test_fixtures
.
js
"
>
<
/
script
>
<
script
>
"
use
strict
"
;
const
{
Assert
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
Assert
.
jsm
"
)
;
const
{
ObjectUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
jsm
"
)
;
/
/
TODO
:
Remove
this
import
for
OS
.
File
.
It
is
currently
being
used
as
a
/
/
stop
gap
for
missing
IOUtils
functionality
.
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
const
tmpDir
=
OS
.
Constants
.
Path
.
tmpDir
;
add_task
(
async
function
test_read_failure
(
)
{
const
doesNotExist
=
OS
.
Path
.
join
(
tmpDir
"
does_not_exist
.
tmp
"
)
;
await
Assert
.
rejects
(
window
.
IOUtils
.
read
(
doesNotExist
)
/
Could
not
open
the
file
at
.
*
/
"
IOUtils
:
:
read
rejects
when
file
does
not
exist
"
)
;
}
)
;
add_task
(
async
function
test_write_no_overwrite
(
)
{
/
/
Make
a
new
file
and
try
to
write
to
it
with
overwrites
disabled
.
const
tmpFileName
=
OS
.
Path
.
join
(
tmpDir
"
test_ioutils_overwrite
.
tmp
"
)
;
const
untouchableContents
=
new
TextEncoder
(
)
.
encode
(
"
Can
'
t
touch
this
!
\
n
"
)
;
await
window
.
IOUtils
.
writeAtomic
(
tmpFileName
untouchableContents
)
;
const
newContents
=
new
TextEncoder
(
)
.
encode
(
"
Nah
nah
nah
!
\
n
"
)
;
await
Assert
.
rejects
(
window
.
IOUtils
.
writeAtomic
(
tmpFileName
newContents
{
noOverwrite
:
true
}
)
/
Refusing
to
overwrite
the
file
at
*
/
"
IOUtils
:
:
writeAtomic
rejects
writing
to
existing
file
if
overwrites
are
disabled
"
)
;
ok
(
await
fileHasBinaryContents
(
tmpFileName
untouchableContents
)
"
IOUtils
:
:
writeAtomic
doesn
'
t
change
target
file
when
overwrite
is
refused
"
)
;
const
bytesWritten
=
await
window
.
IOUtils
.
writeAtomic
(
tmpFileName
newContents
{
noOverwrite
:
false
/
*
Default
.
*
/
}
)
;
is
(
bytesWritten
newContents
.
length
"
IOUtils
:
:
writeAtomic
can
overwrite
files
if
specified
"
)
;
await
cleanup
(
tmpFileName
)
;
}
)
;
add_task
(
async
function
test_write_with_backup
(
)
{
info
(
"
Test
backup
file
option
with
non
-
existing
file
"
)
;
let
fileContents
=
new
TextEncoder
(
)
.
encode
(
"
Original
file
contents
"
)
;
let
destFileName
=
OS
.
Path
.
join
(
tmpDir
"
test_write_with_backup_option
.
tmp
"
)
;
let
backupFileName
=
destFileName
+
"
.
backup
"
;
let
bytesWritten
=
await
window
.
IOUtils
.
writeAtomic
(
destFileName
fileContents
{
backupFile
:
backupFileName
}
)
;
ok
(
await
fileHasTextContents
(
destFileName
"
Original
file
contents
"
)
"
IOUtils
:
:
writeAtomic
creates
a
new
file
with
the
correct
contents
"
)
;
ok
(
!
await
fileExists
(
backupFileName
)
"
IOUtils
:
:
writeAtomic
does
not
create
a
backup
if
the
target
file
does
not
exist
"
)
;
is
(
bytesWritten
fileContents
.
length
"
IOUtils
:
:
writeAtomic
correctly
writes
to
a
new
file
without
performing
a
backup
"
)
;
info
(
"
Test
backup
file
option
with
existing
destination
"
)
;
let
newFileContents
=
new
TextEncoder
(
)
.
encode
(
"
New
file
contents
"
)
;
ok
(
await
fileExists
(
destFileName
)
Expected
{
destFileName
}
to
exist
)
;
bytesWritten
=
await
window
.
IOUtils
.
writeAtomic
(
destFileName
newFileContents
{
backupFile
:
backupFileName
}
)
;
ok
(
await
fileHasTextContents
(
backupFileName
"
Original
file
contents
"
)
"
IOUtils
:
:
writeAtomic
can
backup
an
existing
file
before
writing
"
)
;
ok
(
await
fileHasTextContents
(
destFileName
"
New
file
contents
"
)
"
IOUtils
:
:
writeAtomic
can
create
the
target
with
the
correct
contents
"
)
;
is
(
bytesWritten
newFileContents
.
length
"
IOUtils
:
:
writeAtomic
correctly
writes
to
the
target
after
taking
a
backup
"
)
;
await
cleanup
(
destFileName
backupFileName
)
;
}
)
;
add_task
(
async
function
test_write_with_backup_and_tmp
(
)
{
info
(
"
Test
backup
with
tmp
and
backup
file
options
non
-
existing
destination
"
)
;
let
fileContents
=
new
TextEncoder
(
)
.
encode
(
"
Original
file
contents
"
)
;
let
destFileName
=
OS
.
Path
.
join
(
tmpDir
"
test_write_with_backup_and_tmp_options
.
tmp
"
)
;
let
backupFileName
=
destFileName
+
"
.
backup
"
;
let
tmpFileName
=
OS
.
Path
.
join
(
tmpDir
"
temp_file
.
tmp
"
)
;
let
bytesWritten
=
await
window
.
IOUtils
.
writeAtomic
(
destFileName
fileContents
{
backupFile
:
backupFileName
tmpPath
:
tmpFileName
}
)
;
ok
(
!
await
fileExists
(
tmpFileName
)
"
IOUtils
:
:
writeAtomic
cleans
up
the
tmpFile
"
)
;
ok
(
!
await
fileExists
(
backupFileName
)
"
IOUtils
:
:
writeAtomic
does
not
create
a
backup
if
the
target
file
does
not
exist
"
)
;
ok
(
await
fileHasTextContents
(
destFileName
"
Original
file
contents
"
)
"
IOUtils
:
:
writeAtomic
can
write
to
the
destination
when
a
temporary
file
is
used
"
)
;
is
(
bytesWritten
fileContents
.
length
"
IOUtils
:
:
writeAtomic
can
copy
tmp
file
to
destination
without
performing
a
backup
"
)
;
info
(
"
Test
backup
with
tmp
and
backup
file
options
existing
destination
"
)
;
let
newFileContents
=
new
TextEncoder
(
)
.
encode
(
"
New
file
contents
"
)
;
bytesWritten
=
await
window
.
IOUtils
.
writeAtomic
(
destFileName
newFileContents
{
backupFile
:
backupFileName
tmpPath
:
tmpFileName
}
)
;
ok
(
!
await
fileExists
(
tmpFileName
)
"
IOUtils
:
:
writeAtomic
cleans
up
the
tmpFile
"
)
;
ok
(
await
fileHasTextContents
(
backupFileName
"
Original
file
contents
"
)
"
IOUtils
:
:
writeAtomic
can
create
a
backup
if
the
target
file
exists
"
)
;
ok
(
await
fileHasTextContents
(
destFileName
"
New
file
contents
"
)
"
IOUtils
:
:
writeAtomic
can
write
to
the
destination
when
a
temporary
file
is
used
"
)
;
is
(
bytesWritten
newFileContents
.
length
"
IOUtils
:
:
writeAtomic
IOUtils
:
:
writeAtomic
can
move
tmp
file
to
destination
after
performing
a
backup
"
)
;
await
cleanup
(
destFileName
backupFileName
)
;
}
)
;
add_task
(
async
function
test_partial_read
(
)
{
const
tmpFileName
=
OS
.
Path
.
join
(
tmpDir
"
test_ioutils_partial_read
.
tmp
"
)
;
const
bytes
=
Uint8Array
.
of
(
.
.
.
new
Array
(
50
)
.
keys
(
)
)
;
const
bytesWritten
=
await
window
.
IOUtils
.
writeAtomic
(
tmpFileName
bytes
)
;
is
(
bytesWritten
50
"
IOUtils
:
:
writeAtomic
can
write
entire
byte
array
to
file
"
)
;
/
/
Read
just
the
first
10
bytes
.
const
first10
=
bytes
.
slice
(
0
10
)
;
const
bytes10
=
await
window
.
IOUtils
.
read
(
tmpFileName
10
)
;
ok
(
ObjectUtils
.
deepEqual
(
bytes10
first10
)
"
IOUtils
:
:
read
can
read
part
of
a
file
up
to
specified
max
bytes
"
)
;
/
/
Trying
to
explicitly
read
nothing
isn
'
t
useful
but
it
should
still
/
/
succeed
.
const
bytes0
=
await
window
.
IOUtils
.
read
(
tmpFileName
0
)
;
is
(
bytes0
.
length
0
"
IOUtils
:
:
read
can
read
0
bytes
"
)
;
await
cleanup
(
tmpFileName
)
;
}
)
;
add_task
(
async
function
test_empty_read_and_write
(
)
{
/
/
Trying
to
write
an
empty
file
isn
'
t
very
useful
but
it
should
still
/
/
succeed
.
const
tmpFileName
=
OS
.
Path
.
join
(
tmpDir
"
test_ioutils_empty
.
tmp
"
)
;
const
emptyByteArray
=
new
Uint8Array
(
0
)
;
const
bytesWritten
=
await
window
.
IOUtils
.
writeAtomic
(
tmpFileName
emptyByteArray
)
;
is
(
bytesWritten
0
"
IOUtils
:
:
writeAtomic
can
create
an
empty
file
"
)
;
/
/
Trying
to
explicitly
read
nothing
isn
'
t
useful
but
it
should
still
/
/
succeed
.
const
bytes0
=
await
window
.
IOUtils
.
read
(
tmpFileName
0
)
;
is
(
bytes0
.
length
0
"
IOUtils
:
:
read
can
read
0
bytes
"
)
;
/
/
Implicitly
try
to
read
nothing
.
const
nothing
=
await
window
.
IOUtils
.
read
(
tmpFileName
)
;
is
(
nothing
.
length
0
"
IOUtils
:
:
read
can
read
empty
files
"
)
;
await
cleanup
(
tmpFileName
)
;
}
)
;
add_task
(
async
function
test_full_read_and_write
(
)
{
/
/
Write
a
file
.
info
(
"
Test
writing
to
a
new
binary
file
"
)
;
const
tmpFileName
=
OS
.
Path
.
join
(
tmpDir
"
test_ioutils_numbers
.
tmp
"
)
;
const
bytes
=
Uint8Array
.
of
(
.
.
.
new
Array
(
50
)
.
keys
(
)
)
;
const
bytesWritten
=
await
window
.
IOUtils
.
writeAtomic
(
tmpFileName
bytes
)
;
is
(
bytesWritten
50
"
IOUtils
:
:
writeAtomic
can
write
entire
byte
array
to
file
"
)
;
/
/
Read
it
back
.
info
(
"
Test
reading
a
binary
file
"
)
;
let
fileContents
=
await
window
.
IOUtils
.
read
(
tmpFileName
)
;
ok
(
ObjectUtils
.
deepEqual
(
bytes
fileContents
)
&
&
bytes
.
length
=
=
fileContents
.
length
"
IOUtils
:
:
read
can
read
back
entire
file
"
)
;
const
tooManyBytes
=
bytes
.
length
+
1
;
fileContents
=
await
window
.
IOUtils
.
read
(
tmpFileName
tooManyBytes
)
;
ok
(
ObjectUtils
.
deepEqual
(
bytes
fileContents
)
&
&
fileContents
.
length
=
=
bytes
.
length
"
IOUtils
:
:
read
can
read
entire
file
when
requested
maxBytes
is
too
large
"
)
;
/
/
Clean
up
.
await
cleanup
(
tmpFileName
)
;
}
)
;
add_task
(
async
function
test_write_relative_path
(
)
{
const
tmpFileName
=
"
test_ioutils_write_relative_path
.
tmp
"
;
const
bytes
=
Uint8Array
.
of
(
.
.
.
new
Array
(
50
)
.
keys
(
)
)
;
info
(
"
Test
writing
a
file
at
a
relative
destination
"
)
;
await
Assert
.
rejects
(
window
.
IOUtils
.
writeAtomic
(
tmpFileName
bytes
)
/
Refusing
to
work
with
path
\
(
.
*
\
)
because
only
absolute
file
paths
are
permitted
/
"
IOUtils
:
:
writeAtomic
only
works
with
absolute
paths
"
)
;
}
)
;
add_task
(
async
function
test_read_relative_path
(
)
{
const
tmpFileName
=
"
test_ioutils_read_relative_path
.
tmp
"
;
info
(
"
Test
reading
a
file
at
a
relative
destination
"
)
;
await
Assert
.
rejects
(
window
.
IOUtils
.
read
(
tmpFileName
)
/
Refusing
to
work
with
path
\
(
.
*
\
)
because
only
absolute
file
paths
are
permitted
/
"
IOUtils
:
:
writeAtomic
only
works
with
absolute
paths
"
)
;
}
)
;
<
/
script
>
<
/
head
>
<
body
>
<
p
id
=
"
display
"
>
<
/
p
>
<
div
id
=
"
content
"
style
=
"
display
:
none
"
>
<
/
div
>
<
pre
id
=
"
test
"
>
<
/
pre
>
<
/
body
>
<
/
html
>
