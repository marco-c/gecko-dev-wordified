/
*
-
*
-
Mode
:
C
+
+
;
tab
-
width
:
8
;
indent
-
tabs
-
mode
:
nil
;
c
-
basic
-
offset
:
2
-
*
-
*
/
/
*
vim
:
set
ts
=
8
sts
=
2
et
sw
=
2
tw
=
80
:
*
/
/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
#
include
"
mozilla
/
dom
/
Notification
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
JSONWriter
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
AppNotificationServiceOptionsBinding
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
DOMPrefs
.
h
"
#
include
"
mozilla
/
dom
/
NotificationEvent
.
h
"
#
include
"
mozilla
/
dom
/
PermissionMessageUtils
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
PromiseWorkerProxy
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerGlobalScopeBinding
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerManager
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRef
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRunnable
.
h
"
#
include
"
mozilla
/
dom
/
WorkerScope
.
h
"
#
include
"
nsAlertsUtils
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsContentPermissionHelper
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsDOMJSUtils
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsIAlertsService
.
h
"
#
include
"
nsIContentPermissionPrompt
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsINotificationStorage
.
h
"
#
include
"
nsIPermissionManager
.
h
"
#
include
"
nsIPermission
.
h
"
#
include
"
nsIPushService
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsIServiceWorkerManager
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsIUUIDGenerator
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsStructuredCloneContainer
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsToolkitCompsCID
.
h
"
#
include
"
nsXULAppAPI
.
h
"
namespace
mozilla
{
namespace
dom
{
struct
NotificationStrings
{
const
nsString
mID
;
const
nsString
mTitle
;
const
nsString
mDir
;
const
nsString
mLang
;
const
nsString
mBody
;
const
nsString
mTag
;
const
nsString
mIcon
;
const
nsString
mData
;
const
nsString
mBehavior
;
const
nsString
mServiceWorkerRegistrationScope
;
}
;
class
ScopeCheckingGetCallback
:
public
nsINotificationStorageCallback
{
const
nsString
mScope
;
public
:
explicit
ScopeCheckingGetCallback
(
const
nsAString
&
aScope
)
:
mScope
(
aScope
)
{
}
NS_IMETHOD
Handle
(
const
nsAString
&
aID
const
nsAString
&
aTitle
const
nsAString
&
aDir
const
nsAString
&
aLang
const
nsAString
&
aBody
const
nsAString
&
aTag
const
nsAString
&
aIcon
const
nsAString
&
aData
const
nsAString
&
aBehavior
const
nsAString
&
aServiceWorkerRegistrationScope
)
final
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
!
aID
.
IsEmpty
(
)
)
;
/
/
Skip
scopes
that
don
'
t
match
when
called
from
getNotifications
(
)
.
if
(
!
mScope
.
IsEmpty
(
)
&
&
!
mScope
.
Equals
(
aServiceWorkerRegistrationScope
)
)
{
return
NS_OK
;
}
NotificationStrings
strings
=
{
nsString
(
aID
)
nsString
(
aTitle
)
nsString
(
aDir
)
nsString
(
aLang
)
nsString
(
aBody
)
nsString
(
aTag
)
nsString
(
aIcon
)
nsString
(
aData
)
nsString
(
aBehavior
)
nsString
(
aServiceWorkerRegistrationScope
)
}
;
mStrings
.
AppendElement
(
std
:
:
move
(
strings
)
)
;
return
NS_OK
;
}
NS_IMETHOD
Done
(
)
override
=
0
;
protected
:
virtual
~
ScopeCheckingGetCallback
(
)
{
}
nsTArray
<
NotificationStrings
>
mStrings
;
}
;
class
NotificationStorageCallback
final
:
public
ScopeCheckingGetCallback
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
NotificationStorageCallback
)
NotificationStorageCallback
(
nsIGlobalObject
*
aWindow
const
nsAString
&
aScope
Promise
*
aPromise
)
:
ScopeCheckingGetCallback
(
aScope
)
mWindow
(
aWindow
)
mPromise
(
aPromise
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aWindow
)
;
MOZ_ASSERT
(
aPromise
)
;
}
NS_IMETHOD
Done
(
)
final
{
ErrorResult
result
;
AutoTArray
<
RefPtr
<
Notification
>
5
>
notifications
;
for
(
uint32_t
i
=
0
;
i
<
mStrings
.
Length
(
)
;
+
+
i
)
{
RefPtr
<
Notification
>
n
=
Notification
:
:
ConstructFromFields
(
mWindow
mStrings
[
i
]
.
mID
mStrings
[
i
]
.
mTitle
mStrings
[
i
]
.
mDir
mStrings
[
i
]
.
mLang
mStrings
[
i
]
.
mBody
mStrings
[
i
]
.
mTag
mStrings
[
i
]
.
mIcon
mStrings
[
i
]
.
mData
/
*
mStrings
[
i
]
.
mBehavior
not
*
supported
*
/
mStrings
[
i
]
.
mServiceWorkerRegistrationScope
result
)
;
n
-
>
SetStoredState
(
true
)
;
Unused
<
<
NS_WARN_IF
(
result
.
Failed
(
)
)
;
if
(
!
result
.
Failed
(
)
)
{
notifications
.
AppendElement
(
n
.
forget
(
)
)
;
}
}
mPromise
-
>
MaybeResolve
(
notifications
)
;
return
NS_OK
;
}
private
:
virtual
~
NotificationStorageCallback
(
)
{
}
nsCOMPtr
<
nsIGlobalObject
>
mWindow
;
RefPtr
<
Promise
>
mPromise
;
const
nsString
mScope
;
}
;
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
NotificationStorageCallback
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
NotificationStorageCallback
)
NS_IMPL_CYCLE_COLLECTION
(
NotificationStorageCallback
mWindow
mPromise
)
;
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
NotificationStorageCallback
)
NS_INTERFACE_MAP_ENTRY
(
nsINotificationStorageCallback
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
class
NotificationGetRunnable
final
:
public
Runnable
{
const
nsString
mOrigin
;
const
nsString
mTag
;
nsCOMPtr
<
nsINotificationStorageCallback
>
mCallback
;
public
:
NotificationGetRunnable
(
const
nsAString
&
aOrigin
const
nsAString
&
aTag
nsINotificationStorageCallback
*
aCallback
)
:
Runnable
(
"
NotificationGetRunnable
"
)
mOrigin
(
aOrigin
)
mTag
(
aTag
)
mCallback
(
aCallback
)
{
}
NS_IMETHOD
Run
(
)
override
{
nsresult
rv
;
nsCOMPtr
<
nsINotificationStorage
>
notificationStorage
=
do_GetService
(
NS_NOTIFICATION_STORAGE_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
notificationStorage
-
>
Get
(
mOrigin
mTag
mCallback
)
;
/
/
XXXnsm
Is
it
guaranteed
mCallback
will
be
called
in
case
of
failure
?
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
return
rv
;
}
}
;
class
NotificationPermissionRequest
:
public
nsIContentPermissionRequest
public
nsIRunnable
public
nsINamed
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_NSICONTENTPERMISSIONREQUEST
NS_DECL_NSIRUNNABLE
NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS
(
NotificationPermissionRequest
nsIContentPermissionRequest
)
NotificationPermissionRequest
(
nsIPrincipal
*
aPrincipal
bool
aIsHandlingUserInput
nsPIDOMWindowInner
*
aWindow
Promise
*
aPromise
NotificationPermissionCallback
*
aCallback
)
:
mPrincipal
(
aPrincipal
)
mWindow
(
aWindow
)
mPermission
(
NotificationPermission
:
:
Default
)
mPromise
(
aPromise
)
mCallback
(
aCallback
)
mIsHandlingUserInput
(
aIsHandlingUserInput
)
{
MOZ_ASSERT
(
aPromise
)
;
mRequester
=
new
nsContentPermissionRequester
(
mWindow
)
;
}
NS_IMETHOD
GetName
(
nsACString
&
aName
)
override
{
aName
.
AssignLiteral
(
"
NotificationPermissionRequest
"
)
;
return
NS_OK
;
}
protected
:
virtual
~
NotificationPermissionRequest
(
)
{
}
nsresult
ResolvePromise
(
)
;
nsresult
DispatchResolvePromise
(
)
;
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
nsCOMPtr
<
nsPIDOMWindowInner
>
mWindow
;
NotificationPermission
mPermission
;
RefPtr
<
Promise
>
mPromise
;
RefPtr
<
NotificationPermissionCallback
>
mCallback
;
nsCOMPtr
<
nsIContentPermissionRequester
>
mRequester
;
bool
mIsHandlingUserInput
;
}
;
namespace
{
class
GetPermissionRunnable
final
:
public
WorkerMainThreadRunnable
{
NotificationPermission
mPermission
;
public
:
GetPermissionRunnable
(
)
:
WorkerMainThreadRunnable
(
GetCurrentThreadWorkerPrivate
(
)
NS_LITERAL_CSTRING
(
"
Notification
:
:
Get
Permission
"
)
)
mPermission
(
NotificationPermission
:
:
Denied
)
{
}
bool
MainThreadRun
(
)
override
{
ErrorResult
result
;
mPermission
=
Notification
:
:
GetPermissionInternal
(
mWorkerPrivate
-
>
GetPrincipal
(
)
result
)
;
return
true
;
}
NotificationPermission
GetPermission
(
)
{
return
mPermission
;
}
}
;
class
FocusWindowRunnable
final
:
public
Runnable
{
nsMainThreadPtrHandle
<
nsPIDOMWindowInner
>
mWindow
;
public
:
explicit
FocusWindowRunnable
(
const
nsMainThreadPtrHandle
<
nsPIDOMWindowInner
>
&
aWindow
)
:
Runnable
(
"
FocusWindowRunnable
"
)
mWindow
(
aWindow
)
{
}
NS_IMETHOD
Run
(
)
override
{
AssertIsOnMainThread
(
)
;
if
(
!
mWindow
-
>
IsCurrentInnerWindow
(
)
)
{
/
/
Window
has
been
closed
this
observer
is
not
valid
anymore
return
NS_OK
;
}
/
/
Browser
UI
may
use
DOMWindowFocus
to
focus
the
tab
/
/
from
which
the
event
was
dispatched
.
nsContentUtils
:
:
DispatchFocusChromeEvent
(
mWindow
-
>
GetOuterWindow
(
)
)
;
return
NS_OK
;
}
}
;
nsresult
CheckScope
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aScope
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aPrincipal
)
;
nsCOMPtr
<
nsIURI
>
scopeURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
scopeURI
)
aScope
nullptr
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
aPrincipal
-
>
CheckMayLoad
(
scopeURI
/
*
report
=
*
/
true
/
*
allowIfInheritsPrincipal
=
*
/
false
)
;
}
/
/
This
runnable
is
used
to
release
the
Notification
object
on
the
owning
/
/
thread
.
class
ReleaseNotificationControlRunnable
final
:
public
WorkerControlRunnable
{
public
:
ReleaseNotificationControlRunnable
(
WorkerPrivate
*
aWorkerPrivate
already_AddRefed
<
Notification
>
aNotification
)
:
WorkerControlRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
mNotification
(
std
:
:
move
(
aNotification
)
)
{
MOZ_ASSERT
(
mNotification
)
;
}
bool
PreDispatch
(
WorkerPrivate
*
aWorkerPrivate
)
override
{
return
true
;
}
void
PostDispatch
(
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
{
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
mNotification
=
nullptr
;
return
true
;
}
private
:
RefPtr
<
Notification
>
mNotification
;
}
;
}
/
/
anonymous
namespace
/
/
Simple
runnable
to
start
the
task
on
the
main
-
thread
.
class
NotificationTaskRunnable
final
:
public
Runnable
{
public
:
NotificationTaskRunnable
(
const
char
*
aName
NotificationTask
*
aTask
)
:
Runnable
(
aName
)
mNotificationTask
(
aTask
)
{
}
NS_IMETHOD
Run
(
)
override
;
protected
:
RefPtr
<
NotificationTask
>
mNotificationTask
;
}
;
class
WorkerNotificationObserver
;
class
NotificationTask
final
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
NotificationTask
)
enum
NotificationAction
{
eShow
eClose
}
;
static
already_AddRefed
<
NotificationTask
>
Create
(
Notification
*
aNotification
NotificationAction
aAction
)
;
NotificationAction
Action
(
)
const
{
return
mAction
;
}
ThreadSafeWorkerRef
*
GetWorkerRef
(
)
const
{
/
/
This
is
null
if
Notification
runs
on
the
main
-
thread
.
return
mWorkerRef
;
}
/
/
Only
useful
for
workers
.
void
ReleaseNotificationOnMainThread
(
)
{
AssertIsOnMainThread
(
)
;
if
(
mWorkerRef
&
&
mNotification
)
{
RefPtr
<
ReleaseNotificationControlRunnable
>
r
=
new
ReleaseNotificationControlRunnable
(
mWorkerRef
-
>
Private
(
)
mNotification
.
forget
(
)
)
;
r
-
>
Dispatch
(
)
;
}
}
Notification
*
GetNotification
(
)
{
MOZ_ASSERT
(
mNotification
)
;
return
mNotification
;
}
nsIPrincipal
*
GetPrincipal
(
)
{
AssertIsOnMainThread
(
)
;
if
(
mWorkerRef
)
{
return
mWorkerRef
-
>
Private
(
)
-
>
GetPrincipal
(
)
;
}
nsCOMPtr
<
nsIScriptObjectPrincipal
>
sop
=
do_QueryInterface
(
mNotification
-
>
GetOwner
(
)
)
;
NS_ENSURE_TRUE
(
sop
nullptr
)
;
return
sop
-
>
GetPrincipal
(
)
;
}
nsresult
ResolveIconAndSoundURL
(
nsString
&
aIconUrl
nsString
&
aSoundUrl
)
{
AssertIsOnMainThread
(
)
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIURI
>
baseUri
;
/
/
XXXnsm
If
I
understand
correctly
the
character
encoding
for
resolving
/
/
URIs
in
new
specs
is
dictated
by
the
URL
spec
which
states
that
unless
/
/
the
URL
parser
is
passed
an
override
encoding
the
charset
to
be
used
is
/
/
UTF
-
8
.
The
new
Notification
icon
/
sound
specification
just
says
to
use
the
/
/
Fetch
API
where
the
Request
constructor
defers
to
URL
parsing
specifying
/
/
the
API
base
URL
and
no
override
encoding
.
So
we
'
ve
to
use
UTF
-
8
on
/
/
workers
but
for
backwards
compat
keeping
it
document
charset
on
main
/
/
thread
.
auto
encoding
=
UTF_8_ENCODING
;
if
(
mWorkerRef
)
{
baseUri
=
mWorkerRef
-
>
Private
(
)
-
>
GetBaseURI
(
)
;
}
else
{
nsIDocument
*
doc
=
mNotification
-
>
GetOwner
(
)
?
mNotification
-
>
GetOwner
(
)
-
>
GetExtantDoc
(
)
:
nullptr
;
if
(
doc
)
{
baseUri
=
doc
-
>
GetBaseURI
(
)
;
encoding
=
doc
-
>
GetDocumentCharacterSet
(
)
;
}
else
{
NS_WARNING
(
"
No
document
found
for
main
thread
notification
!
"
)
;
return
NS_ERROR_FAILURE
;
}
}
if
(
baseUri
)
{
if
(
aIconUrl
.
Length
(
)
>
0
)
{
nsCOMPtr
<
nsIURI
>
srcUri
;
rv
=
NS_NewURI
(
getter_AddRefs
(
srcUri
)
aIconUrl
encoding
baseUri
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
src
;
srcUri
-
>
GetSpec
(
src
)
;
aIconUrl
=
NS_ConvertUTF8toUTF16
(
src
)
;
}
}
if
(
mNotification
-
>
Behavior
(
)
.
mSoundFile
.
Length
(
)
>
0
)
{
nsCOMPtr
<
nsIURI
>
srcUri
;
rv
=
NS_NewURI
(
getter_AddRefs
(
srcUri
)
mNotification
-
>
Behavior
(
)
.
mSoundFile
encoding
baseUri
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
src
;
srcUri
-
>
GetSpec
(
src
)
;
aSoundUrl
=
NS_ConvertUTF8toUTF16
(
src
)
;
}
}
}
return
rv
;
}
bool
IsInPrivateBrowsing
(
)
{
AssertIsOnMainThread
(
)
;
nsCOMPtr
<
nsIDocument
>
doc
;
if
(
mWorkerRef
&
&
mWorkerRef
-
>
Private
(
)
)
{
doc
=
mWorkerRef
-
>
Private
(
)
-
>
GetDocument
(
)
;
}
else
if
(
mNotification
-
>
GetOwner
(
)
)
{
doc
=
mNotification
-
>
GetOwner
(
)
-
>
GetExtantDoc
(
)
;
}
if
(
doc
)
{
nsCOMPtr
<
nsILoadContext
>
loadContext
=
doc
-
>
GetLoadContext
(
)
;
return
loadContext
&
&
loadContext
-
>
UsePrivateBrowsing
(
)
;
}
if
(
mWorkerRef
)
{
/
/
Not
all
workers
may
have
a
document
but
with
Bug
1107516
fixed
they
/
/
should
all
have
a
loadcontext
.
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
mWorkerRef
-
>
Private
(
)
-
>
GetLoadGroup
(
)
;
nsCOMPtr
<
nsILoadContext
>
loadContext
;
NS_QueryNotificationCallbacks
(
nullptr
loadGroup
NS_GET_IID
(
nsILoadContext
)
getter_AddRefs
(
loadContext
)
)
;
return
loadContext
&
&
loadContext
-
>
UsePrivateBrowsing
(
)
;
}
/
/
XXXnsm
Should
this
default
to
true
?
return
false
;
}
nsresult
DispatchToMainThread
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
{
if
(
mWorkerRef
)
{
return
mWorkerRef
-
>
Private
(
)
-
>
DispatchToMainThread
(
std
:
:
move
(
aRunnable
)
)
;
}
AssertIsOnMainThread
(
)
;
if
(
nsCOMPtr
<
nsIGlobalObject
>
global
=
mNotification
-
>
GetOwnerGlobal
(
)
)
{
if
(
nsIEventTarget
*
target
=
global
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
{
return
target
-
>
Dispatch
(
std
:
:
move
(
aRunnable
)
nsIEventTarget
:
:
DISPATCH_NORMAL
)
;
}
}
nsCOMPtr
<
nsIEventTarget
>
mainTarget
=
GetMainThreadEventTarget
(
)
;
MOZ_ASSERT
(
mainTarget
)
;
return
mainTarget
-
>
Dispatch
(
std
:
:
move
(
aRunnable
)
nsIEventTarget
:
:
DISPATCH_NORMAL
)
;
}
void
SetObserver
(
WorkerNotificationObserver
*
aObserver
)
{
AssertIsOnMainThread
(
)
;
mObserver
=
aObserver
;
}
WorkerNotificationObserver
*
Observer
(
)
{
return
mObserver
;
}
private
:
explicit
NotificationTask
(
Notification
*
aNotification
NotificationAction
aAction
)
:
mNotification
(
aNotification
)
mAction
(
aAction
)
{
MOZ_ASSERT
(
mNotification
)
;
}
~
NotificationTask
(
)
{
/
/
Let
'
s
release
the
Notification
object
on
the
correct
thread
.
if
(
mWorkerRef
&
&
!
mWorkerRef
-
>
Private
(
)
-
>
IsOnWorkerThread
(
)
)
{
ReleaseNotificationOnMainThread
(
)
;
}
}
RefPtr
<
Notification
>
mNotification
;
RefPtr
<
ThreadSafeWorkerRef
>
mWorkerRef
;
/
/
Touched
on
main
-
thread
only
.
RefPtr
<
WorkerNotificationObserver
>
mObserver
;
NotificationAction
mAction
;
}
;
/
/
Overrides
dispatch
and
run
handlers
so
we
can
directly
dispatch
from
main
/
/
thread
to
child
workers
.
class
NotificationEventWorkerRunnable
final
:
public
MainThreadWorkerRunnable
{
RefPtr
<
NotificationTask
>
mNotificationTask
;
const
nsString
mEventName
;
public
:
NotificationEventWorkerRunnable
(
NotificationTask
*
aNotificationTask
const
nsString
&
aEventName
)
:
MainThreadWorkerRunnable
(
aNotificationTask
-
>
GetWorkerRef
(
)
-
>
Private
(
)
)
mNotificationTask
(
aNotificationTask
)
mEventName
(
aEventName
)
{
AssertIsOnMainThread
(
)
;
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
mNotificationTask
-
>
GetNotification
(
)
-
>
AssertIsOnTargetThread
(
)
;
mNotificationTask
-
>
GetNotification
(
)
-
>
DispatchTrustedEvent
(
mEventName
)
;
return
true
;
}
}
;
uint32_t
Notification
:
:
sCount
=
0
;
NS_IMPL_CYCLE_COLLECTION
(
NotificationPermissionRequest
mWindow
mPromise
mCallback
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
NotificationPermissionRequest
)
NS_INTERFACE_MAP_ENTRY
(
nsIContentPermissionRequest
)
NS_INTERFACE_MAP_ENTRY
(
nsIRunnable
)
NS_INTERFACE_MAP_ENTRY
(
nsINamed
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIContentPermissionRequest
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
NotificationPermissionRequest
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
NotificationPermissionRequest
)
NS_IMETHODIMP
NotificationPermissionRequest
:
:
Run
(
)
{
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
mPrincipal
)
)
{
mPermission
=
NotificationPermission
:
:
Granted
;
}
else
{
/
/
File
are
automatically
granted
permission
.
nsCOMPtr
<
nsIURI
>
uri
;
mPrincipal
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
uri
)
{
bool
isFile
;
uri
-
>
SchemeIs
(
"
file
"
&
isFile
)
;
if
(
isFile
)
{
mPermission
=
NotificationPermission
:
:
Granted
;
}
}
}
/
/
Grant
permission
if
pref
'
ed
on
.
if
(
Preferences
:
:
GetBool
(
"
notification
.
prompt
.
testing
"
false
)
)
{
if
(
Preferences
:
:
GetBool
(
"
notification
.
prompt
.
testing
.
allow
"
true
)
)
{
mPermission
=
NotificationPermission
:
:
Granted
;
}
else
{
mPermission
=
NotificationPermission
:
:
Denied
;
}
}
if
(
mPermission
!
=
NotificationPermission
:
:
Default
)
{
return
DispatchResolvePromise
(
)
;
}
return
nsContentPermissionUtils
:
:
AskPermission
(
this
mWindow
)
;
}
NS_IMETHODIMP
NotificationPermissionRequest
:
:
GetPrincipal
(
nsIPrincipal
*
*
aRequestingPrincipal
)
{
NS_ADDREF
(
*
aRequestingPrincipal
=
mPrincipal
)
;
return
NS_OK
;
}
NS_IMETHODIMP
NotificationPermissionRequest
:
:
GetWindow
(
mozIDOMWindow
*
*
aRequestingWindow
)
{
NS_ADDREF
(
*
aRequestingWindow
=
mWindow
)
;
return
NS_OK
;
}
NS_IMETHODIMP
NotificationPermissionRequest
:
:
GetElement
(
Element
*
*
aElement
)
{
NS_ENSURE_ARG_POINTER
(
aElement
)
;
*
aElement
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
NotificationPermissionRequest
:
:
GetIsHandlingUserInput
(
bool
*
aIsHandlingUserInput
)
{
*
aIsHandlingUserInput
=
mIsHandlingUserInput
;
return
NS_OK
;
}
NS_IMETHODIMP
NotificationPermissionRequest
:
:
Cancel
(
)
{
/
/
Cancel
is
called
if
the
user
denied
permission
or
dismissed
the
/
/
permission
request
.
To
distinguish
between
the
two
we
set
the
/
/
permission
to
"
default
"
and
query
the
permission
manager
in
/
/
ResolvePromise
.
mPermission
=
NotificationPermission
:
:
Default
;
return
DispatchResolvePromise
(
)
;
}
NS_IMETHODIMP
NotificationPermissionRequest
:
:
Allow
(
JS
:
:
HandleValue
aChoices
)
{
MOZ_ASSERT
(
aChoices
.
isUndefined
(
)
)
;
mPermission
=
NotificationPermission
:
:
Granted
;
return
DispatchResolvePromise
(
)
;
}
NS_IMETHODIMP
NotificationPermissionRequest
:
:
GetRequester
(
nsIContentPermissionRequester
*
*
aRequester
)
{
NS_ENSURE_ARG_POINTER
(
aRequester
)
;
nsCOMPtr
<
nsIContentPermissionRequester
>
requester
=
mRequester
;
requester
.
forget
(
aRequester
)
;
return
NS_OK
;
}
inline
nsresult
NotificationPermissionRequest
:
:
DispatchResolvePromise
(
)
{
nsCOMPtr
<
nsIRunnable
>
resolver
=
NewRunnableMethod
(
"
NotificationPermissionRequest
:
:
DispatchResolvePromise
"
this
&
NotificationPermissionRequest
:
:
ResolvePromise
)
;
if
(
nsIEventTarget
*
target
=
mWindow
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
{
return
target
-
>
Dispatch
(
resolver
.
forget
(
)
nsIEventTarget
:
:
DISPATCH_NORMAL
)
;
}
return
NS_ERROR_FAILURE
;
}
nsresult
NotificationPermissionRequest
:
:
ResolvePromise
(
)
{
nsresult
rv
=
NS_OK
;
if
(
mPermission
=
=
NotificationPermission
:
:
Default
)
{
/
/
This
will
still
be
"
default
"
if
the
user
dismissed
the
doorhanger
/
/
or
"
denied
"
otherwise
.
mPermission
=
Notification
:
:
TestPermission
(
mPrincipal
)
;
}
if
(
mCallback
)
{
ErrorResult
error
;
mCallback
-
>
Call
(
mPermission
error
)
;
rv
=
error
.
StealNSResult
(
)
;
}
mPromise
-
>
MaybeResolve
(
mPermission
)
;
return
rv
;
}
NS_IMETHODIMP
NotificationPermissionRequest
:
:
GetTypes
(
nsIArray
*
*
aTypes
)
{
nsTArray
<
nsString
>
emptyOptions
;
return
nsContentPermissionUtils
:
:
CreatePermissionArray
(
NS_LITERAL_CSTRING
(
"
desktop
-
notification
"
)
NS_LITERAL_CSTRING
(
"
unused
"
)
emptyOptions
aTypes
)
;
}
NS_IMPL_ISUPPORTS
(
NotificationTelemetryService
nsIObserver
)
NotificationTelemetryService
:
:
NotificationTelemetryService
(
)
:
mDNDRecorded
(
false
)
{
}
NotificationTelemetryService
:
:
~
NotificationTelemetryService
(
)
{
}
/
*
static
*
/
already_AddRefed
<
NotificationTelemetryService
>
NotificationTelemetryService
:
:
GetInstance
(
)
{
nsCOMPtr
<
nsISupports
>
telemetrySupports
=
do_GetService
(
NOTIFICATIONTELEMETRYSERVICE_CONTRACTID
)
;
if
(
!
telemetrySupports
)
{
return
nullptr
;
}
RefPtr
<
NotificationTelemetryService
>
telemetry
=
static_cast
<
NotificationTelemetryService
*
>
(
telemetrySupports
.
get
(
)
)
;
return
telemetry
.
forget
(
)
;
}
nsresult
NotificationTelemetryService
:
:
Init
(
)
{
/
/
Only
perform
permissions
telemetry
collection
in
the
parent
process
.
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_OK
;
}
RecordPermissions
(
)
;
return
NS_OK
;
}
void
NotificationTelemetryService
:
:
RecordPermissions
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
RecordPermissions
may
only
be
called
in
the
parent
process
"
)
;
if
(
!
Telemetry
:
:
CanRecordBase
(
)
|
|
!
Telemetry
:
:
CanRecordExtended
(
)
)
{
return
;
}
nsCOMPtr
<
nsIPermissionManager
>
permissionManager
=
services
:
:
GetPermissionManager
(
)
;
if
(
!
permissionManager
)
{
return
;
}
nsCOMPtr
<
nsISimpleEnumerator
>
enumerator
;
nsresult
rv
=
permissionManager
-
>
GetEnumerator
(
getter_AddRefs
(
enumerator
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
for
(
;
;
)
{
bool
hasMoreElements
;
nsresult
rv
=
enumerator
-
>
HasMoreElements
(
&
hasMoreElements
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
if
(
!
hasMoreElements
)
{
break
;
}
nsCOMPtr
<
nsISupports
>
supportsPermission
;
rv
=
enumerator
-
>
GetNext
(
getter_AddRefs
(
supportsPermission
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
uint32_t
capability
;
if
(
!
GetNotificationPermission
(
supportsPermission
&
capability
)
)
{
continue
;
}
if
(
capability
=
=
nsIPermissionManager
:
:
DENY_ACTION
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEB_NOTIFICATION_PERMISSIONS
0
)
;
}
else
if
(
capability
=
=
nsIPermissionManager
:
:
ALLOW_ACTION
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEB_NOTIFICATION_PERMISSIONS
1
)
;
}
}
}
bool
NotificationTelemetryService
:
:
GetNotificationPermission
(
nsISupports
*
aSupports
uint32_t
*
aCapability
)
{
nsCOMPtr
<
nsIPermission
>
permission
=
do_QueryInterface
(
aSupports
)
;
if
(
!
permission
)
{
return
false
;
}
nsAutoCString
type
;
permission
-
>
GetType
(
type
)
;
if
(
!
type
.
EqualsLiteral
(
"
desktop
-
notification
"
)
)
{
return
false
;
}
permission
-
>
GetCapability
(
aCapability
)
;
return
true
;
}
void
NotificationTelemetryService
:
:
RecordDNDSupported
(
)
{
if
(
mDNDRecorded
)
{
return
;
}
nsCOMPtr
<
nsIAlertsService
>
alertService
=
do_GetService
(
NS_ALERTSERVICE_CONTRACTID
)
;
if
(
!
alertService
)
{
return
;
}
nsCOMPtr
<
nsIAlertsDoNotDisturb
>
alertServiceDND
=
do_QueryInterface
(
alertService
)
;
if
(
!
alertServiceDND
)
{
return
;
}
mDNDRecorded
=
true
;
bool
isEnabled
;
nsresult
rv
=
alertServiceDND
-
>
GetManualDoNotDisturb
(
&
isEnabled
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
ALERTS_SERVICE_DND_SUPPORTED_FLAG
true
)
;
}
NS_IMETHODIMP
NotificationTelemetryService
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
return
NS_OK
;
}
/
/
Observer
that
the
alert
service
calls
to
do
common
tasks
and
/
or
dispatch
to
the
/
/
specific
observer
for
the
context
e
.
g
.
main
thread
worker
or
service
worker
.
class
NotificationObserver
final
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
NotificationObserver
(
nsIObserver
*
aObserver
nsIPrincipal
*
aPrincipal
)
:
mObserver
(
aObserver
)
mPrincipal
(
aPrincipal
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
mObserver
)
;
MOZ_ASSERT
(
mPrincipal
)
;
}
protected
:
virtual
~
NotificationObserver
(
)
{
AssertIsOnMainThread
(
)
;
}
nsresult
AdjustPushQuota
(
const
char
*
aTopic
)
;
nsCOMPtr
<
nsIObserver
>
mObserver
;
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
}
;
NS_IMPL_ISUPPORTS
(
NotificationObserver
nsIObserver
)
class
MainThreadNotificationObserver
:
public
nsIObserver
{
public
:
RefPtr
<
NotificationTask
>
mNotificationTask
;
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
explicit
MainThreadNotificationObserver
(
NotificationTask
*
aTask
)
:
mNotificationTask
(
aTask
)
{
AssertIsOnMainThread
(
)
;
}
protected
:
virtual
~
MainThreadNotificationObserver
(
)
{
AssertIsOnMainThread
(
)
;
}
}
;
NS_IMPL_ISUPPORTS
(
MainThreadNotificationObserver
nsIObserver
)
NS_IMETHODIMP
NotificationTaskRunnable
:
:
Run
(
)
{
AssertIsOnMainThread
(
)
;
Notification
*
notification
=
mNotificationTask
-
>
GetNotification
(
)
;
if
(
mNotificationTask
-
>
Action
(
)
=
=
NotificationTask
:
:
eShow
)
{
notification
-
>
ShowInternal
(
mNotificationTask
.
forget
(
)
)
;
return
NS_OK
;
}
MOZ_ASSERT
(
mNotificationTask
-
>
Action
(
)
=
=
NotificationTask
:
:
eClose
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
mNotificationTask
-
>
GetPrincipal
(
)
;
notification
-
>
CloseInternal
(
mNotificationTask
.
forget
(
)
principal
)
;
return
NS_OK
;
}
/
/
static
bool
Notification
:
:
PrefEnabled
(
JSContext
*
aCx
JSObject
*
aObj
)
{
if
(
!
NS_IsMainThread
(
)
)
{
WorkerPrivate
*
workerPrivate
=
GetWorkerPrivateFromContext
(
aCx
)
;
if
(
!
workerPrivate
)
{
return
false
;
}
if
(
workerPrivate
-
>
IsServiceWorker
(
)
)
{
return
DOMPrefs
:
:
NotificationEnabledInServiceWorkers
(
)
;
}
}
return
DOMPrefs
:
:
NotificationEnabled
(
)
;
}
/
/
static
bool
Notification
:
:
IsGetEnabled
(
JSContext
*
aCx
JSObject
*
aObj
)
{
return
NS_IsMainThread
(
)
;
}
Notification
:
:
Notification
(
nsIGlobalObject
*
aGlobal
const
nsAString
&
aID
const
nsAString
&
aTitle
const
nsAString
&
aBody
NotificationDirection
aDir
const
nsAString
&
aLang
const
nsAString
&
aTag
const
nsAString
&
aIconUrl
bool
aRequireInteraction
const
NotificationBehavior
&
aBehavior
)
:
DOMEventTargetHelper
(
)
mID
(
aID
)
mTitle
(
aTitle
)
mBody
(
aBody
)
mDir
(
aDir
)
mLang
(
aLang
)
mTag
(
aTag
)
mIconUrl
(
aIconUrl
)
mRequireInteraction
(
aRequireInteraction
)
mBehavior
(
aBehavior
)
mData
(
JS
:
:
NullValue
(
)
)
mIsClosed
(
false
)
mIsStored
(
false
)
{
if
(
NS_IsMainThread
(
)
)
{
/
/
We
can
only
call
this
on
the
main
thread
because
/
/
Event
:
:
SetEventType
(
)
called
down
the
call
chain
when
dispatching
events
/
/
using
DOMEventTargetHelper
:
:
DispatchTrustedEvent
(
)
will
assume
the
event
/
/
is
a
main
thread
event
if
it
has
a
valid
owner
.
It
will
then
attempt
to
/
/
fetch
the
atom
for
the
event
name
which
asserts
main
thread
only
.
BindToOwner
(
aGlobal
)
;
}
}
nsresult
Notification
:
:
Init
(
)
{
AssertIsOnTargetThread
(
)
;
if
(
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
NS_ENSURE_TRUE
(
obs
NS_ERROR_FAILURE
)
;
nsresult
rv
=
obs
-
>
AddObserver
(
this
DOM_WINDOW_DESTROYED_TOPIC
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
obs
-
>
AddObserver
(
this
DOM_WINDOW_FROZEN_TOPIC
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
void
Notification
:
:
SetAlertName
(
nsIPrincipal
*
aPrincipal
)
{
AssertIsOnMainThread
(
)
;
if
(
!
mAlertName
.
IsEmpty
(
)
)
{
return
;
}
nsAutoString
alertName
;
nsresult
rv
=
GetOrigin
(
aPrincipal
alertName
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
/
/
Get
the
notification
name
that
is
unique
per
origin
+
tag
/
ID
.
/
/
The
name
of
the
alert
is
of
the
form
origin
#
tag
/
ID
.
alertName
.
Append
(
'
#
'
)
;
if
(
!
mTag
.
IsEmpty
(
)
)
{
alertName
.
AppendLiteral
(
"
tag
:
"
)
;
alertName
.
Append
(
mTag
)
;
}
else
{
alertName
.
AppendLiteral
(
"
notag
:
"
)
;
alertName
.
Append
(
mID
)
;
}
mAlertName
=
alertName
;
}
/
/
May
be
called
on
any
thread
.
/
/
static
already_AddRefed
<
Notification
>
Notification
:
:
Constructor
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aTitle
const
NotificationOptions
&
aOptions
ErrorResult
&
aRv
)
{
/
/
FIXME
(
nsm
)
:
If
the
sticky
flag
is
set
throw
an
error
.
RefPtr
<
ServiceWorkerGlobalScope
>
scope
;
UNWRAP_OBJECT
(
ServiceWorkerGlobalScope
aGlobal
.
Get
(
)
scope
)
;
if
(
scope
)
{
aRv
.
ThrowTypeError
<
MSG_NOTIFICATION_NO_CONSTRUCTOR_IN_SERVICEWORKER
>
(
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
RefPtr
<
Notification
>
notification
=
CreateAndShow
(
aGlobal
.
Context
(
)
global
aTitle
aOptions
EmptyString
(
)
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
/
/
This
is
be
ok
since
we
are
on
the
worker
thread
where
this
function
will
/
/
run
to
completion
before
the
Notification
has
a
chance
to
go
away
.
return
notification
.
forget
(
)
;
}
/
/
static
already_AddRefed
<
Notification
>
Notification
:
:
ConstructFromFields
(
nsIGlobalObject
*
aGlobal
const
nsAString
&
aID
const
nsAString
&
aTitle
const
nsAString
&
aDir
const
nsAString
&
aLang
const
nsAString
&
aBody
const
nsAString
&
aTag
const
nsAString
&
aIcon
const
nsAString
&
aData
const
nsAString
&
aServiceWorkerRegistrationScope
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aGlobal
)
;
RootedDictionary
<
NotificationOptions
>
options
(
RootingCx
(
)
)
;
options
.
mDir
=
Notification
:
:
StringToDirection
(
nsString
(
aDir
)
)
;
options
.
mLang
=
aLang
;
options
.
mBody
=
aBody
;
options
.
mTag
=
aTag
;
options
.
mIcon
=
aIcon
;
RefPtr
<
Notification
>
notification
=
CreateInternal
(
aGlobal
aID
aTitle
options
)
;
notification
-
>
InitFromBase64
(
aData
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
notification
-
>
SetScope
(
aServiceWorkerRegistrationScope
)
;
return
notification
.
forget
(
)
;
}
nsresult
Notification
:
:
PersistNotification
(
nsIPrincipal
*
aPrincipal
)
{
AssertIsOnMainThread
(
)
;
nsresult
rv
;
nsCOMPtr
<
nsINotificationStorage
>
notificationStorage
=
do_GetService
(
NS_NOTIFICATION_STORAGE_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsString
origin
;
rv
=
GetOrigin
(
aPrincipal
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsString
id
;
GetID
(
id
)
;
nsString
alertName
;
GetAlertName
(
aPrincipal
alertName
)
;
nsAutoString
behavior
;
if
(
!
mBehavior
.
ToJSON
(
behavior
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
notificationStorage
-
>
Put
(
origin
id
mTitle
DirectionToString
(
mDir
)
mLang
mBody
mTag
mIconUrl
alertName
mDataAsBase64
behavior
mScope
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
SetStoredState
(
true
)
;
return
NS_OK
;
}
void
Notification
:
:
UnpersistNotification
(
nsIPrincipal
*
aPrincipal
)
{
AssertIsOnMainThread
(
)
;
if
(
IsStored
(
)
)
{
nsCOMPtr
<
nsINotificationStorage
>
notificationStorage
=
do_GetService
(
NS_NOTIFICATION_STORAGE_CONTRACTID
)
;
if
(
notificationStorage
)
{
nsString
origin
;
nsresult
rv
=
GetOrigin
(
aPrincipal
origin
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
notificationStorage
-
>
Delete
(
origin
mID
)
;
}
}
SetStoredState
(
false
)
;
}
}
already_AddRefed
<
Notification
>
Notification
:
:
CreateInternal
(
nsIGlobalObject
*
aGlobal
const
nsAString
&
aID
const
nsAString
&
aTitle
const
NotificationOptions
&
aOptions
)
{
nsresult
rv
;
nsString
id
;
if
(
!
aID
.
IsEmpty
(
)
)
{
id
=
aID
;
}
else
{
nsCOMPtr
<
nsIUUIDGenerator
>
uuidgen
=
do_GetService
(
"
mozilla
.
org
/
uuid
-
generator
;
1
"
)
;
NS_ENSURE_TRUE
(
uuidgen
nullptr
)
;
nsID
uuid
;
rv
=
uuidgen
-
>
GenerateUUIDInPlace
(
&
uuid
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
char
buffer
[
NSID_LENGTH
]
;
uuid
.
ToProvidedString
(
buffer
)
;
NS_ConvertASCIItoUTF16
convertedID
(
buffer
)
;
id
=
convertedID
;
}
RefPtr
<
Notification
>
notification
=
new
Notification
(
aGlobal
id
aTitle
aOptions
.
mBody
aOptions
.
mDir
aOptions
.
mLang
aOptions
.
mTag
aOptions
.
mIcon
aOptions
.
mRequireInteraction
aOptions
.
mMozbehavior
)
;
rv
=
notification
-
>
Init
(
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
return
notification
.
forget
(
)
;
}
Notification
:
:
~
Notification
(
)
{
mData
.
setUndefined
(
)
;
mozilla
:
:
DropJSObjects
(
this
)
;
AssertIsOnTargetThread
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
Notification
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
Notification
DOMEventTargetHelper
)
tmp
-
>
mData
.
setUndefined
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
Notification
DOMEventTargetHelper
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED
(
Notification
DOMEventTargetHelper
)
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mData
)
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_IMPL_ADDREF_INHERITED
(
Notification
DOMEventTargetHelper
)
NS_IMPL_RELEASE_INHERITED
(
Notification
DOMEventTargetHelper
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
Notification
)
NS_INTERFACE_MAP_ENTRY
(
nsIObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_END_INHERITING
(
DOMEventTargetHelper
)
class
WorkerNotificationObserver
final
:
public
MainThreadNotificationObserver
{
public
:
NS_INLINE_DECL_REFCOUNTING_INHERITED
(
WorkerNotificationObserver
MainThreadNotificationObserver
)
NS_DECL_NSIOBSERVER
explicit
WorkerNotificationObserver
(
NotificationTask
*
aTask
)
:
MainThreadNotificationObserver
(
aTask
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
mNotificationTask
-
>
GetWorkerRef
(
)
)
;
}
void
ReleaseNotificationOnMainThread
(
)
{
AssertIsOnMainThread
(
)
;
mNotificationTask
-
>
ReleaseNotificationOnMainThread
(
)
;
mNotificationTask
=
nullptr
;
}
protected
:
~
WorkerNotificationObserver
(
)
{
AssertIsOnMainThread
(
)
;
}
}
;
class
ServiceWorkerNotificationObserver
final
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
ServiceWorkerNotificationObserver
(
const
nsAString
&
aScope
nsIPrincipal
*
aPrincipal
const
nsAString
&
aID
const
nsAString
&
aTitle
const
nsAString
&
aDir
const
nsAString
&
aLang
const
nsAString
&
aBody
const
nsAString
&
aTag
const
nsAString
&
aIcon
const
nsAString
&
aData
const
nsAString
&
aBehavior
)
:
mScope
(
aScope
)
mID
(
aID
)
mPrincipal
(
aPrincipal
)
mTitle
(
aTitle
)
mDir
(
aDir
)
mLang
(
aLang
)
mBody
(
aBody
)
mTag
(
aTag
)
mIcon
(
aIcon
)
mData
(
aData
)
mBehavior
(
aBehavior
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aPrincipal
)
;
}
private
:
~
ServiceWorkerNotificationObserver
(
)
=
default
;
const
nsString
mScope
;
const
nsString
mID
;
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
const
nsString
mTitle
;
const
nsString
mDir
;
const
nsString
mLang
;
const
nsString
mBody
;
const
nsString
mTag
;
const
nsString
mIcon
;
const
nsString
mData
;
const
nsString
mBehavior
;
}
;
NS_IMPL_ISUPPORTS
(
ServiceWorkerNotificationObserver
nsIObserver
)
/
/
For
ServiceWorkers
.
bool
Notification
:
:
DispatchClickEvent
(
)
{
AssertIsOnTargetThread
(
)
;
RefPtr
<
Event
>
event
=
NS_NewDOMEvent
(
this
nullptr
nullptr
)
;
event
-
>
InitEvent
(
NS_LITERAL_STRING
(
"
click
"
)
false
true
)
;
event
-
>
SetTrusted
(
true
)
;
WantsPopupControlCheck
popupControlCheck
(
event
)
;
return
DispatchEvent
(
*
event
CallerType
:
:
System
IgnoreErrors
(
)
)
;
}
/
/
Overrides
dispatch
and
run
handlers
so
we
can
directly
dispatch
from
main
/
/
thread
to
child
workers
.
class
NotificationClickWorkerRunnable
final
:
public
MainThreadWorkerRunnable
{
RefPtr
<
NotificationTask
>
mNotificationTask
;
/
/
Optional
window
that
gets
focused
if
click
event
is
not
/
/
preventDefault
(
)
ed
.
nsMainThreadPtrHandle
<
nsPIDOMWindowInner
>
mWindow
;
public
:
NotificationClickWorkerRunnable
(
NotificationTask
*
aNotificationTask
const
nsMainThreadPtrHandle
<
nsPIDOMWindowInner
>
&
aWindow
)
:
MainThreadWorkerRunnable
(
aNotificationTask
-
>
GetWorkerRef
(
)
-
>
Private
(
)
)
mNotificationTask
(
aNotificationTask
)
mWindow
(
aWindow
)
{
MOZ_ASSERT_IF
(
aNotificationTask
-
>
GetWorkerRef
(
)
-
>
Private
(
)
-
>
IsServiceWorker
(
)
!
mWindow
)
;
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
bool
doDefaultAction
=
mNotificationTask
-
>
GetNotification
(
)
-
>
DispatchClickEvent
(
)
;
MOZ_ASSERT_IF
(
mWorkerPrivate
-
>
IsServiceWorker
(
)
!
doDefaultAction
)
;
if
(
doDefaultAction
)
{
RefPtr
<
FocusWindowRunnable
>
r
=
new
FocusWindowRunnable
(
mWindow
)
;
mWorkerPrivate
-
>
DispatchToMainThread
(
r
.
forget
(
)
)
;
}
return
true
;
}
}
;
NS_IMETHODIMP
NotificationObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
AssertIsOnMainThread
(
)
;
if
(
!
strcmp
(
"
alertdisablecallback
"
aTopic
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEB_NOTIFICATION_MENU
1
)
;
if
(
XRE_IsParentProcess
(
)
)
{
return
Notification
:
:
RemovePermission
(
mPrincipal
)
;
}
/
/
Permissions
can
'
t
be
removed
from
the
content
process
.
Send
a
message
/
/
to
the
parent
;
ContentParent
:
:
RecvDisableNotifications
will
call
/
/
RemovePermission
.
ContentChild
:
:
GetSingleton
(
)
-
>
SendDisableNotifications
(
IPC
:
:
Principal
(
mPrincipal
)
)
;
return
NS_OK
;
}
else
if
(
!
strcmp
(
"
alertclickcallback
"
aTopic
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEB_NOTIFICATION_CLICKED
1
)
;
}
else
if
(
!
strcmp
(
"
alertsettingscallback
"
aTopic
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEB_NOTIFICATION_MENU
2
)
;
if
(
XRE_IsParentProcess
(
)
)
{
return
Notification
:
:
OpenSettings
(
mPrincipal
)
;
}
/
/
ContentParent
:
:
RecvOpenNotificationSettings
notifies
observers
in
the
/
/
parent
process
.
ContentChild
:
:
GetSingleton
(
)
-
>
SendOpenNotificationSettings
(
IPC
:
:
Principal
(
mPrincipal
)
)
;
return
NS_OK
;
}
else
if
(
!
strcmp
(
"
alertshow
"
aTopic
)
|
|
!
strcmp
(
"
alertfinished
"
aTopic
)
)
{
RefPtr
<
NotificationTelemetryService
>
telemetry
=
NotificationTelemetryService
:
:
GetInstance
(
)
;
if
(
telemetry
)
{
/
/
Record
whether
"
do
not
disturb
"
is
supported
after
the
first
/
/
notification
to
account
for
falling
back
to
XUL
alerts
.
telemetry
-
>
RecordDNDSupported
(
)
;
}
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
AdjustPushQuota
(
aTopic
)
)
)
;
if
(
!
strcmp
(
"
alertshow
"
aTopic
)
)
{
/
/
Record
notifications
actually
shown
(
e
.
g
.
don
'
t
count
if
DND
is
on
)
.
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEB_NOTIFICATION_SHOWN
1
)
;
}
}
return
mObserver
-
>
Observe
(
aSubject
aTopic
aData
)
;
}
nsresult
NotificationObserver
:
:
AdjustPushQuota
(
const
char
*
aTopic
)
{
nsCOMPtr
<
nsIPushQuotaManager
>
pushQuotaManager
=
do_GetService
(
"
mozilla
.
org
/
push
/
Service
;
1
"
)
;
if
(
!
pushQuotaManager
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoCString
origin
;
nsresult
rv
=
mPrincipal
-
>
GetOrigin
(
origin
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
strcmp
(
"
alertshow
"
aTopic
)
)
{
return
pushQuotaManager
-
>
NotificationForOriginShown
(
origin
.
get
(
)
)
;
}
return
pushQuotaManager
-
>
NotificationForOriginClosed
(
origin
.
get
(
)
)
;
}
NS_IMETHODIMP
MainThreadNotificationObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
mNotificationTask
)
;
Notification
*
notification
=
mNotificationTask
-
>
GetNotification
(
)
;
MOZ_ASSERT
(
notification
)
;
if
(
!
strcmp
(
"
alertclickcallback
"
aTopic
)
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
notification
-
>
GetOwner
(
)
;
if
(
NS_WARN_IF
(
!
window
|
|
!
window
-
>
IsCurrentInnerWindow
(
)
)
)
{
/
/
Window
has
been
closed
this
observer
is
not
valid
anymore
return
NS_ERROR_FAILURE
;
}
bool
doDefaultAction
=
notification
-
>
DispatchClickEvent
(
)
;
if
(
doDefaultAction
)
{
/
/
Browser
UI
may
use
DOMWindowFocus
to
focus
the
tab
/
/
from
which
the
event
was
dispatched
.
nsContentUtils
:
:
DispatchFocusChromeEvent
(
window
-
>
GetOuterWindow
(
)
)
;
}
}
else
if
(
!
strcmp
(
"
alertfinished
"
aTopic
)
)
{
notification
-
>
UnpersistNotification
(
mNotificationTask
-
>
GetPrincipal
(
)
)
;
notification
-
>
mIsClosed
=
true
;
notification
-
>
DispatchTrustedEvent
(
NS_LITERAL_STRING
(
"
close
"
)
)
;
}
else
if
(
!
strcmp
(
"
alertshow
"
aTopic
)
)
{
notification
-
>
DispatchTrustedEvent
(
NS_LITERAL_STRING
(
"
show
"
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
WorkerNotificationObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
mNotificationTask
)
;
MOZ_ASSERT
(
mNotificationTask
-
>
GetWorkerRef
(
)
)
;
/
/
For
an
explanation
of
why
it
is
OK
to
pass
this
rawptr
to
the
event
/
/
runnables
see
the
Notification
class
comment
.
Notification
*
notification
=
mNotificationTask
-
>
GetNotification
(
)
;
/
/
We
can
'
t
assert
notification
here
since
the
feature
could
'
ve
unset
it
.
if
(
NS_WARN_IF
(
!
notification
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
WorkerRunnable
>
r
;
if
(
!
strcmp
(
"
alertclickcallback
"
aTopic
)
)
{
nsPIDOMWindowInner
*
window
=
nullptr
;
if
(
!
mNotificationTask
-
>
GetWorkerRef
(
)
-
>
Private
(
)
-
>
IsServiceWorker
(
)
)
{
WorkerPrivate
*
top
=
mNotificationTask
-
>
GetWorkerRef
(
)
-
>
Private
(
)
;
while
(
top
-
>
GetParent
(
)
)
{
top
=
top
-
>
GetParent
(
)
;
}
window
=
top
-
>
GetWindow
(
)
;
if
(
NS_WARN_IF
(
!
window
|
|
!
window
-
>
IsCurrentInnerWindow
(
)
)
)
{
/
/
Window
has
been
closed
this
observer
is
not
valid
anymore
return
NS_ERROR_FAILURE
;
}
}
/
/
Instead
of
bothering
with
adding
features
and
other
worker
lifecycle
/
/
management
we
simply
hold
strongrefs
to
the
window
and
document
.
nsMainThreadPtrHandle
<
nsPIDOMWindowInner
>
windowHandle
(
new
nsMainThreadPtrHolder
<
nsPIDOMWindowInner
>
(
"
WorkerNotificationObserver
:
:
Observe
:
:
nsPIDOMWindowInner
"
window
)
)
;
r
=
new
NotificationClickWorkerRunnable
(
mNotificationTask
windowHandle
)
;
Unused
<
<
NS_WARN_IF
(
!
r
-
>
Dispatch
(
)
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
"
alertfinished
"
aTopic
)
)
{
notification
-
>
UnpersistNotification
(
mNotificationTask
-
>
GetPrincipal
(
)
)
;
notification
-
>
mIsClosed
=
true
;
r
=
new
NotificationEventWorkerRunnable
(
mNotificationTask
NS_LITERAL_STRING
(
"
close
"
)
)
;
/
/
This
is
the
last
notification
.
Let
'
s
break
the
cycle
.
mNotificationTask
-
>
SetObserver
(
nullptr
)
;
mNotificationTask
=
nullptr
;
Unused
<
<
NS_WARN_IF
(
!
r
-
>
Dispatch
(
)
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
"
alertshow
"
aTopic
)
)
{
r
=
new
NotificationEventWorkerRunnable
(
mNotificationTask
NS_LITERAL_STRING
(
"
show
"
)
)
;
Unused
<
<
NS_WARN_IF
(
!
r
-
>
Dispatch
(
)
)
;
return
NS_OK
;
}
return
NS_OK
;
}
NS_IMETHODIMP
ServiceWorkerNotificationObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
AssertIsOnMainThread
(
)
;
nsAutoCString
originSuffix
;
nsresult
rv
=
mPrincipal
-
>
GetOriginSuffix
(
originSuffix
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIServiceWorkerManager
>
swm
=
mozilla
:
:
services
:
:
GetServiceWorkerManager
(
)
;
if
(
NS_WARN_IF
(
!
swm
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
strcmp
(
"
alertclickcallback
"
aTopic
)
)
{
rv
=
swm
-
>
SendNotificationClickEvent
(
originSuffix
NS_ConvertUTF16toUTF8
(
mScope
)
mID
mTitle
mDir
mLang
mBody
mTag
mIcon
mData
mBehavior
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
"
alertfinished
"
aTopic
)
)
{
nsString
origin
;
nsresult
rv
=
Notification
:
:
GetOrigin
(
mPrincipal
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
/
/
Remove
closed
or
dismissed
persistent
notifications
.
nsCOMPtr
<
nsINotificationStorage
>
notificationStorage
=
do_GetService
(
NS_NOTIFICATION_STORAGE_CONTRACTID
)
;
if
(
notificationStorage
)
{
notificationStorage
-
>
Delete
(
origin
mID
)
;
}
rv
=
swm
-
>
SendNotificationCloseEvent
(
originSuffix
NS_ConvertUTF16toUTF8
(
mScope
)
mID
mTitle
mDir
mLang
mBody
mTag
mIcon
mData
mBehavior
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
return
NS_OK
;
}
return
NS_OK
;
}
namespace
{
struct
StringWriteFunc
:
public
JSONWriteFunc
{
nsAString
&
mBuffer
;
/
/
This
struct
must
not
outlive
this
buffer
explicit
StringWriteFunc
(
nsAString
&
buffer
)
:
mBuffer
(
buffer
)
{
}
void
Write
(
const
char
*
aStr
)
override
{
mBuffer
.
Append
(
NS_ConvertUTF8toUTF16
(
aStr
)
)
;
}
}
;
}
void
Notification
:
:
ShowInternal
(
already_AddRefed
<
NotificationTask
>
aTask
)
{
AssertIsOnMainThread
(
)
;
/
/
Transfer
ownership
to
local
scope
so
we
can
either
release
it
at
the
end
/
/
of
this
function
or
transfer
it
to
the
observer
.
RefPtr
<
NotificationTask
>
ownership
=
std
:
:
move
(
aTask
)
;
MOZ_ASSERT
(
ownership
-
>
GetNotification
(
)
=
=
this
)
;
nsresult
rv
=
PersistNotification
(
ownership
-
>
GetPrincipal
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Could
not
persist
Notification
"
)
;
}
nsCOMPtr
<
nsIAlertsService
>
alertService
=
do_GetService
(
NS_ALERTSERVICE_CONTRACTID
)
;
ErrorResult
result
;
NotificationPermission
permission
=
GetPermissionInternal
(
ownership
-
>
GetPrincipal
(
)
result
)
;
/
/
We
rely
on
GetPermissionInternal
returning
Denied
on
all
failure
codepaths
.
MOZ_ASSERT_IF
(
result
.
Failed
(
)
permission
=
=
NotificationPermission
:
:
Denied
)
;
result
.
SuppressException
(
)
;
if
(
permission
!
=
NotificationPermission
:
:
Granted
|
|
!
alertService
)
{
if
(
ownership
-
>
GetWorkerRef
(
)
)
{
RefPtr
<
NotificationEventWorkerRunnable
>
r
=
new
NotificationEventWorkerRunnable
(
ownership
NS_LITERAL_STRING
(
"
error
"
)
)
;
if
(
!
r
-
>
Dispatch
(
)
)
{
NS_WARNING
(
"
Could
not
dispatch
event
to
worker
notification
"
)
;
}
}
else
{
DispatchTrustedEvent
(
NS_LITERAL_STRING
(
"
error
"
)
)
;
}
return
;
}
nsAutoString
iconUrl
;
nsAutoString
soundUrl
;
ownership
-
>
ResolveIconAndSoundURL
(
iconUrl
soundUrl
)
;
bool
isPersistent
=
false
;
nsCOMPtr
<
nsIObserver
>
observer
;
if
(
mScope
.
IsEmpty
(
)
)
{
/
/
Ownership
passed
to
observer
.
if
(
ownership
-
>
GetWorkerRef
(
)
)
{
/
/
Scope
better
be
set
on
ServiceWorker
initiated
requests
.
MOZ_ASSERT
(
!
ownership
-
>
GetWorkerRef
(
)
-
>
Private
(
)
-
>
IsServiceWorker
(
)
)
;
RefPtr
<
WorkerNotificationObserver
>
wObserver
=
new
WorkerNotificationObserver
(
ownership
)
;
ownership
-
>
SetObserver
(
wObserver
)
;
observer
=
wObserver
;
}
else
{
observer
=
new
MainThreadNotificationObserver
(
ownership
)
;
}
}
else
{
isPersistent
=
true
;
/
/
This
observer
does
not
care
about
the
Notification
.
It
will
be
released
/
/
at
the
end
of
this
function
.
/
/
/
/
The
observer
is
wholly
owned
by
the
NotificationObserver
passed
to
the
alert
service
.
nsAutoString
behavior
;
if
(
NS_WARN_IF
(
!
mBehavior
.
ToJSON
(
behavior
)
)
)
{
behavior
.
Truncate
(
)
;
}
observer
=
new
ServiceWorkerNotificationObserver
(
mScope
ownership
-
>
GetPrincipal
(
)
mID
mTitle
DirectionToString
(
mDir
)
mLang
mBody
mTag
iconUrl
mDataAsBase64
behavior
)
;
}
MOZ_ASSERT
(
observer
)
;
nsCOMPtr
<
nsIObserver
>
alertObserver
=
new
NotificationObserver
(
observer
ownership
-
>
GetPrincipal
(
)
)
;
/
/
In
the
case
of
IPC
the
parent
process
uses
the
cookie
to
map
to
/
/
nsIObserver
.
Thus
the
cookie
must
be
unique
to
differentiate
observers
.
nsString
uniqueCookie
=
NS_LITERAL_STRING
(
"
notification
:
"
)
;
uniqueCookie
.
AppendInt
(
sCount
+
+
)
;
bool
inPrivateBrowsing
=
ownership
-
>
IsInPrivateBrowsing
(
)
;
bool
requireInteraction
=
mRequireInteraction
;
if
(
!
DOMPrefs
:
:
NotificationRIEnabled
(
)
)
{
requireInteraction
=
false
;
}
nsAutoString
alertName
;
GetAlertName
(
ownership
-
>
GetPrincipal
(
)
alertName
)
;
nsCOMPtr
<
nsIAlertNotification
>
alert
=
do_CreateInstance
(
ALERT_NOTIFICATION_CONTRACTID
)
;
NS_ENSURE_TRUE_VOID
(
alert
)
;
nsIPrincipal
*
principal
=
ownership
-
>
GetPrincipal
(
)
;
rv
=
alert
-
>
Init
(
alertName
iconUrl
mTitle
mBody
true
uniqueCookie
DirectionToString
(
mDir
)
mLang
mDataAsBase64
ownership
-
>
GetPrincipal
(
)
inPrivateBrowsing
requireInteraction
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
if
(
isPersistent
)
{
nsAutoString
persistentData
;
JSONWriter
w
(
MakeUnique
<
StringWriteFunc
>
(
persistentData
)
)
;
w
.
Start
(
)
;
nsAutoString
origin
;
Notification
:
:
GetOrigin
(
principal
origin
)
;
w
.
StringProperty
(
"
origin
"
NS_ConvertUTF16toUTF8
(
origin
)
.
get
(
)
)
;
w
.
StringProperty
(
"
id
"
NS_ConvertUTF16toUTF8
(
mID
)
.
get
(
)
)
;
nsAutoCString
originSuffix
;
principal
-
>
GetOriginSuffix
(
originSuffix
)
;
w
.
StringProperty
(
"
originSuffix
"
originSuffix
.
get
(
)
)
;
w
.
End
(
)
;
alertService
-
>
ShowPersistentNotification
(
persistentData
alert
alertObserver
)
;
}
else
{
alertService
-
>
ShowAlert
(
alert
alertObserver
)
;
}
}
/
*
static
*
/
bool
Notification
:
:
RequestPermissionEnabledForScope
(
JSContext
*
aCx
JSObject
*
/
*
unused
*
/
)
{
/
/
requestPermission
(
)
is
not
allowed
on
workers
.
The
calling
page
should
ask
/
/
for
permission
on
the
worker
'
s
behalf
.
This
is
to
prevent
'
which
window
/
/
should
show
the
browser
pop
-
up
'
.
See
discussion
:
/
/
http
:
/
/
lists
.
whatwg
.
org
/
pipermail
/
whatwg
-
whatwg
.
org
/
2013
-
October
/
041272
.
html
return
NS_IsMainThread
(
)
;
}
/
/
static
already_AddRefed
<
Promise
>
Notification
:
:
RequestPermission
(
const
GlobalObject
&
aGlobal
const
Optional
<
OwningNonNull
<
NotificationPermissionCallback
>
>
&
aCallback
ErrorResult
&
aRv
)
{
AssertIsOnMainThread
(
)
;
/
/
Get
principal
from
global
to
make
permission
request
for
notifications
.
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
nsCOMPtr
<
nsIScriptObjectPrincipal
>
sop
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
sop
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
sop
-
>
GetPrincipal
(
)
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
window
-
>
AsGlobal
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
NotificationPermissionCallback
*
permissionCallback
=
nullptr
;
if
(
aCallback
.
WasPassed
(
)
)
{
permissionCallback
=
&
aCallback
.
Value
(
)
;
}
bool
isHandlingUserInput
=
EventStateManager
:
:
IsHandlingUserInput
(
)
;
nsCOMPtr
<
nsIRunnable
>
request
=
new
NotificationPermissionRequest
(
principal
isHandlingUserInput
window
promise
permissionCallback
)
;
window
-
>
AsGlobal
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
request
.
forget
(
)
)
;
return
promise
.
forget
(
)
;
}
/
/
static
NotificationPermission
Notification
:
:
GetPermission
(
const
GlobalObject
&
aGlobal
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
return
GetPermission
(
global
aRv
)
;
}
/
/
static
NotificationPermission
Notification
:
:
GetPermission
(
nsIGlobalObject
*
aGlobal
ErrorResult
&
aRv
)
{
if
(
NS_IsMainThread
(
)
)
{
/
/
Get
principal
from
global
to
check
permission
for
notifications
.
nsCOMPtr
<
nsIScriptObjectPrincipal
>
sop
=
do_QueryInterface
(
aGlobal
)
;
if
(
!
sop
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
NotificationPermission
:
:
Denied
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
sop
-
>
GetPrincipal
(
)
;
return
GetPermissionInternal
(
principal
aRv
)
;
}
RefPtr
<
GetPermissionRunnable
>
r
=
new
GetPermissionRunnable
(
)
;
r
-
>
Dispatch
(
Terminating
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
NotificationPermission
:
:
Denied
;
}
return
r
-
>
GetPermission
(
)
;
}
/
*
static
*
/
NotificationPermission
Notification
:
:
GetPermissionInternal
(
nsIPrincipal
*
aPrincipal
ErrorResult
&
aRv
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aPrincipal
)
;
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
aPrincipal
)
)
{
return
NotificationPermission
:
:
Granted
;
}
else
{
/
/
Allow
files
to
show
notifications
by
default
.
nsCOMPtr
<
nsIURI
>
uri
;
aPrincipal
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
uri
)
{
bool
isFile
;
uri
-
>
SchemeIs
(
"
file
"
&
isFile
)
;
if
(
isFile
)
{
return
NotificationPermission
:
:
Granted
;
}
}
}
/
/
We
also
allow
notifications
is
they
are
pref
'
ed
on
.
if
(
Preferences
:
:
GetBool
(
"
notification
.
prompt
.
testing
"
false
)
)
{
if
(
Preferences
:
:
GetBool
(
"
notification
.
prompt
.
testing
.
allow
"
true
)
)
{
return
NotificationPermission
:
:
Granted
;
}
else
{
return
NotificationPermission
:
:
Denied
;
}
}
return
TestPermission
(
aPrincipal
)
;
}
/
*
static
*
/
NotificationPermission
Notification
:
:
TestPermission
(
nsIPrincipal
*
aPrincipal
)
{
AssertIsOnMainThread
(
)
;
uint32_t
permission
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
;
nsCOMPtr
<
nsIPermissionManager
>
permissionManager
=
services
:
:
GetPermissionManager
(
)
;
if
(
!
permissionManager
)
{
return
NotificationPermission
:
:
Default
;
}
permissionManager
-
>
TestExactPermissionFromPrincipal
(
aPrincipal
"
desktop
-
notification
"
&
permission
)
;
/
/
Convert
the
result
to
one
of
the
enum
types
.
switch
(
permission
)
{
case
nsIPermissionManager
:
:
ALLOW_ACTION
:
return
NotificationPermission
:
:
Granted
;
case
nsIPermissionManager
:
:
DENY_ACTION
:
return
NotificationPermission
:
:
Denied
;
default
:
return
NotificationPermission
:
:
Default
;
}
}
already_AddRefed
<
Promise
>
Notification
:
:
Get
(
nsPIDOMWindowInner
*
aWindow
const
GetNotificationOptions
&
aFilter
const
nsAString
&
aScope
ErrorResult
&
aRv
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aWindow
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
aWindow
-
>
GetExtantDoc
(
)
;
if
(
!
doc
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
nsString
origin
;
aRv
=
GetOrigin
(
doc
-
>
NodePrincipal
(
)
origin
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
aWindow
-
>
AsGlobal
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsINotificationStorageCallback
>
callback
=
new
NotificationStorageCallback
(
aWindow
-
>
AsGlobal
(
)
aScope
promise
)
;
RefPtr
<
NotificationGetRunnable
>
r
=
new
NotificationGetRunnable
(
origin
aFilter
.
mTag
callback
)
;
aRv
=
aWindow
-
>
AsGlobal
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
r
.
forget
(
)
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
Notification
:
:
Get
(
const
GlobalObject
&
aGlobal
const
GetNotificationOptions
&
aFilter
ErrorResult
&
aRv
)
{
AssertIsOnMainThread
(
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
MOZ_ASSERT
(
global
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
global
)
;
return
Get
(
window
aFilter
EmptyString
(
)
aRv
)
;
}
class
WorkerGetResultRunnable
final
:
public
MainThreadWorkerRunnable
{
RefPtr
<
PromiseWorkerProxy
>
mPromiseProxy
;
const
nsTArray
<
NotificationStrings
>
mStrings
;
public
:
WorkerGetResultRunnable
(
WorkerPrivate
*
aWorkerPrivate
PromiseWorkerProxy
*
aPromiseProxy
const
nsTArray
<
NotificationStrings
>
&
&
aStrings
)
:
MainThreadWorkerRunnable
(
aWorkerPrivate
)
mPromiseProxy
(
aPromiseProxy
)
mStrings
(
std
:
:
move
(
aStrings
)
)
{
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
RefPtr
<
Promise
>
workerPromise
=
mPromiseProxy
-
>
WorkerPromise
(
)
;
ErrorResult
result
;
AutoTArray
<
RefPtr
<
Notification
>
5
>
notifications
;
for
(
uint32_t
i
=
0
;
i
<
mStrings
.
Length
(
)
;
+
+
i
)
{
RefPtr
<
Notification
>
n
=
Notification
:
:
ConstructFromFields
(
aWorkerPrivate
-
>
GlobalScope
(
)
mStrings
[
i
]
.
mID
mStrings
[
i
]
.
mTitle
mStrings
[
i
]
.
mDir
mStrings
[
i
]
.
mLang
mStrings
[
i
]
.
mBody
mStrings
[
i
]
.
mTag
mStrings
[
i
]
.
mIcon
mStrings
[
i
]
.
mData
/
*
mStrings
[
i
]
.
mBehavior
not
*
supported
*
/
mStrings
[
i
]
.
mServiceWorkerRegistrationScope
result
)
;
n
-
>
SetStoredState
(
true
)
;
Unused
<
<
NS_WARN_IF
(
result
.
Failed
(
)
)
;
if
(
!
result
.
Failed
(
)
)
{
notifications
.
AppendElement
(
n
.
forget
(
)
)
;
}
}
workerPromise
-
>
MaybeResolve
(
notifications
)
;
mPromiseProxy
-
>
CleanUp
(
)
;
return
true
;
}
}
;
class
WorkerGetCallback
final
:
public
ScopeCheckingGetCallback
{
RefPtr
<
PromiseWorkerProxy
>
mPromiseProxy
;
public
:
NS_DECL_ISUPPORTS
WorkerGetCallback
(
PromiseWorkerProxy
*
aProxy
const
nsAString
&
aScope
)
:
ScopeCheckingGetCallback
(
aScope
)
mPromiseProxy
(
aProxy
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aProxy
)
;
}
NS_IMETHOD
Done
(
)
final
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
mPromiseProxy
"
Was
Done
(
)
called
twice
?
"
)
;
RefPtr
<
PromiseWorkerProxy
>
proxy
=
mPromiseProxy
.
forget
(
)
;
MutexAutoLock
lock
(
proxy
-
>
Lock
(
)
)
;
if
(
proxy
-
>
CleanedUp
(
)
)
{
return
NS_OK
;
}
RefPtr
<
WorkerGetResultRunnable
>
r
=
new
WorkerGetResultRunnable
(
proxy
-
>
GetWorkerPrivate
(
)
proxy
std
:
:
move
(
mStrings
)
)
;
r
-
>
Dispatch
(
)
;
return
NS_OK
;
}
private
:
~
WorkerGetCallback
(
)
{
}
}
;
NS_IMPL_ISUPPORTS
(
WorkerGetCallback
nsINotificationStorageCallback
)
class
WorkerGetRunnable
final
:
public
Runnable
{
RefPtr
<
PromiseWorkerProxy
>
mPromiseProxy
;
const
nsString
mTag
;
const
nsString
mScope
;
public
:
WorkerGetRunnable
(
PromiseWorkerProxy
*
aProxy
const
nsAString
&
aTag
const
nsAString
&
aScope
)
:
Runnable
(
"
WorkerGetRunnable
"
)
mPromiseProxy
(
aProxy
)
mTag
(
aTag
)
mScope
(
aScope
)
{
MOZ_ASSERT
(
mPromiseProxy
)
;
}
NS_IMETHOD
Run
(
)
override
{
AssertIsOnMainThread
(
)
;
nsCOMPtr
<
nsINotificationStorageCallback
>
callback
=
new
WorkerGetCallback
(
mPromiseProxy
mScope
)
;
nsresult
rv
;
nsCOMPtr
<
nsINotificationStorage
>
notificationStorage
=
do_GetService
(
NS_NOTIFICATION_STORAGE_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
callback
-
>
Done
(
)
;
return
rv
;
}
MutexAutoLock
lock
(
mPromiseProxy
-
>
Lock
(
)
)
;
if
(
mPromiseProxy
-
>
CleanedUp
(
)
)
{
return
NS_OK
;
}
nsString
origin
;
rv
=
Notification
:
:
GetOrigin
(
mPromiseProxy
-
>
GetWorkerPrivate
(
)
-
>
GetPrincipal
(
)
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
callback
-
>
Done
(
)
;
return
rv
;
}
rv
=
notificationStorage
-
>
Get
(
origin
mTag
callback
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
callback
-
>
Done
(
)
;
return
rv
;
}
return
NS_OK
;
}
private
:
~
WorkerGetRunnable
(
)
{
}
}
;
/
/
static
already_AddRefed
<
Promise
>
Notification
:
:
WorkerGet
(
WorkerPrivate
*
aWorkerPrivate
const
GetNotificationOptions
&
aFilter
const
nsAString
&
aScope
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
RefPtr
<
Promise
>
p
=
Promise
:
:
Create
(
aWorkerPrivate
-
>
GlobalScope
(
)
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
RefPtr
<
PromiseWorkerProxy
>
proxy
=
PromiseWorkerProxy
:
:
Create
(
aWorkerPrivate
p
)
;
if
(
!
proxy
)
{
aRv
.
Throw
(
NS_ERROR_DOM_ABORT_ERR
)
;
return
nullptr
;
}
RefPtr
<
WorkerGetRunnable
>
r
=
new
WorkerGetRunnable
(
proxy
aFilter
.
mTag
aScope
)
;
/
/
Since
this
is
called
from
script
via
/
/
ServiceWorkerRegistration
:
:
GetNotifications
we
can
assert
dispatch
.
MOZ_ALWAYS_SUCCEEDS
(
aWorkerPrivate
-
>
DispatchToMainThread
(
r
.
forget
(
)
)
)
;
return
p
.
forget
(
)
;
}
JSObject
*
Notification
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
mozilla
:
:
dom
:
:
NotificationBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
Notification
:
:
Close
(
)
{
AssertIsOnTargetThread
(
)
;
RefPtr
<
NotificationTask
>
task
=
NotificationTask
:
:
Create
(
this
NotificationTask
:
:
eClose
)
;
if
(
NS_WARN_IF
(
!
task
)
)
{
return
;
}
nsCOMPtr
<
nsIRunnable
>
r
=
new
NotificationTaskRunnable
(
"
Notification
:
:
Close
"
task
)
;
nsresult
rv
=
task
-
>
DispatchToMainThread
(
r
.
forget
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
DispatchTrustedEvent
(
NS_LITERAL_STRING
(
"
error
"
)
)
;
/
/
If
dispatch
fails
NotificationTaskRunnable
will
release
the
task
when
it
/
/
goes
out
of
scope
at
the
end
of
this
function
.
}
}
void
Notification
:
:
CloseInternal
(
already_AddRefed
<
NotificationTask
>
aTask
nsIPrincipal
*
aPrincipal
)
{
AssertIsOnMainThread
(
)
;
/
/
aTask
can
be
null
.
RefPtr
<
NotificationTask
>
ownership
=
std
:
:
move
(
aTask
)
;
SetAlertName
(
aPrincipal
)
;
UnpersistNotification
(
aPrincipal
)
;
if
(
!
mIsClosed
)
{
nsCOMPtr
<
nsIAlertsService
>
alertService
=
do_GetService
(
NS_ALERTSERVICE_CONTRACTID
)
;
if
(
alertService
)
{
nsAutoString
alertName
;
GetAlertName
(
aPrincipal
alertName
)
;
alertService
-
>
CloseAlert
(
alertName
aPrincipal
)
;
}
}
}
nsresult
Notification
:
:
GetOrigin
(
nsIPrincipal
*
aPrincipal
nsString
&
aOrigin
)
{
if
(
!
aPrincipal
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
nsContentUtils
:
:
GetUTFOrigin
(
aPrincipal
aOrigin
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
bool
Notification
:
:
RequireInteraction
(
)
const
{
return
mRequireInteraction
;
}
void
Notification
:
:
GetData
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
)
{
if
(
mData
.
isNull
(
)
&
&
!
mDataAsBase64
.
IsEmpty
(
)
)
{
nsresult
rv
;
RefPtr
<
nsStructuredCloneContainer
>
container
=
new
nsStructuredCloneContainer
(
)
;
rv
=
container
-
>
InitFromBase64
(
mDataAsBase64
JS_STRUCTURED_CLONE_VERSION
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRetval
.
setNull
(
)
;
return
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
data
(
aCx
)
;
rv
=
container
-
>
DeserializeToJsval
(
aCx
&
data
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRetval
.
setNull
(
)
;
return
;
}
if
(
data
.
isGCThing
(
)
)
{
mozilla
:
:
HoldJSObjects
(
this
)
;
}
mData
=
data
;
}
if
(
mData
.
isNull
(
)
)
{
aRetval
.
setNull
(
)
;
return
;
}
aRetval
.
set
(
mData
)
;
}
void
Notification
:
:
InitFromJSVal
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aData
ErrorResult
&
aRv
)
{
if
(
!
mDataAsBase64
.
IsEmpty
(
)
|
|
aData
.
isNull
(
)
)
{
return
;
}
RefPtr
<
nsStructuredCloneContainer
>
dataObjectContainer
=
new
nsStructuredCloneContainer
(
)
;
aRv
=
dataObjectContainer
-
>
InitFromJSVal
(
aData
aCx
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
aRv
=
dataObjectContainer
-
>
GetDataAsBase64
(
mDataAsBase64
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
}
void
Notification
:
:
InitFromBase64
(
const
nsAString
&
aData
ErrorResult
&
aRv
)
{
if
(
!
mDataAsBase64
.
IsEmpty
(
)
|
|
aData
.
IsEmpty
(
)
)
{
return
;
}
/
/
To
and
fro
to
ensure
it
is
valid
base64
.
RefPtr
<
nsStructuredCloneContainer
>
container
=
new
nsStructuredCloneContainer
(
)
;
aRv
=
container
-
>
InitFromBase64
(
aData
JS_STRUCTURED_CLONE_VERSION
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
aRv
=
container
-
>
GetDataAsBase64
(
mDataAsBase64
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
}
/
*
*
Checks
:
*
1
)
Is
aWorker
allowed
to
show
a
notification
for
scope
?
*
2
)
Is
aWorker
an
active
worker
?
*
*
If
it
is
not
an
active
worker
Result
(
)
will
be
NS_ERROR_NOT_AVAILABLE
.
*
/
class
CheckLoadRunnable
final
:
public
WorkerMainThreadRunnable
{
nsresult
mRv
;
nsCString
mScope
;
public
:
explicit
CheckLoadRunnable
(
WorkerPrivate
*
aWorker
const
nsACString
&
aScope
)
:
WorkerMainThreadRunnable
(
aWorker
NS_LITERAL_CSTRING
(
"
Notification
:
:
Check
Load
"
)
)
mRv
(
NS_ERROR_DOM_SECURITY_ERR
)
mScope
(
aScope
)
{
}
bool
MainThreadRun
(
)
override
{
nsIPrincipal
*
principal
=
mWorkerPrivate
-
>
GetPrincipal
(
)
;
mRv
=
CheckScope
(
principal
mScope
)
;
if
(
NS_FAILED
(
mRv
)
)
{
return
true
;
}
RefPtr
<
ServiceWorkerManager
>
swm
=
ServiceWorkerManager
:
:
GetInstance
(
)
;
if
(
!
swm
)
{
/
/
browser
shutdown
began
mRv
=
NS_ERROR_FAILURE
;
return
true
;
}
RefPtr
<
ServiceWorkerRegistrationInfo
>
registration
=
swm
-
>
GetRegistration
(
principal
mScope
)
;
/
/
This
is
coming
from
a
ServiceWorkerRegistration
.
MOZ_ASSERT
(
registration
)
;
if
(
!
registration
-
>
GetActive
(
)
|
|
registration
-
>
GetActive
(
)
-
>
ID
(
)
!
=
mWorkerPrivate
-
>
ServiceWorkerID
(
)
)
{
mRv
=
NS_ERROR_NOT_AVAILABLE
;
}
return
true
;
}
nsresult
Result
(
)
{
return
mRv
;
}
}
;
/
*
static
*
/
already_AddRefed
<
Promise
>
Notification
:
:
ShowPersistentNotification
(
JSContext
*
aCx
nsIGlobalObject
*
aGlobal
const
nsAString
&
aScope
const
nsAString
&
aTitle
const
NotificationOptions
&
aOptions
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aGlobal
)
;
/
/
Validate
scope
.
/
/
XXXnsm
:
This
may
be
slow
due
to
blocking
the
worker
and
waiting
on
the
main
/
/
thread
.
On
calls
from
content
we
can
be
sure
the
scope
is
valid
since
/
/
ServiceWorkerRegistrations
have
their
scope
set
correctly
.
Can
this
be
made
/
/
debug
only
?
The
problem
is
that
there
would
be
different
semantics
in
/
/
debug
and
non
-
debug
builds
in
such
a
case
.
if
(
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIScriptObjectPrincipal
>
sop
=
do_QueryInterface
(
aGlobal
)
;
if
(
NS_WARN_IF
(
!
sop
)
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
nsIPrincipal
*
principal
=
sop
-
>
GetPrincipal
(
)
;
if
(
NS_WARN_IF
(
!
principal
)
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
aRv
=
CheckScope
(
principal
NS_ConvertUTF16toUTF8
(
aScope
)
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
nullptr
;
}
}
else
{
WorkerPrivate
*
worker
=
GetCurrentThreadWorkerPrivate
(
)
;
MOZ_ASSERT
(
worker
)
;
worker
-
>
AssertIsOnWorkerThread
(
)
;
RefPtr
<
CheckLoadRunnable
>
loadChecker
=
new
CheckLoadRunnable
(
worker
NS_ConvertUTF16toUTF8
(
aScope
)
)
;
loadChecker
-
>
Dispatch
(
Terminating
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
loadChecker
-
>
Result
(
)
)
)
)
{
if
(
loadChecker
-
>
Result
(
)
=
=
NS_ERROR_NOT_AVAILABLE
)
{
aRv
.
ThrowTypeError
<
MSG_NO_ACTIVE_WORKER
>
(
aScope
)
;
}
else
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
}
return
nullptr
;
}
}
RefPtr
<
Promise
>
p
=
Promise
:
:
Create
(
aGlobal
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
/
/
We
check
permission
here
rather
than
pass
the
Promise
to
NotificationTask
/
/
which
leads
to
uglier
code
.
NotificationPermission
permission
=
GetPermission
(
aGlobal
aRv
)
;
/
/
"
If
permission
for
notification
'
s
origin
is
not
"
granted
"
reject
promise
with
a
TypeError
exception
and
terminate
these
substeps
.
"
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
|
|
permission
=
=
NotificationPermission
:
:
Denied
)
{
ErrorResult
result
;
result
.
ThrowTypeError
<
MSG_NOTIFICATION_PERMISSION_DENIED
>
(
)
;
p
-
>
MaybeReject
(
result
)
;
return
p
.
forget
(
)
;
}
/
/
"
Otherwise
resolve
promise
with
undefined
.
"
/
/
The
Notification
may
still
not
be
shown
due
to
other
errors
but
the
spec
/
/
is
not
concerned
with
those
.
p
-
>
MaybeResolveWithUndefined
(
)
;
RefPtr
<
Notification
>
notification
=
CreateAndShow
(
aCx
aGlobal
aTitle
aOptions
aScope
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
return
p
.
forget
(
)
;
}
/
*
static
*
/
already_AddRefed
<
Notification
>
Notification
:
:
CreateAndShow
(
JSContext
*
aCx
nsIGlobalObject
*
aGlobal
const
nsAString
&
aTitle
const
NotificationOptions
&
aOptions
const
nsAString
&
aScope
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aGlobal
)
;
RefPtr
<
Notification
>
notification
=
CreateInternal
(
aGlobal
EmptyString
(
)
aTitle
aOptions
)
;
/
/
Make
a
structured
clone
of
the
aOptions
.
mData
object
JS
:
:
Rooted
<
JS
:
:
Value
>
data
(
aCx
aOptions
.
mData
)
;
notification
-
>
InitFromJSVal
(
aCx
data
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
notification
-
>
SetScope
(
aScope
)
;
RefPtr
<
NotificationTask
>
task
=
NotificationTask
:
:
Create
(
notification
NotificationTask
:
:
eShow
)
;
if
(
NS_WARN_IF
(
!
task
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_ABORT_ERR
)
;
return
nullptr
;
}
/
/
Queue
a
task
to
show
the
notification
.
nsCOMPtr
<
nsIRunnable
>
r
=
new
NotificationTaskRunnable
(
"
Notification
:
:
CreateAndShow
"
task
)
;
nsresult
rv
=
task
-
>
DispatchToMainThread
(
r
.
forget
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
notification
-
>
DispatchTrustedEvent
(
NS_LITERAL_STRING
(
"
error
"
)
)
;
}
return
notification
.
forget
(
)
;
}
/
*
static
*
/
nsresult
Notification
:
:
RemovePermission
(
nsIPrincipal
*
aPrincipal
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
nsCOMPtr
<
nsIPermissionManager
>
permissionManager
=
mozilla
:
:
services
:
:
GetPermissionManager
(
)
;
if
(
!
permissionManager
)
{
return
NS_ERROR_FAILURE
;
}
permissionManager
-
>
RemoveFromPrincipal
(
aPrincipal
"
desktop
-
notification
"
)
;
return
NS_OK
;
}
/
*
static
*
/
nsresult
Notification
:
:
OpenSettings
(
nsIPrincipal
*
aPrincipal
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
obs
)
{
return
NS_ERROR_FAILURE
;
}
/
/
Notify
other
observers
so
they
can
show
settings
UI
.
obs
-
>
NotifyObservers
(
aPrincipal
"
notifications
-
open
-
settings
"
nullptr
)
;
return
NS_OK
;
}
NS_IMETHODIMP
Notification
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
AssertIsOnMainThread
(
)
;
if
(
!
strcmp
(
aTopic
DOM_WINDOW_DESTROYED_TOPIC
)
|
|
!
strcmp
(
aTopic
DOM_WINDOW_FROZEN_TOPIC
)
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
GetOwner
(
)
;
if
(
SameCOMIdentity
(
aSubject
window
)
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
RemoveObserver
(
this
DOM_WINDOW_DESTROYED_TOPIC
)
;
obs
-
>
RemoveObserver
(
this
DOM_WINDOW_FROZEN_TOPIC
)
;
}
nsCOMPtr
<
nsIScriptObjectPrincipal
>
sop
=
do_QueryInterface
(
window
)
;
if
(
sop
)
{
CloseInternal
(
nullptr
sop
-
>
GetPrincipal
(
)
)
;
}
}
}
return
NS_OK
;
}
/
*
static
*
/
already_AddRefed
<
NotificationTask
>
NotificationTask
:
:
Create
(
Notification
*
aNotification
NotificationAction
aAction
)
{
MOZ_ASSERT
(
aNotification
)
;
aNotification
-
>
AssertIsOnTargetThread
(
)
;
RefPtr
<
NotificationTask
>
task
=
new
NotificationTask
(
aNotification
aAction
)
;
if
(
IsCurrentThreadRunningWorker
(
)
)
{
RefPtr
<
StrongWorkerRef
>
workerRef
=
StrongWorkerRef
:
:
Create
(
GetCurrentThreadWorkerPrivate
(
)
"
Notification
"
[
task
]
(
)
{
/
/
When
the
worker
is
shutting
down
just
for
eShow
action
we
must
break
/
/
the
cycle
with
the
observer
.
if
(
task
-
>
mAction
=
=
eShow
)
{
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
"
NotificationTask
:
:
Shutdown
"
[
task
]
(
)
{
AssertIsOnMainThread
(
)
;
if
(
task
-
>
Observer
(
)
)
{
task
-
>
Observer
(
)
-
>
ReleaseNotificationOnMainThread
(
)
;
task
-
>
SetObserver
(
nullptr
)
;
}
task
-
>
GetNotification
(
)
-
>
CloseInternal
(
nullptr
task
-
>
GetPrincipal
(
)
)
;
}
)
;
task
-
>
GetWorkerRef
(
)
-
>
Private
(
)
-
>
DispatchToMainThread
(
r
)
;
}
}
)
;
if
(
NS_WARN_IF
(
!
workerRef
)
)
{
return
nullptr
;
}
task
-
>
mWorkerRef
=
new
ThreadSafeWorkerRef
(
workerRef
)
;
}
return
task
.
forget
(
)
;
}
}
/
/
namespace
dom
}
/
/
namespace
mozilla
