"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
results
:
Cr
}
=
Components
;
const
BASE_URI
=
"
http
:
/
/
mochi
.
test
:
8888
/
browser
/
dom
/
workers
/
test
/
serviceworkers
/
"
;
const
emptyDoc
=
BASE_URI
+
"
empty
.
html
"
;
const
fakeDoc
=
BASE_URI
+
"
fake
.
html
"
;
const
helloDoc
=
BASE_URI
+
"
hello
.
html
"
;
const
sw
=
BASE_URI
+
"
fetch
.
js
"
;
/
/
XXXtt
:
We
should
be
able
to
move
this
check
to
chrome
process
after
we
move
/
/
the
interception
logic
to
chrome
process
.
async
function
checkObserverInContent
(
aInput
)
{
let
promiseResolve
;
function
observer
(
aSubject
)
{
var
channel
=
aSubject
.
QueryInterface
(
Ci
.
nsIChannel
)
;
/
/
Since
we
cannot
make
sure
that
the
network
event
triggered
by
the
fetch
(
)
/
/
in
this
testcase
is
the
very
next
event
processed
by
ObserverService
we
/
/
have
to
wait
until
we
catch
the
one
we
want
.
if
(
!
channel
.
URI
.
spec
.
endsWith
(
aInput
.
url
)
)
{
return
;
}
var
tc
=
aSubject
.
QueryInterface
(
Ci
.
nsITimedChannel
)
;
/
/
Check
service
worker
related
timings
.
var
serviceWorkerTimings
=
[
{
start
:
tc
.
launchServiceWorkerStartTime
end
:
tc
.
launchServiceWorkerEndTime
}
{
start
:
tc
.
dispatchFetchEventStartTime
end
:
tc
.
dispatchFetchEventEndTime
}
{
start
:
tc
.
handleFetchEventStartTime
end
:
tc
.
handleFetchEventEndTime
}
]
;
if
(
aInput
.
intercepted
)
{
serviceWorkerTimings
.
reduce
(
(
aPreviousTimings
aCurrentTimings
)
=
>
{
ok
(
aPreviousTimings
.
start
<
=
aCurrentTimings
.
start
"
Start
time
order
check
.
"
)
;
ok
(
aPreviousTimings
.
end
<
=
aCurrentTimings
.
end
"
End
time
order
check
.
"
)
;
ok
(
aCurrentTimings
.
start
<
=
aCurrentTimings
.
end
"
Start
time
should
be
smaller
than
end
time
.
"
)
;
return
aCurrentTimings
;
}
)
;
}
else
{
serviceWorkerTimings
.
forEach
(
aTimings
=
>
{
is
(
aTimings
.
start
0
"
SW
timings
should
be
0
.
"
)
;
is
(
aTimings
.
end
0
"
SW
timings
should
be
0
.
"
)
;
}
)
;
}
/
/
Check
network
related
timings
.
var
networkTimings
=
[
tc
.
domainLookupStartTime
tc
.
domainLookupEndTime
tc
.
connectStartTime
tc
.
connectEndTime
tc
.
requestStartTime
tc
.
responseStartTime
tc
.
responseEndTime
]
;
if
(
aInput
.
fetch
)
{
networkTimings
.
reduce
(
(
aPreviousTiming
aCurrentTiming
)
=
>
{
ok
(
aPreviousTiming
<
=
aCurrentTiming
"
Checking
network
timings
"
)
;
return
aCurrentTiming
;
}
)
;
}
else
{
networkTimings
.
forEach
(
aTiming
=
>
is
(
aTiming
0
"
Network
timings
should
be
0
.
"
)
)
;
}
Services
.
obs
.
removeObserver
(
observer
topic
)
;
promiseResolve
(
)
;
}
const
topic
=
"
http
-
on
-
stop
-
request
"
;
Services
.
obs
.
addObserver
(
observer
topic
)
;
await
new
Promise
(
resolve
=
>
{
promiseResolve
=
resolve
;
}
)
;
}
async
function
contentFetch
(
aURL
)
{
await
content
.
window
.
fetch
(
aURL
)
;
}
async
function
registerSWAndWaitForActive
(
aServiceWorker
)
{
let
swr
=
await
content
.
navigator
.
serviceWorker
.
register
(
aServiceWorker
)
;
await
new
Promise
(
resolve
=
>
{
let
worker
=
swr
.
installing
|
|
swr
.
waiting
|
|
swr
.
active
;
if
(
worker
.
state
=
=
=
'
activated
'
)
{
return
resolve
(
)
;
}
worker
.
addEventListener
(
'
statechange
'
(
)
=
>
{
if
(
worker
.
state
=
=
=
'
activated
'
)
{
return
resolve
(
)
;
}
}
)
;
}
)
;
await
swr
.
active
.
postMessage
(
'
claim
'
)
;
}
async
function
unregisterSW
(
)
{
let
swr
=
await
content
.
navigator
.
serviceWorker
.
getRegistration
(
)
;
swr
.
unregister
(
)
;
}
add_task
(
async
function
test_serivce_worker_interception
(
)
{
info
(
"
Setting
the
prefs
to
having
e10s
enabled
"
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
"
set
"
:
[
/
/
Make
sure
observer
and
testing
function
run
in
the
same
process
[
"
dom
.
ipc
.
processCount
"
1
]
[
"
dom
.
serviceWorkers
.
enabled
"
true
]
[
"
dom
.
serviceWorkers
.
testing
.
enabled
"
true
]
]
}
)
;
waitForExplicitFinish
(
)
;
info
(
"
Open
the
tab
"
)
;
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
emptyDoc
)
;
let
tabBrowser
=
gBrowser
.
getBrowserForTab
(
tab
)
;
await
BrowserTestUtils
.
browserLoaded
(
tabBrowser
)
;
info
(
"
Open
the
tab
for
observing
"
)
;
let
tab_observer
=
BrowserTestUtils
.
addTab
(
gBrowser
emptyDoc
)
;
let
tabBrowser_observer
=
gBrowser
.
getBrowserForTab
(
tab_observer
)
;
await
BrowserTestUtils
.
browserLoaded
(
tabBrowser_observer
)
;
let
testcases
=
[
{
url
:
helloDoc
intercepted
:
false
fetch
:
true
}
{
url
:
fakeDoc
intercepted
:
true
fetch
:
false
/
/
should
use
HTTP
cache
}
{
url
:
helloDoc
+
"
?
ForBypassingHttpCache
=
"
+
Date
.
now
(
)
intercepted
:
true
fetch
:
true
}
]
;
info
(
"
Test
1
:
Verify
simple
fetch
"
)
;
let
promise
=
ContentTask
.
spawn
(
tabBrowser_observer
testcases
[
0
]
checkObserverInContent
)
;
await
ContentTask
.
spawn
(
tabBrowser
testcases
[
0
]
.
url
contentFetch
)
;
await
promise
;
info
(
"
Register
a
service
worker
"
)
;
await
ContentTask
.
spawn
(
tabBrowser
sw
registerSWAndWaitForActive
)
;
info
(
"
Test
2
:
Verify
simple
hijack
"
)
;
promise
=
ContentTask
.
spawn
(
tabBrowser_observer
testcases
[
1
]
checkObserverInContent
)
;
await
ContentTask
.
spawn
(
tabBrowser
testcases
[
1
]
.
url
contentFetch
)
;
await
promise
;
info
(
"
Test
3
:
Verify
fetch
without
using
http
cache
"
)
;
promise
=
ContentTask
.
spawn
(
tabBrowser_observer
testcases
[
2
]
checkObserverInContent
)
;
await
ContentTask
.
spawn
(
tabBrowser
testcases
[
2
]
.
url
contentFetch
)
;
await
promise
;
info
(
"
Clean
up
"
)
;
await
ContentTask
.
spawn
(
tabBrowser
undefined
unregisterSW
)
;
gBrowser
.
removeTab
(
tab
)
;
gBrowser
.
removeTab
(
tab_observer
)
;
}
)
;
