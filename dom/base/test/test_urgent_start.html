<
!
DOCTYPE
HTML
>
<
!
-
-
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
1348050
Test
for
fetch
and
xhr
to
guarantee
we
only
mark
channel
as
urgent
-
start
when
it
is
triggered
by
user
input
events
.
For
{
Fetch
XHR
}
do
the
test
as
following
:
Step
1
:
Verify
them
not
mark
the
channel
when
there
is
no
any
input
event
.
Step
2
:
Verify
them
mark
the
channel
there
is
a
user
input
event
.
Step
3
:
Verify
them
not
mark
the
channel
when
there
is
a
non
input
event
.
In
each
steps
it
shows
that
we
only
mark
channel
on
direct
triggering
task
.
We
won
'
t
mark
the
channel
for
additional
task
(
setTimeout
)
or
micro
-
task
(
promise
)
.
-
-
>
<
html
>
<
head
>
<
title
>
Test
for
urgent
-
start
on
Fetch
and
XHR
<
/
title
>
<
script
type
=
"
application
/
javascript
"
src
=
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
SimpleTest
.
js
"
>
<
/
script
>
<
link
rel
=
"
stylesheet
"
type
=
"
text
/
css
"
href
=
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
test
.
css
"
>
<
script
type
=
"
text
/
javascript
"
src
=
"
manifest
.
js
"
>
<
/
script
>
<
/
head
>
<
body
>
<
pre
id
=
"
test
"
>
<
script
class
=
"
testbody
"
type
=
"
text
/
javascript
"
>
const
{
classes
:
Cc
interfaces
:
Ci
}
=
Components
;
SimpleTest
.
waitForExplicitFinish
(
)
;
SimpleTest
.
waitForFocus
(
runTest
)
;
const
topic
=
"
http
-
on
-
opening
-
request
"
;
const
url
=
"
http
:
/
/
mochi
.
test
:
8888
/
chrome
/
dom
/
base
/
test
/
file_empty
.
html
"
;
let
expectedResults
=
[
]
;
let
testcases
=
[
"
fetch
"
"
xhr
"
]
;
let
testcase
;
function
isUrgentStart
(
aClassFlags
)
{
if
(
!
aClassFlags
)
{
return
false
;
}
const
urgentStartFlag
=
1
<
<
6
;
return
!
!
(
urgentStartFlag
&
aClassFlags
)
;
}
/
/
Test
for
setTimeout
(
task
)
function
testSetTimeout
(
)
{
return
new
Promise
(
aResolve
=
>
setTimeout
(
function
(
)
{
testSimple
(
)
.
then
(
aResolve
)
;
}
0
)
)
;
}
/
/
Test
for
promise
chain
(
micro
-
task
)
function
testPromise
(
)
{
return
Promise
.
resolve
(
)
.
then
(
testSimple
)
;
}
function
testSimple
(
)
{
if
(
testcase
=
=
"
fetch
"
)
{
return
fetch
(
url
)
;
}
else
if
(
testcase
=
=
"
xhr
"
)
{
return
new
Promise
(
aResolve
=
>
{
let
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
open
(
"
GET
"
url
false
)
;
xhr
.
send
(
null
)
;
aResolve
(
)
;
}
)
;
}
ok
(
false
"
Shouldn
'
t
go
here
.
"
)
;
}
function
sendRequsetAndCheckUrgentStart
(
)
{
info
(
"
SendRequsetAndCheckUrgentStart
"
)
;
let
promise_resolve
;
let
promise
=
new
Promise
(
aResolve
=
>
{
promise_resolve
=
aResolve
;
}
)
;
function
checkUrgentStart
(
aSubject
)
{
var
channel
=
aSubject
.
QueryInterface
(
Ci
.
nsIChannel
)
;
if
(
!
channel
.
URI
.
spec
.
endsWith
(
url
)
)
{
return
;
}
info
(
"
CheckUrgentStart
"
)
;
let
cos
=
channel
.
QueryInterface
(
Ci
.
nsIClassOfService
)
;
let
expectedResult
=
expectedResults
.
shift
(
)
;
is
(
isUrgentStart
(
cos
.
classFlags
)
expectedResult
"
Expect
get
:
"
+
expectedResult
+
"
get
:
"
+
isUrgentStart
(
cos
.
classFlags
)
+
"
in
the
"
+
(
9
-
expectedResults
.
length
)
+
"
test
of
"
+
testcase
)
;
/
/
Resolve
if
we
'
ve
tested
each
three
conditions
/
/
(
simple
promise
setTimeout
)
.
if
(
expectedResults
.
length
%
3
=
=
=
0
)
{
SpecialPowers
.
removeObserver
(
checkUrgentStart
topic
)
;
promise_resolve
(
)
;
}
}
SpecialPowers
.
addObserver
(
checkUrgentStart
topic
)
;
return
Promise
.
all
(
[
testSimple
(
)
testSetTimeout
(
)
testPromise
(
)
promise
]
)
;
}
function
userInputEventTriggerRequestCheckUrgentStart
(
)
{
info
(
"
UserInputEventTriggerRequestCheckUrgentStart
"
)
;
let
promise_resolve
;
let
promise
=
new
Promise
(
aResolve
=
>
{
promise_resolve
=
aResolve
;
}
)
;
info
(
"
AddUserInputEventListener
"
)
;
let
eventHandle
=
function
(
)
{
sendRequsetAndCheckUrgentStart
(
)
.
then
(
_
=
>
promise_resolve
(
)
)
;
}
/
/
User
Input
Event
window
.
addEventListener
(
"
mousedown
"
eventHandle
{
once
:
true
}
)
;
info
(
"
SendUserInputEvent
"
)
;
var
utils
=
SpecialPowers
.
getDOMWindowUtils
(
window
)
;
utils
.
sendMouseEvent
(
"
mousedown
"
1
1
0
1
0
)
;
return
promise
;
}
function
nonUserInputEventTriggerRequestCheckUrgentStart
(
)
{
info
(
"
NonUserInputEventTriggerRequestCheckUrgentStart
"
)
;
let
promise_resolve
;
let
promise
=
new
Promise
(
aResolve
=
>
{
promise_resolve
=
aResolve
;
}
)
;
info
(
"
AddNonUserInputEventListener
"
)
;
let
eventHandle
=
function
(
)
{
sendRequsetAndCheckUrgentStart
(
)
.
then
(
_
=
>
promise_resolve
(
)
)
;
}
/
/
Non
user
Input
Event
window
.
addEventListener
(
"
message
"
eventHandle
{
once
:
true
}
)
;
info
(
"
SendNonUserInputEvent
"
)
;
window
.
postMessage
(
"
hello
"
"
*
"
)
;
return
promise
;
}
function
executeTest
(
)
{
is
(
expectedResults
.
length
0
"
expectedResults
should
be
0
be
executeTest
.
"
)
;
/
/
We
will
test
fetch
first
and
then
xhr
.
testcase
=
testcases
.
shift
(
)
;
info
(
"
Verify
"
+
testcase
)
;
expectedResults
=
[
/
*
SimpleTest
without
any
events
*
/
false
/
*
PromiseTest
without
any
events
*
/
false
/
*
SetTimeoutTest
without
any
events
*
/
false
/
*
SimpleTest
with
a
user
input
event
*
/
true
/
*
PromiseTest
with
a
user
input
event
*
/
false
/
*
SetTimeoutTest
with
user
input
event
*
/
false
/
*
SimpleTest
with
a
non
user
input
event
*
/
false
/
*
PromiseTest
with
a
non
user
input
event
*
/
false
/
*
SetTimeoutTest
with
a
non
user
input
event
*
/
false
]
;
return
Promise
.
resolve
(
)
/
/
Verify
urgent
-
start
is
not
set
when
the
request
is
not
triggered
by
any
/
/
events
.
.
then
(
sendRequsetAndCheckUrgentStart
)
/
/
Verify
urgent
-
start
is
set
only
when
the
request
is
triggered
by
a
user
/
/
input
event
.
(
not
for
another
microtask
(
e
.
g
.
promise
-
chain
)
and
/
/
task
(
e
.
g
.
setTimeout
)
)
.
.
then
(
userInputEventTriggerRequestCheckUrgentStart
)
/
/
Verify
urgent
-
start
is
not
set
when
the
request
is
triggered
by
a
non
user
/
/
input
event
.
.
then
(
nonUserInputEventTriggerRequestCheckUrgentStart
)
.
then
(
_
=
>
{
if
(
testcases
.
length
!
=
=
0
)
{
/
/
Run
the
other
test
if
we
still
have
tests
needed
to
be
run
.
return
executeTest
(
)
;
}
return
Promise
.
resolve
(
)
;
}
)
;
}
function
endCheck
(
)
{
info
(
"
End
Check
:
make
sure
that
we
'
ve
done
all
the
tests
.
"
)
;
is
(
testcases
.
length
0
"
All
the
tests
should
be
executed
.
"
)
;
is
(
expectedResults
.
length
0
"
All
the
tests
should
be
executed
.
"
)
;
return
Promise
.
resolve
(
)
;
}
function
runTest
(
)
{
return
Promise
.
resolve
(
)
.
then
(
executeTest
)
.
then
(
endCheck
)
.
catch
(
aError
=
>
ok
(
false
"
Some
test
failed
with
error
"
+
aError
)
)
.
then
(
SimpleTest
.
finish
)
;
}
<
/
script
>
<
/
pre
>
<
/
body
>
<
/
html
>
