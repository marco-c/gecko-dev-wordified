/
*
-
*
-
Mode
:
C
+
+
;
tab
-
width
:
8
;
indent
-
tabs
-
mode
:
nil
;
c
-
basic
-
offset
:
2
-
*
-
*
/
/
*
vim
:
set
ts
=
8
sts
=
2
et
sw
=
2
tw
=
80
:
*
/
/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
/
*
Static
case
=
=
=
=
=
=
=
=
=
=
=
When
we
see
a
new
content
node
with
dir
=
auto
from
the
parser
we
set
the
NodeHasDirAuto
flag
on
the
node
.
We
won
'
t
have
enough
information
to
decide
the
directionality
of
the
node
at
this
point
.
When
we
bind
a
new
content
node
to
the
document
if
its
parent
has
either
of
the
NodeAncestorHasDirAuto
or
NodeHasDirAuto
flags
we
set
the
NodeAncestorHasDirAuto
flag
on
the
node
.
When
a
new
input
with
type
=
text
/
search
/
tel
/
url
/
email
and
dir
=
auto
is
added
from
the
parser
we
resolve
the
directionality
based
on
its
value
.
When
a
new
text
node
with
non
-
neutral
content
is
appended
to
a
textarea
element
with
NodeHasDirAuto
if
the
directionality
of
the
textarea
element
is
still
unresolved
it
is
resolved
based
on
the
value
of
the
text
node
.
Elements
with
unresolved
directionality
behave
as
Ltr
.
When
a
new
text
node
with
non
-
neutral
content
is
appended
to
an
element
that
is
not
a
textarea
but
has
either
of
the
NodeAncestorHasDirAuto
or
NodeHasDirAuto
flags
we
walk
up
the
parent
chain
while
the
NodeAncestorHasDirAuto
flag
is
present
and
when
we
reach
an
element
with
NodeHasDirAuto
and
no
resolved
directionality
we
resolve
the
directionality
based
on
the
contents
of
the
text
node
and
cease
walking
the
parent
chain
.
Note
that
we
should
ignore
elements
with
NodeHasDirAuto
with
resolved
directionality
so
that
the
second
text
node
in
this
example
tree
doesn
'
t
affect
the
directionality
of
the
div
:
<
div
dir
=
auto
>
<
span
>
foo
<
/
span
>
<
span
>
<
/
span
>
<
/
div
>
The
parent
chain
walk
will
be
aborted
if
we
hit
a
script
or
style
element
or
if
we
hit
an
element
with
dir
=
ltr
or
dir
=
rtl
.
I
will
call
this
algorithm
"
upward
propagation
"
.
Each
text
node
keeps
a
flag
if
it
might
determine
the
directionality
of
any
ancestor
.
This
is
useful
to
make
dynamic
changes
more
efficient
.
Handling
dynamic
changes
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
We
need
to
handle
the
following
cases
:
1
.
When
the
value
of
an
input
element
with
type
=
text
/
search
/
tel
/
url
/
email
is
changed
if
it
has
NodeHasDirAuto
we
update
the
resolved
directionality
.
2
.
When
the
dir
attribute
is
changed
from
something
else
(
including
the
case
where
it
doesn
'
t
exist
)
to
auto
on
a
textarea
or
an
input
element
with
type
=
text
/
search
/
tel
/
url
/
email
we
set
the
NodeHasDirAuto
flag
and
resolve
the
directionality
based
on
the
value
of
the
element
.
3
.
When
the
dir
attribute
is
changed
from
something
else
(
including
the
case
where
it
doesn
'
t
exist
)
to
auto
on
any
element
except
case
1
above
and
the
bdi
element
we
run
the
following
algorithm
:
*
We
set
the
NodeHasDirAuto
flag
.
*
If
the
element
doesn
'
t
have
the
NodeAncestorHasDirAuto
flag
we
set
the
NodeAncestorHasDirAuto
flag
on
all
of
its
child
nodes
.
(
Note
that
if
the
element
does
have
NodeAncestorHasDirAuto
all
of
its
children
should
already
have
this
flag
too
.
We
can
assert
this
in
debug
builds
.
)
*
To
resolve
the
directionality
of
the
element
we
run
the
algorithm
explained
in
http
:
/
/
www
.
whatwg
.
org
/
specs
/
web
-
apps
/
current
-
work
/
multipage
/
elements
.
html
#
the
-
dir
-
attribute
(
I
'
ll
call
this
the
"
downward
propagation
algorithm
"
.
)
by
walking
the
child
subtree
in
tree
order
.
Note
that
an
element
with
dir
=
auto
should
not
affect
other
elements
in
its
document
with
dir
=
auto
.
So
there
is
no
need
to
walk
up
the
parent
chain
in
this
case
.
3a
.
When
the
dir
attribute
is
set
to
any
valid
value
on
an
element
that
didn
'
t
have
a
valid
dir
attribute
before
this
means
that
any
descendant
of
that
element
will
not
affect
the
directionality
of
any
of
its
ancestors
.
So
we
need
to
check
whether
any
text
node
descendants
of
the
element
can
set
the
dir
of
any
ancestor
and
whether
the
elements
whose
direction
they
set
are
ancestors
of
the
element
.
If
so
we
need
to
rerun
the
downward
propagation
algorithm
for
those
ancestors
.
That
'
s
done
by
OnSetDirAttr
.
4
.
When
the
dir
attribute
is
changed
from
auto
to
something
else
(
including
the
case
where
it
gets
removed
)
on
a
textarea
or
an
input
element
with
type
=
text
/
search
/
tel
/
url
/
email
we
unset
the
NodeHasDirAuto
flag
and
resolve
the
directionality
based
on
the
directionality
of
the
value
of
the
dir
attribute
on
element
itself
or
its
parent
element
.
5
.
When
the
dir
attribute
is
changed
from
auto
to
something
else
(
including
the
case
where
it
gets
removed
)
on
any
element
except
case
4
above
and
the
bdi
element
we
run
the
following
algorithm
:
*
We
unset
the
NodeHasDirAuto
flag
.
*
If
the
element
does
not
have
the
NodeAncestorHasDirAuto
flag
we
unset
the
NodeAncestorHasDirAuto
flag
on
all
of
its
child
nodes
except
those
who
are
a
descendant
of
another
element
with
NodeHasDirAuto
.
(
Note
that
if
the
element
has
the
NodeAncestorHasDirAuto
flag
all
of
its
child
nodes
should
still
retain
the
same
flag
.
)
*
We
resolve
the
directionality
of
the
element
based
on
the
value
of
the
dir
attribute
on
the
element
itself
or
its
parent
element
.
5a
.
When
the
dir
attribute
is
removed
or
set
to
an
invalid
value
on
any
element
(
except
a
bdi
element
)
with
the
NodeAncestorHasDirAuto
flag
which
previously
had
a
valid
dir
attribute
it
might
have
a
text
node
descendant
that
did
not
previously
affect
the
directionality
of
any
of
its
ancestors
but
should
now
begin
to
affect
them
.
We
run
OnSetDirAttr
.
6
.
When
an
element
with
dir
=
auto
is
added
to
the
document
we
should
handle
it
similar
to
the
case
2
/
3
above
.
7
.
When
an
element
with
NodeHasDirAuto
or
NodeAncestorHasDirAuto
is
removed
from
the
document
we
should
handle
it
similar
to
the
case
4
/
5
above
except
that
we
don
'
t
need
to
handle
anything
in
the
child
subtree
.
8
.
When
the
contents
of
a
text
node
is
changed
either
from
script
or
by
the
user
we
need
to
run
TextNode
{
WillChange
Changed
}
Direction
see
inline
docs
for
details
.
9
.
When
a
new
text
node
is
injected
into
a
document
we
need
to
run
SetDirectionFromNewTextNode
.
10
.
When
a
text
node
is
removed
from
a
document
we
need
to
run
ResetDirectionSetByTextNode
.
11
.
If
the
value
of
the
dir
attribute
on
a
bdi
element
is
changed
to
an
invalid
value
(
or
if
it
'
s
removed
)
determine
the
new
directionality
similar
to
the
case
3
above
.
=
=
Implemention
Notes
=
=
When
a
new
node
gets
bound
to
the
tree
the
BindToTree
function
gets
called
.
The
reverse
case
is
UnbindFromTree
.
When
the
contents
of
a
text
node
change
CharacterData
:
:
SetTextInternal
gets
called
.
*
/
#
include
"
mozilla
/
dom
/
DirectionalityUtils
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSlotElement
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
mozilla
/
dom
/
UnbindContext
.
h
"
#
include
"
mozilla
/
intl
/
UnicodeProperties
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsAttrValue
.
h
"
namespace
mozilla
{
using
mozilla
:
:
dom
:
:
Element
;
using
mozilla
:
:
dom
:
:
HTMLInputElement
;
using
mozilla
:
:
dom
:
:
HTMLSlotElement
;
using
mozilla
:
:
dom
:
:
ShadowRoot
;
using
mozilla
:
:
dom
:
:
Text
;
static
nsIContent
*
GetParentOrHostOrSlot
(
const
nsIContent
*
aContent
)
{
if
(
HTMLSlotElement
*
slot
=
aContent
-
>
GetAssignedSlot
(
)
)
{
return
slot
;
}
if
(
nsIContent
*
parent
=
aContent
-
>
GetParent
(
)
)
{
return
parent
;
}
if
(
const
ShadowRoot
*
sr
=
ShadowRoot
:
:
FromNode
(
aContent
)
)
{
return
sr
-
>
GetHost
(
)
;
}
return
nullptr
;
}
/
*
*
*
Returns
true
if
aElement
is
one
of
the
elements
whose
text
content
should
*
affect
its
own
direction
or
the
direction
of
ancestors
with
dir
=
auto
.
*
*
Note
that
this
does
not
include
<
bdi
>
whose
content
does
affect
its
own
*
direction
when
it
has
dir
=
auto
(
which
it
has
by
default
)
so
one
needs
to
*
test
for
it
separately
e
.
g
.
with
EstablishesOwnDirection
.
*
It
*
does
*
include
textarea
because
even
if
a
textarea
has
dir
=
auto
it
has
*
unicode
-
bidi
:
plaintext
and
is
handled
automatically
in
bidi
resolution
.
*
It
also
includes
input
because
it
takes
the
dir
value
from
its
value
*
attribute
instead
of
the
child
nodes
.
*
/
static
bool
ParticipatesInAutoDirection
(
const
nsIContent
*
aContent
)
{
if
(
aContent
-
>
IsInNativeAnonymousSubtree
(
)
)
{
return
false
;
}
if
(
aContent
-
>
IsShadowRoot
(
)
)
{
return
true
;
}
return
!
aContent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
script
nsGkAtoms
:
:
style
nsGkAtoms
:
:
input
nsGkAtoms
:
:
textarea
)
;
}
/
*
*
*
Returns
the
directionality
of
a
Unicode
character
*
/
static
Directionality
GetDirectionFromChar
(
uint32_t
ch
)
{
switch
(
intl
:
:
UnicodeProperties
:
:
GetBidiClass
(
ch
)
)
{
case
intl
:
:
BidiClass
:
:
RightToLeft
:
case
intl
:
:
BidiClass
:
:
RightToLeftArabic
:
return
Directionality
:
:
Rtl
;
case
intl
:
:
BidiClass
:
:
LeftToRight
:
return
Directionality
:
:
Ltr
;
default
:
return
Directionality
:
:
Unset
;
}
}
/
*
*
*
Returns
true
if
aElement
establishes
its
own
direction
or
does
not
have
one
.
*
*
From
https
:
/
/
html
.
spec
.
whatwg
.
org
/
#
auto
-
directionality
step
3
.
1
.
this
is
*
bdi
script
style
textarea
and
elements
with
auto
ltr
or
rtl
dir
.
*
Additionally
it
includes
input
as
the
class
handles
directionality
itself
.
*
/
inline
static
bool
EstablishesOwnDirection
(
const
Element
*
aElement
)
{
return
!
ParticipatesInAutoDirection
(
aElement
)
|
|
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
bdi
)
|
|
aElement
-
>
HasFixedDir
(
)
|
|
aElement
-
>
HasDirAuto
(
)
;
}
/
*
*
*
Returns
true
if
aContent
is
dir
=
auto
affects
a
dir
=
auto
ancestor
is
*
assigned
to
a
dir
=
auto
slot
or
has
an
ancestor
assigned
to
a
dir
=
auto
slot
.
*
*
It
'
s
false
for
input
and
textarea
as
they
handle
their
directionality
*
themselves
.
We
are
concerned
about
steps
2
and
3
of
*
https
:
/
/
html
.
spec
.
whatwg
.
org
/
#
auto
-
directionality
*
/
inline
static
bool
AffectsDirAutoElement
(
nsIContent
*
aContent
)
{
return
aContent
&
&
ParticipatesInAutoDirection
(
aContent
)
&
&
(
aContent
-
>
NodeOrAncestorHasDirAuto
(
)
|
|
aContent
-
>
AffectsDirAutoSlot
(
)
)
;
}
Directionality
GetDirectionFromText
(
const
char16_t
*
aText
const
uint32_t
aLength
uint32_t
*
aFirstStrong
)
{
const
char16_t
*
start
=
aText
;
const
char16_t
*
end
=
aText
+
aLength
;
while
(
start
<
end
)
{
uint32_t
current
=
start
-
aText
;
uint32_t
ch
=
*
start
+
+
;
if
(
start
<
end
&
&
NS_IS_SURROGATE_PAIR
(
ch
*
start
)
)
{
ch
=
SURROGATE_TO_UCS4
(
ch
*
start
+
+
)
;
current
+
+
;
}
/
/
Just
ignore
lone
surrogates
if
(
!
IS_SURROGATE
(
ch
)
)
{
Directionality
dir
=
GetDirectionFromChar
(
ch
)
;
if
(
dir
!
=
Directionality
:
:
Unset
)
{
if
(
aFirstStrong
)
{
*
aFirstStrong
=
current
;
}
return
dir
;
}
}
}
if
(
aFirstStrong
)
{
*
aFirstStrong
=
UINT32_MAX
;
}
return
Directionality
:
:
Unset
;
}
static
Directionality
GetDirectionFromText
(
const
char
*
aText
const
uint32_t
aLength
uint32_t
*
aFirstStrong
=
nullptr
)
{
const
char
*
start
=
aText
;
const
char
*
end
=
aText
+
aLength
;
while
(
start
<
end
)
{
uint32_t
current
=
start
-
aText
;
unsigned
char
ch
=
(
unsigned
char
)
*
start
+
+
;
Directionality
dir
=
GetDirectionFromChar
(
ch
)
;
if
(
dir
!
=
Directionality
:
:
Unset
)
{
if
(
aFirstStrong
)
{
*
aFirstStrong
=
current
;
}
return
dir
;
}
}
if
(
aFirstStrong
)
{
*
aFirstStrong
=
UINT32_MAX
;
}
return
Directionality
:
:
Unset
;
}
static
Directionality
GetDirectionFromText
(
const
Text
*
aTextNode
uint32_t
*
aFirstStrong
=
nullptr
)
{
const
nsTextFragment
*
frag
=
&
aTextNode
-
>
TextFragment
(
)
;
if
(
frag
-
>
Is2b
(
)
)
{
return
GetDirectionFromText
(
frag
-
>
Get2b
(
)
frag
-
>
GetLength
(
)
aFirstStrong
)
;
}
return
GetDirectionFromText
(
frag
-
>
Get1b
(
)
frag
-
>
GetLength
(
)
aFirstStrong
)
;
}
/
*
*
*
Compute
auto
direction
aRoot
should
have
based
on
descendants
*
https
:
/
/
html
.
spec
.
whatwg
.
org
/
#
auto
-
directionality
step
3
*
/
Directionality
WalkDescendantsAndGetDirectionFromText
(
nsINode
*
aRoot
)
{
nsIContent
*
child
=
aRoot
-
>
GetFirstChild
(
)
;
while
(
child
)
{
if
(
child
-
>
IsElement
(
)
&
&
EstablishesOwnDirection
(
child
-
>
AsElement
(
)
)
)
{
child
=
child
-
>
GetNextNonChildNode
(
aRoot
)
;
continue
;
}
/
/
Step
3
.
2
.
If
descendant
is
a
slot
element
whose
root
is
a
shadow
root
/
/
then
return
the
directionality
of
that
shadow
root
'
s
host
.
if
(
auto
*
slot
=
HTMLSlotElement
:
:
FromNode
(
child
)
)
{
if
(
const
ShadowRoot
*
sr
=
slot
-
>
GetContainingShadow
(
)
)
{
Element
*
host
=
sr
-
>
GetHost
(
)
;
MOZ_ASSERT
(
host
)
;
return
host
-
>
GetDirectionality
(
)
;
}
}
/
/
Step
3
.
3
-
5
.
If
descendant
is
a
Text
node
return
its
/
/
text
node
directionality
if
it
is
not
null
if
(
auto
*
text
=
Text
:
:
FromNode
(
child
)
)
{
Directionality
textNodeDir
=
GetDirectionFromText
(
text
)
;
if
(
textNodeDir
!
=
Directionality
:
:
Unset
)
{
text
-
>
SetMaySetDirAuto
(
)
;
return
textNodeDir
;
}
}
child
=
child
-
>
GetNextNode
(
aRoot
)
;
}
return
Directionality
:
:
Unset
;
}
static
Directionality
ComputeAutoDirectionality
(
Element
*
aElement
bool
aNotify
)
;
/
*
*
*
Compute
auto
direction
aSlot
should
have
based
on
assigned
nodes
*
https
:
/
/
html
.
spec
.
whatwg
.
org
/
#
auto
-
directionality
step
2
*
/
Directionality
ComputeAutoDirectionFromAssignedNodes
(
HTMLSlotElement
*
aSlot
const
nsTArray
<
RefPtr
<
nsINode
>
>
&
assignedNodes
bool
aNotify
)
{
/
/
Step
2
.
1
.
For
each
node
child
of
element
'
s
assigned
nodes
:
for
(
const
RefPtr
<
nsINode
>
&
assignedNode
:
assignedNodes
)
{
/
/
Step
2
.
1
.
1
.
Let
childDirection
be
null
.
Directionality
childDirection
=
Directionality
:
:
Unset
;
/
/
Step
2
.
1
.
2
.
If
child
is
a
Text
node
.
.
.
if
(
auto
*
text
=
Text
:
:
FromNode
(
assignedNode
)
)
{
childDirection
=
GetDirectionFromText
(
text
)
;
if
(
childDirection
!
=
Directionality
:
:
Unset
)
{
text
-
>
SetMaySetDirAuto
(
)
;
}
}
else
{
/
/
Step
2
.
1
.
3
.
1
.
Assert
:
child
is
an
Element
node
.
Element
*
assignedElement
=
Element
:
:
FromNode
(
assignedNode
)
;
MOZ_ASSERT
(
assignedElement
)
;
/
/
Step
2
.
1
.
3
.
2
.
Set
childDirection
to
the
auto
directionality
of
child
.
/
/
TODO
use
value
for
input
and
textarea
children
if
(
ParticipatesInAutoDirection
(
assignedElement
)
)
{
childDirection
=
ComputeAutoDirectionality
(
assignedElement
aNotify
)
;
}
}
/
/
Step
2
.
1
.
4
.
If
childDirection
is
not
null
then
return
childDirection
.
if
(
childDirection
!
=
Directionality
:
:
Unset
)
{
return
childDirection
;
}
}
/
/
Step
2
.
2
.
Return
null
.
return
Directionality
:
:
Unset
;
}
/
*
*
*
Set
the
directionality
of
a
node
with
dir
=
auto
as
defined
in
*
https
:
/
/
html
.
spec
.
whatwg
.
org
/
#
auto
-
directionality
*
not
including
step
1
:
auto
-
directionality
form
-
associated
elements
this
is
*
implemented
by
the
elements
themselves
.
*
*
Sets
NodeMaySetDirAuto
on
the
text
node
that
determined
the
direction
.
*
/
static
Directionality
ComputeAutoDirectionality
(
Element
*
aElement
bool
aNotify
)
{
MOZ_ASSERT
(
aElement
"
Must
have
an
element
"
)
;
if
(
!
ParticipatesInAutoDirection
(
aElement
)
)
{
return
Directionality
:
:
Unset
;
}
/
/
Step
2
.
If
element
is
a
slot
element
whose
root
is
a
shadow
root
and
/
/
element
'
s
assigned
nodes
are
not
empty
:
if
(
auto
*
slot
=
HTMLSlotElement
:
:
FromNode
(
aElement
)
)
{
const
nsTArray
<
RefPtr
<
nsINode
>
>
&
assignedNodes
=
slot
-
>
AssignedNodes
(
)
;
if
(
!
assignedNodes
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
slot
-
>
IsInShadowTree
(
)
)
;
return
ComputeAutoDirectionFromAssignedNodes
(
slot
assignedNodes
aNotify
)
;
}
}
/
/
Step
3
.
find
first
text
or
slot
that
determines
the
direction
Directionality
nodeDir
=
WalkDescendantsAndGetDirectionFromText
(
aElement
)
;
if
(
nodeDir
!
=
Directionality
:
:
Unset
)
{
return
nodeDir
;
}
/
/
Step
4
.
return
null
return
Directionality
:
:
Unset
;
}
Directionality
GetParentDirectionality
(
const
Element
*
aElement
)
{
if
(
nsIContent
*
parent
=
GetParentOrHostOrSlot
(
aElement
)
)
{
if
(
ShadowRoot
*
shadow
=
ShadowRoot
:
:
FromNode
(
parent
)
)
{
parent
=
shadow
-
>
GetHost
(
)
;
}
if
(
parent
&
&
parent
-
>
IsElement
(
)
)
{
/
/
If
the
node
doesn
'
t
have
an
explicit
dir
attribute
with
a
valid
value
/
/
the
directionality
is
the
same
as
the
parent
element
(
but
don
'
t
/
/
propagate
the
parent
directionality
if
it
isn
'
t
set
yet
)
.
Directionality
parentDir
=
parent
-
>
AsElement
(
)
-
>
GetDirectionality
(
)
;
if
(
parentDir
!
=
Directionality
:
:
Unset
)
{
return
parentDir
;
}
}
}
return
Directionality
:
:
Ltr
;
}
Directionality
RecomputeDirectionality
(
Element
*
aElement
bool
aNotify
)
{
MOZ_ASSERT
(
!
aElement
-
>
HasDirAuto
(
)
"
RecomputeDirectionality
called
with
dir
=
auto
"
)
;
if
(
aElement
-
>
HasValidDir
(
)
)
{
return
aElement
-
>
GetDirectionality
(
)
;
}
/
/
https
:
/
/
html
.
spec
.
whatwg
.
org
/
multipage
/
dom
.
html
#
the
-
directionality
:
/
/
/
/
If
the
element
is
an
input
element
whose
type
attribute
is
in
the
/
/
Telephone
state
and
the
dir
attribute
is
not
in
a
defined
state
/
/
(
i
.
e
.
it
is
not
present
or
has
an
invalid
value
)
/
/
/
/
The
directionality
of
the
element
is
'
ltr
'
.
if
(
auto
*
input
=
HTMLInputElement
:
:
FromNode
(
*
aElement
)
)
{
if
(
input
-
>
ControlType
(
)
=
=
FormControlType
:
:
InputTel
)
{
aElement
-
>
SetDirectionality
(
Directionality
:
:
Ltr
aNotify
)
;
return
Directionality
:
:
Ltr
;
}
}
const
Directionality
dir
=
GetParentDirectionality
(
aElement
)
;
aElement
-
>
SetDirectionality
(
dir
aNotify
)
;
return
dir
;
}
/
/
Whether
the
element
establishes
its
own
directionality
and
the
one
of
its
/
/
descendants
.
static
inline
bool
IsBoundary
(
const
Element
&
aElement
)
{
return
aElement
.
HasValidDir
(
)
|
|
aElement
.
HasDirAuto
(
)
;
}
static
void
SetDirectionalityOnDescendantsInternal
(
nsINode
*
aNode
Directionality
aDir
bool
aNotify
)
{
if
(
auto
*
element
=
Element
:
:
FromNode
(
aNode
)
)
{
if
(
ShadowRoot
*
shadow
=
element
-
>
GetShadowRoot
(
)
)
{
SetDirectionalityOnDescendantsInternal
(
shadow
aDir
aNotify
)
;
}
}
for
(
nsIContent
*
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
)
{
auto
*
element
=
Element
:
:
FromNode
(
child
)
;
if
(
!
element
)
{
child
=
child
-
>
GetNextNode
(
aNode
)
;
continue
;
}
if
(
IsBoundary
(
*
element
)
|
|
element
-
>
GetAssignedSlot
(
)
|
|
element
-
>
GetDirectionality
(
)
=
=
aDir
)
{
/
/
If
the
element
is
a
directionality
boundary
or
it
'
s
assigned
to
a
slot
/
/
(
in
which
case
it
doesn
'
t
inherit
the
directionality
from
its
direct
/
/
parent
)
or
already
has
the
right
directionality
then
we
can
skip
the
/
/
whole
subtree
.
child
=
child
-
>
GetNextNonChildNode
(
aNode
)
;
continue
;
}
if
(
ShadowRoot
*
shadow
=
element
-
>
GetShadowRoot
(
)
)
{
SetDirectionalityOnDescendantsInternal
(
shadow
aDir
aNotify
)
;
}
if
(
auto
*
slot
=
HTMLSlotElement
:
:
FromNode
(
child
)
)
{
for
(
const
RefPtr
<
nsINode
>
&
assignedNode
:
slot
-
>
AssignedNodes
(
)
)
{
auto
*
assignedElement
=
Element
:
:
FromNode
(
*
assignedNode
)
;
if
(
assignedElement
&
&
!
IsBoundary
(
*
assignedElement
)
)
{
assignedElement
-
>
SetDirectionality
(
aDir
aNotify
)
;
SetDirectionalityOnDescendantsInternal
(
assignedElement
aDir
aNotify
)
;
}
}
}
element
-
>
SetDirectionality
(
aDir
aNotify
)
;
child
=
child
-
>
GetNextNode
(
aNode
)
;
}
}
/
/
We
want
the
public
version
of
this
only
to
acc
void
SetDirectionalityOnDescendants
(
Element
*
aElement
Directionality
aDir
bool
aNotify
)
{
return
SetDirectionalityOnDescendantsInternal
(
aElement
aDir
aNotify
)
;
}
static
void
ResetAutoDirection
(
Element
*
aElement
bool
aNotify
)
{
MOZ_ASSERT
(
aElement
-
>
HasDirAuto
(
)
)
;
Directionality
dir
=
ComputeAutoDirectionality
(
aElement
aNotify
)
;
if
(
dir
!
=
Directionality
:
:
Unset
)
{
aElement
-
>
SetDirectionality
(
dir
aNotify
)
;
}
else
{
aElement
-
>
SetDirectionality
(
Directionality
:
:
Ltr
aNotify
)
;
}
SetDirectionalityOnDescendants
(
aElement
aElement
-
>
GetDirectionality
(
)
aNotify
)
;
}
/
*
*
*
Walk
the
parent
chain
of
a
text
node
whose
dir
attribute
has
been
removed
or
*
added
and
reset
the
direction
of
any
of
its
ancestors
which
have
dir
=
auto
and
*
whose
directionality
is
determined
by
a
text
node
descendant
.
*
/
void
WalkAncestorsResetAutoDirection
(
Element
*
aElement
bool
aNotify
)
{
for
(
nsIContent
*
parent
=
GetParentOrHostOrSlot
(
aElement
)
;
parent
&
&
parent
-
>
NodeOrAncestorHasDirAuto
(
)
;
parent
=
GetParentOrHostOrSlot
(
parent
)
)
{
auto
*
parentElement
=
Element
:
:
FromNode
(
*
parent
)
;
if
(
parentElement
&
&
parentElement
-
>
HasDirAuto
(
)
)
{
ResetAutoDirection
(
parentElement
aNotify
)
;
break
;
}
}
}
void
SlotStateChanged
(
HTMLSlotElement
*
aSlot
)
{
if
(
aSlot
-
>
HasDirAuto
(
)
)
{
ResetAutoDirection
(
aSlot
true
)
;
}
}
static
void
DownwardPropagateDirAutoFlags
(
nsINode
*
aRoot
)
{
bool
affectsAncestor
=
aRoot
-
>
NodeOrAncestorHasDirAuto
(
)
affectsSlot
=
aRoot
-
>
AffectsDirAutoSlot
(
)
;
if
(
!
affectsAncestor
&
&
!
affectsSlot
)
{
return
;
}
nsIContent
*
child
=
aRoot
-
>
GetFirstChild
(
)
;
while
(
child
)
{
if
(
child
-
>
IsElement
(
)
&
&
EstablishesOwnDirection
(
child
-
>
AsElement
(
)
)
)
{
child
=
child
-
>
GetNextNonChildNode
(
aRoot
)
;
continue
;
}
if
(
affectsAncestor
)
{
child
-
>
SetAncestorHasDirAuto
(
)
;
}
if
(
affectsSlot
)
{
child
-
>
SetAffectsDirAutoSlot
(
)
;
}
child
=
child
-
>
GetNextNode
(
aRoot
)
;
}
}
/
*
*
*
aContent
no
longer
affects
the
auto
directionality
of
it
'
s
assigned
slot
*
e
.
g
.
as
it
is
removed
from
the
slot
or
the
slot
no
longer
has
dir
=
auto
.
*
Check
if
aContent
impacts
another
slot
and
otherwise
clear
the
flag
.
*
/
static
void
MaybeClearAffectsDirAutoSlot
(
nsIContent
*
aContent
)
{
DebugOnly
<
HTMLSlotElement
*
>
slot
=
aContent
-
>
GetAssignedSlot
(
)
;
MOZ_ASSERT
(
!
slot
|
|
!
slot
-
>
HasDirAuto
(
)
"
Function
expects
aContent
not
to
impact
its
assigned
slot
"
)
;
/
/
check
if
aContent
still
inherits
the
flag
from
its
parent
if
(
Element
*
parent
=
aContent
-
>
GetParentElement
(
)
)
{
/
/
do
not
check
EstablishesOwnDirection
(
parent
)
as
it
is
only
true
despite
/
/
AffectsDirAutoSlot
if
parent
is
directly
assigned
to
a
dir
=
auto
slot
if
(
parent
-
>
AffectsDirAutoSlot
(
)
&
&
!
(
aContent
-
>
IsElement
(
)
&
&
EstablishesOwnDirection
(
aContent
-
>
AsElement
(
)
)
)
)
{
MOZ_ASSERT
(
aContent
-
>
AffectsDirAutoSlot
(
)
)
;
return
;
}
}
aContent
-
>
ClearAffectsDirAutoSlot
(
)
;
nsIContent
*
child
=
aContent
-
>
GetFirstChild
(
)
;
while
(
child
)
{
if
(
child
-
>
IsElement
(
)
&
&
EstablishesOwnDirection
(
child
-
>
AsElement
(
)
)
)
{
child
=
child
-
>
GetNextNonChildNode
(
aContent
)
;
continue
;
}
if
(
HTMLSlotElement
*
slot
=
child
-
>
GetAssignedSlot
(
)
)
{
if
(
slot
-
>
HasDirAuto
(
)
)
{
child
=
child
-
>
GetNextNonChildNode
(
aContent
)
;
continue
;
}
}
child
-
>
ClearAffectsDirAutoSlot
(
)
;
child
=
child
-
>
GetNextNode
(
aContent
)
;
}
}
void
SlotAssignedNodeAdded
(
HTMLSlotElement
*
aSlot
nsIContent
&
aAssignedNode
)
{
if
(
aSlot
-
>
HasDirAuto
(
)
)
{
aAssignedNode
.
SetAffectsDirAutoSlot
(
)
;
DownwardPropagateDirAutoFlags
(
&
aAssignedNode
)
;
}
SlotStateChanged
(
aSlot
)
;
}
void
SlotAssignedNodeRemoved
(
HTMLSlotElement
*
aSlot
nsIContent
&
aUnassignedNode
)
{
if
(
aSlot
-
>
HasDirAuto
(
)
)
{
MaybeClearAffectsDirAutoSlot
(
&
aUnassignedNode
)
;
}
SlotStateChanged
(
aSlot
)
;
}
void
WalkDescendantsSetDirAuto
(
Element
*
aElement
bool
aNotify
)
{
MOZ_ASSERT
(
aElement
-
>
HasDirAuto
(
)
)
;
/
/
Only
test
for
ParticipatesInAutoDirection
-
-
in
other
words
if
aElement
is
/
/
a
<
bdi
>
which
is
having
its
dir
attribute
set
to
auto
(
or
/
/
removed
or
set
to
an
invalid
value
which
are
equivalent
to
dir
=
auto
for
/
/
<
bdi
>
we
*
do
*
want
to
set
AncestorHasDirAuto
on
its
descendants
unlike
/
/
in
SetDirOnBind
where
we
don
'
t
propagate
AncestorHasDirAuto
to
a
<
bdi
>
/
/
being
bound
to
an
existing
node
with
dir
=
auto
.
if
(
ParticipatesInAutoDirection
(
aElement
)
&
&
!
aElement
-
>
AncestorHasDirAuto
(
)
)
{
DownwardPropagateDirAutoFlags
(
aElement
)
;
}
ResetAutoDirection
(
aElement
aNotify
)
;
}
void
WalkDescendantsClearAncestorDirAuto
(
nsIContent
*
aContent
)
{
nsIContent
*
child
=
aContent
-
>
GetFirstChild
(
)
;
while
(
child
)
{
if
(
child
-
>
IsElement
(
)
&
&
EstablishesOwnDirection
(
child
-
>
AsElement
(
)
)
)
{
child
=
child
-
>
GetNextNonChildNode
(
aContent
)
;
continue
;
}
child
-
>
ClearAncestorHasDirAuto
(
)
;
child
=
child
-
>
GetNextNode
(
aContent
)
;
}
}
struct
DirAutoElementResult
{
Element
*
mElement
=
nullptr
;
/
/
This
is
false
when
we
hit
the
top
of
the
ancestor
chain
without
finding
a
/
/
dir
=
auto
element
or
an
element
with
a
fixed
direction
.
This
is
useful
when
/
/
processing
node
removals
since
we
might
need
to
look
at
the
subtree
we
'
re
/
/
removing
from
.
bool
mAnswerIsDefinitive
=
false
;
}
;
static
DirAutoElementResult
FindDirAutoElementFrom
(
nsIContent
*
aContent
)
{
for
(
nsIContent
*
parent
=
aContent
;
parent
&
&
parent
-
>
NodeOrAncestorHasDirAuto
(
)
;
parent
=
GetParentOrHostOrSlot
(
parent
)
)
{
auto
*
parentElement
=
Element
:
:
FromNode
(
*
parent
)
;
if
(
!
parentElement
)
{
continue
;
}
if
(
!
ParticipatesInAutoDirection
(
parentElement
)
|
|
parentElement
-
>
HasFixedDir
(
)
)
{
return
{
nullptr
true
}
;
}
if
(
parentElement
-
>
HasDirAuto
(
)
)
{
return
{
parentElement
true
}
;
}
}
return
{
nullptr
false
}
;
}
static
DirAutoElementResult
FindDirAutoElementForText
(
Text
*
aTextNode
)
{
MOZ_ASSERT
(
aTextNode
-
>
IsText
(
)
"
Must
be
a
text
node
"
)
;
return
FindDirAutoElementFrom
(
GetParentOrHostOrSlot
(
aTextNode
)
)
;
}
static
DirAutoElementResult
SetAncestorDirectionIfAuto
(
Text
*
aTextNode
Directionality
aDir
bool
aNotify
=
true
)
{
auto
result
=
FindDirAutoElementForText
(
aTextNode
)
;
if
(
Element
*
parentElement
=
result
.
mElement
)
{
if
(
parentElement
-
>
GetDirectionality
(
)
=
=
aDir
)
{
/
/
If
we
know
that
the
directionality
is
already
correct
we
don
'
t
need
to
/
/
reset
it
.
But
we
might
be
responsible
for
the
directionality
of
/
/
parentElement
.
MOZ_ASSERT
(
aDir
!
=
Directionality
:
:
Unset
)
;
aTextNode
-
>
SetMaySetDirAuto
(
)
;
}
else
{
/
/
Otherwise
recompute
the
directionality
of
parentElement
.
ResetAutoDirection
(
parentElement
aNotify
)
;
}
}
return
result
;
}
bool
TextNodeWillChangeDirection
(
Text
*
aTextNode
Directionality
*
aOldDir
uint32_t
aOffset
)
{
if
(
!
AffectsDirAutoElement
(
aTextNode
)
)
{
return
false
;
}
/
/
If
the
change
has
happened
after
the
first
character
with
strong
/
/
directionality
in
the
text
node
do
nothing
.
uint32_t
firstStrong
;
*
aOldDir
=
GetDirectionFromText
(
aTextNode
&
firstStrong
)
;
return
(
aOffset
<
=
firstStrong
)
;
}
void
TextNodeChangedDirection
(
Text
*
aTextNode
Directionality
aOldDir
bool
aNotify
)
{
MOZ_ASSERT
(
AffectsDirAutoElement
(
aTextNode
)
"
Caller
should
check
"
)
;
Directionality
newDir
=
GetDirectionFromText
(
aTextNode
)
;
if
(
newDir
=
=
aOldDir
)
{
return
;
}
/
/
If
the
old
directionality
is
Unset
we
might
determine
now
dir
=
auto
/
/
ancestor
direction
now
even
if
we
don
'
t
have
the
MaySetDirAuto
flag
.
/
/
/
/
Otherwise
we
used
to
have
a
strong
directionality
and
either
no
longer
/
/
does
or
it
changed
.
We
might
need
to
reset
the
direction
.
if
(
aOldDir
=
=
Directionality
:
:
Unset
|
|
aTextNode
-
>
MaySetDirAuto
(
)
)
{
SetAncestorDirectionIfAuto
(
aTextNode
newDir
aNotify
)
;
}
}
void
SetDirectionFromNewTextNode
(
Text
*
aTextNode
)
{
/
/
Need
to
check
parent
as
aTextNode
does
not
yet
have
flags
set
if
(
!
AffectsDirAutoElement
(
aTextNode
-
>
GetParent
(
)
)
)
{
return
;
}
nsIContent
*
parent
=
aTextNode
-
>
GetParent
(
)
;
MOZ_ASSERT
(
parent
)
;
if
(
parent
-
>
NodeOrAncestorHasDirAuto
(
)
)
{
aTextNode
-
>
SetAncestorHasDirAuto
(
)
;
}
if
(
parent
-
>
AffectsDirAutoSlot
(
)
)
{
aTextNode
-
>
SetAffectsDirAutoSlot
(
)
;
}
Directionality
dir
=
GetDirectionFromText
(
aTextNode
)
;
if
(
dir
!
=
Directionality
:
:
Unset
)
{
SetAncestorDirectionIfAuto
(
aTextNode
dir
)
;
}
}
void
ResetDirectionSetByTextNode
(
Text
*
aTextNode
dom
:
:
UnbindContext
&
aContext
)
{
MOZ_ASSERT
(
!
aTextNode
-
>
IsInComposedDoc
(
)
"
Should
be
disconnected
already
"
)
;
if
(
!
aTextNode
-
>
MaySetDirAuto
(
)
)
{
return
;
}
auto
result
=
FindDirAutoElementForText
(
aTextNode
)
;
if
(
result
.
mAnswerIsDefinitive
)
{
/
/
The
dir
=
auto
element
is
in
our
(
now
detached
)
subtree
.
We
'
re
done
as
/
/
nothing
really
changed
for
our
purposes
.
return
;
}
MOZ_ASSERT
(
!
result
.
mElement
)
;
/
/
The
dir
=
auto
element
might
have
been
on
the
element
we
'
re
unbinding
from
.
/
/
In
any
case
this
text
node
is
clearly
no
longer
what
determines
its
/
/
directionality
.
aTextNode
-
>
ClearMaySetDirAuto
(
)
;
auto
*
unboundFrom
=
nsIContent
:
:
FromNodeOrNull
(
aContext
.
GetOriginalSubtreeParent
(
)
)
;
if
(
!
unboundFrom
|
|
!
AffectsDirAutoElement
(
unboundFrom
)
)
{
return
;
}
Directionality
dir
=
GetDirectionFromText
(
aTextNode
)
;
if
(
dir
=
=
Directionality
:
:
Unset
)
{
return
;
}
result
=
FindDirAutoElementFrom
(
unboundFrom
)
;
if
(
!
result
.
mElement
|
|
result
.
mElement
-
>
GetDirectionality
(
)
!
=
dir
)
{
return
;
}
ResetAutoDirection
(
result
.
mElement
/
*
aNotify
=
*
/
true
)
;
}
void
SetDirectionalityFromValue
(
Element
*
aElement
const
nsAString
&
value
bool
aNotify
)
{
Directionality
dir
=
GetDirectionFromText
(
value
.
BeginReading
(
)
value
.
Length
(
)
)
;
if
(
dir
=
=
Directionality
:
:
Unset
)
{
dir
=
Directionality
:
:
Ltr
;
}
if
(
aElement
-
>
GetDirectionality
(
)
!
=
dir
)
{
aElement
-
>
SetDirectionality
(
dir
aNotify
)
;
}
}
void
OnSetDirAttr
(
Element
*
aElement
const
nsAttrValue
*
aNewValue
bool
hadValidDir
bool
hadDirAuto
bool
aNotify
)
{
if
(
!
ParticipatesInAutoDirection
(
aElement
)
)
{
return
;
}
auto
*
elementAsSlot
=
HTMLSlotElement
:
:
FromNode
(
aElement
)
;
/
/
If
element
was
a
boundary
but
is
no
more
inherit
flags
to
subtree
if
(
(
hadDirAuto
|
|
hadValidDir
)
&
&
!
EstablishesOwnDirection
(
aElement
)
)
{
if
(
auto
*
slot
=
aElement
-
>
GetAssignedSlot
(
)
)
{
if
(
slot
-
>
HasDirAuto
(
)
)
{
aElement
-
>
SetAffectsDirAutoSlot
(
)
;
}
}
if
(
auto
*
parent
=
aElement
-
>
GetParent
(
)
)
{
DownwardPropagateDirAutoFlags
(
parent
)
;
}
}
if
(
AffectsDirAutoElement
(
aElement
)
)
{
/
/
The
element
is
a
descendant
of
an
element
with
dir
=
auto
is
having
its
/
/
dir
attribute
changed
.
Reset
the
direction
of
any
of
its
ancestors
whose
/
/
direction
might
be
determined
by
a
text
node
descendant
WalkAncestorsResetAutoDirection
(
aElement
aNotify
)
;
}
else
if
(
hadDirAuto
&
&
!
aElement
-
>
HasDirAuto
(
)
)
{
/
/
The
element
isn
'
t
a
descendant
of
an
element
with
dir
=
auto
and
is
/
/
having
its
dir
attribute
set
to
something
other
than
auto
.
/
/
Walk
the
descendant
tree
and
clear
the
AncestorHasDirAuto
flag
.
/
/
/
/
N
.
B
:
For
elements
other
than
<
bdi
>
it
would
be
enough
to
test
that
the
/
/
current
value
of
dir
was
"
auto
"
in
BeforeSetAttr
to
know
that
we
/
/
were
unsetting
dir
=
"
auto
"
.
For
<
bdi
>
things
are
more
complicated
/
/
since
it
behaves
like
dir
=
"
auto
"
whenever
the
dir
attribute
is
/
/
empty
or
invalid
so
we
would
have
to
check
whether
the
old
value
/
/
was
not
either
"
ltr
"
or
"
rtl
"
and
the
new
value
was
either
"
ltr
"
/
/
or
"
rtl
"
.
Element
:
:
HasDirAuto
(
)
encapsulates
all
that
so
doing
it
/
/
here
is
simpler
.
WalkDescendantsClearAncestorDirAuto
(
aElement
)
;
if
(
elementAsSlot
)
{
for
(
const
auto
&
assignedNode
:
elementAsSlot
-
>
AssignedNodes
(
)
)
{
MaybeClearAffectsDirAutoSlot
(
assignedNode
-
>
AsContent
(
)
)
;
}
}
}
if
(
aElement
-
>
HasDirAuto
(
)
)
{
if
(
elementAsSlot
)
{
for
(
const
auto
&
assignedNode
:
elementAsSlot
-
>
AssignedNodes
(
)
)
{
assignedNode
-
>
SetAffectsDirAutoSlot
(
)
;
DownwardPropagateDirAutoFlags
(
assignedNode
)
;
}
}
MaybeClearAffectsDirAutoSlot
(
aElement
)
;
WalkDescendantsSetDirAuto
(
aElement
aNotify
)
;
}
else
{
SetDirectionalityOnDescendants
(
aElement
RecomputeDirectionality
(
aElement
aNotify
)
aNotify
)
;
}
}
void
SetDirOnBind
(
Element
*
aElement
nsIContent
*
aParent
)
{
/
/
Propagate
flags
from
parent
to
new
element
if
(
!
EstablishesOwnDirection
(
aElement
)
&
&
AffectsDirAutoElement
(
aParent
)
)
{
if
(
aParent
-
>
NodeOrAncestorHasDirAuto
(
)
)
{
aElement
-
>
SetAncestorHasDirAuto
(
)
;
}
if
(
aParent
-
>
AffectsDirAutoSlot
(
)
)
{
aElement
-
>
SetAffectsDirAutoSlot
(
)
;
}
DownwardPropagateDirAutoFlags
(
aElement
)
;
if
(
aElement
-
>
GetFirstChild
(
)
|
|
aElement
-
>
GetShadowRoot
(
)
)
{
/
/
We
may
also
need
to
reset
the
direction
of
an
ancestor
with
dir
=
auto
WalkAncestorsResetAutoDirection
(
aElement
true
)
;
}
}
if
(
!
aElement
-
>
HasDirAuto
(
)
)
{
/
/
if
the
element
doesn
'
t
have
dir
=
auto
set
its
own
directionality
from
/
/
the
dir
attribute
or
by
inheriting
from
its
ancestors
.
RecomputeDirectionality
(
aElement
false
)
;
}
}
void
ResetDir
(
Element
*
aElement
)
{
if
(
!
aElement
-
>
HasDirAuto
(
)
)
{
RecomputeDirectionality
(
aElement
false
)
;
}
}
}
/
/
end
namespace
mozilla
