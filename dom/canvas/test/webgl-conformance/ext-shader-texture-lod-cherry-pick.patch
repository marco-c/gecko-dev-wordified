#
HG
changeset
patch
#
User
Kearwood
(
Kip
)
Gilbert
<
kgilbert
mozilla
.
com
>
#
Date
1441751266
25200
#
Tue
Sep
08
15
:
27
:
46
2015
-
0700
#
Node
ID
43ba953a36814b5f276174afae234f68486f349f
#
Parent
1cbec4a92eae5d8d076072f4b8d27eb2c9dbb363
Bug
1111689
:
Part
2
-
Update
ext
-
shader
-
texture
-
lod
WebGL
conformance
test
-
Cherry
picked
minimal
changes
to
support
updated
ext
-
shader
-
texture
-
lod
webgl
conformance
test
.
diff
-
-
git
a
/
dom
/
canvas
/
test
/
webgl
-
conformance
/
conformance
/
extensions
/
ext
-
shader
-
texture
-
lod
.
html
b
/
dom
/
canvas
/
test
/
webgl
-
conformance
/
conformance
/
extensions
/
ext
-
shader
-
texture
-
lod
.
html
-
-
-
a
/
dom
/
canvas
/
test
/
webgl
-
conformance
/
conformance
/
extensions
/
ext
-
shader
-
texture
-
lod
.
html
+
+
+
b
/
dom
/
canvas
/
test
/
webgl
-
conformance
/
conformance
/
extensions
/
ext
-
shader
-
texture
-
lod
.
html
-
1
37
+
1
60
-
<
!
-
-
-
Copyright
(
c
)
2011
The
Chromium
Authors
.
All
rights
reserved
.
-
Use
of
this
source
code
is
governed
by
a
BSD
-
style
license
that
can
be
-
found
in
the
LICENSE
file
.
-
-
-
>
+
<
!
-
-
+
+
/
*
+
*
*
Copyright
(
c
)
2014
The
Khronos
Group
Inc
.
+
*
*
+
*
*
Permission
is
hereby
granted
free
of
charge
to
any
person
obtaining
a
+
*
*
copy
of
this
software
and
/
or
associated
documentation
files
(
the
+
*
*
"
Materials
"
)
to
deal
in
the
Materials
without
restriction
including
+
*
*
without
limitation
the
rights
to
use
copy
modify
merge
publish
+
*
*
distribute
sublicense
and
/
or
sell
copies
of
the
Materials
and
to
+
*
*
permit
persons
to
whom
the
Materials
are
furnished
to
do
so
subject
to
+
*
*
the
following
conditions
:
+
*
*
+
*
*
The
above
copyright
notice
and
this
permission
notice
shall
be
included
+
*
*
in
all
copies
or
substantial
portions
of
the
Materials
.
+
*
*
+
*
*
THE
MATERIALS
ARE
PROVIDED
"
AS
IS
"
WITHOUT
WARRANTY
OF
ANY
KIND
+
*
*
EXPRESS
OR
IMPLIED
INCLUDING
BUT
NOT
LIMITED
TO
THE
WARRANTIES
OF
+
*
*
MERCHANTABILITY
FITNESS
FOR
A
PARTICULAR
PURPOSE
AND
NONINFRINGEMENT
.
+
*
*
IN
NO
EVENT
SHALL
THE
AUTHORS
OR
COPYRIGHT
HOLDERS
BE
LIABLE
FOR
ANY
+
*
*
CLAIM
DAMAGES
OR
OTHER
LIABILITY
WHETHER
IN
AN
ACTION
OF
CONTRACT
+
*
*
TORT
OR
OTHERWISE
ARISING
FROM
OUT
OF
OR
IN
CONNECTION
WITH
THE
+
*
*
MATERIALS
OR
THE
USE
OR
OTHER
DEALINGS
IN
THE
MATERIALS
.
+
*
/
+
+
-
-
>
<
!
DOCTYPE
html
>
<
html
>
<
head
>
<
meta
charset
=
"
utf
-
8
"
>
<
title
>
WebGL
EXT_shader_texture_lod
Conformance
Tests
<
/
title
>
<
link
rel
=
"
stylesheet
"
href
=
"
.
.
/
.
.
/
resources
/
js
-
test
-
style
.
css
"
/
>
-
<
script
src
=
"
.
.
/
.
.
/
resources
/
desktop
-
gl
-
constants
.
js
"
type
=
"
text
/
javascript
"
>
<
/
script
>
+
<
script
src
=
"
.
.
/
.
.
/
resources
/
desktop
-
gl
-
constants
.
js
"
>
<
/
script
>
<
script
src
=
"
.
.
/
.
.
/
resources
/
js
-
test
-
pre
.
js
"
>
<
/
script
>
-
<
script
src
=
"
.
.
/
resources
/
webgl
-
test
.
js
"
>
<
/
script
>
<
script
src
=
"
.
.
/
resources
/
webgl
-
test
-
utils
.
js
"
>
<
/
script
>
<
/
head
>
<
body
>
<
div
id
=
"
description
"
>
<
/
div
>
-
<
canvas
id
=
"
canvas
"
width
=
"
256
"
height
=
"
256
"
style
=
"
width
:
50px
;
height
:
50px
;
"
>
<
/
canvas
>
+
<
canvas
id
=
"
canvas
"
style
=
"
width
:
256px
;
height
:
256px
;
"
>
<
/
canvas
>
+
<
canvas
id
=
"
canvas2
"
style
=
"
width
:
256px
;
height
:
256px
;
"
>
<
/
canvas
>
<
div
id
=
"
console
"
>
<
/
div
>
-
<
!
-
-
Shaders
for
testing
standard
derivatives
-
-
>
+
<
!
-
-
Shaders
for
testing
texture
LOD
functions
-
-
>
<
!
-
-
Shader
omitting
the
required
#
extension
pragma
-
-
>
<
script
id
=
"
missingPragmaFragmentShader
"
type
=
"
x
-
shader
/
x
-
fragment
"
>
precision
mediump
float
;
varying
vec2
texCoord0v
;
+
uniform
float
lod
;
+
uniform
sampler2D
tex
;
void
main
(
)
{
vec4
color
=
texture2DLodEXT
(
tex
texCoord0v
lod
)
;
-
gl_FragColor
=
vec4
(
dx
dy
w
1
.
0
)
;
+
gl_FragColor
=
color
;
}
<
/
script
>
<
!
-
-
Shader
to
test
macro
definition
-
-
>
<
script
id
=
"
macroFragmentShader
"
type
=
"
x
-
shader
/
x
-
fragment
"
>
precision
mediump
float
;
void
main
(
)
{
#
ifdef
GL_EXT_shader_texture_lod
-
91
47
+
114
60
void
main
(
)
{
<
script
>
description
(
"
This
test
verifies
the
functionality
of
the
EXT_shader_texture_lod
extension
if
it
is
available
.
"
)
;
debug
(
"
"
)
;
var
wtu
=
WebGLTestUtils
;
var
canvas
=
document
.
getElementById
(
"
canvas
"
)
;
-
-
shouldBe
(
"
canvas
.
width
"
"
256
"
)
;
-
shouldBe
(
"
canvas
.
height
"
"
256
"
)
;
-
var
gl
=
wtu
.
create3DContext
(
canvas
)
;
var
ext
=
null
;
-
if
(
!
gl
)
{
-
testFailed
(
"
WebGL
context
does
not
exist
"
)
;
-
}
else
{
-
testPassed
(
"
WebGL
context
exists
"
)
;
+
/
/
Run
all
tests
once
.
+
runAllTests
(
)
;
-
/
/
Run
tests
with
extension
disabled
-
runShaderTests
(
false
)
;
+
/
/
Run
all
tests
against
with
a
new
context
to
test
for
any
cache
issues
.
+
debug
(
"
"
)
;
+
debug
(
"
Testing
new
context
to
catch
cache
errors
"
)
;
+
var
canvas2
=
document
.
getElementById
(
"
canvas2
"
)
;
+
gl
=
wtu
.
create3DContext
(
canvas2
)
;
+
ext
=
null
;
+
runAllTests
(
)
;
-
/
/
Query
the
extension
and
store
globally
so
shouldBe
can
access
it
-
ext
=
gl
.
getExtension
(
"
EXT_shader_texture_lod
"
)
;
-
if
(
!
ext
)
{
-
testPassed
(
"
No
EXT_shader_texture_lod
support
-
-
this
is
legal
"
)
;
+
function
runAllTests
(
)
{
+
if
(
!
gl
)
{
+
testFailed
(
"
WebGL
context
does
not
exist
"
)
;
+
}
else
{
+
testPassed
(
"
WebGL
context
exists
"
)
;
-
runSupportedTest
(
false
)
;
-
}
else
{
-
testPassed
(
"
Successfully
enabled
EXT_shader_texture_lod
extension
"
)
;
+
/
/
Run
tests
with
extension
disabled
+
runShaderTests
(
false
)
;
-
runSupportedTest
(
true
)
;
+
/
/
Query
the
extension
and
store
globally
so
shouldBe
can
access
it
+
ext
=
gl
.
getExtension
(
"
EXT_shader_texture_lod
"
)
;
+
if
(
!
ext
)
{
+
testPassed
(
"
No
EXT_shader_texture_lod
support
-
-
this
is
legal
"
)
;
-
runShaderTests
(
true
)
;
-
runOutputTests
(
)
;
-
runUniqueObjectTest
(
)
;
-
runReferenceCycleTest
(
)
;
+
runSupportedTest
(
false
)
;
+
}
else
{
+
testPassed
(
"
Successfully
enabled
EXT_shader_texture_lod
extension
"
)
;
+
+
runSupportedTest
(
true
)
;
+
+
runShaderTests
(
true
)
;
+
runOutputTests
(
)
;
+
runUniqueObjectTest
(
)
;
+
runReferenceCycleTest
(
)
;
+
+
/
/
Run
deferred
link
tests
.
+
runDeferredLinkTests
(
)
;
+
}
}
+
}
function
runSupportedTest
(
extensionEnabled
)
{
var
supported
=
gl
.
getSupportedExtensions
(
)
;
if
(
supported
.
indexOf
(
"
EXT_shader_texture_lod
"
)
>
=
0
)
{
if
(
extensionEnabled
)
{
testPassed
(
"
EXT_shader_texture_lod
listed
as
supported
and
getExtension
succeeded
"
)
;
}
else
{
-
188
93
+
224
138
function
runShaderTests
(
extensionEnabled
testFailed
(
"
Shader
built
-
ins
compiled
successfully
when
extension
disabled
"
)
;
}
else
{
testPassed
(
"
Shader
built
-
ins
failed
to
compile
when
extension
disabled
"
)
;
}
}
}
function
runOutputTests
(
)
{
+
debug
(
"
"
)
;
debug
(
"
Testing
various
draws
for
valid
built
-
in
function
behavior
"
)
;
-
-
canvas
.
width
=
256
;
canvas
.
height
=
256
;
gl
.
viewport
(
0
0
canvas
.
width
canvas
.
height
)
;
var
program
=
wtu
.
setupProgram
(
gl
[
"
outputVertexShader
"
"
outputFragmentShader
"
]
[
'
vPosition
'
'
texCoord0
'
]
[
0
1
]
)
;
var
quadParameters
=
wtu
.
setupUnitQuad
(
gl
0
1
)
;
var
colors
=
[
-
{
name
:
'
red
'
color
:
[
255
0
0
255
]
}
-
{
name
:
'
green
'
color
:
[
0
255
0
255
]
}
-
{
name
:
'
blue
'
color
:
[
0
0
255
255
]
}
-
{
name
:
'
yellow
'
color
:
[
255
255
0
255
]
}
-
{
name
:
'
magenta
'
color
:
[
255
0
255
255
]
}
-
{
name
:
'
cyan
'
color
:
[
0
255
255
255
]
}
-
{
name
:
'
pink
'
color
:
[
255
128
128
255
]
}
-
{
name
:
'
gray
'
color
:
[
128
128
128
255
]
}
-
{
name
:
'
light
green
'
color
:
[
128
255
128
255
]
}
+
{
name
:
'
red
'
color
:
[
255
0
0
255
]
}
+
{
name
:
'
green
'
color
:
[
0
255
0
255
]
}
+
{
name
:
'
blue
'
color
:
[
0
0
255
255
]
}
+
{
name
:
'
yellow
'
color
:
[
255
255
0
255
]
}
+
{
name
:
'
magenta
'
color
:
[
255
0
255
255
]
}
+
{
name
:
'
cyan
'
color
:
[
0
255
255
255
]
}
+
{
name
:
'
pink
'
color
:
[
255
128
128
255
]
}
+
{
name
:
'
gray
'
color
:
[
128
128
128
255
]
}
+
{
name
:
'
light
green
'
color
:
[
128
255
128
255
]
}
]
;
-
if
(
colors
.
length
!
=
9
)
{
-
testFailed
(
"
9
colors
are
needed
(
9
mips
for
256x256
texture
)
only
have
"
+
colors
.
length
)
;
-
}
else
{
-
testPassed
(
"
9
colors
found
(
9
mips
for
256x256
texture
)
"
)
;
-
}
-
var
tex
=
gl
.
createTexture
(
)
;
gl
.
bindTexture
(
gl
.
TEXTURE_2D
tex
)
;
-
gl
.
texParameteri
(
-
gl
.
TEXTURE_2D
gl
.
TEXTURE_MIN_FILTER
gl
.
NEAREST_MIPMAP_LINEAR
)
;
+
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MIN_FILTER
gl
.
NEAREST_MIPMAP_LINEAR
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MAG_FILTER
gl
.
LINEAR
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_WRAP_S
gl
.
REPEAT
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_WRAP_T
gl
.
REPEAT
)
;
for
(
var
ii
=
0
;
ii
<
colors
.
length
;
+
+
ii
)
{
-
var
color
=
colors
[
ii
]
;
-
var
size
=
Math
.
pow
(
2
colors
.
length
-
ii
-
1
)
;
-
wtu
.
fillTexture
(
gl
tex
size
size
color
.
color
ii
)
;
+
var
color
=
colors
[
ii
]
;
+
var
size
=
Math
.
pow
(
2
colors
.
length
-
ii
-
1
)
;
+
wtu
.
fillTexture
(
gl
tex
size
size
color
.
color
ii
)
;
}
var
loc
=
gl
.
getUniformLocation
(
program
"
lod
"
)
;
for
(
var
ii
=
0
;
ii
<
colors
.
length
;
+
+
ii
)
{
-
gl
.
uniform1f
(
loc
ii
)
;
-
var
color
=
colors
[
ii
]
;
-
wtu
.
drawQuad
(
gl
)
;
-
wtu
.
checkCanvas
(
-
gl
color
.
color
-
"
256x256
texture
drawn
to
256x256
dest
with
lod
=
"
+
ii
+
-
"
should
be
"
+
color
.
name
)
;
+
gl
.
uniform1f
(
loc
ii
)
;
+
var
color
=
colors
[
ii
]
;
+
wtu
.
drawUnitQuad
(
gl
)
;
+
wtu
.
checkCanvas
(
+
gl
color
.
color
+
"
256x256
texture
drawn
to
256x256
dest
with
lod
=
"
+
ii
+
+
"
should
be
"
+
color
.
name
)
;
}
-
glErrorShouldBe
(
gl
gl
.
NO_ERROR
"
Should
be
no
errors
.
"
)
;
+
wtu
.
glErrorShouldBe
(
gl
gl
.
NO_ERROR
)
;
}
function
runUniqueObjectTest
(
)
{
+
debug
(
"
"
)
;
debug
(
"
Testing
that
getExtension
(
)
returns
the
same
object
each
time
"
)
;
gl
.
getExtension
(
"
EXT_shader_texture_lod
"
)
.
myProperty
=
2
;
gc
(
)
;
shouldBe
(
'
gl
.
getExtension
(
"
EXT_shader_texture_lod
"
)
.
myProperty
'
'
2
'
)
;
}
function
runReferenceCycleTest
(
)
{
/
/
create
some
reference
cycles
.
The
goal
is
to
see
if
they
cause
leaks
.
The
point
is
that
/
/
some
browser
test
runners
have
instrumentation
to
detect
leaked
refcounted
objects
.
-
+
debug
(
"
"
)
;
debug
(
"
Testing
reference
cycles
between
context
and
extension
objects
"
)
;
var
ext
=
gl
.
getExtension
(
"
EXT_shader_texture_lod
"
)
;
/
/
create
cycle
between
extension
and
context
since
the
context
has
to
hold
a
reference
to
the
extension
ext
.
context
=
gl
;
/
/
create
a
self
-
cycle
on
the
extension
object
ext
.
ext
=
ext
;
}
+
function
runDeferredLinkTests
(
)
{
+
debug
(
"
"
)
;
+
debug
(
"
Testing
deferred
shader
compilation
tests
.
"
)
;
+
+
/
/
Test
for
compilation
failures
that
are
caused
by
missing
extensions
+
/
/
do
not
succeed
if
extensions
are
enabled
during
linking
.
This
would
+
/
/
only
happen
for
deferred
shader
compilations
.
+
+
/
/
First
test
if
link
succeeds
with
extension
enabled
.
+
var
glEnabled
=
wtu
.
create3DContext
(
)
;
+
var
extEnabled
=
glEnabled
.
getExtension
(
"
EXT_shader_texture_lod
"
)
;
+
if
(
!
extEnabled
)
{
+
testFailed
(
"
Deferred
link
test
expects
the
extension
to
be
supported
"
)
;
+
}
+
+
var
vertexShader
=
wtu
.
loadShaderFromScript
(
glEnabled
"
goodVertexShader
"
)
;
+
var
fragmentShader
=
wtu
.
loadShaderFromScript
(
glEnabled
"
macroFragmentShader
"
)
;
+
+
if
(
!
vertexShader
|
|
!
fragmentShader
)
{
+
testFailed
(
"
Could
not
create
good
shaders
.
"
)
;
+
return
;
+
}
+
+
var
program
=
wtu
.
setupProgram
(
glEnabled
[
vertexShader
fragmentShader
]
)
;
+
+
if
(
!
program
)
{
+
testFailed
(
"
Compilation
with
extension
enabled
failed
.
"
)
;
+
return
;
+
}
+
+
/
/
Create
new
context
to
test
link
failure
without
extension
enabled
.
+
var
glDeferred
=
wtu
.
create3DContext
(
)
;
+
+
var
vertexShader
=
wtu
.
loadShaderFromScript
(
glDeferred
"
goodVertexShader
"
glDeferred
.
VERTEX_SHADER
undefined
undefined
true
)
;
+
var
fragmentShader
=
wtu
.
loadShaderFromScript
(
glDeferred
"
macroFragmentShader
"
glDeferred
.
FRAGMENT_SHADER
undefined
undefined
true
)
;
+
+
if
(
vertexShader
=
=
null
|
|
fragmentShader
=
=
null
)
{
+
testFailed
(
"
Could
not
create
shaders
.
"
)
;
+
return
;
+
}
+
+
/
/
Shader
compilations
should
have
failed
due
to
extensions
not
enabled
.
+
glDeferred
.
getExtension
(
"
EXT_shader_texture_lod
"
)
;
+
var
program
=
wtu
.
setupProgram
(
glDeferred
[
vertexShader
fragmentShader
]
)
;
+
if
(
program
)
{
+
testFailed
(
"
Compilation
with
extension
disabled
then
linking
with
extension
enabled
should
have
failed
.
"
)
;
+
return
;
+
}
+
+
testPassed
(
"
Compilation
with
extension
disabled
then
linking
with
extension
enabled
.
"
)
;
+
}
+
debug
(
"
"
)
;
successfullyParsed
=
true
;
<
/
script
>
<
script
>
finishTest
(
)
;
<
/
script
>
<
/
body
>
<
/
html
>
diff
-
-
git
a
/
dom
/
canvas
/
test
/
webgl
-
conformance
/
conformance
/
resources
/
webgl
-
test
-
utils
.
js
b
/
dom
/
canvas
/
test
/
webgl
-
conformance
/
conformance
/
resources
/
webgl
-
test
-
utils
.
js
-
-
-
a
/
dom
/
canvas
/
test
/
webgl
-
conformance
/
conformance
/
resources
/
webgl
-
test
-
utils
.
js
+
+
+
b
/
dom
/
canvas
/
test
/
webgl
-
conformance
/
conformance
/
resources
/
webgl
-
test
-
utils
.
js
-
994
19
+
994
28
var
readFileList
=
function
(
url
)
{
}
;
/
*
*
*
Loads
a
shader
.
*
param
{
!
WebGLContext
}
gl
The
WebGLContext
to
use
.
*
param
{
string
}
shaderSource
The
shader
source
.
*
param
{
number
}
shaderType
The
type
of
shader
.
*
param
{
function
(
string
)
:
void
)
opt_errorCallback
callback
for
errors
.
+
*
param
{
boolean
}
opt_logShaders
Whether
to
log
shader
source
.
+
*
param
{
string
}
opt_shaderLabel
Label
that
identifies
the
shader
source
in
+
*
the
log
.
+
*
param
{
string
}
opt_url
URL
from
where
the
shader
source
was
loaded
from
.
+
*
If
opt_logShaders
is
set
then
a
link
to
the
source
file
will
also
be
+
*
added
.
+
*
param
{
boolean
}
Skip
compilation
status
check
.
Default
=
false
.
*
return
{
!
WebGLShader
}
The
created
shader
.
*
/
-
var
loadShader
=
function
(
gl
shaderSource
shaderType
opt_errorCallback
)
{
+
var
loadShader
=
function
(
+
gl
shaderSource
shaderType
opt_errorCallback
opt_logShaders
+
opt_shaderLabel
opt_url
opt_skipCompileStatus
)
{
var
errFn
=
opt_errorCallback
|
|
error
;
/
/
Create
the
shader
object
var
shader
=
gl
.
createShader
(
shaderType
)
;
if
(
shader
=
=
null
)
{
errFn
(
"
*
*
*
Error
:
unable
to
create
shader
'
"
+
shaderSource
+
"
'
"
)
;
return
null
;
}
-
1016
24
+
1025
35
var
loadShader
=
function
(
gl
shaderSour
if
(
err
!
=
gl
.
NO_ERROR
)
{
errFn
(
"
*
*
*
Error
loading
shader
'
"
+
shader
+
"
'
:
"
+
glEnumToString
(
gl
err
)
)
;
return
null
;
}
/
/
Compile
the
shader
gl
.
compileShader
(
shader
)
;
+
if
(
opt_logShaders
)
{
+
var
label
=
shaderType
=
=
gl
.
VERTEX_SHADER
?
'
vertex
shader
'
:
'
fragment_shader
'
;
+
if
(
opt_shaderLabel
)
{
+
label
=
opt_shaderLabel
+
'
'
+
label
;
+
}
+
addShaderSources
(
+
gl
document
.
getElementById
(
'
console
'
)
label
shader
shaderSource
opt_url
)
;
+
}
+
/
/
Check
the
compile
status
-
var
compiled
=
gl
.
getShaderParameter
(
shader
gl
.
COMPILE_STATUS
)
;
-
if
(
!
compiled
)
{
-
/
/
Something
went
wrong
during
compilation
;
get
the
error
-
lastError
=
gl
.
getShaderInfoLog
(
shader
)
;
-
errFn
(
"
*
*
*
Error
compiling
shader
'
"
+
shader
+
"
'
:
"
+
lastError
)
;
-
gl
.
deleteShader
(
shader
)
;
-
return
null
;
+
if
(
!
opt_skipCompileStatus
)
{
+
var
compiled
=
gl
.
getShaderParameter
(
shader
gl
.
COMPILE_STATUS
)
;
+
if
(
!
compiled
)
{
+
/
/
Something
went
wrong
during
compilation
;
get
the
error
+
lastError
=
gl
.
getShaderInfoLog
(
shader
)
;
+
errFn
(
"
*
*
*
Error
compiling
"
+
glEnumToString
(
gl
shaderType
)
+
"
'
"
+
shader
+
"
'
:
"
+
lastError
)
;
+
gl
.
deleteShader
(
shader
)
;
+
return
null
;
+
}
}
return
shader
;
}
/
*
*
*
Loads
a
shader
from
a
URL
.
*
param
{
!
WebGLContext
}
gl
The
WebGLContext
to
use
.
-
1060
42
+
1080
42
var
getScript
=
function
(
scriptId
)
{
/
*
*
*
Loads
a
shader
from
a
script
tag
.
*
param
{
!
WebGLContext
}
gl
The
WebGLContext
to
use
.
*
param
{
string
}
scriptId
The
id
of
the
script
tag
.
*
param
{
number
}
opt_shaderType
The
type
of
shader
.
If
not
passed
in
it
will
*
be
derived
from
the
type
of
the
script
tag
.
*
param
{
function
(
string
)
:
void
)
opt_errorCallback
callback
for
errors
.
+
*
param
{
boolean
}
opt_logShaders
Whether
to
log
shader
source
.
+
*
param
{
boolean
}
Skip
compilation
status
check
.
Default
=
false
.
*
return
{
!
WebGLShader
}
The
created
shader
.
*
/
var
loadShaderFromScript
=
function
(
-
gl
scriptId
opt_shaderType
opt_errorCallback
)
{
+
gl
scriptId
opt_shaderType
opt_errorCallback
opt_logShaders
opt_skipCompileStatus
)
{
var
shaderSource
=
"
"
;
-
var
shaderType
;
var
shaderScript
=
document
.
getElementById
(
scriptId
)
;
if
(
!
shaderScript
)
{
throw
(
"
*
*
*
Error
:
unknown
script
element
"
+
scriptId
)
;
}
shaderSource
=
shaderScript
.
text
;
if
(
!
opt_shaderType
)
{
if
(
shaderScript
.
type
=
=
"
x
-
shader
/
x
-
vertex
"
)
{
-
shaderType
=
gl
.
VERTEX_SHADER
;
+
opt_shaderType
=
gl
.
VERTEX_SHADER
;
}
else
if
(
shaderScript
.
type
=
=
"
x
-
shader
/
x
-
fragment
"
)
{
-
shaderType
=
gl
.
FRAGMENT_SHADER
;
-
}
else
if
(
shaderType
!
=
gl
.
VERTEX_SHADER
&
&
shaderType
!
=
gl
.
FRAGMENT_SHADER
)
{
+
opt_shaderType
=
gl
.
FRAGMENT_SHADER
;
+
}
else
{
throw
(
"
*
*
*
Error
:
unknown
shader
type
"
)
;
return
null
;
}
}
-
return
loadShader
(
-
gl
shaderSource
opt_shaderType
?
opt_shaderType
:
shaderType
-
opt_errorCallback
)
;
+
return
loadShader
(
gl
shaderSource
opt_shaderType
opt_errorCallback
+
opt_logShaders
undefined
undefined
opt_skipCompileStatus
)
;
}
;
var
loadStandardProgram
=
function
(
gl
)
{
var
program
=
gl
.
createProgram
(
)
;
gl
.
attachShader
(
program
loadStandardVertexShader
(
gl
)
)
;
gl
.
attachShader
(
program
loadStandardFragmentShader
(
gl
)
)
;
linkProgram
(
gl
program
)
;
return
program
;
