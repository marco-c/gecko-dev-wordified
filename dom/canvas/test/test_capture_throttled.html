<
!
DOCTYPE
html
>
<
meta
charset
=
"
utf
-
8
"
/
>
<
title
>
Canvas2D
test
:
CaptureStream
(
)
with
throttled
rAF
<
/
title
>
<
script
src
=
"
/
tests
/
SimpleTest
/
SimpleTest
.
js
"
>
<
/
script
>
<
script
src
=
"
captureStream_common
.
js
"
>
<
/
script
>
<
link
rel
=
"
stylesheet
"
href
=
"
/
tests
/
SimpleTest
/
test
.
css
"
/
>
<
script
>
SimpleTest
.
waitForExplicitFinish
(
)
;
SimpleTest
.
requestFlakyTimeout
(
"
Ensuring
nothing
happens
until
timing
out
with
good
margin
"
)
;
/
/
CaptureStreamTestHelper
holding
utility
test
functions
.
const
h
=
new
CaptureStreamTestHelper2D
(
)
;
async
function
measureRequestAnimationFrameRate
(
)
{
const
start
=
await
new
Promise
(
r
=
>
requestAnimationFrame
(
r
)
)
;
for
(
let
count
=
1
;
;
count
+
+
)
{
const
time
=
await
new
Promise
(
r
=
>
requestAnimationFrame
(
r
)
)
;
if
(
time
-
start
>
1000
)
{
/
/
One
second
has
passed
break
.
return
count
/
(
(
time
-
start
)
/
1000
)
;
}
}
}
async
function
measureSetTimeoutRate
(
)
{
/
/
The
average
isn
'
t
accurate
at
low
counts
.
const
COUNT
=
25
;
const
start
=
performance
.
now
(
)
;
for
(
let
i
=
0
;
i
<
COUNT
;
+
+
i
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
}
return
COUNT
/
(
(
performance
.
now
(
)
-
start
)
/
1000
)
;
}
async
function
measureCanvasCaptureFrameRate
(
captureRate
)
{
/
/
Canvas
element
captured
by
streams
.
const
c
=
h
.
createAndAppendElement
(
"
canvas
"
"
c
"
)
;
/
/
Since
we
are
in
a
background
tab
the
video
element
won
'
t
get
composited
/
/
so
we
cannot
look
for
a
frame
count
there
.
Instead
we
use
RTCPeerConnection
/
/
and
RTCOutboundRtpStreamStats
.
framesEncoded
.
const
pc1
=
new
RTCPeerConnection
(
)
;
const
pc2
=
new
RTCPeerConnection
(
)
;
/
/
Add
the
canvas
.
captureStream
track
.
const
ctx
=
c
.
getContext
(
"
2d
"
)
;
const
[
track
]
=
c
.
captureStream
(
captureRate
)
.
getTracks
(
)
;
const
sender
=
pc1
.
addTrack
(
track
)
;
/
/
Ice
candidates
signaling
pc1
.
onicecandidate
=
e
=
>
pc2
.
addIceCandidate
(
e
.
candidate
)
;
pc2
.
onicecandidate
=
e
=
>
pc1
.
addIceCandidate
(
e
.
candidate
)
;
/
/
Offer
/
Answer
exchange
await
pc1
.
setLocalDescription
(
)
;
await
pc2
.
setRemoteDescription
(
pc1
.
localDescription
)
;
await
pc2
.
setLocalDescription
(
)
;
await
pc1
.
setRemoteDescription
(
pc2
.
localDescription
)
;
/
/
Wait
for
RTP
packets
to
arrive
.
const
event
=
await
new
Promise
(
r
=
>
pc2
.
ontrack
=
r
)
;
await
new
Promise
(
r
=
>
event
.
track
.
onunmute
=
r
)
;
/
/
Draw
to
the
canvas
const
intervalMillis
=
1000
/
60
;
const
getFrameCount
=
async
(
)
=
>
{
const
stats
=
await
sender
.
getStats
(
)
;
const
outbound
=
[
.
.
.
stats
.
values
(
)
]
.
find
(
(
{
type
}
)
=
>
type
=
=
"
outbound
-
rtp
"
)
;
return
outbound
?
.
framesEncoded
?
?
0
;
/
/
See
bug
1789768
.
}
;
is
(
await
getFrameCount
(
)
0
"
frame
count
starts
at
0
"
)
;
const
start
=
performance
.
now
(
)
;
let
end
;
do
{
h
.
drawColor
(
c
h
.
green
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
intervalMillis
)
)
;
end
=
performance
.
now
(
)
;
}
while
(
end
-
start
<
=
1000
)
;
const
framerate
=
(
await
getFrameCount
(
)
)
/
(
(
end
-
start
)
/
1000
)
;
pc1
.
close
(
)
;
pc2
.
close
(
)
;
return
framerate
;
}
(
async
(
)
=
>
{
/
/
Disable
background
timer
throttling
so
we
can
use
setTimeout
to
draw
to
the
/
/
canvas
while
the
refresh
driver
is
throttled
.
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
timeout
.
enable_budget_timer_throttling
"
false
]
[
"
dom
.
min_background_timeout_value
"
0
]
[
"
dom
.
min_background_timeout_value_without_budget_throttling
"
0
]
[
"
browser
.
link
.
open_newwindow
"
3
]
/
/
window
.
open
in
new
tab
]
}
)
;
/
/
Throttle
the
canvas
'
refresh
driver
by
opening
a
new
foreground
tab
const
foregroundTab
=
window
.
open
(
"
about
:
blank
"
)
;
/
/
Let
the
throttling
take
effect
await
new
Promise
(
r
=
>
setTimeout
(
r
500
)
)
;
const
rAFRate
=
await
measureRequestAnimationFrameRate
(
)
;
ok
(
rAFRate
<
5
rAF
framerate
is
at
{
rAFRate
}
fps
)
;
const
setTimeoutRate
=
await
measureSetTimeoutRate
(
)
;
ok
(
setTimeoutRate
>
30
setTimeout
rate
is
at
{
setTimeoutRate
}
tps
)
;
const
autoRate
=
await
measureCanvasCaptureFrameRate
(
)
;
ok
(
autoRate
>
5
captureStream
(
)
framerate
is
at
{
autoRate
}
fps
)
;
const
cappedRate
=
await
measureCanvasCaptureFrameRate
(
10
)
;
ok
(
cappedRate
>
5
captureStream
(
10
)
framerate
is
at
{
cappedRate
}
fps
)
;
foregroundTab
.
close
(
)
;
SimpleTest
.
finish
(
)
;
}
)
(
)
;
<
/
script
>
