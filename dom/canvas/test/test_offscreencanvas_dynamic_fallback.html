<
!
DOCTYPE
HTML
>
<
html
>
<
head
>
<
title
>
WebGL
in
OffscreenCanvas
<
/
title
>
<
script
src
=
"
/
tests
/
SimpleTest
/
SimpleTest
.
js
"
>
<
/
script
>
<
script
src
=
"
/
tests
/
SimpleTest
/
WindowSnapshot
.
js
"
>
<
/
script
>
<
link
rel
=
"
stylesheet
"
href
=
"
/
tests
/
SimpleTest
/
test
.
css
"
>
<
/
head
>
<
body
>
<
script
>
SimpleTest
.
waitForExplicitFinish
(
)
;
function
createCanvas
(
initWithMask
)
{
var
canvas
=
document
.
createElement
(
"
canvas
"
)
;
canvas
.
width
=
64
;
canvas
.
height
=
64
;
document
.
body
.
appendChild
(
canvas
)
;
if
(
initWithMask
)
{
canvas
.
style
.
mask
=
"
url
(
'
offscreencanvas_mask
.
svg
#
fade_mask_both
'
)
"
;
}
return
canvas
;
}
function
getRefSnapshot
(
initWithMask
)
{
var
refCanvas
=
createCanvas
(
!
initWithMask
)
;
var
ctx
=
refCanvas
.
getContext
(
"
2d
"
)
;
ctx
.
rect
(
0
0
64
64
)
;
ctx
.
fillStyle
=
"
#
00FF00
"
;
ctx
.
fill
(
)
;
var
result
=
snapshotWindow
(
window
)
;
document
.
body
.
removeChild
(
refCanvas
)
;
return
result
;
}
function
runTest
(
)
{
var
startWorker
=
function
(
canvas
canvasType
testType
initWithMask
)
{
var
canvas
=
createCanvas
(
initWithMask
)
;
var
worker
=
new
Worker
(
"
offscreencanvas
.
js
"
)
;
ok
(
canvas
.
transferControlToOffscreen
"
[
"
+
canvasType
+
"
]
"
+
"
HTMLCanvasElement
has
transferControlToOffscreen
function
"
)
;
var
offscreenCanvas
=
canvas
.
transferControlToOffscreen
(
)
;
ok
(
offscreenCanvas
"
[
"
+
canvasType
+
"
]
"
+
"
Expected
transferControlToOffscreen
to
succeed
"
)
;
worker
.
postMessage
(
{
canvasType
:
canvasType
testType
:
testType
canvas
:
offscreenCanvas
}
[
offscreenCanvas
]
)
;
return
new
Promise
(
function
(
resolved
)
{
worker
.
onmessage
=
function
(
evt
)
{
var
msg
=
evt
.
data
|
|
{
}
;
if
(
msg
.
type
=
=
"
test
"
)
{
ok
(
msg
.
result
"
[
"
+
canvasType
+
"
]
"
+
msg
.
name
)
;
}
if
(
msg
.
type
=
=
"
draw
"
)
{
if
(
msg
.
count
=
=
=
10
)
{
/
/
Change
the
fallback
state
dynamically
when
drawing
count
reaches
10
.
if
(
initWithMask
)
{
canvas
.
style
.
mask
=
"
"
;
}
else
{
canvas
.
style
.
mask
=
"
url
(
'
offscreencanvas_mask
.
svg
#
fade_mask_both
'
)
"
;
}
}
else
if
(
msg
.
count
=
=
=
20
)
{
var
snapshotFallback
=
snapshotWindow
(
window
)
;
worker
.
terminate
(
)
;
document
.
body
.
removeChild
(
canvas
)
;
var
results
=
compareSnapshots
(
snapshotFallback
getRefSnapshot
(
initWithMask
)
true
)
;
ok
(
results
[
0
]
"
[
"
+
canvasType
+
"
]
"
+
"
after
dynamic
fallback
screenshots
should
be
the
same
"
)
;
resolved
(
)
;
}
}
}
}
)
;
}
startWorker
(
createCanvas
(
false
)
'
2d
'
'
fallback
'
false
)
.
then
(
function
(
)
{
startWorker
(
createCanvas
(
true
)
'
2d
'
'
fallback
'
true
)
.
then
(
function
(
)
{
startWorker
(
createCanvas
(
false
)
'
webgl
'
'
fallback
'
false
)
.
then
(
function
(
)
{
startWorker
(
createCanvas
(
true
)
'
webgl
'
'
fallback
'
true
)
.
then
(
function
(
)
{
SimpleTest
.
finish
(
)
;
}
)
}
)
}
)
}
)
;
}
SpecialPowers
.
pushPrefEnv
(
{
'
set
'
:
[
[
'
gfx
.
offscreencanvas
.
enabled
'
true
]
[
'
webgl
.
force
-
enabled
'
true
]
]
}
runTest
)
;
<
/
script
>
<
/
body
>
<
/
html
>
