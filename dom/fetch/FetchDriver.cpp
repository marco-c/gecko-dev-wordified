/
*
-
*
-
Mode
:
C
+
+
;
tab
-
width
:
2
;
indent
-
tabs
-
mode
:
nil
;
c
-
basic
-
offset
:
2
-
*
-
*
/
/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
#
include
"
mozilla
/
dom
/
FetchDriver
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIOutputStream
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIHttpHeaderVisitor
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsIThreadRetargetableRequest
.
h
"
#
include
"
nsIUploadChannel2
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsCORSListenerProxy
.
h
"
#
include
"
nsDataHandler
.
h
"
#
include
"
nsHostObjectProtocolHandler
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
mozilla
/
dom
/
workers
/
Workers
.
h
"
#
include
"
Fetch
.
h
"
#
include
"
InternalRequest
.
h
"
#
include
"
InternalResponse
.
h
"
namespace
mozilla
{
namespace
dom
{
NS_IMPL_ISUPPORTS
(
FetchDriver
nsIStreamListener
)
FetchDriver
:
:
FetchDriver
(
InternalRequest
*
aRequest
nsIPrincipal
*
aPrincipal
nsILoadGroup
*
aLoadGroup
)
:
mPrincipal
(
aPrincipal
)
mLoadGroup
(
aLoadGroup
)
mRequest
(
aRequest
)
mFetchRecursionCount
(
0
)
mResponseAvailableCalled
(
false
)
{
}
FetchDriver
:
:
~
FetchDriver
(
)
{
/
/
We
assert
this
since
even
on
failures
we
should
call
/
/
FailWithNetworkError
(
)
.
MOZ_ASSERT
(
mResponseAvailableCalled
)
;
}
nsresult
FetchDriver
:
:
Fetch
(
FetchDriverObserver
*
aObserver
)
{
workers
:
:
AssertIsOnMainThread
(
)
;
mObserver
=
aObserver
;
return
Fetch
(
false
/
*
CORS
flag
*
/
)
;
}
nsresult
FetchDriver
:
:
Fetch
(
bool
aCORSFlag
)
{
/
/
We
do
not
currently
implement
parts
of
the
spec
that
lead
to
recursion
.
MOZ_ASSERT
(
mFetchRecursionCount
=
=
0
)
;
mFetchRecursionCount
+
+
;
/
/
FIXME
(
nsm
)
:
Deal
with
HSTS
.
if
(
!
mRequest
-
>
IsSynchronous
(
)
&
&
mFetchRecursionCount
<
=
1
)
{
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableMethodWithArg
<
bool
>
(
this
&
FetchDriver
:
:
ContinueFetch
aCORSFlag
)
;
nsresult
rv
=
NS_DispatchToCurrentThread
(
r
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
}
return
rv
;
}
MOZ_CRASH
(
"
Synchronous
fetch
not
supported
"
)
;
}
nsresult
FetchDriver
:
:
ContinueFetch
(
bool
aCORSFlag
)
{
workers
:
:
AssertIsOnMainThread
(
)
;
nsAutoCString
url
;
mRequest
-
>
GetURL
(
url
)
;
nsCOMPtr
<
nsIURI
>
requestURI
;
/
/
FIXME
(
nsm
)
:
Deal
with
relative
URLs
.
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
requestURI
)
url
nullptr
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
FailWithNetworkError
(
)
;
}
/
/
Begin
Step
4
of
the
Fetch
algorithm
/
/
https
:
/
/
fetch
.
spec
.
whatwg
.
org
/
#
fetching
/
/
FIXME
(
nsm
)
:
Bug
1039846
:
Add
CSP
checks
nsAutoCString
scheme
;
rv
=
requestURI
-
>
GetScheme
(
scheme
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
FailWithNetworkError
(
)
;
}
rv
=
mPrincipal
-
>
CheckMayLoad
(
requestURI
false
/
*
report
*
/
false
/
*
allowIfInheritsPrincipal
*
/
)
;
if
(
(
!
aCORSFlag
&
&
NS_SUCCEEDED
(
rv
)
)
|
|
(
scheme
.
EqualsLiteral
(
"
data
"
)
&
&
mRequest
-
>
SameOriginDataURL
(
)
)
|
|
scheme
.
EqualsLiteral
(
"
about
"
)
)
{
return
BasicFetch
(
)
;
}
if
(
mRequest
-
>
Mode
(
)
=
=
RequestMode
:
:
Same_origin
)
{
return
FailWithNetworkError
(
)
;
}
if
(
mRequest
-
>
Mode
(
)
=
=
RequestMode
:
:
No_cors
)
{
mRequest
-
>
SetResponseTainting
(
InternalRequest
:
:
RESPONSETAINT_OPAQUE
)
;
return
BasicFetch
(
)
;
}
if
(
!
scheme
.
EqualsLiteral
(
"
http
"
)
&
&
!
scheme
.
EqualsLiteral
(
"
https
"
)
)
{
return
FailWithNetworkError
(
)
;
}
bool
corsPreflight
=
false
;
if
(
mRequest
-
>
Mode
(
)
=
=
RequestMode
:
:
Cors_with_forced_preflight
|
|
(
mRequest
-
>
UnsafeRequest
(
)
&
&
(
!
mRequest
-
>
HasSimpleMethod
(
)
|
|
!
mRequest
-
>
Headers
(
)
-
>
HasOnlySimpleHeaders
(
)
)
)
)
{
corsPreflight
=
true
;
}
mRequest
-
>
SetResponseTainting
(
InternalRequest
:
:
RESPONSETAINT_CORS
)
;
return
HttpFetch
(
true
/
*
aCORSFlag
*
/
corsPreflight
)
;
}
nsresult
FetchDriver
:
:
BasicFetch
(
)
{
nsAutoCString
url
;
mRequest
-
>
GetURL
(
url
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
url
nullptr
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
return
rv
;
}
nsAutoCString
scheme
;
rv
=
uri
-
>
GetScheme
(
scheme
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
return
rv
;
}
if
(
scheme
.
LowerCaseEqualsLiteral
(
"
about
"
)
)
{
if
(
url
.
EqualsLiteral
(
"
about
:
blank
"
)
)
{
nsRefPtr
<
InternalResponse
>
response
=
new
InternalResponse
(
200
NS_LITERAL_CSTRING
(
"
OK
"
)
)
;
ErrorResult
result
;
response
-
>
Headers
(
)
-
>
Append
(
NS_LITERAL_CSTRING
(
"
content
-
type
"
)
NS_LITERAL_CSTRING
(
"
text
/
html
;
charset
=
utf
-
8
"
)
result
)
;
MOZ_ASSERT
(
!
result
.
Failed
(
)
)
;
nsCOMPtr
<
nsIInputStream
>
body
;
rv
=
NS_NewCStringInputStream
(
getter_AddRefs
(
body
)
EmptyCString
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
return
rv
;
}
response
-
>
SetBody
(
body
)
;
BeginResponse
(
response
)
;
return
SucceedWithResponse
(
)
;
}
return
FailWithNetworkError
(
)
;
}
if
(
scheme
.
LowerCaseEqualsLiteral
(
"
blob
"
)
)
{
nsRefPtr
<
FileImpl
>
blobImpl
;
rv
=
NS_GetBlobForBlobURI
(
uri
getter_AddRefs
(
blobImpl
)
)
;
FileImpl
*
blob
=
static_cast
<
FileImpl
*
>
(
blobImpl
.
get
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
return
rv
;
}
nsRefPtr
<
InternalResponse
>
response
=
new
InternalResponse
(
200
NS_LITERAL_CSTRING
(
"
OK
"
)
)
;
{
ErrorResult
result
;
uint64_t
size
=
blob
-
>
GetSize
(
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
FailWithNetworkError
(
)
;
return
result
.
ErrorCode
(
)
;
}
nsAutoString
sizeStr
;
sizeStr
.
AppendInt
(
size
)
;
response
-
>
Headers
(
)
-
>
Append
(
NS_LITERAL_CSTRING
(
"
Content
-
Length
"
)
NS_ConvertUTF16toUTF8
(
sizeStr
)
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
FailWithNetworkError
(
)
;
return
result
.
ErrorCode
(
)
;
}
nsAutoString
type
;
blob
-
>
GetType
(
type
)
;
response
-
>
Headers
(
)
-
>
Append
(
NS_LITERAL_CSTRING
(
"
Content
-
Type
"
)
NS_ConvertUTF16toUTF8
(
type
)
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
FailWithNetworkError
(
)
;
return
result
.
ErrorCode
(
)
;
}
}
nsCOMPtr
<
nsIInputStream
>
stream
;
rv
=
blob
-
>
GetInternalStream
(
getter_AddRefs
(
stream
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
return
rv
;
}
response
-
>
SetBody
(
stream
)
;
BeginResponse
(
response
)
;
return
SucceedWithResponse
(
)
;
}
if
(
scheme
.
LowerCaseEqualsLiteral
(
"
data
"
)
)
{
nsAutoCString
method
;
mRequest
-
>
GetMethod
(
method
)
;
if
(
method
.
LowerCaseEqualsASCII
(
"
get
"
)
)
{
/
/
Use
nsDataHandler
directly
so
that
we
can
extract
the
content
type
.
/
/
XXX
(
nsm
)
:
Is
there
a
way
to
acquire
the
charset
without
such
tight
/
/
coupling
with
the
DataHandler
?
nsIProtocolHandler
does
not
provide
/
/
anything
similar
.
nsAutoCString
contentType
contentCharset
dataBuffer
hashRef
;
bool
isBase64
;
rv
=
nsDataHandler
:
:
ParseURI
(
url
contentType
contentCharset
isBase64
dataBuffer
hashRef
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
ErrorResult
result
;
nsRefPtr
<
InternalResponse
>
response
=
new
InternalResponse
(
200
NS_LITERAL_CSTRING
(
"
OK
"
)
)
;
if
(
!
contentCharset
.
IsEmpty
(
)
)
{
contentType
.
Append
(
"
;
charset
=
"
)
;
contentType
.
Append
(
contentCharset
)
;
}
response
-
>
Headers
(
)
-
>
Append
(
NS_LITERAL_CSTRING
(
"
Content
-
Type
"
)
contentType
result
)
;
if
(
!
result
.
Failed
(
)
)
{
nsCOMPtr
<
nsIInputStream
>
stream
;
rv
=
NS_NewCStringInputStream
(
getter_AddRefs
(
stream
)
dataBuffer
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
response
-
>
SetBody
(
stream
)
;
BeginResponse
(
response
)
;
return
SucceedWithResponse
(
)
;
}
}
}
}
return
FailWithNetworkError
(
)
;
}
if
(
scheme
.
LowerCaseEqualsLiteral
(
"
file
"
)
)
{
}
else
if
(
scheme
.
LowerCaseEqualsLiteral
(
"
http
"
)
|
|
scheme
.
LowerCaseEqualsLiteral
(
"
https
"
)
)
{
return
HttpFetch
(
)
;
}
return
FailWithNetworkError
(
)
;
}
/
/
This
function
implements
the
"
HTTP
Fetch
"
algorithm
from
the
Fetch
spec
.
/
/
Functionality
is
often
split
between
here
the
CORS
listener
proxy
and
the
/
/
Necko
HTTP
implementation
.
nsresult
FetchDriver
:
:
HttpFetch
(
bool
aCORSFlag
bool
aCORSPreflightFlag
bool
aAuthenticationFlag
)
{
/
/
Step
1
.
"
Let
response
be
null
.
"
mResponse
=
nullptr
;
nsresult
rv
;
nsCOMPtr
<
nsIIOService
>
ios
=
do_GetIOService
(
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
return
rv
;
}
nsAutoCString
url
;
mRequest
-
>
GetURL
(
url
)
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
url
nullptr
nullptr
ios
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
return
rv
;
}
/
/
Step
2
deals
with
letting
ServiceWorkers
intercept
requests
.
This
is
/
/
handled
by
Necko
after
the
channel
is
opened
.
/
/
FIXME
(
nsm
)
:
Bug
1119026
:
The
channel
'
s
skip
service
worker
flag
should
be
/
/
set
based
on
the
Request
'
s
flag
.
/
/
From
here
on
we
create
a
channel
and
set
its
properties
with
the
/
/
information
from
the
InternalRequest
.
This
is
an
implementation
detail
.
MOZ_ASSERT
(
mLoadGroup
)
;
nsCOMPtr
<
nsIChannel
>
chan
;
rv
=
NS_NewChannel
(
getter_AddRefs
(
chan
)
uri
mPrincipal
nsILoadInfo
:
:
SEC_NORMAL
mRequest
-
>
GetContext
(
)
mLoadGroup
nullptr
/
*
aCallbacks
*
/
nsIRequest
:
:
LOAD_NORMAL
ios
)
;
mLoadGroup
=
nullptr
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
return
rv
;
}
/
/
Step
3
.
1
"
If
the
CORS
preflight
flag
is
set
and
one
of
these
conditions
is
/
/
true
.
.
.
"
is
handled
by
the
CORS
proxy
.
/
/
/
/
Step
3
.
2
"
Set
request
'
s
skip
service
worker
flag
.
"
This
isn
'
t
required
/
/
since
Necko
will
fall
back
to
the
network
if
the
ServiceWorker
does
not
/
/
respond
with
a
valid
Response
.
/
/
/
/
NS_StartCORSPreflight
(
)
will
automatically
kick
off
the
original
request
/
/
if
it
succeeds
so
we
need
to
have
everything
setup
for
the
original
/
/
request
too
.
/
/
Step
3
.
3
"
Let
credentials
flag
be
set
if
either
request
'
s
credentials
mode
/
/
is
include
or
request
'
s
credentials
mode
is
same
-
origin
and
the
CORS
flag
/
/
is
unset
and
unset
otherwise
.
"
bool
useCredentials
=
false
;
if
(
mRequest
-
>
GetCredentialsMode
(
)
=
=
RequestCredentials
:
:
Include
|
|
(
mRequest
-
>
GetCredentialsMode
(
)
=
=
RequestCredentials
:
:
Same_origin
&
&
!
aCORSFlag
)
)
{
useCredentials
=
true
;
}
/
/
FIXME
(
nsm
)
:
Bug
1120715
.
/
/
Step
3
.
4
"
If
request
'
s
cache
mode
is
default
and
request
'
s
header
list
/
/
contains
a
header
named
If
-
Modified
-
Since
If
-
None
-
Match
/
/
If
-
Unmodified
-
Since
If
-
Match
or
If
-
Range
set
request
'
s
cache
mode
/
/
to
no
-
store
.
"
/
/
Step
3
.
5
begins
"
HTTP
network
or
cache
fetch
"
.
/
/
HTTP
network
or
cache
fetch
/
/
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
/
/
Step
1
"
Let
HTTPRequest
.
.
.
"
The
channel
is
the
HTTPRequest
.
nsCOMPtr
<
nsIHttpChannel
>
httpChan
=
do_QueryInterface
(
chan
)
;
if
(
httpChan
)
{
/
/
Copy
the
method
.
nsAutoCString
method
;
mRequest
-
>
GetMethod
(
method
)
;
rv
=
httpChan
-
>
SetRequestMethod
(
method
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
return
rv
;
}
/
/
Set
the
same
headers
.
nsAutoTArray
<
InternalHeaders
:
:
Entry
5
>
headers
;
mRequest
-
>
Headers
(
)
-
>
GetEntries
(
headers
)
;
for
(
uint32_t
i
=
0
;
i
<
headers
.
Length
(
)
;
+
+
i
)
{
httpChan
-
>
SetRequestHeader
(
headers
[
i
]
.
mName
headers
[
i
]
.
mValue
false
/
*
merge
*
/
)
;
}
/
/
Step
2
.
Set
the
referrer
.
This
is
handled
better
in
Bug
1112922
.
MOZ_ASSERT
(
mRequest
-
>
ReferrerIsURL
(
)
)
;
nsCString
referrer
=
mRequest
-
>
ReferrerAsURL
(
)
;
if
(
!
referrer
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
referrer
nullptr
nullptr
ios
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
FailWithNetworkError
(
)
;
}
rv
=
httpChan
-
>
SetReferrer
(
uri
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
FailWithNetworkError
(
)
;
}
}
/
/
Step
3
"
If
HTTPRequest
'
s
force
Origin
header
flag
is
set
.
.
.
"
if
(
mRequest
-
>
ForceOriginHeader
(
)
)
{
nsAutoString
origin
;
rv
=
nsContentUtils
:
:
GetUTFOrigin
(
mPrincipal
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
FailWithNetworkError
(
)
;
}
httpChan
-
>
SetRequestHeader
(
NS_LITERAL_CSTRING
(
"
origin
"
)
NS_ConvertUTF16toUTF8
(
origin
)
false
/
*
merge
*
/
)
;
}
/
/
Bug
1120722
-
Authorization
will
be
handled
later
.
/
/
Auth
may
require
prompting
we
don
'
t
support
it
yet
.
/
/
The
next
patch
in
this
same
bug
prevents
this
from
aborting
the
request
.
/
/
Credentials
checks
for
CORS
are
handled
by
nsCORSListenerProxy
}
/
/
Step
5
.
Proxy
authentication
will
be
handled
by
Necko
.
/
/
FIXME
(
nsm
)
:
Bug
1120715
.
/
/
Step
7
-
10
.
"
If
request
'
s
cache
mode
is
neither
no
-
store
nor
reload
.
.
.
"
/
/
Continue
setting
up
'
HTTPRequest
'
.
Content
-
Type
and
body
data
.
nsCOMPtr
<
nsIUploadChannel2
>
uploadChan
=
do_QueryInterface
(
chan
)
;
if
(
uploadChan
)
{
nsAutoCString
contentType
;
ErrorResult
result
;
mRequest
-
>
Headers
(
)
-
>
Get
(
NS_LITERAL_CSTRING
(
"
content
-
type
"
)
contentType
result
)
;
/
/
This
is
an
error
because
the
Request
constructor
explicitly
extracts
and
/
/
sets
a
content
-
type
per
spec
.
if
(
result
.
Failed
(
)
)
{
return
FailWithNetworkError
(
)
;
}
nsCOMPtr
<
nsIInputStream
>
bodyStream
;
mRequest
-
>
GetBody
(
getter_AddRefs
(
bodyStream
)
)
;
if
(
bodyStream
)
{
nsAutoCString
method
;
mRequest
-
>
GetMethod
(
method
)
;
rv
=
uploadChan
-
>
ExplicitSetUploadStream
(
bodyStream
contentType
-
1
method
false
/
*
aStreamHasHeaders
*
/
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
FailWithNetworkError
(
)
;
}
}
}
/
/
Set
up
a
CORS
proxy
that
will
handle
the
various
requirements
of
the
CORS
/
/
protocol
.
It
handles
the
preflight
cache
and
CORS
response
headers
.
/
/
If
the
request
is
allowed
it
will
start
our
original
request
/
/
and
our
observer
will
be
notified
.
On
failure
our
observer
is
notified
/
/
directly
.
nsRefPtr
<
nsCORSListenerProxy
>
corsListener
=
new
nsCORSListenerProxy
(
this
mPrincipal
useCredentials
)
;
rv
=
corsListener
-
>
Init
(
chan
true
/
*
allow
data
uri
*
/
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
FailWithNetworkError
(
)
;
}
/
/
If
preflight
is
required
start
a
"
CORS
preflight
fetch
"
/
/
https
:
/
/
fetch
.
spec
.
whatwg
.
org
/
#
cors
-
preflight
-
fetch
-
0
.
All
the
/
/
implementation
is
handled
by
NS_StartCORSPreflight
we
just
set
up
the
/
/
unsafeHeaders
so
they
can
be
verified
against
the
response
'
s
/
/
"
Access
-
Control
-
Allow
-
Headers
"
header
.
if
(
aCORSPreflightFlag
)
{
nsCOMPtr
<
nsIChannel
>
preflightChannel
;
nsAutoTArray
<
nsCString
5
>
unsafeHeaders
;
mRequest
-
>
Headers
(
)
-
>
GetUnsafeHeaders
(
unsafeHeaders
)
;
rv
=
NS_StartCORSPreflight
(
chan
corsListener
mPrincipal
useCredentials
unsafeHeaders
getter_AddRefs
(
preflightChannel
)
)
;
}
else
{
rv
=
chan
-
>
AsyncOpen
(
corsListener
nullptr
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
FailWithNetworkError
(
)
;
}
/
/
Step
4
onwards
of
"
HTTP
Fetch
"
is
handled
internally
by
Necko
.
return
NS_OK
;
}
nsresult
FetchDriver
:
:
ContinueHttpFetchAfterNetworkFetch
(
)
{
workers
:
:
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
mResponse
)
;
MOZ_ASSERT
(
!
mResponse
-
>
IsError
(
)
)
;
return
SucceedWithResponse
(
)
;
}
already_AddRefed
<
InternalResponse
>
FetchDriver
:
:
BeginAndGetFilteredResponse
(
InternalResponse
*
aResponse
)
{
MOZ_ASSERT
(
aResponse
)
;
nsAutoCString
reqURL
;
mRequest
-
>
GetURL
(
reqURL
)
;
aResponse
-
>
SetUrl
(
reqURL
)
;
/
/
FIXME
(
nsm
)
:
Handle
mixed
content
check
step
7
of
fetch
.
nsRefPtr
<
InternalResponse
>
filteredResponse
;
switch
(
mRequest
-
>
GetResponseTainting
(
)
)
{
case
InternalRequest
:
:
RESPONSETAINT_BASIC
:
filteredResponse
=
InternalResponse
:
:
BasicResponse
(
aResponse
)
;
break
;
case
InternalRequest
:
:
RESPONSETAINT_CORS
:
filteredResponse
=
InternalResponse
:
:
CORSResponse
(
aResponse
)
;
break
;
case
InternalRequest
:
:
RESPONSETAINT_OPAQUE
:
filteredResponse
=
InternalResponse
:
:
OpaqueResponse
(
)
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
case
"
)
;
}
MOZ_ASSERT
(
filteredResponse
)
;
MOZ_ASSERT
(
mObserver
)
;
mObserver
-
>
OnResponseAvailable
(
filteredResponse
)
;
mResponseAvailableCalled
=
true
;
return
filteredResponse
.
forget
(
)
;
}
void
FetchDriver
:
:
BeginResponse
(
InternalResponse
*
aResponse
)
{
nsRefPtr
<
InternalResponse
>
r
=
BeginAndGetFilteredResponse
(
aResponse
)
;
/
/
Release
the
ref
.
}
nsresult
FetchDriver
:
:
SucceedWithResponse
(
)
{
workers
:
:
AssertIsOnMainThread
(
)
;
if
(
mObserver
)
{
mObserver
-
>
OnResponseEnd
(
)
;
mObserver
=
nullptr
;
}
return
NS_OK
;
}
nsresult
FetchDriver
:
:
FailWithNetworkError
(
)
{
workers
:
:
AssertIsOnMainThread
(
)
;
nsRefPtr
<
InternalResponse
>
error
=
InternalResponse
:
:
NetworkError
(
)
;
if
(
mObserver
)
{
mObserver
-
>
OnResponseAvailable
(
error
)
;
mResponseAvailableCalled
=
true
;
mObserver
-
>
OnResponseEnd
(
)
;
mObserver
=
nullptr
;
}
return
NS_OK
;
}
namespace
{
class
FillResponseHeaders
MOZ_FINAL
:
public
nsIHttpHeaderVisitor
{
InternalResponse
*
mResponse
;
~
FillResponseHeaders
(
)
{
}
public
:
NS_DECL_ISUPPORTS
explicit
FillResponseHeaders
(
InternalResponse
*
aResponse
)
:
mResponse
(
aResponse
)
{
}
NS_IMETHOD
VisitHeader
(
const
nsACString
&
aHeader
const
nsACString
&
aValue
)
MOZ_OVERRIDE
{
ErrorResult
result
;
mResponse
-
>
Headers
(
)
-
>
Append
(
aHeader
aValue
result
)
;
return
result
.
ErrorCode
(
)
;
}
}
;
NS_IMPL_ISUPPORTS
(
FillResponseHeaders
nsIHttpHeaderVisitor
)
}
/
/
anonymous
namespace
NS_IMETHODIMP
FetchDriver
:
:
OnStartRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
)
{
workers
:
:
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
!
mPipeOutputStream
)
;
MOZ_ASSERT
(
mObserver
)
;
nsresult
rv
;
aRequest
-
>
GetStatus
(
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
return
rv
;
}
nsCOMPtr
<
nsIHttpChannel
>
channel
=
do_QueryInterface
(
aRequest
)
;
/
/
For
now
we
only
support
HTTP
.
MOZ_ASSERT
(
channel
)
;
aRequest
-
>
GetStatus
(
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
return
rv
;
}
uint32_t
responseStatus
;
channel
-
>
GetResponseStatus
(
&
responseStatus
)
;
nsAutoCString
statusText
;
channel
-
>
GetResponseStatusText
(
statusText
)
;
nsRefPtr
<
InternalResponse
>
response
=
new
InternalResponse
(
responseStatus
statusText
)
;
nsRefPtr
<
FillResponseHeaders
>
visitor
=
new
FillResponseHeaders
(
response
)
;
rv
=
channel
-
>
VisitResponseHeaders
(
visitor
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
Failed
to
visit
all
headers
.
"
)
;
}
mResponse
=
BeginAndGetFilteredResponse
(
response
)
;
/
/
We
open
a
pipe
so
that
we
can
immediately
set
the
pipe
'
s
read
end
as
the
/
/
response
'
s
body
.
Setting
the
segment
size
to
UINT32_MAX
means
that
the
/
/
pipe
has
infinite
space
.
The
nsIChannel
will
continue
to
buffer
data
in
/
/
xpcom
events
even
if
we
block
on
a
fixed
size
pipe
.
It
might
be
possible
/
/
to
suspend
the
channel
and
then
resume
when
there
is
space
available
but
/
/
for
now
use
an
infinite
pipe
to
avoid
blocking
.
nsCOMPtr
<
nsIInputStream
>
pipeInputStream
;
rv
=
NS_NewPipe
(
getter_AddRefs
(
pipeInputStream
)
getter_AddRefs
(
mPipeOutputStream
)
0
/
*
default
segment
size
*
/
UINT32_MAX
/
*
infinite
pipe
*
/
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
/
/
Cancel
request
.
return
rv
;
}
mResponse
-
>
SetBody
(
pipeInputStream
)
;
nsCOMPtr
<
nsIEventTarget
>
sts
=
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
/
/
Cancel
request
.
return
rv
;
}
/
/
Try
to
retarget
off
main
thread
.
nsCOMPtr
<
nsIThreadRetargetableRequest
>
rr
=
do_QueryInterface
(
aRequest
)
;
if
(
rr
)
{
rr
-
>
RetargetDeliveryTo
(
sts
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
FetchDriver
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aInputStream
uint64_t
aOffset
uint32_t
aCount
)
{
uint32_t
aRead
;
MOZ_ASSERT
(
mResponse
)
;
MOZ_ASSERT
(
mPipeOutputStream
)
;
nsresult
rv
=
aInputStream
-
>
ReadSegments
(
NS_CopySegmentToStream
mPipeOutputStream
aCount
&
aRead
)
;
return
rv
;
}
NS_IMETHODIMP
FetchDriver
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatusCode
)
{
workers
:
:
AssertIsOnMainThread
(
)
;
if
(
mPipeOutputStream
)
{
mPipeOutputStream
-
>
Close
(
)
;
}
if
(
NS_FAILED
(
aStatusCode
)
)
{
FailWithNetworkError
(
)
;
return
aStatusCode
;
}
ContinueHttpFetchAfterNetworkFetch
(
)
;
return
NS_OK
;
}
}
/
/
namespace
dom
}
/
/
namespace
mozilla
