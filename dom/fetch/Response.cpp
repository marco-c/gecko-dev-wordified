/
*
-
*
-
Mode
:
C
+
+
;
tab
-
width
:
2
;
indent
-
tabs
-
mode
:
nil
;
c
-
basic
-
offset
:
2
-
*
-
*
/
/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
#
include
"
Response
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
Headers
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
nsDOMString
.
h
"
#
include
"
InternalResponse
.
h
"
namespace
mozilla
{
namespace
dom
{
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
Response
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
Response
)
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
Response
mOwner
mHeaders
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
Response
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
Response
:
:
Response
(
nsIGlobalObject
*
aGlobal
InternalResponse
*
aInternalResponse
)
:
FetchBody
<
Response
>
(
)
mOwner
(
aGlobal
)
mInternalResponse
(
aInternalResponse
)
{
}
Response
:
:
~
Response
(
)
{
}
/
*
static
*
/
already_AddRefed
<
Response
>
Response
:
:
Error
(
const
GlobalObject
&
aGlobal
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
nsRefPtr
<
InternalResponse
>
error
=
InternalResponse
:
:
NetworkError
(
)
;
nsRefPtr
<
Response
>
r
=
new
Response
(
global
error
)
;
return
r
.
forget
(
)
;
}
/
*
static
*
/
already_AddRefed
<
Response
>
Response
:
:
Redirect
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aUrl
uint16_t
aStatus
)
{
ErrorResult
result
;
ResponseInit
init
;
Optional
<
ArrayBufferOrArrayBufferViewOrScalarValueStringOrURLSearchParams
>
body
;
nsRefPtr
<
Response
>
r
=
Response
:
:
Constructor
(
aGlobal
body
init
result
)
;
return
r
.
forget
(
)
;
}
/
*
static
*
/
already_AddRefed
<
Response
>
Response
:
:
Constructor
(
const
GlobalObject
&
aGlobal
const
Optional
<
ArrayBufferOrArrayBufferViewOrScalarValueStringOrURLSearchParams
>
&
aBody
const
ResponseInit
&
aInit
ErrorResult
&
aRv
)
{
if
(
aInit
.
mStatus
<
200
|
|
aInit
.
mStatus
>
599
)
{
aRv
.
Throw
(
NS_ERROR_RANGE_ERR
)
;
return
nullptr
;
}
nsCString
statusText
;
if
(
aInit
.
mStatusText
.
WasPassed
(
)
)
{
statusText
=
aInit
.
mStatusText
.
Value
(
)
;
nsACString
:
:
const_iterator
start
end
;
statusText
.
BeginReading
(
start
)
;
statusText
.
EndReading
(
end
)
;
if
(
FindCharInReadable
(
'
\
r
'
start
end
)
)
{
aRv
.
ThrowTypeError
(
MSG_RESPONSE_INVALID_STATUSTEXT_ERROR
)
;
return
nullptr
;
}
/
/
Reset
iterator
since
FindCharInReadable
advances
it
.
statusText
.
BeginReading
(
start
)
;
if
(
FindCharInReadable
(
'
\
n
'
start
end
)
)
{
aRv
.
ThrowTypeError
(
MSG_RESPONSE_INVALID_STATUSTEXT_ERROR
)
;
return
nullptr
;
}
}
else
{
/
/
Since
we
don
'
t
support
default
values
for
ByteString
.
statusText
=
NS_LITERAL_CSTRING
(
"
OK
"
)
;
}
nsRefPtr
<
InternalResponse
>
internalResponse
=
new
InternalResponse
(
aInit
.
mStatus
statusText
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
nsRefPtr
<
Response
>
r
=
new
Response
(
global
internalResponse
)
;
if
(
aInit
.
mHeaders
.
WasPassed
(
)
)
{
internalResponse
-
>
Headers
(
)
-
>
Clear
(
)
;
/
/
Instead
of
using
Fill
create
an
object
to
allow
the
constructor
to
/
/
unwrap
the
HeadersInit
.
nsRefPtr
<
Headers
>
headers
=
Headers
:
:
Constructor
(
aGlobal
aInit
.
mHeaders
.
Value
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
internalResponse
-
>
Headers
(
)
-
>
Fill
(
*
headers
-
>
GetInternalHeaders
(
)
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
}
if
(
aBody
.
WasPassed
(
)
)
{
nsCOMPtr
<
nsIInputStream
>
bodyStream
;
nsCString
contentType
;
aRv
=
ExtractByteStreamFromBody
(
aBody
.
Value
(
)
getter_AddRefs
(
bodyStream
)
contentType
)
;
internalResponse
-
>
SetBody
(
bodyStream
)
;
if
(
!
contentType
.
IsVoid
(
)
&
&
!
internalResponse
-
>
Headers
(
)
-
>
Has
(
NS_LITERAL_CSTRING
(
"
Content
-
Type
"
)
aRv
)
)
{
internalResponse
-
>
Headers
(
)
-
>
Append
(
NS_LITERAL_CSTRING
(
"
Content
-
Type
"
)
contentType
aRv
)
;
}
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
}
r
-
>
SetMimeType
(
aRv
)
;
return
r
.
forget
(
)
;
}
/
/
FIXME
(
nsm
)
:
Bug
1073231
:
This
is
currently
unspecced
!
already_AddRefed
<
Response
>
Response
:
:
Clone
(
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
mOwner
)
;
nsRefPtr
<
Response
>
response
=
new
Response
(
global
mInternalResponse
)
;
return
response
.
forget
(
)
;
}
void
Response
:
:
SetBody
(
nsIInputStream
*
aBody
)
{
/
/
FIXME
(
nsm
)
:
Do
we
flip
bodyUsed
here
?
mInternalResponse
-
>
SetBody
(
aBody
)
;
}
Headers
*
Response
:
:
Headers_
(
)
{
if
(
!
mHeaders
)
{
mHeaders
=
new
Headers
(
mOwner
mInternalResponse
-
>
Headers
(
)
)
;
}
return
mHeaders
;
}
}
/
/
namespace
dom
}
/
/
namespace
mozilla
