<
!
DOCTYPE
HTML
>
<
html
>
<
head
>
<
meta
charset
=
"
utf
-
8
"
>
<
script
type
=
"
application
/
javascript
"
src
=
"
mediaStreamPlayback
.
js
"
>
<
/
script
>
<
/
head
>
<
body
>
<
script
type
=
"
application
/
javascript
"
>
"
use
strict
"
;
createHTML
(
{
title
:
"
ondevicechange
tests
"
bug
:
"
1152383
"
}
)
;
async
function
resolveOnEvent
(
target
name
)
{
return
new
Promise
(
r
=
>
target
.
addEventListener
(
name
r
{
once
:
true
}
)
)
;
}
let
eventCount
=
0
;
async
function
triggerVideoDevicechange
(
)
{
+
+
eventCount
;
return
pushPrefs
(
[
"
media
.
getusermedia
.
fake
-
camera
-
name
"
devicechange
{
eventCount
}
]
)
}
/
/
Trigger
and
await
two
devicechanges
on
mediaDevices
to
wait
long
enough
to
/
/
provide
that
a
devicechange
on
another
MediaDevices
would
be
received
.
async
function
doVideoDevicechanges
(
mediaDevices
)
{
for
(
let
i
=
0
;
i
<
2
;
+
+
i
)
{
await
Promise
.
all
(
[
resolveOnEvent
(
mediaDevices
"
devicechange
"
)
triggerVideoDevicechange
(
)
]
)
;
}
}
runTest
(
async
(
)
=
>
{
/
/
A
toplevel
Window
and
an
iframe
Window
are
compared
for
devicechange
/
/
events
.
const
iframe
=
document
.
createElement
(
"
iframe
"
)
;
/
/
Workaround
for
bug
1743933
const
promiseIframeLoad
=
resolveOnEvent
(
iframe
"
load
"
)
;
document
.
documentElement
.
appendChild
(
iframe
)
;
await
Promise
.
all
(
[
promiseIframeLoad
pushPrefs
(
/
/
Use
the
fake
video
backend
to
trigger
devicechange
events
.
[
"
media
.
navigator
.
streams
.
fake
"
true
]
/
/
Loopback
would
override
fake
.
[
"
media
.
video_loopback_dev
"
"
"
]
/
/
Make
fake
devices
count
as
real
permission
-
wise
or
devicechange
/
/
events
won
'
t
be
exposed
[
"
media
.
navigator
.
permission
.
fake
"
true
]
/
/
For
gUM
.
[
"
media
.
navigator
.
permission
.
disabled
"
true
]
)
]
)
;
const
topDevices
=
navigator
.
mediaDevices
;
const
frameDevices
=
iframe
.
contentWindow
.
navigator
.
mediaDevices
;
/
/
Initialization
of
MediaDevices
:
:
mLastPhysicalDevices
is
triggered
when
/
/
ondevicechange
is
set
but
tests
"
media
.
getusermedia
.
fake
-
camera
-
name
"
/
/
asynchronously
.
Wait
for
getUserMedia
(
)
completion
to
ensure
that
the
/
/
pref
has
been
read
before
doDevicechanges
(
)
changes
it
.
frameDevices
.
ondevicechange
=
(
)
=
>
{
}
;
const
topEventPromise
=
resolveOnEvent
(
topDevices
"
devicechange
"
)
;
const
frameStream
=
await
frameDevices
.
getUserMedia
(
{
video
:
true
}
)
;
frameStream
.
getVideoTracks
(
)
[
0
]
.
stop
(
)
;
await
doVideoDevicechanges
(
frameDevices
)
;
ok
(
true
"
devicechange
event
is
fired
when
gUM
has
been
in
use
"
)
;
/
/
Race
a
settled
Promise
to
check
that
the
event
has
not
been
received
in
/
/
the
toplevel
Window
.
const
racer
=
{
}
;
is
(
await
Promise
.
race
(
[
topEventPromise
racer
]
)
racer
"
devicechange
event
is
NOT
fired
when
gUM
has
NOT
been
in
use
"
)
;
const
frameEventPromise1
=
resolveOnEvent
(
frameDevices
"
devicechange
"
)
;
while
(
true
)
{
const
racePromise
=
Promise
.
race
(
[
frameEventPromise1
/
/
100ms
is
half
the
coalescing
time
in
MediaManager
:
:
DeviceListChanged
(
)
.
wait
(
100
{
type
:
"
wait
done
"
}
)
]
)
;
await
triggerVideoDevicechange
(
)
;
if
(
(
await
racePromise
)
.
type
=
=
"
devicechange
"
)
{
ok
(
true
"
devicechange
event
is
fired
even
when
hardware
changes
continue
"
)
;
break
;
}
}
if
(
navigator
.
userAgent
.
includes
(
"
Android
"
)
)
{
todo
(
false
"
test
assumes
Firefox
-
for
-
Desktop
specific
API
and
behavior
"
)
;
return
;
}
/
/
Open
a
new
tab
which
is
expected
to
receive
focus
and
hide
the
first
tab
.
const
tab
=
window
.
open
(
)
;
SimpleTest
.
registerCleanupFunction
(
(
)
=
>
tab
.
close
(
)
)
;
await
Promise
.
all
(
[
resolveOnEvent
(
document
'
visibilitychange
'
)
resolveOnEvent
(
tab
'
focus
'
)
]
)
;
ok
(
tab
.
document
.
hasFocus
(
)
"
tab
.
document
.
hasFocus
(
)
"
)
;
await
Promise
.
all
(
[
resolveOnEvent
(
tab
'
blur
'
)
SpecialPowers
.
spawnChrome
(
[
]
function
focusUrlBar
(
)
{
this
.
browsingContext
.
topChromeWindow
.
gURLBar
.
focus
(
)
;
}
)
]
)
;
ok
(
!
tab
.
document
.
hasFocus
(
)
"
!
tab
.
document
.
hasFocus
(
)
"
)
;
is
(
document
.
visibilityState
'
hidden
'
'
visibilityState
'
)
const
frameEventPromise2
=
resolveOnEvent
(
frameDevices
"
devicechange
"
)
;
const
tabDevices
=
tab
.
navigator
.
mediaDevices
;
tabDevices
.
ondevicechange
=
(
)
=
>
{
}
;
const
tabStream
=
await
tabDevices
.
getUserMedia
(
{
video
:
true
}
)
;
await
doVideoDevicechanges
(
tabDevices
)
;
is
(
await
Promise
.
race
(
[
frameEventPromise2
racer
]
)
racer
"
devicechange
event
is
NOT
fired
while
tab
is
in
background
"
)
;
tab
.
close
(
)
;
await
resolveOnEvent
(
document
'
visibilitychange
'
)
;
is
(
document
.
visibilityState
'
visible
'
'
visibilityState
'
)
await
frameEventPromise2
;
ok
(
true
"
devicechange
event
IS
fired
when
tab
returns
to
foreground
"
)
;
const
audioLoopbackDev
=
SpecialPowers
.
getCharPref
(
"
media
.
audio_loopback_dev
"
"
"
)
;
if
(
!
navigator
.
userAgent
.
includes
(
"
Linux
"
)
)
{
todo_isnot
(
audioLoopbackDev
"
"
"
audio_loopback_dev
"
)
;
return
;
}
isnot
(
audioLoopbackDev
"
"
"
audio_loopback_dev
"
)
;
await
Promise
.
all
(
[
resolveOnEvent
(
topDevices
"
devicechange
"
)
pushPrefs
(
[
"
media
.
audio_loopback_dev
"
"
none
"
]
)
]
)
;
ok
(
true
"
devicechange
event
IS
fired
when
last
audio
device
is
removed
and
"
+
"
gUM
has
NOT
been
in
use
"
)
;
await
Promise
.
all
(
[
resolveOnEvent
(
topDevices
"
devicechange
"
)
pushPrefs
(
[
"
media
.
audio_loopback_dev
"
audioLoopbackDev
]
)
]
)
;
ok
(
true
"
devicechange
event
IS
fired
when
first
audio
device
is
added
and
"
+
"
gUM
has
NOT
been
in
use
"
)
;
}
)
;
<
/
script
>
<
/
body
>
<
/
html
>
