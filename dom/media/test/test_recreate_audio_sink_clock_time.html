<
!
DOCTYPE
HTML
>
<
html
>
<
head
>
<
title
>
consistent
growing
clock
time
after
switching
to
new
audio
sink
<
/
title
>
<
script
src
=
"
/
tests
/
SimpleTest
/
SimpleTest
.
js
"
>
<
/
script
>
<
script
src
=
"
manifest
.
js
"
>
<
/
script
>
<
link
rel
=
"
stylesheet
"
type
=
"
text
/
css
"
href
=
"
/
tests
/
SimpleTest
/
test
.
css
"
/
>
<
/
head
>
<
body
>
<
script
class
=
"
testbody
"
type
=
"
text
/
javascript
"
>
/
*
*
*
This
test
is
used
to
ensure
that
when
recreating
another
audio
sink
the
old
*
sink
should
inherit
the
clock
time
from
the
previous
sink
in
order
to
make
*
the
clock
time
consistently
growing
.
*
/
add_task
(
async
function
setTestPref
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
media
.
testing
-
only
-
events
"
true
]
]
}
)
;
}
)
;
add_task
(
async
function
testConsistentGrowingClockTimeBetweenSinks
(
)
{
const
kExpectedLoopingTimes
=
3
;
const
audio
=
await
createPlayingAndAudibleLoopingAudio
(
)
;
await
waitAtLeastFinishLoopingOnce
(
audio
{
times
:
kExpectedLoopingTimes
}
)
;
info
(
suspend
then
resume
the
media
element
which
would
result
in
creating
a
new
audio
sink
)
;
let
waitingSinkPromise
=
Promise
.
all
(
[
once
(
audio
"
mozsuspendedmediasink
"
)
once
(
audio
"
mozresumedmediasink
"
)
]
)
;
let
gapCounter
=
0
;
audio
.
addEventListener
(
"
mozaudiosinkaudiogapdetected
"
_
=
>
{
/
/
When
we
switch
to
the
new
sink
it
'
s
possible
to
have
one
small
gap
/
/
because
the
previous
clock
time
would
not
always
match
the
first
sample
.
/
/
But
we
shouldn
'
t
have
other
gaps
if
we
keep
playing
in
the
same
sink
.
if
(
+
+
gapCounter
>
1
)
{
ok
(
false
gap
{
gapCounter
}
:
too
many
gaps
in
this
audio
!
)
;
}
}
)
;
SpecialPowers
.
wrap
(
audio
)
.
setSuspend
(
true
)
;
SpecialPowers
.
wrap
(
audio
)
.
setSuspend
(
false
)
;
await
waitingSinkPromise
;
/
/
Wait
a
while
to
see
if
we
receive
any
gap
events
.
await
expectToReceiveEvent
(
audio
"
timeupdate
"
{
times
:
5
}
)
;
}
)
;
/
*
*
*
Follwing
are
helper
functions
.
*
/
async
function
createPlayingAndAudibleLoopingAudio
(
)
{
const
audio
=
document
.
createElement
(
'
audio
'
)
;
audio
.
src
=
"
small
-
shot
.
ogg
"
;
audio
.
loop
=
true
;
document
.
body
.
appendChild
(
audio
)
;
info
(
wait
for
audio
starting
playing
and
becoming
audible
.
)
;
await
Promise
.
all
(
[
expectToReceiveEvent
(
audio
"
mozaudiblestatechanged
"
{
times
:
1
}
)
audio
.
play
(
)
]
)
;
return
audio
;
}
function
waitAtLeastFinishLoopingOnce
(
element
{
times
}
)
{
info
(
wait
until
audio
finishes
looping
at
least
once
)
;
return
expectToReceiveEvent
(
element
"
seeked
"
{
times
}
)
;
}
function
expectToReceiveEvent
(
element
event
{
times
}
)
{
return
new
Promise
(
r
=
>
{
let
receivedTimes
=
0
;
element
.
addEventListener
(
event
_
=
>
{
if
(
+
+
receivedTimes
=
=
times
)
{
ok
(
true
received
{
event
}
{
times
}
times
.
)
;
r
(
)
;
}
}
)
;
}
)
;
}
<
/
script
>
<
/
body
>
<
/
html
>
