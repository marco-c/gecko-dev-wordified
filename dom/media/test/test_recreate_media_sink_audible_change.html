<
!
DOCTYPE
HTML
>
<
html
>
<
head
>
<
title
>
Test
media
sink
and
media
'
s
audible
state
<
/
title
>
<
script
src
=
"
/
tests
/
SimpleTest
/
SimpleTest
.
js
"
>
<
/
script
>
<
script
src
=
"
manifest
.
js
"
>
<
/
script
>
<
link
rel
=
"
stylesheet
"
type
=
"
text
/
css
"
href
=
"
/
tests
/
SimpleTest
/
test
.
css
"
/
>
<
/
head
>
<
body
>
<
script
class
=
"
testbody
"
type
=
"
text
/
javascript
"
>
/
*
*
*
This
test
is
used
to
ensure
that
when
shutdown
and
recreate
the
media
sink
*
the
media
element
'
s
audible
state
should
reflect
the
audio
sink
'
s
status
.
*
Eg
.
when
shutdown
the
sink
the
audible
state
would
become
inaudible
because
*
we
have
no
sink
at
that
moment
.
After
recreating
the
sink
the
audible
state
*
should
become
audible
again
when
the
sink
starts
playing
audible
.
*
/
add_task
(
async
function
setTestPref
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
media
.
testing
-
only
-
events
"
true
]
[
"
media
.
setsinkid
.
enabled
"
true
]
/
/
For
using
navigator
.
mediaDevices
.
enumerateDevices
(
)
[
"
media
.
devices
.
insecure
.
enabled
"
true
]
]
}
)
;
}
)
;
add_task
(
async
function
testRecreateMediaSinkWhenChangeSinkId
(
)
{
const
kExpectedLoopingTimes
=
10
;
const
audio
=
await
createPlayingAndAudibleLoopingAudio
(
)
;
await
waitAtLeastFinishLoopingOnce
(
audio
{
times
:
kExpectedLoopingTimes
}
)
;
info
(
set
sink
id
in
order
to
recreate
the
media
sink
)
;
const
allDevices
=
await
navigator
.
mediaDevices
.
enumerateDevices
(
)
;
const
audioDevices
=
allDevices
.
filter
(
(
{
kind
}
)
=
>
kind
=
=
'
audiooutput
'
)
;
info
(
found
{
audioDevices
.
length
}
output
devices
)
;
ok
(
audioDevices
.
length
>
0
"
More
than
one
output
device
found
"
)
;
/
/
This
part
is
a
little
unintuitive
which
simulates
the
situation
where
the
/
/
issue
happened
that
should
not
happen
again
after
fixing
bug
1693250
.
/
/
Let
'
s
say
we
have
an
audio
which
duration
is
10s
and
has
looped
5
times
/
/
so
the
current
sink
'
s
clock
time
is
larger
than
50s
.
If
we
switch
to
a
new
/
/
sink
the
sink
'
s
clock
time
would
start
from
0
and
then
will
keep
playing
/
/
silence
in
next
5
times
of
looping
until
the
new
sink
'
s
clock
time
catches
/
/
up
with
the
old
sink
.
So
if
the
issue
is
already
fixed
audio
should
become
/
/
audible
immediately
because
we
keep
the
clock
time
consistent
between
sinks
/
/
instead
of
restarting
time
from
0
.
info
(
audio
should
become
audible
before
reaching
the
expected
looping
times
)
;
let
loopTimes
=
0
;
audio
.
onseeked
=
_
=
>
loopTimes
+
+
;
await
Promise
.
all
(
[
expectToReceiveEvent
(
audio
"
mozaudiblestatechanged
"
{
times
:
2
}
)
audio
.
setSinkId
(
audioDevices
[
0
]
.
deviceId
)
]
)
;
ok
(
loopTimes
<
kExpectedLoopingTimes
Become
audible
in
{
loopTimes
}
times
of
looping
)
;
}
)
;
/
*
*
*
Follwing
are
helper
functions
.
*
/
async
function
createPlayingAndAudibleLoopingAudio
(
)
{
const
audio
=
document
.
createElement
(
'
audio
'
)
;
audio
.
src
=
"
small
-
shot
.
ogg
"
;
audio
.
loop
=
true
;
document
.
body
.
appendChild
(
audio
)
;
info
(
wait
for
audio
starting
playing
and
becoming
audible
.
)
;
await
Promise
.
all
(
[
expectToReceiveEvent
(
audio
"
mozaudiblestatechanged
"
{
times
:
1
}
)
audio
.
play
(
)
]
)
;
return
audio
;
}
function
waitAtLeastFinishLoopingOnce
(
element
{
times
}
)
{
info
(
wait
until
audio
finishes
looping
at
least
once
)
;
return
expectToReceiveEvent
(
element
"
seeked
"
{
times
}
)
;
}
function
expectToReceiveEvent
(
element
event
{
times
}
)
{
return
new
Promise
(
r
=
>
{
let
receivedTimes
=
0
;
element
.
addEventListener
(
event
_
=
>
{
if
(
+
+
receivedTimes
=
=
times
)
{
ok
(
true
received
{
event
}
{
times
}
times
.
)
;
r
(
)
;
}
}
)
;
}
)
;
}
<
/
script
>
<
/
body
>
<
/
html
>
