<
!
DOCTYPE
HTML
>
<
html
>
<
head
>
<
title
>
Test
media
'
s
audible
state
should
change
when
changing
audio
sink
<
/
title
>
<
script
src
=
"
/
tests
/
SimpleTest
/
SimpleTest
.
js
"
>
<
/
script
>
<
script
src
=
"
manifest
.
js
"
>
<
/
script
>
<
link
rel
=
"
stylesheet
"
type
=
"
text
/
css
"
href
=
"
/
tests
/
SimpleTest
/
test
.
css
"
/
>
<
/
head
>
<
body
>
<
script
class
=
"
testbody
"
type
=
"
text
/
javascript
"
>
/
*
*
*
This
test
is
used
to
ensure
that
when
shutdown
and
recreate
the
audio
sink
*
the
media
element
'
s
audible
state
should
reflect
the
audio
sink
'
s
status
.
*
Eg
.
when
shutdown
the
sink
the
audible
state
would
become
inaudible
because
*
we
have
no
sink
at
that
moment
.
After
recreating
the
sink
the
audible
state
*
should
become
audible
again
when
the
sink
starts
playing
audible
.
*
/
add_task
(
async
function
setTestPref
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
media
.
testing
-
only
-
events
"
true
]
[
"
media
.
setsinkid
.
enabled
"
true
]
/
/
Disable
the
prompt
in
order
to
expose
audio
output
[
"
media
.
navigator
.
permission
.
disabled
"
true
]
]
}
)
;
}
)
;
add_task
(
async
function
testRecreateAudioSinkWhenChangeAudioSink
(
)
{
const
audio
=
await
createPlayingAndAudibleLoopingAudio
(
)
;
/
/
Expose
an
audio
output
device
.
SpecialPowers
.
wrap
(
document
)
.
notifyUserGestureActivation
(
)
;
await
navigator
.
mediaDevices
.
selectAudioOutput
(
)
;
info
(
set
sink
id
in
order
to
recreate
the
audio
sink
)
;
let
{
deviceId
}
=
await
navigator
.
mediaDevices
.
selectAudioOutput
(
)
.
catch
(
e
=
>
ok
(
false
failed
to
get
device
Id
)
)
;
info
(
audible
state
should
be
reset
first
when
the
old
sink
is
shut
down
)
;
await
Promise
.
all
(
[
/
/
Become
inaudible
first
then
audible
expectToReceiveEvent
(
audio
"
mozaudiblestatechanged
"
{
times
:
2
}
)
audio
.
setSinkId
(
deviceId
)
]
)
;
ok
(
true
new
sink
should
become
audible
again
)
;
}
)
;
/
*
*
*
Follwing
are
helper
functions
.
*
/
async
function
createPlayingAndAudibleLoopingAudio
(
)
{
const
audio
=
document
.
createElement
(
'
audio
'
)
;
audio
.
src
=
"
small
-
shot
.
ogg
"
;
audio
.
loop
=
true
;
document
.
body
.
appendChild
(
audio
)
;
info
(
wait
for
audio
starting
playing
and
becoming
audible
.
)
;
await
Promise
.
all
(
[
expectToReceiveEvent
(
audio
"
mozaudiblestatechanged
"
{
times
:
1
}
)
audio
.
play
(
)
]
)
;
return
audio
;
}
function
expectToReceiveEvent
(
element
event
{
times
}
)
{
return
new
Promise
(
r
=
>
{
let
receivedTimes
=
0
;
element
.
addEventListener
(
event
_
=
>
{
if
(
+
+
receivedTimes
=
=
times
)
{
ok
(
true
received
{
event
}
{
times
}
times
.
)
;
r
(
)
;
}
}
)
;
}
)
;
}
<
/
script
>
<
/
body
>
<
/
html
>
