/
*
-
*
-
Mode
:
C
+
+
;
tab
-
width
:
2
;
indent
-
tabs
-
mode
:
nil
;
c
-
basic
-
offset
:
2
-
*
-
*
/
/
*
vim
:
set
ts
=
2
sw
=
2
sts
=
2
et
cindent
:
*
/
/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
#
include
"
FFmpegAudioDecoder
.
h
"
#
include
"
FFmpegLog
.
h
"
#
include
"
TimeUnits
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
BufferReader
.
h
"
#
if
defined
(
FFVPX_VERSION
)
#
include
"
libavutil
/
channel_layout
.
h
"
#
endif
#
include
"
mozilla
/
StaticPrefs_media
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
namespace
mozilla
{
using
TimeUnit
=
media
:
:
TimeUnit
;
FFmpegAudioDecoder
<
LIBAV_VER
>
:
:
FFmpegAudioDecoder
(
FFmpegLibWrapper
*
aLib
const
AudioInfo
&
aInfo
)
:
FFmpegDataDecoder
(
aLib
GetCodecId
(
aInfo
.
mMimeType
aInfo
)
)
mAudioInfo
(
aInfo
)
{
MOZ_COUNT_CTOR
(
FFmpegAudioDecoder
)
;
if
(
mCodecID
=
=
AV_CODEC_ID_AAC
&
&
aInfo
.
mCodecSpecificConfig
.
is
<
AacCodecSpecificData
>
(
)
)
{
const
AacCodecSpecificData
&
aacCodecSpecificData
=
aInfo
.
mCodecSpecificConfig
.
as
<
AacCodecSpecificData
>
(
)
;
mExtraData
=
new
MediaByteBuffer
;
/
/
Ffmpeg
expects
the
DecoderConfigDescriptor
blob
.
mExtraData
-
>
AppendElements
(
*
aacCodecSpecificData
.
mDecoderConfigDescriptorBinaryBlob
)
;
FFMPEG_LOG
(
"
FFmpegAudioDecoder
ctor
(
aac
)
"
)
;
return
;
}
if
(
mCodecID
=
=
AV_CODEC_ID_MP3
)
{
/
/
Nothing
to
do
return
;
}
if
(
mCodecID
=
=
AV_CODEC_ID_FLAC
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aInfo
.
mCodecSpecificConfig
.
is
<
FlacCodecSpecificData
>
(
)
)
;
/
/
Gracefully
handle
bad
data
.
If
don
'
t
hit
the
preceding
assert
once
this
/
/
has
been
shipped
for
awhile
we
can
remove
it
and
make
the
following
code
/
/
non
-
conditional
.
if
(
aInfo
.
mCodecSpecificConfig
.
is
<
FlacCodecSpecificData
>
(
)
)
{
const
FlacCodecSpecificData
&
flacCodecSpecificData
=
aInfo
.
mCodecSpecificConfig
.
as
<
FlacCodecSpecificData
>
(
)
;
if
(
flacCodecSpecificData
.
mStreamInfoBinaryBlob
-
>
IsEmpty
(
)
)
{
/
/
Flac
files
without
headers
will
be
missing
stream
info
.
In
this
case
/
/
we
don
'
t
want
to
feed
ffmpeg
empty
extra
data
as
it
will
fail
just
/
/
early
return
.
return
;
}
/
/
Use
a
new
MediaByteBuffer
as
the
object
will
be
modified
during
/
/
initialization
.
mExtraData
=
new
MediaByteBuffer
;
mExtraData
-
>
AppendElements
(
*
flacCodecSpecificData
.
mStreamInfoBinaryBlob
)
;
return
;
}
}
/
/
Vorbis
is
handled
by
this
case
.
RefPtr
<
MediaByteBuffer
>
audioCodecSpecificBinaryBlob
=
GetAudioCodecSpecificBlob
(
aInfo
.
mCodecSpecificConfig
)
;
if
(
audioCodecSpecificBinaryBlob
&
&
audioCodecSpecificBinaryBlob
-
>
Length
(
)
)
{
/
/
Use
a
new
MediaByteBuffer
as
the
object
will
be
modified
during
/
/
initialization
.
mExtraData
=
new
MediaByteBuffer
;
mExtraData
-
>
AppendElements
(
*
audioCodecSpecificBinaryBlob
)
;
}
}
RefPtr
<
MediaDataDecoder
:
:
InitPromise
>
FFmpegAudioDecoder
<
LIBAV_VER
>
:
:
Init
(
)
{
MediaResult
rv
=
InitDecoder
(
)
;
return
NS_SUCCEEDED
(
rv
)
?
InitPromise
:
:
CreateAndResolve
(
TrackInfo
:
:
kAudioTrack
__func__
)
:
InitPromise
:
:
CreateAndReject
(
rv
__func__
)
;
}
void
FFmpegAudioDecoder
<
LIBAV_VER
>
:
:
InitCodecContext
(
)
{
MOZ_ASSERT
(
mCodecContext
)
;
/
/
We
do
not
want
to
set
this
value
to
0
as
FFmpeg
by
default
will
/
/
use
the
number
of
cores
which
with
our
mozlibavutil
get_cpu_count
/
/
isn
'
t
implemented
.
mCodecContext
-
>
thread_count
=
1
;
/
/
FFmpeg
takes
this
as
a
suggestion
for
what
format
to
use
for
audio
samples
.
/
/
LibAV
0
.
8
produces
rubbish
float
interleaved
samples
request
16
bits
/
/
audio
.
mCodecContext
-
>
request_sample_fmt
=
(
mLib
-
>
mVersion
=
=
53
)
?
AV_SAMPLE_FMT_S16
:
AV_SAMPLE_FMT_FLT
;
#
ifdef
FFVPX_VERSION
/
/
AudioInfo
'
s
layout
first
32
-
bits
are
bit
-
per
-
bit
compatible
with
/
/
WAVEFORMATEXTENSIBLE
and
FFmpeg
'
s
AVChannel
enum
.
We
can
cast
here
.
mCodecContext
-
>
ch_layout
.
nb_channels
=
AssertedCast
<
int
>
(
mAudioInfo
.
mChannels
)
;
if
(
mAudioInfo
.
mChannelMap
!
=
AudioConfig
:
:
ChannelLayout
:
:
UNKNOWN_MAP
)
{
mLib
-
>
av_channel_layout_from_mask
(
&
mCodecContext
-
>
ch_layout
AssertedCast
<
uint64_t
>
(
mAudioInfo
.
mChannelMap
)
)
;
}
else
{
mLib
-
>
av_channel_layout_default
(
&
mCodecContext
-
>
ch_layout
AssertedCast
<
int
>
(
mAudioInfo
.
mChannels
)
)
;
}
mCodecContext
-
>
sample_rate
=
AssertedCast
<
int
>
(
mAudioInfo
.
mRate
)
;
#
endif
#
ifdef
FFVPX_VERSION
/
/
AudioInfo
'
s
layout
first
32
-
bits
are
bit
-
per
-
bit
compatible
with
/
/
WAVEFORMATEXTENSIBLE
and
FFmpeg
'
s
AVChannel
enum
.
We
can
cast
here
.
mCodecContext
-
>
ch_layout
.
nb_channels
=
AssertedCast
<
int
>
(
mAudioInfo
.
mChannels
)
;
if
(
mAudioInfo
.
mChannelMap
!
=
AudioConfig
:
:
ChannelLayout
:
:
UNKNOWN_MAP
)
{
mLib
-
>
av_channel_layout_from_mask
(
&
mCodecContext
-
>
ch_layout
static_cast
<
uint64_t
>
(
mAudioInfo
.
mChannelMap
)
)
;
}
else
{
mLib
-
>
av_channel_layout_default
(
&
mCodecContext
-
>
ch_layout
AssertedCast
<
int
>
(
mAudioInfo
.
mChannels
)
)
;
}
mCodecContext
-
>
sample_rate
=
AssertedCast
<
int
>
(
mAudioInfo
.
mRate
)
;
#
endif
}
static
AlignedAudioBuffer
CopyAndPackAudio
(
AVFrame
*
aFrame
uint32_t
aNumChannels
uint32_t
aNumAFrames
)
{
AlignedAudioBuffer
audio
(
aNumChannels
*
aNumAFrames
)
;
if
(
!
audio
)
{
return
audio
;
}
#
ifdef
MOZ_SAMPLE_TYPE_S16
if
(
aFrame
-
>
format
=
=
AV_SAMPLE_FMT_FLT
)
{
/
/
Audio
data
already
packed
.
Need
to
convert
from
32
bits
Float
to
S16
AudioDataValue
*
tmp
=
audio
.
get
(
)
;
float
*
data
=
reinterpret_cast
<
float
*
*
>
(
aFrame
-
>
data
)
[
0
]
;
for
(
uint32_t
frame
=
0
;
frame
<
aNumAFrames
;
frame
+
+
)
{
for
(
uint32_t
channel
=
0
;
channel
<
aNumChannels
;
channel
+
+
)
{
*
tmp
+
+
=
FloatToAudioSample
<
int16_t
>
(
*
data
+
+
)
;
}
}
}
else
if
(
aFrame
-
>
format
=
=
AV_SAMPLE_FMT_FLTP
)
{
/
/
Planar
audio
data
.
Convert
it
from
32
bits
float
to
S16
/
/
and
pack
it
into
something
we
can
understand
.
AudioDataValue
*
tmp
=
audio
.
get
(
)
;
float
*
*
data
=
reinterpret_cast
<
float
*
*
>
(
aFrame
-
>
data
)
;
for
(
uint32_t
frame
=
0
;
frame
<
aNumAFrames
;
frame
+
+
)
{
for
(
uint32_t
channel
=
0
;
channel
<
aNumChannels
;
channel
+
+
)
{
*
tmp
+
+
=
FloatToAudioSample
<
int16_t
>
(
data
[
channel
]
[
frame
]
)
;
}
}
}
else
if
(
aFrame
-
>
format
=
=
AV_SAMPLE_FMT_S16
)
{
/
/
Audio
data
already
packed
.
No
need
to
do
anything
other
than
copy
it
/
/
into
a
buffer
we
own
.
memcpy
(
audio
.
get
(
)
aFrame
-
>
data
[
0
]
aNumChannels
*
aNumAFrames
*
sizeof
(
AudioDataValue
)
)
;
}
else
if
(
aFrame
-
>
format
=
=
AV_SAMPLE_FMT_S16P
)
{
/
/
Planar
audio
data
.
Pack
it
into
something
we
can
understand
.
AudioDataValue
*
tmp
=
audio
.
get
(
)
;
AudioDataValue
*
*
data
=
reinterpret_cast
<
AudioDataValue
*
*
>
(
aFrame
-
>
data
)
;
for
(
uint32_t
frame
=
0
;
frame
<
aNumAFrames
;
frame
+
+
)
{
for
(
uint32_t
channel
=
0
;
channel
<
aNumChannels
;
channel
+
+
)
{
*
tmp
+
+
=
data
[
channel
]
[
frame
]
;
}
}
}
else
if
(
aFrame
-
>
format
=
=
AV_SAMPLE_FMT_S32
)
{
/
/
Audio
data
already
packed
.
Need
to
convert
from
S32
to
S16
AudioDataValue
*
tmp
=
audio
.
get
(
)
;
int32_t
*
data
=
reinterpret_cast
<
int32_t
*
*
>
(
aFrame
-
>
data
)
[
0
]
;
for
(
uint32_t
frame
=
0
;
frame
<
aNumAFrames
;
frame
+
+
)
{
for
(
uint32_t
channel
=
0
;
channel
<
aNumChannels
;
channel
+
+
)
{
*
tmp
+
+
=
*
data
+
+
/
(
1U
<
<
16
)
;
}
}
}
else
if
(
aFrame
-
>
format
=
=
AV_SAMPLE_FMT_S32P
)
{
/
/
Planar
audio
data
.
Convert
it
from
S32
to
S16
/
/
and
pack
it
into
something
we
can
understand
.
AudioDataValue
*
tmp
=
audio
.
get
(
)
;
int32_t
*
*
data
=
reinterpret_cast
<
int32_t
*
*
>
(
aFrame
-
>
data
)
;
for
(
uint32_t
frame
=
0
;
frame
<
aNumAFrames
;
frame
+
+
)
{
for
(
uint32_t
channel
=
0
;
channel
<
aNumChannels
;
channel
+
+
)
{
*
tmp
+
+
=
data
[
channel
]
[
frame
]
/
(
1U
<
<
16
)
;
}
}
}
#
else
if
(
aFrame
-
>
format
=
=
AV_SAMPLE_FMT_FLT
)
{
/
/
Audio
data
already
packed
.
No
need
to
do
anything
other
than
copy
it
/
/
into
a
buffer
we
own
.
memcpy
(
audio
.
get
(
)
aFrame
-
>
data
[
0
]
aNumChannels
*
aNumAFrames
*
sizeof
(
AudioDataValue
)
)
;
}
else
if
(
aFrame
-
>
format
=
=
AV_SAMPLE_FMT_FLTP
)
{
/
/
Planar
audio
data
.
Pack
it
into
something
we
can
understand
.
AudioDataValue
*
tmp
=
audio
.
get
(
)
;
AudioDataValue
*
*
data
=
reinterpret_cast
<
AudioDataValue
*
*
>
(
aFrame
-
>
data
)
;
for
(
uint32_t
frame
=
0
;
frame
<
aNumAFrames
;
frame
+
+
)
{
for
(
uint32_t
channel
=
0
;
channel
<
aNumChannels
;
channel
+
+
)
{
*
tmp
+
+
=
data
[
channel
]
[
frame
]
;
}
}
}
else
if
(
aFrame
-
>
format
=
=
AV_SAMPLE_FMT_S16
)
{
/
/
Audio
data
already
packed
.
Need
to
convert
from
S16
to
32
bits
Float
AudioDataValue
*
tmp
=
audio
.
get
(
)
;
int16_t
*
data
=
reinterpret_cast
<
int16_t
*
*
>
(
aFrame
-
>
data
)
[
0
]
;
for
(
uint32_t
frame
=
0
;
frame
<
aNumAFrames
;
frame
+
+
)
{
for
(
uint32_t
channel
=
0
;
channel
<
aNumChannels
;
channel
+
+
)
{
*
tmp
+
+
=
AudioSampleToFloat
(
*
data
+
+
)
;
}
}
}
else
if
(
aFrame
-
>
format
=
=
AV_SAMPLE_FMT_S16P
)
{
/
/
Planar
audio
data
.
Convert
it
from
S16
to
32
bits
float
/
/
and
pack
it
into
something
we
can
understand
.
AudioDataValue
*
tmp
=
audio
.
get
(
)
;
int16_t
*
*
data
=
reinterpret_cast
<
int16_t
*
*
>
(
aFrame
-
>
data
)
;
for
(
uint32_t
frame
=
0
;
frame
<
aNumAFrames
;
frame
+
+
)
{
for
(
uint32_t
channel
=
0
;
channel
<
aNumChannels
;
channel
+
+
)
{
*
tmp
+
+
=
AudioSampleToFloat
(
data
[
channel
]
[
frame
]
)
;
}
}
}
else
if
(
aFrame
-
>
format
=
=
AV_SAMPLE_FMT_S32
)
{
/
/
Audio
data
already
packed
.
Need
to
convert
from
S16
to
32
bits
Float
AudioDataValue
*
tmp
=
audio
.
get
(
)
;
int32_t
*
data
=
reinterpret_cast
<
int32_t
*
*
>
(
aFrame
-
>
data
)
[
0
]
;
for
(
uint32_t
frame
=
0
;
frame
<
aNumAFrames
;
frame
+
+
)
{
for
(
uint32_t
channel
=
0
;
channel
<
aNumChannels
;
channel
+
+
)
{
*
tmp
+
+
=
AudioSampleToFloat
(
*
data
+
+
)
;
}
}
}
else
if
(
aFrame
-
>
format
=
=
AV_SAMPLE_FMT_S32P
)
{
/
/
Planar
audio
data
.
Convert
it
from
S32
to
32
bits
float
/
/
and
pack
it
into
something
we
can
understand
.
AudioDataValue
*
tmp
=
audio
.
get
(
)
;
int32_t
*
*
data
=
reinterpret_cast
<
int32_t
*
*
>
(
aFrame
-
>
data
)
;
for
(
uint32_t
frame
=
0
;
frame
<
aNumAFrames
;
frame
+
+
)
{
for
(
uint32_t
channel
=
0
;
channel
<
aNumChannels
;
channel
+
+
)
{
*
tmp
+
+
=
AudioSampleToFloat
(
data
[
channel
]
[
frame
]
)
;
}
}
}
#
endif
return
audio
;
}
using
ChannelLayout
=
AudioConfig
:
:
ChannelLayout
;
MediaResult
FFmpegAudioDecoder
<
LIBAV_VER
>
:
:
PostProcessOutput
(
bool
aDecoded
MediaRawData
*
aSample
DecodedData
&
aResults
bool
*
aGotFrame
size_t
aSamplePositionOffset
)
{
int64_t
samplePosition
=
AssertedCast
<
int64_t
>
(
aSample
-
>
mOffset
+
aSamplePositionOffset
)
;
media
:
:
TimeUnit
pts
=
aSample
-
>
mTime
;
if
(
mFrame
-
>
format
!
=
AV_SAMPLE_FMT_FLT
&
&
mFrame
-
>
format
!
=
AV_SAMPLE_FMT_FLTP
&
&
mFrame
-
>
format
!
=
AV_SAMPLE_FMT_S16
&
&
mFrame
-
>
format
!
=
AV_SAMPLE_FMT_S16P
&
&
mFrame
-
>
format
!
=
AV_SAMPLE_FMT_S32
&
&
mFrame
-
>
format
!
=
AV_SAMPLE_FMT_S32P
)
{
return
MediaResult
(
NS_ERROR_DOM_MEDIA_DECODE_ERR
RESULT_DETAIL
(
"
FFmpeg
audio
decoder
outputs
unsupported
audio
format
"
)
)
;
}
FFMPEG_LOG
(
"
FFmpegAudioDecoder
decoded
:
%
zu
bytes
[
%
s
%
s
]
(
Duration
:
%
s
)
[
%
s
]
"
aSamplePositionOffset
aSample
-
>
mTime
.
ToString
(
)
.
get
(
)
aSample
-
>
GetEndTime
(
)
.
ToString
(
)
.
get
(
)
aSample
-
>
mDuration
.
ToString
(
)
.
get
(
)
mLib
-
>
av_get_sample_fmt_name
(
mFrame
-
>
format
)
)
;
uint32_t
numChannels
=
mCodecContext
-
>
channels
;
uint32_t
samplingRate
=
mCodecContext
-
>
sample_rate
;
AlignedAudioBuffer
audio
=
CopyAndPackAudio
(
mFrame
numChannels
mFrame
-
>
nb_samples
)
;
if
(
!
audio
)
{
FFMPEG_LOG
(
"
CopyAndPackAudio
error
(
OOM
)
"
)
;
return
MediaResult
(
NS_ERROR_OUT_OF_MEMORY
__func__
)
;
}
media
:
:
TimeUnit
duration
=
TimeUnit
(
mFrame
-
>
nb_samples
samplingRate
)
;
if
(
!
duration
.
IsValid
(
)
)
{
FFMPEG_LOG
(
"
Duration
isn
'
t
valid
(
%
d
+
%
d
)
"
mFrame
-
>
nb_samples
samplingRate
)
;
return
MediaResult
(
NS_ERROR_DOM_MEDIA_OVERFLOW_ERR
RESULT_DETAIL
(
"
Invalid
sample
duration
"
)
)
;
}
media
:
:
TimeUnit
newpts
=
pts
+
duration
;
if
(
!
newpts
.
IsValid
(
)
)
{
FFMPEG_LOG
(
"
New
pts
isn
'
t
valid
(
%
lf
+
%
lf
)
"
pts
.
ToSeconds
(
)
duration
.
ToSeconds
(
)
)
;
return
MediaResult
(
NS_ERROR_DOM_MEDIA_OVERFLOW_ERR
RESULT_DETAIL
(
"
Invalid
count
of
accumulated
audio
samples
"
)
)
;
}
RefPtr
<
AudioData
>
data
=
new
AudioData
(
samplePosition
pts
std
:
:
move
(
audio
)
numChannels
samplingRate
mCodecContext
-
>
channel_layout
)
;
MOZ_ASSERT
(
duration
=
=
data
-
>
mDuration
"
must
be
equal
"
)
;
aResults
.
AppendElement
(
std
:
:
move
(
data
)
)
;
pts
=
newpts
;
if
(
aGotFrame
)
{
*
aGotFrame
=
true
;
}
return
NS_OK
;
}
#
if
LIBAVCODEC_VERSION_MAJOR
<
59
MediaResult
FFmpegAudioDecoder
<
LIBAV_VER
>
:
:
DecodeUsingFFmpeg
(
AVPacket
*
aPacket
int
&
aOutBytesConsumed
bool
&
aDecoded
MediaRawData
*
aSample
DecodedData
&
aResults
bool
*
aGotFrame
)
{
int
decoded
=
0
;
int
rv
=
mLib
-
>
avcodec_decode_audio4
(
mCodecContext
mFrame
&
decoded
aPacket
)
;
aDecoded
=
decoded
=
=
1
;
if
(
rv
<
0
)
{
NS_WARNING
(
"
FFmpeg
audio
decoder
error
.
"
)
;
return
MediaResult
(
NS_ERROR_DOM_MEDIA_DECODE_ERR
RESULT_DETAIL
(
"
FFmpeg
audio
error
:
%
d
"
aOutBytesConsumed
)
)
;
}
PostProcessOutput
(
decoded
aSample
aResults
aGotFrame
aOutBytesConsumed
)
;
aOutBytesConsumed
+
=
rv
;
return
NS_OK
;
}
#
else
#
define
AVRESULT_OK
0
MediaResult
FFmpegAudioDecoder
<
LIBAV_VER
>
:
:
DecodeUsingFFmpeg
(
AVPacket
*
aPacket
int
&
aOutBytesConsumed
bool
&
aDecoded
MediaRawData
*
aSample
DecodedData
&
aResults
bool
*
aGotFrame
)
{
int
ret
=
mLib
-
>
avcodec_send_packet
(
mCodecContext
aPacket
)
;
int
consumed
=
0
;
switch
(
ret
)
{
case
AVRESULT_OK
:
consumed
=
aPacket
-
>
size
;
break
;
case
AVERROR
(
EAGAIN
)
:
FFMPEG_LOG
(
"
av_codec_send_packet
:
EAGAIN
.
"
)
;
break
;
case
AVERROR_EOF
:
FFMPEG_LOG
(
"
End
of
stream
.
"
)
;
return
MediaResult
(
NS_ERROR_DOM_MEDIA_END_OF_STREAM
RESULT_DETAIL
(
"
End
of
stream
"
)
)
;
default
:
NS_WARNING
(
"
FFmpeg
audio
decoder
error
(
avcodec_send_packet
)
.
"
)
;
return
MediaResult
(
NS_ERROR_DOM_MEDIA_DECODE_ERR
RESULT_DETAIL
(
"
FFmpeg
audio
error
"
)
)
;
}
while
(
ret
>
=
0
)
{
ret
=
mLib
-
>
avcodec_receive_frame
(
mCodecContext
mFrame
)
;
switch
(
ret
)
{
case
AVRESULT_OK
:
aDecoded
=
true
;
aOutBytesConsumed
+
=
consumed
;
break
;
case
AVERROR
(
EAGAIN
)
:
aOutBytesConsumed
+
=
consumed
;
FFMPEG_LOG
(
"
EAGAIN
.
"
)
;
break
;
case
AVERROR_EOF
:
{
FFMPEG_LOG
(
"
End
of
stream
.
"
)
;
aOutBytesConsumed
+
=
consumed
;
return
MediaResult
(
NS_ERROR_DOM_MEDIA_END_OF_STREAM
RESULT_DETAIL
(
"
End
of
stream
"
)
)
;
default
:
FFMPEG_LOG
(
"
avcodec_receive_packet
error
.
"
)
;
NS_WARNING
(
"
FFmpeg
audio
decoder
error
(
avcodec_receive_packet
)
.
"
)
;
return
MediaResult
(
NS_ERROR_DOM_MEDIA_DECODE_ERR
RESULT_DETAIL
(
"
FFmpeg
audio
error
"
)
)
;
}
}
if
(
aDecoded
)
{
PostProcessOutput
(
aDecoded
aSample
aResults
aGotFrame
aOutBytesConsumed
)
;
}
}
return
NS_OK
;
}
#
endif
MediaResult
FFmpegAudioDecoder
<
LIBAV_VER
>
:
:
DoDecode
(
MediaRawData
*
aSample
uint8_t
*
aData
int
aSize
bool
*
aGotFrame
DecodedData
&
aResults
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
PROCESS_DECODE_LOG
(
aSample
)
;
AVPacket
packet
;
mLib
-
>
av_init_packet
(
&
packet
)
;
FFMPEG_LOG
(
"
FFmpegAudioDecoder
:
:
DoDecode
:
%
d
bytes
[
%
s
%
s
]
(
Duration
:
%
s
)
"
aSize
aSample
-
>
mTime
.
ToString
(
)
.
get
(
)
aSample
-
>
GetEndTime
(
)
.
ToString
(
)
.
get
(
)
aSample
-
>
mDuration
.
ToString
(
)
.
get
(
)
)
;
packet
.
data
=
const_cast
<
uint8_t
*
>
(
aData
)
;
packet
.
size
=
aSize
;
if
(
aGotFrame
)
{
*
aGotFrame
=
false
;
}
if
(
!
PrepareFrame
(
)
)
{
FFMPEG_LOG
(
"
FFmpegAudioDecoder
:
OOM
in
PrepareFrame
"
)
;
return
MediaResult
(
NS_ERROR_OUT_OF_MEMORY
RESULT_DETAIL
(
"
FFmpeg
audio
decoder
failed
to
allocate
frame
"
)
)
;
}
while
(
packet
.
size
>
0
)
{
bool
decoded
=
false
;
int
bytesConsumed
=
0
;
auto
rv
=
DecodeUsingFFmpeg
(
&
packet
bytesConsumed
decoded
aSample
aResults
aGotFrame
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
/
/
If
the
packet
wasn
'
t
sent
to
ffmpeg
another
attempt
will
happen
next
/
/
iteration
.
packet
.
data
+
=
bytesConsumed
;
packet
.
size
-
=
bytesConsumed
;
}
return
NS_OK
;
}
AVCodecID
FFmpegAudioDecoder
<
LIBAV_VER
>
:
:
GetCodecId
(
const
nsACString
&
aMimeType
const
AudioInfo
&
aInfo
)
{
if
(
aMimeType
.
EqualsLiteral
(
"
audio
/
mpeg
"
)
)
{
#
ifdef
FFVPX_VERSION
if
(
!
StaticPrefs
:
:
media_ffvpx_mp3_enabled
(
)
)
{
return
AV_CODEC_ID_NONE
;
}
#
endif
return
AV_CODEC_ID_MP3
;
}
if
(
aMimeType
.
EqualsLiteral
(
"
audio
/
flac
"
)
)
{
return
AV_CODEC_ID_FLAC
;
}
if
(
aMimeType
.
EqualsLiteral
(
"
audio
/
mp4a
-
latm
"
)
)
{
return
AV_CODEC_ID_AAC
;
}
if
(
aMimeType
.
EqualsLiteral
(
"
audio
/
vorbis
"
)
)
{
#
ifdef
FFVPX_VERSION
if
(
!
StaticPrefs
:
:
media_ffvpx_vorbis_enabled
(
)
)
{
return
AV_CODEC_ID_NONE
;
}
#
endif
return
AV_CODEC_ID_VORBIS
;
}
return
AV_CODEC_ID_NONE
;
}
nsCString
FFmpegAudioDecoder
<
LIBAV_VER
>
:
:
GetCodecName
(
)
const
{
#
if
LIBAVCODEC_VERSION_MAJOR
>
53
return
nsCString
(
mLib
-
>
avcodec_descriptor_get
(
mCodecID
)
-
>
name
)
;
#
else
return
"
unknown
"
_ns
;
#
endif
}
FFmpegAudioDecoder
<
LIBAV_VER
>
:
:
~
FFmpegAudioDecoder
(
)
{
MOZ_COUNT_DTOR
(
FFmpegAudioDecoder
)
;
}
}
/
/
namespace
mozilla
