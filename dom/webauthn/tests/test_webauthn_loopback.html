<
!
DOCTYPE
html
>
<
meta
charset
=
utf
-
8
>
<
head
>
<
title
>
Full
-
run
test
for
MakeCredential
/
GetAssertion
for
W3C
Web
Authentication
<
/
title
>
<
script
type
=
"
text
/
javascript
"
src
=
"
/
tests
/
SimpleTest
/
SimpleTest
.
js
"
>
<
/
script
>
<
script
type
=
"
text
/
javascript
"
src
=
"
u2futil
.
js
"
>
<
/
script
>
<
script
type
=
"
text
/
javascript
"
src
=
"
pkijs
/
common
.
js
"
>
<
/
script
>
<
script
type
=
"
text
/
javascript
"
src
=
"
pkijs
/
asn1
.
js
"
>
<
/
script
>
<
script
type
=
"
text
/
javascript
"
src
=
"
pkijs
/
x509_schema
.
js
"
>
<
/
script
>
<
script
type
=
"
text
/
javascript
"
src
=
"
pkijs
/
x509_simpl
.
js
"
>
<
/
script
>
<
link
rel
=
"
stylesheet
"
type
=
"
text
/
css
"
href
=
"
/
tests
/
SimpleTest
/
test
.
css
"
/
>
<
/
head
>
<
body
>
<
h1
>
Full
-
run
test
for
MakeCredential
/
GetAssertion
for
W3C
Web
Authentication
<
/
h1
>
<
a
target
=
"
_blank
"
href
=
"
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
1309284
"
>
Mozilla
Bug
1309284
<
/
a
>
<
script
class
=
"
testbody
"
type
=
"
text
/
javascript
"
>
"
use
strict
"
;
/
/
Execute
the
full
-
scope
test
SimpleTest
.
waitForExplicitFinish
(
)
;
SpecialPowers
.
pushPrefEnv
(
{
"
set
"
:
[
[
"
security
.
webauth
.
webauthn
"
true
]
[
"
security
.
webauth
.
webauthn_enable_softtoken
"
true
]
[
"
security
.
webauth
.
webauthn_enable_usbtoken
"
false
]
]
}
function
(
)
{
isnot
(
navigator
.
authentication
undefined
"
WebAuthn
API
endpoint
must
exist
"
)
;
isnot
(
navigator
.
authentication
.
makeCredential
undefined
"
WebAuthn
makeCredential
API
endpoint
must
exist
"
)
;
isnot
(
navigator
.
authentication
.
getAssertion
undefined
"
WebAuthn
getAssertion
API
endpoint
must
exist
"
)
;
let
authn
=
navigator
.
authentication
;
let
gCredentialChallenge
=
new
Uint8Array
(
16
)
;
window
.
crypto
.
getRandomValues
(
gCredentialChallenge
)
;
let
gAssertionChallenge
=
new
Uint8Array
(
16
)
;
window
.
crypto
.
getRandomValues
(
gAssertionChallenge
)
;
testMakeCredential
(
)
;
function
checkCredentialValid
(
aCredInfo
)
{
/
*
PublicKeyCredential
:
Credential
-
rawId
:
Key
Handle
buffer
pulled
from
U2F
Register
(
)
Response
-
response
:
AuthenticatorAttestationResponse
:
AuthenticatorResponse
-
attestationObject
:
RP
ID
Hash
|
|
U2F
Sign
(
)
Response
-
clientDataJSON
:
serialized
JSON
-
clientExtensionResults
:
(
not
yet
supported
)
*
/
ok
(
aCredInfo
.
rawId
.
length
>
0
"
Key
ID
exists
"
)
;
is
(
aCredInfo
.
response
.
attestationObject
[
0
]
0x05
"
Reserved
byte
is
correct
"
)
;
let
clientData
=
JSON
.
parse
(
buffer2string
(
aCredInfo
.
response
.
clientDataJSON
)
)
;
is
(
clientData
.
challenge
bytesToBase64UrlSafe
(
gCredentialChallenge
)
"
Challenge
is
correct
"
)
;
is
(
clientData
.
origin
window
.
location
.
origin
"
Origin
is
correct
"
)
;
is
(
clientData
.
hashAlg
"
S256
"
"
Hash
algorithm
is
correct
"
)
;
return
decodeU2FRegistration
(
aCredInfo
.
response
.
attestationObject
)
.
then
(
function
(
u2fObj
)
{
aCredInfo
.
u2fReg
=
u2fObj
;
return
aCredInfo
;
}
)
;
}
function
checkAssertionAndSigValid
(
aPublicKey
aAssertion
)
{
/
*
PublicKeyCredential
:
Credential
-
rawId
:
ID
of
Credential
from
AllowList
that
succeeded
-
response
:
AuthenticatorAssertionResponse
:
AuthenticatorResponse
-
clientDataJSON
:
serialized
JSON
-
authenticatorData
:
RP
ID
Hash
|
|
U2F
Sign
(
)
Response
-
signature
:
U2F
Sign
(
)
Response
*
/
ok
(
aAssertion
.
rawId
.
length
>
0
"
Key
ID
exists
"
)
;
ok
(
aAssertion
.
response
.
authenticatorData
.
length
>
0
"
Authenticator
data
exists
"
)
;
let
clientData
=
JSON
.
parse
(
buffer2string
(
aAssertion
.
response
.
clientDataJSON
)
)
;
is
(
clientData
.
challenge
bytesToBase64UrlSafe
(
gAssertionChallenge
)
"
Challenge
is
correct
"
)
;
is
(
clientData
.
origin
window
.
location
.
origin
"
Origin
is
correct
"
)
;
is
(
clientData
.
hashAlg
"
S256
"
"
Hash
algorithm
is
correct
"
)
;
/
/
Parse
the
signature
data
if
(
aAssertion
.
response
.
signature
[
0
]
!
=
0x01
)
{
throw
"
User
presence
byte
not
set
"
;
}
let
presenceAndCounter
=
aAssertion
.
response
.
signature
.
slice
(
0
5
)
;
let
signatureValue
=
aAssertion
.
response
.
signature
.
slice
(
5
)
;
let
rpIdHash
=
aAssertion
.
response
.
authenticatorData
.
slice
(
0
32
)
;
/
/
Assemble
the
signed
data
and
verify
the
signature
return
deriveAppAndChallengeParam
(
clientData
.
origin
aAssertion
.
response
.
clientDataJSON
)
.
then
(
function
(
aParams
)
{
console
.
log
(
aParams
.
appParam
rpIdHash
presenceAndCounter
aParams
.
challengeParam
)
;
console
.
log
(
"
ClientData
buffer
:
"
hexEncode
(
aAssertion
.
response
.
clientDataJSON
)
)
;
console
.
log
(
"
ClientDataHash
:
"
hexEncode
(
aParams
.
challengeParam
)
)
;
return
assembleSignedData
(
aParams
.
appParam
presenceAndCounter
aParams
.
challengeParam
)
;
}
)
.
then
(
function
(
aSignedData
)
{
console
.
log
(
aPublicKey
aSignedData
signatureValue
)
;
return
verifySignature
(
aPublicKey
aSignedData
signatureValue
)
;
}
)
}
function
testMakeCredential
(
)
{
let
acct
=
{
rpDisplayName
:
"
none
"
displayName
:
"
none
"
id
:
"
none
"
}
;
let
param
=
{
type
:
"
ScopedCred
"
algorithm
:
"
p
-
256
"
}
;
authn
.
makeCredential
(
acct
[
param
]
gCredentialChallenge
)
.
then
(
checkCredentialValid
)
.
then
(
testMakeDuplicate
)
.
catch
(
function
(
aReason
)
{
ok
(
false
aReason
)
;
SimpleTest
.
finish
(
)
;
}
)
;
}
function
testMakeDuplicate
(
aCredInfo
)
{
let
acct
=
{
rpDisplayName
:
"
none
"
displayName
:
"
none
"
id
:
"
none
"
}
;
let
param
=
{
type
:
"
ScopedCred
"
algorithm
:
"
p
-
256
"
}
;
let
options
=
{
rpId
:
document
.
origin
excludeList
:
[
{
type
:
"
ScopedCred
"
id
:
Uint8Array
.
from
(
aCredInfo
.
rawId
)
transports
:
[
"
usb
"
]
}
]
}
;
authn
.
makeCredential
(
acct
[
param
]
gCredentialChallenge
options
)
.
then
(
function
(
)
{
/
/
We
should
have
errored
here
!
ok
(
false
"
The
excludeList
didn
'
t
stop
a
duplicate
being
created
!
"
)
;
SimpleTest
.
finish
(
)
;
}
)
.
catch
(
function
(
aReason
)
{
ok
(
aReason
.
toString
(
)
.
startsWith
(
"
NotAllowedError
"
)
"
Expect
NotAllowedError
got
"
+
aReason
)
;
testAssertion
(
aCredInfo
)
;
}
)
;
}
function
testAssertion
(
aCredInfo
)
{
let
newCredential
=
{
type
:
"
ScopedCred
"
id
:
Uint8Array
.
from
(
aCredInfo
.
rawId
)
transports
:
[
"
usb
"
]
}
let
assertOptions
=
{
rpId
:
document
.
origin
timeoutSeconds
:
5
allowList
:
[
newCredential
]
}
;
authn
.
getAssertion
(
gAssertionChallenge
assertOptions
)
.
then
(
function
(
aAssertion
)
{
/
*
Pass
along
the
pubKey
.
*
/
return
checkAssertionAndSigValid
(
aCredInfo
.
u2fReg
.
publicKey
aAssertion
)
;
}
)
.
then
(
function
(
aSigVerifyResult
)
{
ok
(
aSigVerifyResult
"
Signing
signature
verified
"
)
;
SimpleTest
.
finish
(
)
;
}
)
.
catch
(
function
(
reason
)
{
ok
(
false
"
Signing
signature
invalid
:
"
+
reason
)
;
SimpleTest
.
finish
(
)
;
}
)
;
}
}
)
;
<
/
script
>
<
/
body
>
<
/
html
>
