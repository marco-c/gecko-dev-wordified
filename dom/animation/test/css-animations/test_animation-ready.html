<
!
doctype
html
>
<
meta
charset
=
utf
-
8
>
<
script
src
=
"
/
resources
/
testharness
.
js
"
>
<
/
script
>
<
script
src
=
"
/
resources
/
testharnessreport
.
js
"
>
<
/
script
>
<
script
src
=
"
.
.
/
testcommon
.
js
"
>
<
/
script
>
<
style
>
keyframes
abc
{
to
{
transform
:
translate
(
10px
)
}
}
<
/
style
>
<
body
>
<
div
id
=
"
log
"
>
<
/
div
>
<
script
>
'
use
strict
'
;
promise_test
(
async
t
=
>
{
const
div
=
addDiv
(
t
)
;
div
.
style
.
animation
=
'
abc
100s
paused
'
;
const
animation
=
div
.
getAnimations
(
)
[
0
]
;
const
originalReadyPromise
=
animation
.
ready
;
await
animation
.
ready
;
div
.
style
.
animationPlayState
=
'
running
'
;
assert_not_equals
(
animation
.
ready
originalReadyPromise
'
After
updating
animation
-
play
-
state
a
new
ready
promise
'
+
'
object
is
created
'
)
;
}
'
A
new
ready
promise
is
created
when
setting
animation
-
play
-
state
:
running
'
)
;
promise_test
(
async
t
=
>
{
const
div
=
addDiv
(
t
)
;
/
/
Set
up
pending
animation
div
.
style
.
animation
=
'
abc
100s
'
;
const
animation
=
div
.
getAnimations
(
)
[
0
]
;
assert_true
(
animation
.
pending
'
Animation
is
initially
pending
'
)
;
const
readyPromise
=
animation
.
ready
;
/
/
Cancel
the
animation
and
flush
styles
div
.
style
.
animation
=
'
'
;
getComputedStyle
(
div
)
.
animation
;
try
{
await
readyPromise
;
assert_unreached
(
'
ready
promise
is
fulfilled
'
)
;
}
catch
(
err
)
{
assert_equals
(
err
.
name
'
AbortError
'
'
ready
promise
is
rejected
with
AbortError
'
)
;
}
}
'
ready
promise
is
rejected
when
an
animation
is
canceled
by
resetting
'
+
'
the
animation
property
'
)
;
promise_test
(
async
t
=
>
{
const
div
=
addDiv
(
t
)
;
/
/
As
before
but
this
time
instead
of
removing
all
animations
simply
update
/
/
the
list
of
animations
.
At
least
for
Firefox
updating
is
a
different
/
/
code
path
.
/
/
Set
up
pending
animation
div
.
style
.
animation
=
'
abc
100s
'
;
const
animation
=
div
.
getAnimations
(
)
[
0
]
;
assert_true
(
animation
.
pending
'
Animation
is
initially
pending
'
)
;
const
readyPromise
=
animation
.
ready
;
/
/
Update
the
animation
and
flush
styles
div
.
style
.
animation
=
'
def
100s
'
;
getComputedStyle
(
div
)
.
animation
;
try
{
await
readyPromise
;
assert_unreached
(
'
ready
promise
is
fulfilled
'
)
;
}
catch
(
err
)
{
assert_equals
(
err
.
name
'
AbortError
'
'
ready
promise
is
rejected
with
AbortError
'
)
;
}
}
'
ready
promise
is
rejected
when
an
animation
is
cancelled
by
updating
'
+
'
the
animation
property
'
)
;
promise_test
(
async
t
=
>
{
const
div
=
addDiv
(
t
{
style
:
'
animation
:
abc
100s
'
}
)
;
const
animation
=
div
.
getAnimations
(
)
[
0
]
;
const
originalReadyPromise
=
animation
.
ready
;
await
animation
.
ready
;
div
.
style
.
animationPlayState
=
'
paused
'
;
assert_not_equals
(
animation
.
ready
originalReadyPromise
'
A
new
Promise
object
is
generated
when
setting
'
+
'
animation
-
play
-
state
:
paused
'
)
;
}
'
A
new
ready
promise
is
created
when
setting
animation
-
play
-
state
:
paused
'
)
;
promise_test
(
async
t
=
>
{
const
div
=
addDiv
(
t
{
style
:
'
animation
:
abc
100s
'
}
)
;
const
animation
=
div
.
getAnimations
(
)
[
0
]
;
await
animation
.
ready
;
div
.
style
.
animationPlayState
=
'
paused
'
;
const
firstReadyPromise
=
animation
.
ready
;
animation
.
pause
(
)
;
assert_equals
(
animation
.
ready
firstReadyPromise
'
Ready
promise
objects
are
identical
after
redundant
pause
'
)
;
}
'
Pausing
twice
re
-
uses
the
same
Promise
'
)
;
promise_test
(
async
t
=
>
{
const
div
=
addDiv
(
t
{
style
:
'
animation
:
abc
100s
'
}
)
;
const
animation
=
div
.
getAnimations
(
)
[
0
]
;
await
animation
.
ready
;
div
.
style
.
animationPlayState
=
'
paused
'
;
/
/
Flush
style
and
verify
we
'
re
pending
at
the
same
time
assert_true
(
animation
.
pending
'
Animation
is
pending
'
)
;
const
pauseReadyPromise
=
animation
.
ready
;
/
/
Now
play
again
immediately
div
.
style
.
animationPlayState
=
'
running
'
;
assert_true
(
animation
.
pending
'
Animation
is
still
pending
'
)
;
assert_equals
(
animation
.
ready
pauseReadyPromise
'
The
pause
Promise
is
re
-
used
when
playing
while
waiting
'
+
'
to
pause
'
)
;
await
animation
.
ready
;
assert_true
(
!
animation
.
pending
&
&
animation
.
playState
=
=
=
'
running
'
'
Animation
is
running
after
aborting
a
pause
'
)
;
}
'
If
a
pause
operation
is
interrupted
the
ready
promise
is
reused
'
)
;
promise_test
(
async
t
=
>
{
const
div
=
addDiv
(
t
{
style
:
'
animation
:
abc
100s
'
}
)
;
const
animation
=
div
.
getAnimations
(
)
[
0
]
;
await
animation
.
ready
;
div
.
style
.
animationPlayState
=
'
paused
'
;
const
resolvedAnimation
=
await
animation
.
ready
;
assert_equals
(
resolvedAnimation
animation
'
Promise
received
when
ready
Promise
for
a
pause
operation
'
+
'
is
completed
is
the
animation
on
which
the
pause
was
'
+
'
performed
'
)
;
}
'
When
a
pause
is
complete
the
Promise
callback
gets
the
correct
animation
'
)
;
<
/
script
>
<
/
body
>
