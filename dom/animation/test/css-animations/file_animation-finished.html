<
!
doctype
html
>
<
meta
charset
=
utf
-
8
>
<
script
src
=
"
.
.
/
testcommon
.
js
"
>
<
/
script
>
<
style
>
keyframes
abc
{
to
{
transform
:
translate
(
10px
)
}
}
keyframes
def
{
}
<
/
style
>
<
body
>
<
script
>
'
use
strict
'
;
const
ANIM_PROP_VAL
=
'
abc
100s
'
;
const
ANIM_DURATION
=
100
*
MS_PER_SEC
;
promise_test
(
function
(
t
)
{
var
div
=
addDiv
(
t
)
;
div
.
style
.
animation
=
ANIM_PROP_VAL
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
var
previousFinishedPromise
=
animation
.
finished
;
return
animation
.
ready
.
then
(
function
(
)
{
assert_equals
(
animation
.
finished
previousFinishedPromise
'
Finished
promise
is
the
same
object
when
playing
starts
'
)
;
animation
.
pause
(
)
;
assert_equals
(
animation
.
finished
previousFinishedPromise
'
Finished
promise
does
not
change
when
pausing
'
)
;
animation
.
play
(
)
;
assert_equals
(
animation
.
finished
previousFinishedPromise
'
Finished
promise
does
not
change
when
play
(
)
unpauses
'
)
;
animation
.
currentTime
=
ANIM_DURATION
;
return
animation
.
finished
;
}
)
.
then
(
function
(
)
{
assert_equals
(
animation
.
finished
previousFinishedPromise
'
Finished
promise
is
the
same
object
when
playing
completes
'
)
;
}
)
;
}
'
Test
pausing
then
playing
does
not
change
the
finished
promise
'
)
;
promise_test
(
function
(
t
)
{
var
div
=
addDiv
(
t
)
;
div
.
style
.
animation
=
ANIM_PROP_VAL
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
var
previousFinishedPromise
=
animation
.
finished
;
animation
.
finish
(
)
;
return
animation
.
finished
.
then
(
function
(
)
{
assert_equals
(
animation
.
finished
previousFinishedPromise
'
Finished
promise
is
the
same
object
when
playing
completes
'
)
;
animation
.
play
(
)
;
assert_not_equals
(
animation
.
finished
previousFinishedPromise
'
Finished
promise
changes
when
replaying
animation
'
)
;
previousFinishedPromise
=
animation
.
finished
;
animation
.
play
(
)
;
assert_equals
(
animation
.
finished
previousFinishedPromise
'
Finished
promise
is
the
same
after
redundant
play
(
)
call
'
)
;
}
)
;
}
'
Test
restarting
a
finished
animation
'
)
;
promise_test
(
function
(
t
)
{
var
div
=
addDiv
(
t
)
;
div
.
style
.
animation
=
ANIM_PROP_VAL
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
var
previousFinishedPromise
;
animation
.
finish
(
)
;
return
animation
.
finished
.
then
(
function
(
)
{
previousFinishedPromise
=
animation
.
finished
;
animation
.
playbackRate
=
-
1
;
assert_not_equals
(
animation
.
finished
previousFinishedPromise
'
Finished
promise
should
be
replaced
when
reversing
a
'
+
'
finished
promise
'
)
;
animation
.
currentTime
=
0
;
return
animation
.
finished
;
}
)
.
then
(
function
(
)
{
previousFinishedPromise
=
animation
.
finished
;
animation
.
play
(
)
;
assert_not_equals
(
animation
.
finished
previousFinishedPromise
'
Finished
promise
is
replaced
after
play
(
)
call
on
'
+
'
finished
reversed
animation
'
)
;
}
)
;
}
'
Test
restarting
a
reversed
finished
animation
'
)
;
promise_test
(
function
(
t
)
{
var
div
=
addDiv
(
t
)
;
div
.
style
.
animation
=
ANIM_PROP_VAL
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
var
previousFinishedPromise
=
animation
.
finished
;
animation
.
finish
(
)
;
return
animation
.
finished
.
then
(
function
(
)
{
animation
.
currentTime
=
ANIM_DURATION
+
1000
;
assert_equals
(
animation
.
finished
previousFinishedPromise
'
Finished
promise
is
unchanged
jumping
past
end
of
'
+
'
finished
animation
'
)
;
}
)
;
}
'
Test
redundant
finishing
of
animation
'
)
;
promise_test
(
function
(
t
)
{
var
div
=
addDiv
(
t
)
;
div
.
style
.
animation
=
ANIM_PROP_VAL
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
/
/
Setup
callback
to
run
if
finished
promise
is
resolved
var
finishPromiseResolved
=
false
;
animation
.
finished
.
then
(
function
(
)
{
finishPromiseResolved
=
true
;
}
)
;
return
animation
.
ready
.
then
(
function
(
)
{
/
/
Jump
to
mid
-
way
in
interval
and
pause
animation
.
currentTime
=
ANIM_DURATION
/
2
;
animation
.
pause
(
)
;
return
animation
.
ready
;
}
)
.
then
(
function
(
)
{
/
/
Jump
to
the
end
/
/
(
But
don
'
t
use
finish
(
)
since
that
should
unpause
as
well
)
animation
.
currentTime
=
ANIM_DURATION
;
return
waitForAnimationFrames
(
2
)
;
}
)
.
then
(
function
(
)
{
assert_false
(
finishPromiseResolved
'
Finished
promise
should
not
resolve
when
paused
'
)
;
}
)
;
}
'
Finished
promise
does
not
resolve
when
paused
'
)
;
promise_test
(
function
(
t
)
{
var
div
=
addDiv
(
t
)
;
div
.
style
.
animation
=
ANIM_PROP_VAL
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
/
/
Setup
callback
to
run
if
finished
promise
is
resolved
var
finishPromiseResolved
=
false
;
animation
.
finished
.
then
(
function
(
)
{
finishPromiseResolved
=
true
;
}
)
;
return
animation
.
ready
.
then
(
function
(
)
{
/
/
Jump
to
mid
-
way
in
interval
and
pause
animation
.
currentTime
=
ANIM_DURATION
/
2
;
animation
.
pause
(
)
;
/
/
Jump
to
the
end
animation
.
currentTime
=
ANIM_DURATION
;
return
waitForAnimationFrames
(
2
)
;
}
)
.
then
(
function
(
)
{
assert_false
(
finishPromiseResolved
'
Finished
promise
should
not
resolve
when
pause
-
pending
'
)
;
}
)
;
}
'
Finished
promise
does
not
resolve
when
pause
-
pending
'
)
;
promise_test
(
function
(
t
)
{
var
div
=
addDiv
(
t
)
;
div
.
style
.
animation
=
ANIM_PROP_VAL
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
animation
.
currentTime
=
ANIM_DURATION
;
return
animation
.
finished
.
then
(
function
(
resolvedAnimation
)
{
assert_equals
(
resolvedAnimation
animation
'
Object
identity
of
animation
passed
to
Promise
callback
'
+
'
matches
the
animation
object
owning
the
Promise
'
)
;
}
)
;
}
'
The
finished
promise
is
fulfilled
with
its
Animation
'
)
;
promise_test
(
function
(
t
)
{
var
div
=
addDiv
(
t
)
;
/
/
Set
up
pending
animation
div
.
style
.
animation
=
ANIM_PROP_VAL
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
var
previousFinishedPromise
=
animation
.
finished
;
/
/
Set
up
listeners
on
finished
promise
var
retPromise
=
animation
.
finished
.
then
(
function
(
)
{
assert_unreached
(
'
finished
promise
is
fulfilled
'
)
;
}
)
.
catch
(
function
(
err
)
{
assert_equals
(
err
.
name
'
AbortError
'
'
finished
promise
is
rejected
with
AbortError
'
)
;
assert_not_equals
(
animation
.
finished
previousFinishedPromise
'
Finished
promise
should
change
after
the
original
is
'
+
'
rejected
'
)
;
}
)
;
/
/
Now
cancel
the
animation
and
flush
styles
div
.
style
.
animation
=
'
'
;
window
.
getComputedStyle
(
div
)
.
animation
;
return
retPromise
;
}
'
finished
promise
is
rejected
when
an
animation
is
cancelled
by
resetting
'
+
'
the
animation
property
'
)
;
promise_test
(
function
(
t
)
{
var
div
=
addDiv
(
t
)
;
/
/
As
before
but
this
time
instead
of
removing
all
animations
simply
update
/
/
the
list
of
animations
.
At
least
for
Firefox
updating
is
a
different
/
/
code
path
.
/
/
Set
up
pending
animation
div
.
style
.
animation
=
ANIM_PROP_VAL
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
var
previousFinishedPromise
=
animation
.
finished
;
/
/
Set
up
listeners
on
finished
promise
var
retPromise
=
animation
.
finished
.
then
(
function
(
)
{
assert_unreached
(
'
finished
promise
was
fulfilled
'
)
;
}
)
.
catch
(
function
(
err
)
{
assert_equals
(
err
.
name
'
AbortError
'
'
finished
promise
is
rejected
with
AbortError
'
)
;
assert_not_equals
(
animation
.
finished
previousFinishedPromise
'
Finished
promise
should
change
after
the
original
is
'
+
'
rejected
'
)
;
}
)
;
/
/
Now
update
the
animation
and
flush
styles
div
.
style
.
animation
=
'
def
100s
'
;
window
.
getComputedStyle
(
div
)
.
animation
;
return
retPromise
;
}
'
finished
promise
is
rejected
when
an
animation
is
cancelled
by
changing
'
+
'
the
animation
property
'
)
;
promise_test
(
function
(
t
)
{
var
div
=
addDiv
(
t
)
;
div
.
style
.
animation
=
ANIM_PROP_VAL
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
var
previousFinishedPromise
=
animation
.
finished
;
/
/
Set
up
listeners
on
finished
promise
var
retPromise
=
animation
.
finished
.
then
(
function
(
)
{
assert_unreached
(
'
finished
promise
was
fulfilled
'
)
;
}
)
.
catch
(
function
(
err
)
{
assert_equals
(
err
.
name
'
AbortError
'
'
finished
promise
is
rejected
with
AbortError
'
)
;
assert_not_equals
(
animation
.
finished
previousFinishedPromise
'
Finished
promise
should
change
after
the
original
is
'
+
'
rejected
'
)
;
}
)
;
animation
.
cancel
(
)
;
return
retPromise
;
}
'
finished
promise
is
rejected
when
an
animation
is
cancelled
by
calling
'
+
'
cancel
(
)
'
)
;
promise_test
(
function
(
t
)
{
var
div
=
addDiv
(
t
)
;
div
.
style
.
animation
=
ANIM_PROP_VAL
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
var
previousFinishedPromise
=
animation
.
finished
;
animation
.
currentTime
=
ANIM_DURATION
;
return
animation
.
finished
.
then
(
function
(
)
{
animation
.
cancel
(
)
;
assert_not_equals
(
animation
.
finished
previousFinishedPromise
'
A
new
finished
promise
should
be
created
when
'
+
'
cancelling
a
finished
animation
'
)
;
}
)
;
}
'
cancelling
an
already
-
finished
animation
replaces
the
finished
promise
'
)
;
promise_test
(
function
(
t
)
{
var
div
=
addDiv
(
t
)
;
div
.
style
.
animation
=
ANIM_PROP_VAL
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
animation
.
cancel
(
)
;
/
/
The
spec
says
we
still
create
a
new
finished
promise
and
reject
the
old
/
/
one
even
if
we
'
re
already
idle
.
That
behavior
might
change
but
for
now
/
/
test
that
we
do
that
.
var
retPromise
=
animation
.
finished
.
catch
(
function
(
err
)
{
assert_equals
(
err
.
name
'
AbortError
'
'
finished
promise
is
rejected
with
AbortError
'
)
;
}
)
;
/
/
Redundant
call
to
cancel
(
)
;
var
previousFinishedPromise
=
animation
.
finished
;
animation
.
cancel
(
)
;
assert_not_equals
(
animation
.
finished
previousFinishedPromise
'
A
redundant
call
to
cancel
(
)
should
still
generate
a
new
'
+
'
finished
promise
'
)
;
return
retPromise
;
}
'
cancelling
an
idle
animation
still
replaces
the
finished
promise
'
)
;
promise_test
(
function
(
t
)
{
var
div
=
addDiv
(
t
)
;
div
.
style
.
animation
=
ANIM_PROP_VAL
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
const
HALF_DUR
=
ANIM_DURATION
/
2
;
const
QUARTER_DUR
=
ANIM_DURATION
/
4
;
var
gotNextFrame
=
false
;
var
currentTimeBeforeShortening
;
animation
.
currentTime
=
HALF_DUR
;
return
animation
.
ready
.
then
(
function
(
)
{
currentTimeBeforeShortening
=
animation
.
currentTime
;
div
.
style
.
animationDuration
=
QUARTER_DUR
+
'
ms
'
;
window
.
getComputedStyle
(
div
)
.
animationDuration
;
/
/
flush
style
/
/
Animation
should
now
be
finished
/
/
Below
we
use
gotNextFrame
to
check
that
shortening
of
the
animation
/
/
duration
causes
the
finished
promise
to
resolve
rather
than
it
just
/
/
getting
resolved
on
the
next
animation
frame
.
This
relies
on
the
fact
/
/
that
the
promises
are
resolved
as
a
micro
-
task
before
the
next
frame
/
/
happens
.
waitForFrame
(
)
.
then
(
function
(
)
{
gotNextFrame
=
true
;
}
)
;
return
animation
.
finished
;
}
)
.
then
(
function
(
)
{
assert_false
(
gotNextFrame
'
shortening
of
the
animation
duration
should
'
+
'
resolve
the
finished
promise
'
)
;
assert_equals
(
animation
.
currentTime
currentTimeBeforeShortening
'
currentTime
should
be
unchanged
when
duration
shortened
'
)
;
var
previousFinishedPromise
=
animation
.
finished
;
div
.
style
.
animationDuration
=
ANIM_DURATION
+
'
ms
'
;
/
/
now
active
again
window
.
getComputedStyle
(
div
)
.
animationDuration
;
/
/
flush
style
assert_not_equals
(
animation
.
finished
previousFinishedPromise
'
Finished
promise
should
change
after
lengthening
the
'
+
'
duration
causes
the
animation
to
become
active
'
)
;
}
)
;
}
'
Test
finished
promise
changes
for
animation
duration
changes
'
)
;
promise_test
(
function
(
t
)
{
var
div
=
addDiv
(
t
)
;
div
.
style
.
animation
=
ANIM_PROP_VAL
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
var
retPromise
=
animation
.
ready
.
then
(
function
(
)
{
animation
.
playbackRate
=
0
;
animation
.
currentTime
=
ANIM_DURATION
+
1000
;
return
waitForAnimationFrames
(
2
)
;
}
)
;
animation
.
finished
.
then
(
t
.
step_func
(
function
(
)
{
assert_unreached
(
'
finished
promise
should
not
resolve
when
playbackRate
'
+
'
is
zero
'
)
;
}
)
)
;
return
retPromise
;
}
'
Test
finished
promise
changes
when
playbackRate
=
=
0
'
)
;
promise_test
(
function
(
t
)
{
var
div
=
addDiv
(
t
)
;
div
.
style
.
animation
=
ANIM_PROP_VAL
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
return
animation
.
ready
.
then
(
function
(
)
{
animation
.
playbackRate
=
-
1
;
return
animation
.
finished
;
}
)
;
}
'
Test
finished
promise
resolves
when
playbackRate
set
to
a
negative
value
'
)
;
promise_test
(
function
(
t
)
{
var
div
=
addDiv
(
t
)
;
div
.
style
.
animation
=
ANIM_PROP_VAL
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
var
previousFinishedPromise
=
animation
.
finished
;
animation
.
currentTime
=
ANIM_DURATION
;
return
animation
.
finished
.
then
(
function
(
)
{
div
.
style
.
animationPlayState
=
'
running
'
;
return
waitForAnimationFrames
(
2
)
;
}
)
.
then
(
function
(
)
{
assert_equals
(
animation
.
finished
previousFinishedPromise
'
Should
not
replay
when
animation
-
play
-
state
changes
to
'
+
'
"
running
"
on
finished
animation
'
)
;
assert_equals
(
animation
.
currentTime
ANIM_DURATION
'
currentTime
should
not
change
when
animation
-
play
-
state
'
+
'
changes
to
"
running
"
on
finished
animation
'
)
;
}
)
;
}
'
Test
finished
promise
changes
when
animationPlayState
set
to
running
'
)
;
promise_test
(
function
(
t
)
{
var
div
=
addDiv
(
t
)
;
div
.
style
.
animation
=
ANIM_PROP_VAL
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
var
previousFinishedPromise
=
animation
.
finished
;
animation
.
currentTime
=
ANIM_DURATION
;
return
animation
.
finished
.
then
(
function
(
)
{
animation
.
currentTime
=
0
;
assert_not_equals
(
animation
.
finished
previousFinishedPromise
'
Finished
promise
should
change
once
a
prior
'
+
'
finished
promise
resolved
and
the
animation
'
+
'
falls
out
finished
state
'
)
;
}
)
;
}
'
Test
finished
promise
changes
when
a
prior
finished
promise
resolved
'
+
'
and
the
animation
falls
out
finished
state
'
)
;
test
(
function
(
t
)
{
var
div
=
addDiv
(
t
)
;
div
.
style
.
animation
=
ANIM_PROP_VAL
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
var
previousFinishedPromise
=
animation
.
finished
;
animation
.
currentTime
=
ANIM_DURATION
;
animation
.
currentTime
=
ANIM_DURATION
/
2
;
assert_equals
(
animation
.
finished
previousFinishedPromise
'
No
new
finished
promise
generated
when
finished
state
'
+
'
is
checked
asynchronously
'
)
;
}
'
Test
no
new
finished
promise
generated
when
finished
state
'
+
'
is
checked
asynchronously
'
)
;
test
(
function
(
t
)
{
var
div
=
addDiv
(
t
)
;
div
.
style
.
animation
=
ANIM_PROP_VAL
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
var
previousFinishedPromise
=
animation
.
finished
;
animation
.
finish
(
)
;
animation
.
currentTime
=
ANIM_DURATION
/
2
;
assert_not_equals
(
animation
.
finished
previousFinishedPromise
'
New
finished
promise
generated
when
finished
state
'
+
'
is
checked
synchronously
'
)
;
}
'
Test
new
finished
promise
generated
when
finished
state
'
+
'
is
checked
synchronously
'
)
;
promise_test
(
function
(
t
)
{
var
div
=
addDiv
(
t
)
;
div
.
style
.
animation
=
ANIM_PROP_VAL
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
var
resolvedFinished
=
false
;
animation
.
finished
.
then
(
function
(
)
{
resolvedFinished
=
true
;
}
)
;
return
animation
.
ready
.
then
(
function
(
)
{
animation
.
finish
(
)
;
animation
.
currentTime
=
ANIM_DURATION
/
2
;
}
)
.
then
(
function
(
)
{
assert_true
(
resolvedFinished
'
Animation
.
finished
should
be
resolved
even
if
'
+
'
the
finished
state
is
changed
soon
'
)
;
}
)
;
}
'
Test
synchronous
finished
promise
resolved
even
if
finished
state
'
+
'
is
changed
soon
'
)
;
promise_test
(
function
(
t
)
{
var
div
=
addDiv
(
t
)
;
div
.
style
.
animation
=
ANIM_PROP_VAL
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
var
resolvedFinished
=
false
;
animation
.
finished
.
then
(
function
(
)
{
resolvedFinished
=
true
;
}
)
;
return
animation
.
ready
.
then
(
function
(
)
{
animation
.
currentTime
=
ANIM_DURATION
;
animation
.
finish
(
)
;
}
)
.
then
(
function
(
)
{
assert_true
(
resolvedFinished
'
Animation
.
finished
should
be
resolved
soon
after
finish
(
)
is
'
+
'
called
even
if
there
are
other
asynchronous
promises
just
before
it
'
)
;
}
)
;
}
'
Test
synchronous
finished
promise
resolved
even
if
asynchronous
'
+
'
finished
promise
happens
just
before
synchronous
promise
'
)
;
promise_test
(
function
(
t
)
{
var
div
=
addDiv
(
t
)
;
div
.
style
.
animation
=
ANIM_PROP_VAL
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
animation
.
finished
.
then
(
t
.
step_func
(
function
(
)
{
assert_unreached
(
'
Animation
.
finished
should
not
be
resolved
'
)
;
}
)
)
;
return
animation
.
ready
.
then
(
function
(
)
{
animation
.
currentTime
=
ANIM_DURATION
;
animation
.
currentTime
=
ANIM_DURATION
/
2
;
}
)
;
}
'
Test
finished
promise
is
not
resolved
when
the
animation
'
+
'
falls
out
finished
state
immediately
'
)
;
promise_test
(
function
(
t
)
{
var
div
=
addDiv
(
t
)
;
div
.
style
.
animation
=
ANIM_PROP_VAL
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
return
animation
.
ready
.
then
(
function
(
)
{
animation
.
currentTime
=
ANIM_DURATION
;
animation
.
finished
.
then
(
t
.
step_func
(
function
(
)
{
assert_unreached
(
'
Animation
.
finished
should
not
be
resolved
'
)
;
}
)
)
;
animation
.
currentTime
=
0
;
}
)
;
}
'
Test
finished
promise
is
not
resolved
once
the
animation
'
+
'
falls
out
finished
state
even
though
the
current
finished
'
+
'
promise
is
generated
soon
after
animation
state
became
finished
'
)
;
done
(
)
;
<
/
script
>
<
/
body
>
