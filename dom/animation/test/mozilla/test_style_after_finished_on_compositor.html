<
!
doctype
html
>
<
head
>
<
meta
charset
=
utf
-
8
>
<
title
>
Test
for
styles
after
an
animation
has
finished
on
the
compositor
<
/
title
>
<
script
src
=
"
/
resources
/
testharness
.
js
"
>
<
/
script
>
<
script
src
=
"
/
resources
/
testharnessreport
.
js
"
>
<
/
script
>
<
script
src
=
"
.
.
/
testcommon
.
js
"
>
<
/
script
>
<
style
>
.
compositor
{
/
*
Element
needs
geometry
to
be
eligible
for
layerization
*
/
width
:
100px
;
height
:
100px
;
background
-
color
:
green
;
}
<
/
style
>
<
/
head
>
<
body
>
<
div
id
=
"
log
"
>
<
/
div
>
<
script
>
"
use
strict
"
;
promise_test
(
async
t
=
>
{
const
div
=
addDiv
(
t
{
'
class
'
:
'
compositor
'
}
)
;
const
anim
=
div
.
animate
(
[
{
offset
:
0
opacity
:
1
}
{
offset
:
1
opacity
:
0
}
]
{
delay
:
10
duration
:
100
}
)
;
await
anim
.
finished
;
await
waitForNextFrame
(
)
;
const
opacity
=
SpecialPowers
.
DOMWindowUtils
.
getOMTAStyle
(
div
'
opacity
'
)
;
assert_equals
(
opacity
'
'
'
No
opacity
animation
runs
on
the
compositor
'
)
;
}
'
Opacity
animation
with
positive
delay
is
removed
from
compositor
when
'
+
'
finished
'
)
;
promise_test
(
async
t
=
>
{
const
div
=
addDiv
(
t
{
'
class
'
:
'
compositor
'
}
)
;
const
anim
=
div
.
animate
(
[
{
offset
:
0
opacity
:
1
}
{
offset
:
0
.
9
opacity
:
1
}
{
offset
:
1
opacity
:
0
}
]
{
duration
:
100
}
)
;
await
anim
.
finished
;
await
waitForNextFrame
(
)
;
const
opacity
=
SpecialPowers
.
DOMWindowUtils
.
getOMTAStyle
(
div
'
opacity
'
)
;
assert_equals
(
opacity
'
'
'
No
opacity
animation
runs
on
the
compositor
'
)
;
}
'
Opacity
animation
initially
opacity
:
1
is
removed
from
compositor
when
'
+
'
finished
'
)
;
promise_test
(
async
t
=
>
{
const
div
=
addDiv
(
t
{
'
class
'
:
'
compositor
'
}
)
;
const
anim
=
div
.
animate
(
[
{
offset
:
0
opacity
:
0
}
{
offset
:
0
.
5
opacity
:
1
}
{
offset
:
0
.
51
opacity
:
1
}
{
offset
:
1
opacity
:
0
}
]
{
delay
:
10
duration
:
100
}
)
;
await
waitForAnimationFrames
(
2
)
;
/
/
Setting
the
current
time
at
the
offset
generating
opacity
:
1
.
anim
.
currentTime
=
60
;
await
anim
.
finished
;
await
waitForNextFrame
(
)
;
const
opacity
=
SpecialPowers
.
DOMWindowUtils
.
getOMTAStyle
(
div
'
opacity
'
)
;
assert_equals
(
opacity
'
'
'
No
opacity
animation
runs
on
the
compositor
'
)
;
}
'
Opacity
animation
is
removed
from
compositor
even
when
it
only
visits
'
+
'
exactly
the
point
where
the
opacity
:
1
value
was
set
'
)
;
promise_test
(
async
t
=
>
{
const
div
=
addDiv
(
t
{
'
class
'
:
'
compositor
'
}
)
;
const
anim
=
div
.
animate
(
[
{
offset
:
0
transform
:
'
none
'
}
{
offset
:
1
transform
:
'
translateX
(
100px
)
'
}
]
{
delay
:
10
duration
:
100
}
)
;
await
anim
.
finished
;
await
waitForNextFrame
(
)
;
const
transform
=
SpecialPowers
.
DOMWindowUtils
.
getOMTAStyle
(
div
'
transform
'
)
;
assert_equals
(
transform
'
'
'
No
transform
animation
runs
on
the
compositor
'
)
;
}
'
Transform
animation
with
positive
delay
is
removed
from
compositor
when
'
+
'
finished
'
)
;
promise_test
(
async
t
=
>
{
const
div
=
addDiv
(
t
{
'
class
'
:
'
compositor
'
}
)
;
const
anim
=
div
.
animate
(
[
{
offset
:
0
transform
:
'
none
'
}
{
offset
:
0
.
9
transform
:
'
none
'
}
{
offset
:
1
transform
:
'
translateX
(
100px
)
'
}
]
{
duration
:
100
}
)
;
await
anim
.
finished
;
await
waitForNextFrame
(
)
;
const
transform
=
SpecialPowers
.
DOMWindowUtils
.
getOMTAStyle
(
div
'
transform
'
)
;
assert_equals
(
transform
'
'
'
No
transform
animation
runs
on
the
compositor
'
)
;
}
'
Transform
animation
initially
transform
:
none
is
removed
from
compositor
'
+
'
when
finished
'
)
;
promise_test
(
async
t
=
>
{
const
div
=
addDiv
(
t
{
'
class
'
:
'
compositor
'
}
)
;
const
anim
=
div
.
animate
(
[
{
offset
:
0
transform
:
'
translateX
(
100px
)
'
}
{
offset
:
0
.
5
transform
:
'
none
'
}
{
offset
:
0
.
9
transform
:
'
none
'
}
{
offset
:
1
transform
:
'
translateX
(
100px
)
'
}
]
{
delay
:
10
duration
:
100
}
)
;
await
waitForAnimationFrames
(
2
)
;
/
/
Setting
the
current
time
at
the
offset
generating
transform
:
none
.
anim
.
currentTime
=
60
;
await
anim
.
finished
;
await
waitForNextFrame
(
)
;
const
transform
=
SpecialPowers
.
DOMWindowUtils
.
getOMTAStyle
(
div
'
transform
'
)
;
assert_equals
(
transform
'
'
'
No
transform
animation
runs
on
the
compositor
'
)
;
}
'
Transform
animation
is
removed
from
compositor
even
when
it
only
visits
'
+
'
exactly
the
point
where
the
transform
:
none
value
was
set
'
)
;
/
*
*
*
Tests
for
synthesized
fill
modes
used
when
an
animation
on
the
compositor
*
has
finished
and
is
waiting
to
be
removed
by
the
main
thread
.
*
*
/
promise_test
(
async
t
=
>
{
/
/
Below
if
painting
takes
too
long
we
'
ll
skip
the
test
so
in
order
to
give
/
/
the
test
a
better
chance
of
running
wait
until
the
system
settles
down
.
await
waitForIdle
(
)
;
const
div
=
addDiv
(
t
{
class
:
'
compositor
'
}
)
;
const
anim
=
div
.
animate
(
{
opacity
:
[
1
0
]
}
100
)
;
const
timeBeforeStart
=
window
.
performance
.
now
(
)
;
await
waitForPaints
(
)
;
/
/
If
it
took
over
50ms
to
paint
the
first
frame
of
the
animation
we
can
'
t
/
/
reliably
test
it
.
This
situation
can
happen
if
for
example
GC
runs
while
/
/
waiting
for
the
paint
.
if
(
window
.
performance
.
now
(
)
-
timeBeforeStart
>
=
50
)
{
console
.
log
(
'
Skipping
test
because
it
took
too
long
to
paint
the
'
+
'
first
frame
'
)
;
return
;
}
let
opacity
=
SpecialPowers
.
DOMWindowUtils
.
getOMTAStyle
(
div
'
opacity
'
)
;
assert_not_equals
(
opacity
'
'
'
The
animation
style
is
applied
on
the
compositor
'
)
;
/
/
Generate
artificial
busyness
on
the
main
thread
for
200ms
.
const
waitStart
=
window
.
performance
.
now
(
)
;
while
(
window
.
performance
.
now
(
)
-
waitStart
<
200
)
{
}
/
/
By
now
the
animation
on
the
compositor
should
have
finished
but
should
/
/
stay
at
the
end
of
the
animation
because
the
main
thread
hasn
'
t
had
/
/
a
chance
to
remove
the
animation
from
the
compositor
yet
.
opacity
=
SpecialPowers
.
DOMWindowUtils
.
getOMTAStyle
(
div
'
opacity
'
)
;
assert_equals
(
opacity
'
0
'
'
The
opacity
style
from
the
end
of
the
animation
is
still
applied
on
'
+
'
the
compositor
'
)
;
}
'
Opacity
animation
when
playing
forwards
uses
fill
:
forwards
while
'
+
'
waiting
for
the
main
thread
to
catch
up
'
)
;
promise_test
(
async
t
=
>
{
await
waitForIdle
(
)
;
const
div
=
addDiv
(
t
{
class
:
'
compositor
'
}
)
;
const
anim
=
div
.
animate
(
{
opacity
:
[
0
1
]
}
100
)
;
anim
.
playbackRate
=
-
1
;
anim
.
play
(
)
;
const
timeBeforeStart
=
window
.
performance
.
now
(
)
;
await
waitForPaints
(
)
;
/
/
If
it
took
over
50ms
to
paint
the
first
frame
of
the
animation
we
can
'
t
/
/
reliably
test
it
.
This
situation
can
happen
if
for
example
GC
runs
while
/
/
waiting
for
the
paint
.
if
(
window
.
performance
.
now
(
)
-
timeBeforeStart
>
=
50
)
{
console
.
log
(
'
Skipping
test
because
it
took
too
long
to
paint
the
'
+
'
first
frame
'
)
;
return
;
}
/
/
Bug
1496313
:
For
animations
playing
backwards
in
some
cases
the
animation
/
/
will
not
have
arrived
at
the
compositor
by
the
time
we
go
to
check
it
.
/
/
For
now
we
just
skip
that
if
it
happens
since
it
only
happens
occasionally
.
if
(
SpecialPowers
.
DOMWindowUtils
.
getOMTAStyle
(
div
'
opacity
'
)
=
=
=
'
'
)
{
console
.
log
(
'
Skipping
test
because
the
took
too
long
to
paint
the
'
+
'
first
frame
'
)
;
return
;
}
/
/
Generate
artificial
busyness
on
the
main
thread
for
200ms
.
const
waitStart
=
window
.
performance
.
now
(
)
;
while
(
window
.
performance
.
now
(
)
-
waitStart
<
200
)
{
}
/
/
By
now
the
animation
on
the
compositor
should
have
finished
but
should
/
/
stay
at
the
start
of
the
animation
because
the
main
thread
hasn
'
t
had
/
/
a
chance
to
remove
the
animation
from
the
compositor
yet
.
const
opacity
=
SpecialPowers
.
DOMWindowUtils
.
getOMTAStyle
(
div
'
opacity
'
)
;
assert_equals
(
opacity
'
0
'
'
The
opacity
style
from
the
start
of
the
animation
is
still
'
+
'
applied
on
the
compositor
'
)
;
}
'
Opacity
animation
when
playing
backwards
uses
fill
:
backwards
while
'
+
'
waiting
for
the
main
thread
to
catch
up
'
)
;
/
*
*
The
following
tests
are
as
above
but
for
a
different
initial
fill
mode
*
hence
comments
have
been
removed
.
*
/
promise_test
(
async
t
=
>
{
await
waitForIdle
(
)
;
const
div
=
addDiv
(
t
{
class
:
'
compositor
'
}
)
;
const
anim
=
div
.
animate
(
{
opacity
:
[
1
0
]
}
{
duration
:
100
fill
:
'
backwards
'
}
)
;
const
timeBeforeStart
=
window
.
performance
.
now
(
)
;
await
waitForPaints
(
)
;
if
(
window
.
performance
.
now
(
)
-
timeBeforeStart
>
=
50
)
{
console
.
log
(
'
Skipping
test
because
it
took
too
long
to
paint
the
'
+
'
first
frame
'
)
;
return
;
}
let
opacity
=
SpecialPowers
.
DOMWindowUtils
.
getOMTAStyle
(
div
'
opacity
'
)
;
assert_not_equals
(
opacity
'
'
'
The
animation
style
is
applied
on
the
compositor
'
)
;
const
waitStart
=
window
.
performance
.
now
(
)
;
while
(
window
.
performance
.
now
(
)
-
waitStart
<
200
)
{
}
opacity
=
SpecialPowers
.
DOMWindowUtils
.
getOMTAStyle
(
div
'
opacity
'
)
;
assert_equals
(
opacity
'
0
'
'
The
opacity
style
from
the
end
of
the
animation
is
still
'
+
'
applied
on
the
compositor
'
)
;
}
'
Opacity
animation
playing
forwards
with
fill
:
backwards
'
+
'
uses
fill
:
both
while
waiting
for
the
main
thread
to
catch
up
'
)
;
promise_test
(
async
t
=
>
{
await
waitForIdle
(
)
;
const
div
=
addDiv
(
t
{
class
:
'
compositor
'
}
)
;
const
anim
=
div
.
animate
(
{
opacity
:
[
0
1
]
}
{
duration
:
100
fill
:
'
forwards
'
}
)
;
anim
.
playbackRate
=
-
1
;
anim
.
play
(
)
;
const
timeBeforeStart
=
window
.
performance
.
now
(
)
;
await
waitForPaints
(
)
;
if
(
window
.
performance
.
now
(
)
-
timeBeforeStart
>
=
50
)
{
console
.
log
(
'
Skipping
test
because
it
took
too
long
to
paint
the
'
+
'
first
frame
'
)
;
return
;
}
/
/
Bug
1496313
:
For
animations
playing
backwards
in
some
cases
the
animation
/
/
will
not
have
arrived
at
the
compositor
by
the
time
we
go
to
check
it
.
/
/
For
now
we
just
skip
that
if
it
happens
since
it
only
happens
occasionally
.
if
(
SpecialPowers
.
DOMWindowUtils
.
getOMTAStyle
(
div
'
opacity
'
)
=
=
=
'
'
)
{
console
.
log
(
'
Skipping
test
because
the
took
too
long
to
paint
the
'
+
'
first
frame
'
)
;
return
;
}
const
waitStart
=
window
.
performance
.
now
(
)
;
while
(
window
.
performance
.
now
(
)
-
waitStart
<
200
)
{
}
const
opacity
=
SpecialPowers
.
DOMWindowUtils
.
getOMTAStyle
(
div
'
opacity
'
)
;
assert_equals
(
opacity
'
0
'
'
The
opacity
style
from
the
start
of
the
animation
is
still
'
+
'
applied
on
the
compositor
'
)
;
}
'
Opacity
animation
playing
backwards
with
fill
:
forwards
'
+
'
uses
fill
:
both
while
waiting
for
the
main
thread
to
catch
up
'
)
;
<
/
script
>
<
/
body
>
