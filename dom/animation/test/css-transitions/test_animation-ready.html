<
!
doctype
html
>
<
meta
charset
=
utf
-
8
>
<
script
src
=
"
/
resources
/
testharness
.
js
"
>
<
/
script
>
<
script
src
=
"
/
resources
/
testharnessreport
.
js
"
>
<
/
script
>
<
script
src
=
"
.
.
/
testcommon
.
js
"
>
<
/
script
>
<
body
>
<
div
id
=
"
log
"
>
<
/
div
>
<
script
>
'
use
strict
'
;
promise_test
(
async
t
=
>
{
var
div
=
addDiv
(
t
)
;
div
.
style
.
transform
=
'
translate
(
0px
)
'
;
getComputedStyle
(
div
)
.
transform
;
div
.
style
.
transition
=
'
transform
100s
'
;
div
.
style
.
transform
=
'
translate
(
10px
)
'
;
getComputedStyle
(
div
)
.
transform
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
var
originalReadyPromise
=
animation
.
ready
;
await
animation
.
ready
;
assert_equals
(
animation
.
ready
originalReadyPromise
'
Ready
promise
is
the
same
object
when
playing
completes
'
)
;
animation
.
pause
(
)
;
assert_not_equals
(
animation
.
ready
originalReadyPromise
'
Ready
promise
object
identity
differs
when
pausing
'
)
;
}
'
A
new
ready
promise
is
created
each
time
play
(
)
is
called
'
+
'
the
animation
property
'
)
;
promise_test
(
async
t
=
>
{
var
div
=
addDiv
(
t
)
;
/
/
Set
up
pending
transition
div
.
style
.
transform
=
'
translate
(
0px
)
'
;
getComputedStyle
(
div
)
.
transform
;
div
.
style
.
transition
=
'
transform
100s
'
;
div
.
style
.
transform
=
'
translate
(
10px
)
'
;
getComputedStyle
(
div
)
.
transform
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
assert_true
(
animation
.
pending
'
Animation
is
initially
pending
'
)
;
const
readyPromise
=
animation
.
ready
;
/
/
Now
remove
transform
from
transition
-
property
and
flush
styles
div
.
style
.
transitionProperty
=
'
none
'
;
getComputedStyle
(
div
)
.
transitionProperty
;
try
{
await
readyPromise
;
assert_unreached
(
'
ready
promise
was
fulfilled
'
)
;
}
catch
(
err
)
{
assert_equals
(
err
.
name
'
AbortError
'
'
ready
promise
is
rejected
with
AbortError
'
)
;
assert_equals
(
animation
.
playState
'
idle
'
'
Animation
is
idle
after
transition
was
cancelled
'
)
;
}
}
'
ready
promise
is
rejected
when
a
transition
is
cancelled
by
updating
'
+
'
transition
-
property
'
)
;
promise_test
(
async
t
=
>
{
var
div
=
addDiv
(
t
)
;
/
/
Set
up
pending
transition
div
.
style
.
marginLeft
=
'
0px
'
;
getComputedStyle
(
div
)
.
marginLeft
;
div
.
style
.
transition
=
'
margin
-
left
100s
'
;
div
.
style
.
marginLeft
=
'
100px
'
;
getComputedStyle
(
div
)
.
marginLeft
;
var
animation
=
div
.
getAnimations
(
)
[
0
]
;
assert_true
(
animation
.
pending
'
Animation
is
initially
pending
'
)
;
const
readyPromise
=
animation
.
ready
;
/
/
Update
the
transition
to
animate
to
something
not
-
interpolable
div
.
style
.
marginLeft
=
'
auto
'
;
getComputedStyle
(
div
)
.
marginLeft
;
try
{
await
readyPromise
;
assert_unreached
(
'
ready
promise
was
fulfilled
'
)
;
}
catch
(
err
)
{
assert_equals
(
err
.
name
'
AbortError
'
'
ready
promise
is
rejected
with
AbortError
'
)
;
assert_equals
(
animation
.
playState
'
idle
'
'
Animation
is
idle
after
transition
was
cancelled
'
)
;
}
}
'
ready
promise
is
rejected
when
a
transition
is
cancelled
by
changing
'
+
'
the
transition
property
to
something
not
interpolable
'
)
;
<
/
script
>
<
/
body
>
