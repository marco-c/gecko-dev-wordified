/
*
-
*
-
Mode
:
C
+
+
;
tab
-
width
:
8
;
indent
-
tabs
-
mode
:
nil
;
c
-
basic
-
offset
:
2
-
*
-
*
/
/
*
vim
:
set
ts
=
8
sts
=
2
et
sw
=
2
tw
=
80
:
*
/
/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
file
*
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
#
ifndef
mozilla_AnimationEventDispatcher_h
#
define
mozilla_AnimationEventDispatcher_h
#
include
<
algorithm
>
/
/
For
<
std
:
:
stable_sort
>
#
include
"
mozilla
/
AnimationComparator
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
class
nsPresContext
;
namespace
mozilla
{
template
<
class
EventInfo
>
class
AnimationEventDispatcher
final
{
public
:
AnimationEventDispatcher
(
)
:
mIsSorted
(
true
)
{
}
void
QueueEvents
(
nsTArray
<
EventInfo
>
&
&
aEvents
)
{
mPendingEvents
.
AppendElements
(
Forward
<
nsTArray
<
EventInfo
>
>
(
aEvents
)
)
;
mIsSorted
=
false
;
}
/
/
This
is
exposed
as
a
separate
method
so
that
when
we
are
dispatching
/
/
*
both
*
transition
events
and
animation
events
we
can
sort
both
lists
/
/
once
using
the
current
state
of
the
document
before
beginning
any
/
/
dispatch
.
void
SortEvents
(
)
{
if
(
mIsSorted
)
{
return
;
}
/
/
FIXME
:
Replace
with
mPendingEvents
.
StableSort
when
bug
1147091
is
/
/
fixed
.
std
:
:
stable_sort
(
mPendingEvents
.
begin
(
)
mPendingEvents
.
end
(
)
EventInfoLessThan
(
)
)
;
mIsSorted
=
true
;
}
/
/
Takes
a
reference
to
the
owning
manager
'
s
pres
context
so
it
can
/
/
detect
if
the
pres
context
is
destroyed
while
dispatching
one
of
/
/
the
events
.
/
/
/
/
This
will
call
SortEvents
automatically
if
it
has
not
already
been
/
/
called
.
void
DispatchEvents
(
nsPresContext
*
const
&
aPresContext
)
{
if
(
!
aPresContext
|
|
mPendingEvents
.
IsEmpty
(
)
)
{
return
;
}
SortEvents
(
)
;
EventArray
events
;
mPendingEvents
.
SwapElements
(
events
)
;
/
/
mIsSorted
will
be
set
to
true
by
SortEvents
above
and
we
leave
it
/
/
that
way
since
mPendingEvents
is
now
empty
for
(
EventInfo
&
info
:
events
)
{
EventDispatcher
:
:
Dispatch
(
info
.
mElement
aPresContext
&
info
.
mEvent
)
;
if
(
!
aPresContext
)
{
break
;
}
}
}
void
ClearEventQueue
(
)
{
mPendingEvents
.
Clear
(
)
;
mIsSorted
=
true
;
}
bool
HasQueuedEvents
(
)
const
{
return
!
mPendingEvents
.
IsEmpty
(
)
;
}
/
/
Methods
for
supporting
cycle
-
collection
void
Traverse
(
nsCycleCollectionTraversalCallback
*
aCallback
const
char
*
aName
)
{
for
(
EventInfo
&
info
:
mPendingEvents
)
{
ImplCycleCollectionTraverse
(
*
aCallback
info
.
mElement
aName
)
;
ImplCycleCollectionTraverse
(
*
aCallback
info
.
mAnimation
aName
)
;
}
}
void
Unlink
(
)
{
ClearEventQueue
(
)
;
}
protected
:
class
EventInfoLessThan
{
public
:
bool
operator
(
)
(
const
EventInfo
&
a
const
EventInfo
&
b
)
const
{
if
(
a
.
mTimeStamp
!
=
b
.
mTimeStamp
)
{
/
/
Null
timestamps
sort
first
if
(
a
.
mTimeStamp
.
IsNull
(
)
|
|
b
.
mTimeStamp
.
IsNull
(
)
)
{
return
a
.
mTimeStamp
.
IsNull
(
)
;
}
else
{
return
a
.
mTimeStamp
<
b
.
mTimeStamp
;
}
}
AnimationPtrComparator
<
RefPtr
<
dom
:
:
Animation
>
>
comparator
;
return
comparator
.
LessThan
(
a
.
mAnimation
b
.
mAnimation
)
;
}
}
;
typedef
nsTArray
<
EventInfo
>
EventArray
;
EventArray
mPendingEvents
;
bool
mIsSorted
;
}
;
template
<
class
EventInfo
>
inline
void
ImplCycleCollectionUnlink
(
AnimationEventDispatcher
<
EventInfo
>
&
aField
)
{
aField
.
Unlink
(
)
;
}
template
<
class
EventInfo
>
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
AnimationEventDispatcher
<
EventInfo
>
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
aField
.
Traverse
(
&
aCallback
aName
)
;
}
}
/
/
namespace
mozilla
#
endif
/
/
mozilla_AnimationEventDispatcher_h
