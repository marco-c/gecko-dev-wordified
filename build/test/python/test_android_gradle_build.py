#
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
#
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
#
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
import
hashlib
import
logging
import
os
import
sys
import
textwrap
from
collections
import
defaultdict
from
pathlib
import
Path
import
mozunit
import
pytest
from
buildconfig
import
topsrcdir
from
mach
.
util
import
get_state_dir
from
mozpack
.
files
import
JarFinder
from
mozpack
.
mozjar
import
JarReader
from
mozprocess
import
ProcessHandler
logger
=
logging
.
getLogger
(
__name__
)
pytest
.
fixture
(
scope
=
"
session
"
)
def
test_dir
(
)
:
    
return
(
        
Path
(
get_state_dir
(
specific_to_topsrcdir
=
True
topsrcdir
=
topsrcdir
)
)
        
/
"
android
-
gradle
-
build
"
    
)
pytest
.
fixture
(
scope
=
"
session
"
)
def
objdir
(
test_dir
)
:
    
return
test_dir
/
"
objdir
"
pytest
.
fixture
(
scope
=
"
session
"
)
def
mozconfig
(
test_dir
objdir
)
:
    
mozconfig_path
=
test_dir
/
"
mozconfig
"
    
mozconfig_path
.
parent
.
mkdir
(
parents
=
True
exist_ok
=
True
)
    
mozconfig_path
.
write_text
(
        
textwrap
.
dedent
(
            
f
"
"
"
                
ac_add_options
-
-
enable
-
application
=
mobile
/
android
                
ac_add_options
-
-
enable
-
artifact
-
builds
                
ac_add_options
-
-
target
=
arm
                
mk_add_options
MOZ_OBJDIR
=
"
{
objdir
}
"
            
"
"
"
        
)
    
)
    
return
mozconfig_path
pytest
.
fixture
(
scope
=
"
session
"
)
def
run_mach
(
mozconfig
)
:
    
def
inner
(
argv
cwd
=
None
)
:
        
env
=
os
.
environ
.
copy
(
)
        
env
[
"
MOZCONFIG
"
]
=
str
(
mozconfig
)
        
env
[
"
MACH_NO_TERMINAL_FOOTER
"
]
=
"
1
"
        
env
[
"
MACH_NO_WRITE_TIMES
"
]
=
"
1
"
        
def
pol
(
line
)
:
            
logger
.
debug
(
line
)
        
proc
=
ProcessHandler
(
            
[
sys
.
executable
"
mach
"
]
+
argv
            
env
=
env
            
cwd
=
cwd
or
topsrcdir
            
processOutputLine
=
pol
            
universal_newlines
=
True
        
)
        
proc
.
run
(
)
        
proc
.
wait
(
)
        
return
proc
.
poll
(
)
proc
.
output
    
return
inner
AARS
=
{
    
"
geckoview
.
aar
"
:
"
gradle
/
build
/
mobile
/
android
/
geckoview
/
outputs
/
aar
/
geckoview
-
debug
.
aar
"
}
APKS
=
{
    
"
test_runner
.
apk
"
:
"
gradle
/
build
/
mobile
/
android
/
test_runner
/
outputs
/
apk
/
debug
/
test_runner
-
debug
.
apk
"
    
"
androidTest
"
:
"
gradle
/
build
/
mobile
/
android
/
geckoview
/
outputs
/
apk
/
androidTest
/
debug
/
geckoview
-
debug
-
androidTest
.
apk
"
    
"
geckoview_example
.
apk
"
:
"
gradle
/
build
/
mobile
/
android
/
geckoview_example
/
outputs
/
apk
/
debug
/
geckoview_example
-
debug
.
apk
"
    
"
messaging_example
.
apk
"
:
"
gradle
/
build
/
mobile
/
android
/
examples
/
messaging_example
/
app
/
outputs
/
apk
/
debug
/
messaging_example
-
debug
.
apk
"
    
"
port_messaging_example
.
apk
"
:
"
gradle
/
build
/
mobile
/
android
/
examples
/
port_messaging_example
/
app
/
outputs
/
apk
/
debug
/
port_messaging_example
-
debug
.
apk
"
}
def
hashes
(
objdir
pattern
targets
=
{
*
*
AARS
*
*
APKS
}
)
:
    
target_to_hash
=
{
}
    
hash_to_target
=
defaultdict
(
list
)
    
for
shortname
target
in
targets
.
items
(
)
:
        
finder
=
JarFinder
(
target
JarReader
(
str
(
objdir
/
target
)
)
)
        
hasher
=
hashlib
.
blake2b
(
)
        
#
We
sort
paths
.
This
allows
a
pattern
like
classes
*
.
dex
to
capture
        
#
changes
to
any
of
the
DEX
files
no
matter
how
they
are
ordered
in
an
        
#
AAR
or
APK
.
        
for
p
f
in
sorted
(
finder
.
find
(
pattern
)
key
=
lambda
x
:
x
[
0
]
)
:
            
fp
=
f
.
open
(
)
            
while
True
:
                
data
=
fp
.
read
(
8192
)
                
if
not
len
(
data
)
:
                    
break
                
hasher
.
update
(
data
)
        
h
=
hasher
.
hexdigest
(
)
        
target_to_hash
[
shortname
]
=
h
        
hash_to_target
[
h
]
.
append
(
shortname
)
    
return
target_to_hash
hash_to_target
def
test_artifact_build
(
objdir
mozconfig
run_mach
)
:
    
(
returncode
output
)
=
run_mach
(
[
"
build
"
]
)
    
assert
"
>
Task
:
machBuildFaster
SKIPPED
"
in
output
    
assert
"
Skipping
task
:
machBuildFaster
because
:
within
mach
build
"
in
output
    
assert
"
>
Task
:
machStagePackage
SKIPPED
"
in
output
    
assert
"
Skipping
task
:
machStagePackage
because
:
within
mach
build
"
in
output
    
assert
returncode
=
=
0
    
#
Order
matters
since
mach
build
stage
-
package
depends
on
the
    
#
outputs
of
mach
build
faster
.
    
assert
output
.
index
(
"
>
Task
:
machBuildFaster
SKIPPED
"
)
<
output
.
index
(
        
"
>
Task
:
machStagePackage
SKIPPED
"
    
)
    
_
omnijar_hash_to
=
hashes
(
objdir
"
assets
/
omni
.
ja
"
)
    
assert
len
(
omnijar_hash_to
)
=
=
1
    
(
omnijar_hash_orig
)
=
omnijar_hash_to
.
values
(
)
    
(
returncode
output
)
=
run_mach
(
[
"
gradle
"
"
geckoview_example
:
assembleDebug
"
]
)
    
assert
returncode
=
=
0
    
assert
"
Executing
task
:
machBuildFaster
"
in
output
    
assert
"
Executing
task
:
machStagePackage
"
in
output
    
#
Order
matters
since
mach
build
stage
-
package
depends
on
the
    
#
outputs
of
mach
build
faster
.
    
assert
output
.
index
(
"
Executing
task
:
machBuildFaster
"
)
<
output
.
index
(
        
"
Executing
task
:
machStagePackage
"
    
)
    
_
omnijar_hash_to
=
hashes
(
objdir
"
assets
/
omni
.
ja
"
)
    
assert
len
(
omnijar_hash_to
)
=
=
1
    
(
omnijar_hash_new
)
=
omnijar_hash_to
.
values
(
)
    
assert
omnijar_hash_orig
=
=
omnijar_hash_new
if
__name__
=
=
"
__main__
"
:
    
mozunit
.
main
(
)
