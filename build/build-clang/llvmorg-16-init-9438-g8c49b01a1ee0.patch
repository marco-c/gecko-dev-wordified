From
55e4e8614971b745551a99a7f04c72634ceeef69
Mon
Sep
17
00
:
00
:
00
2001
From
:
Arthur
Eubanks
<
aeubanks
google
.
com
>
Date
:
Tue
1
Nov
2022
11
:
37
:
10
-
0700
Subject
:
[
PATCH
]
[
GlobalOpt
]
Don
'
t
remove
inalloca
from
varargs
functions
Varargs
and
inalloca
have
a
weird
interaction
where
varargs
are
actually
passed
via
the
inalloca
alloca
.
Removing
inalloca
breaks
the
varargs
because
they
'
re
still
not
passed
as
separate
arguments
.
Fixes
#
58718
Reviewed
By
:
rnk
Differential
Revision
:
https
:
/
/
reviews
.
llvm
.
org
/
D137182
-
-
-
llvm
/
lib
/
Transforms
/
IPO
/
GlobalOpt
.
cpp
|
2
+
-
.
.
.
/
Transforms
/
GlobalOpt
/
inalloca
-
varargs
.
ll
|
38
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
2
files
changed
39
insertions
(
+
)
1
deletion
(
-
)
create
mode
100644
llvm
/
test
/
Transforms
/
GlobalOpt
/
inalloca
-
varargs
.
ll
diff
-
-
git
a
/
llvm
/
lib
/
Transforms
/
IPO
/
GlobalOpt
.
cpp
b
/
llvm
/
lib
/
Transforms
/
IPO
/
GlobalOpt
.
cpp
index
6df0409256bb
.
.
6fc7b29c5b78
100644
-
-
-
a
/
llvm
/
lib
/
Transforms
/
IPO
/
GlobalOpt
.
cpp
+
+
+
b
/
llvm
/
lib
/
Transforms
/
IPO
/
GlobalOpt
.
cpp
-
2003
7
+
2003
7
OptimizeFunctions
(
Module
&
M
/
/
FIXME
:
We
should
also
hoist
alloca
affected
by
this
to
the
entry
/
/
block
if
possible
.
if
(
F
.
getAttributes
(
)
.
hasAttrSomewhere
(
Attribute
:
:
InAlloca
)
&
&
-
!
F
.
hasAddressTaken
(
)
&
&
!
hasMustTailCallers
(
&
F
)
)
{
+
!
F
.
hasAddressTaken
(
)
&
&
!
hasMustTailCallers
(
&
F
)
&
&
!
F
.
isVarArg
(
)
)
{
RemoveAttribute
(
&
F
Attribute
:
:
InAlloca
)
;
Changed
=
true
;
}
diff
-
-
git
a
/
llvm
/
test
/
Transforms
/
GlobalOpt
/
inalloca
-
varargs
.
ll
b
/
llvm
/
test
/
Transforms
/
GlobalOpt
/
inalloca
-
varargs
.
ll
new
file
mode
100644
index
000000000000
.
.
188210782edd
-
-
-
/
dev
/
null
+
+
+
b
/
llvm
/
test
/
Transforms
/
GlobalOpt
/
inalloca
-
varargs
.
ll
-
0
0
+
1
38
+
;
NOTE
:
Assertions
have
been
autogenerated
by
utils
/
update_test_checks
.
py
UTC_ARGS
:
-
-
function
-
signature
+
;
RUN
:
opt
-
passes
=
globalopt
-
S
<
%
s
|
FileCheck
%
s
+
+
define
i32
main
(
ptr
%
a
)
{
+
;
CHECK
-
LABEL
:
define
{
{
[
^
]
+
}
}
main
+
;
CHECK
-
SAME
:
(
ptr
[
[
A
:
%
.
*
]
]
)
local_unnamed_addr
{
+
;
CHECK
-
NEXT
:
[
[
ARGMEM
:
%
.
*
]
]
=
alloca
inalloca
<
{
ptr
i32
}
>
align
4
+
;
CHECK
-
NEXT
:
store
ptr
[
[
A
]
]
ptr
[
[
ARGMEM
]
]
align
8
+
;
CHECK
-
NEXT
:
[
[
G0
:
%
.
*
]
]
=
getelementptr
inbounds
<
{
ptr
i32
}
>
ptr
[
[
ARGMEM
]
]
i32
0
i32
1
+
;
CHECK
-
NEXT
:
store
i32
5
ptr
[
[
G0
]
]
align
4
+
;
CHECK
-
NEXT
:
[
[
CALL3
:
%
.
*
]
]
=
call
i32
(
ptr
.
.
.
)
i
(
ptr
inalloca
(
ptr
)
[
[
ARGMEM
]
]
)
+
;
CHECK
-
NEXT
:
ret
i32
[
[
CALL3
]
]
+
;
+
%
argmem
=
alloca
inalloca
<
{
ptr
i32
}
>
align
4
+
store
ptr
%
a
ptr
%
argmem
align
8
+
%
g0
=
getelementptr
inbounds
<
{
ptr
i32
}
>
ptr
%
argmem
i32
0
i32
1
+
store
i32
5
ptr
%
g0
align
4
+
%
call3
=
call
i32
(
ptr
.
.
.
)
i
(
ptr
inalloca
(
ptr
)
%
argmem
)
+
ret
i32
%
call3
+
}
+
+
define
internal
i32
i
(
ptr
inalloca
(
ptr
)
%
a
.
.
.
)
{
+
;
CHECK
-
LABEL
:
define
{
{
[
^
]
+
}
}
i
+
;
CHECK
-
SAME
:
(
ptr
inalloca
(
ptr
)
[
[
A
:
%
.
*
]
]
.
.
.
)
unnamed_addr
{
+
;
CHECK
-
NEXT
:
[
[
AP
:
%
.
*
]
]
=
alloca
ptr
align
4
+
;
CHECK
-
NEXT
:
call
void
llvm
.
va_start
(
ptr
[
[
AP
]
]
)
+
;
CHECK
-
NEXT
:
[
[
ARGP_CUR
:
%
.
*
]
]
=
load
ptr
ptr
[
[
AP
]
]
align
4
+
;
CHECK
-
NEXT
:
[
[
L
:
%
.
*
]
]
=
load
i32
ptr
[
[
ARGP_CUR
]
]
align
4
+
;
CHECK
-
NEXT
:
ret
i32
[
[
L
]
]
+
;
+
%
ap
=
alloca
ptr
align
4
+
call
void
llvm
.
va_start
(
ptr
%
ap
)
+
%
argp
.
cur
=
load
ptr
ptr
%
ap
align
4
+
%
l
=
load
i32
ptr
%
argp
.
cur
align
4
+
ret
i32
%
l
+
}
+
+
declare
void
llvm
.
va_start
(
ptr
)
-
-
2
.
38
.
1
.
1
.
g6d9df9d320
