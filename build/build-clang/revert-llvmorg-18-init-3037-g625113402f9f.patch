From
482cbe8016544c18ef781504b9feea281da887fd
Mon
Sep
17
00
:
00
:
00
2001
From
:
Mike
Hommey
<
mh
glandium
.
org
>
Date
:
Tue
12
Sep
2023
15
:
00
:
11
+
0900
Subject
:
[
PATCH
]
Revert
"
[
IR
]
Remove
support
for
and
/
or
constant
expressions
"
This
reverts
commit
625113402f9febd4d8c907a342ea09a3c0982ba8
because
it
breaks
reading
LLVM
IR
from
rust
during
cross
-
language
LTO
.
-
-
-
llvm
/
bindings
/
ocaml
/
llvm
/
llvm
.
ml
|
2
+
+
llvm
/
bindings
/
ocaml
/
llvm
/
llvm
.
mli
|
10
+
+
+
+
+
+
+
llvm
/
bindings
/
ocaml
/
llvm
/
llvm_ocaml
.
c
|
12
+
+
+
+
+
+
+
+
llvm
/
docs
/
LangRef
.
rst
|
4
+
+
+
llvm
/
docs
/
ReleaseNotes
.
rst
|
12
-
-
-
-
-
-
-
-
llvm
/
include
/
llvm
-
c
/
Core
.
h
|
2
+
+
llvm
/
include
/
llvm
/
IR
/
Constants
.
h
|
2
+
+
llvm
/
lib
/
Analysis
/
ConstantFolding
.
cpp
|
13
+
+
+
+
+
+
+
+
+
llvm
/
lib
/
AsmParser
/
LLParser
.
cpp
|
6
+
+
-
-
llvm
/
lib
/
IR
/
ConstantFold
.
cpp
|
29
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
llvm
/
lib
/
IR
/
Constants
.
cpp
|
12
+
+
+
+
+
+
-
-
llvm
/
lib
/
IR
/
Core
.
cpp
|
10
+
+
+
+
+
+
+
.
.
.
/
2004
-
03
-
07
-
FunctionAddressAlignment
.
ll
|
16
+
+
+
+
+
+
+
+
+
+
llvm
/
test
/
Assembler
/
ConstantExprFold
.
ll
|
8
+
+
+
+
+
llvm
/
test
/
Bindings
/
OCaml
/
core
.
ml
|
4
+
+
+
.
.
.
/
InstCombine
/
constant
-
fold
-
alias
.
ll
|
26
+
+
+
+
+
+
+
+
+
+
-
-
-
-
-
-
-
.
.
.
/
Transforms
/
InstCombine
/
select
-
and
-
or
.
ll
|
8
+
+
-
-
-
.
.
.
/
InstSimplify
/
ConstProp
/
constant
-
expr
.
ll
|
20
+
+
+
+
+
+
+
+
+
+
+
+
+
llvm
/
unittests
/
IR
/
ConstantsTest
.
cpp
|
11
+
+
+
-
-
-
-
19
files
changed
170
insertions
(
+
)
37
deletions
(
-
)
create
mode
100644
llvm
/
test
/
Assembler
/
2004
-
03
-
07
-
FunctionAddressAlignment
.
ll
diff
-
-
git
a
/
llvm
/
bindings
/
ocaml
/
llvm
/
llvm
.
ml
b
/
llvm
/
bindings
/
ocaml
/
llvm
/
llvm
.
ml
index
a768d10d5d4d
.
.
77de9a6e46fa
100644
-
-
-
a
/
llvm
/
bindings
/
ocaml
/
llvm
/
llvm
.
ml
+
+
+
b
/
llvm
/
bindings
/
ocaml
/
llvm
/
llvm
.
ml
-
648
6
+
648
8
external
const_nuw_sub
:
llvalue
-
>
llvalue
-
>
llvalue
=
"
llvm_const_nuw_sub
"
external
const_mul
:
llvalue
-
>
llvalue
-
>
llvalue
=
"
llvm_const_mul
"
external
const_nsw_mul
:
llvalue
-
>
llvalue
-
>
llvalue
=
"
llvm_const_nsw_mul
"
external
const_nuw_mul
:
llvalue
-
>
llvalue
-
>
llvalue
=
"
llvm_const_nuw_mul
"
+
external
const_and
:
llvalue
-
>
llvalue
-
>
llvalue
=
"
llvm_const_and
"
+
external
const_or
:
llvalue
-
>
llvalue
-
>
llvalue
=
"
llvm_const_or
"
external
const_xor
:
llvalue
-
>
llvalue
-
>
llvalue
=
"
llvm_const_xor
"
external
const_icmp
:
Icmp
.
t
-
>
llvalue
-
>
llvalue
-
>
llvalue
=
"
llvm_const_icmp
"
diff
-
-
git
a
/
llvm
/
bindings
/
ocaml
/
llvm
/
llvm
.
mli
b
/
llvm
/
bindings
/
ocaml
/
llvm
/
llvm
.
mli
index
4ec760a44571
.
.
9c8b3b883e14
100644
-
-
-
a
/
llvm
/
bindings
/
ocaml
/
llvm
/
llvm
.
mli
+
+
+
b
/
llvm
/
bindings
/
ocaml
/
llvm
/
llvm
.
mli
-
1125
6
+
1125
16
val
const_nsw_mul
:
llvalue
-
>
llvalue
-
>
llvalue
See
the
method
[
llvm
:
:
ConstantExpr
:
:
getNSWMul
]
.
*
)
val
const_nuw_mul
:
llvalue
-
>
llvalue
-
>
llvalue
+
(
*
*
[
const_and
c1
c2
]
returns
the
constant
bitwise
[
AND
]
of
two
integer
+
constants
.
+
See
the
method
[
llvm
:
:
ConstantExpr
:
:
getAnd
]
.
*
)
+
val
const_and
:
llvalue
-
>
llvalue
-
>
llvalue
+
+
(
*
*
[
const_or
c1
c2
]
returns
the
constant
bitwise
[
OR
]
of
two
integer
+
constants
.
+
See
the
method
[
llvm
:
:
ConstantExpr
:
:
getOr
]
.
*
)
+
val
const_or
:
llvalue
-
>
llvalue
-
>
llvalue
+
(
*
*
[
const_xor
c1
c2
]
returns
the
constant
bitwise
[
XOR
]
of
two
integer
constants
.
See
the
method
[
llvm
:
:
ConstantExpr
:
:
getXor
]
.
*
)
diff
-
-
git
a
/
llvm
/
bindings
/
ocaml
/
llvm
/
llvm_ocaml
.
c
b
/
llvm
/
bindings
/
ocaml
/
llvm
/
llvm_ocaml
.
c
index
f0e47a31af03
.
.
0154b2f49c25
100644
-
-
-
a
/
llvm
/
bindings
/
ocaml
/
llvm
/
llvm_ocaml
.
c
+
+
+
b
/
llvm
/
bindings
/
ocaml
/
llvm
/
llvm_ocaml
.
c
-
1209
6
+
1209
18
value
llvm_const_nuw_mul
(
value
LHS
value
RHS
)
{
return
to_val
(
Value
)
;
}
+
/
*
llvalue
-
>
llvalue
-
>
llvalue
*
/
+
value
llvm_const_and
(
value
LHS
value
RHS
)
{
+
LLVMValueRef
Value
=
LLVMConstAnd
(
Value_val
(
LHS
)
Value_val
(
RHS
)
)
;
+
return
to_val
(
Value
)
;
+
}
+
+
/
*
llvalue
-
>
llvalue
-
>
llvalue
*
/
+
value
llvm_const_or
(
value
LHS
value
RHS
)
{
+
LLVMValueRef
Value
=
LLVMConstOr
(
Value_val
(
LHS
)
Value_val
(
RHS
)
)
;
+
return
to_val
(
Value
)
;
+
}
+
/
*
llvalue
-
>
llvalue
-
>
llvalue
*
/
value
llvm_const_xor
(
value
LHS
value
RHS
)
{
LLVMValueRef
Value
=
LLVMConstXor
(
Value_val
(
LHS
)
Value_val
(
RHS
)
)
;
diff
-
-
git
a
/
llvm
/
docs
/
LangRef
.
rst
b
/
llvm
/
docs
/
LangRef
.
rst
index
dc5c84de420d
.
.
9fd672fde82b
100644
-
-
-
a
/
llvm
/
docs
/
LangRef
.
rst
+
+
+
b
/
llvm
/
docs
/
LangRef
.
rst
-
4638
6
+
4638
10
The
following
is
the
syntax
for
constant
expressions
:
Perform
a
logical
right
shift
on
constants
.
ashr
(
LHS
RHS
)
Perform
an
arithmetic
right
shift
on
constants
.
+
and
(
LHS
RHS
)
+
Perform
a
bitwise
and
on
constants
.
+
or
(
LHS
RHS
)
+
Perform
a
bitwise
or
on
constants
.
xor
(
LHS
RHS
)
Perform
a
bitwise
xor
on
constants
.
diff
-
-
git
a
/
llvm
/
docs
/
ReleaseNotes
.
rst
b
/
llvm
/
docs
/
ReleaseNotes
.
rst
index
533c93e62e5e
.
.
3a76959ca564
100644
-
-
-
a
/
llvm
/
docs
/
ReleaseNotes
.
rst
+
+
+
b
/
llvm
/
docs
/
ReleaseNotes
.
rst
-
52
11
+
52
6
Changes
to
the
LLVM
IR
*
The
llvm
.
stacksave
and
llvm
.
stackrestore
intrinsics
now
use
an
overloaded
pointer
type
to
support
non
-
0
address
spaces
.
-
*
The
constant
expression
variants
of
the
following
instructions
have
been
-
removed
:
-
-
*
and
-
*
or
*
Added
llvm
.
exp10
intrinsic
.
-
135
13
+
130
6
Changes
to
the
C
API
*
Added
LLVMGetTailCallKind
and
LLVMSetTailCallKind
to
allow
getting
and
setting
tail
musttail
and
notail
attributes
on
call
instructions
.
-
*
The
following
functions
for
creating
constant
expressions
have
been
removed
-
because
the
underlying
constant
expressions
are
no
longer
supported
.
Instead
-
an
instruction
should
be
created
using
the
LLVMBuildXYZ
APIs
which
will
-
constant
fold
the
operands
if
possible
and
create
an
instruction
otherwise
:
-
-
*
LLVMConstAnd
-
*
LLVMConstOr
Changes
to
the
CodeGen
infrastructure
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
diff
-
-
git
a
/
llvm
/
include
/
llvm
-
c
/
Core
.
h
b
/
llvm
/
include
/
llvm
-
c
/
Core
.
h
index
7ee46cac4304
.
.
35c58caee786
100644
-
-
-
a
/
llvm
/
include
/
llvm
-
c
/
Core
.
h
+
+
+
b
/
llvm
/
include
/
llvm
-
c
/
Core
.
h
-
2276
6
+
2276
8
LLVMValueRef
LLVMConstNUWSub
(
LLVMValueRef
LHSConstant
LLVMValueRef
RHSConstant
)
LLVMValueRef
LLVMConstMul
(
LLVMValueRef
LHSConstant
LLVMValueRef
RHSConstant
)
;
LLVMValueRef
LLVMConstNSWMul
(
LLVMValueRef
LHSConstant
LLVMValueRef
RHSConstant
)
;
LLVMValueRef
LLVMConstNUWMul
(
LLVMValueRef
LHSConstant
LLVMValueRef
RHSConstant
)
;
+
LLVMValueRef
LLVMConstAnd
(
LLVMValueRef
LHSConstant
LLVMValueRef
RHSConstant
)
;
+
LLVMValueRef
LLVMConstOr
(
LLVMValueRef
LHSConstant
LLVMValueRef
RHSConstant
)
;
LLVMValueRef
LLVMConstXor
(
LLVMValueRef
LHSConstant
LLVMValueRef
RHSConstant
)
;
LLVMValueRef
LLVMConstICmp
(
LLVMIntPredicate
Predicate
LLVMValueRef
LHSConstant
LLVMValueRef
RHSConstant
)
;
diff
-
-
git
a
/
llvm
/
include
/
llvm
/
IR
/
Constants
.
h
b
/
llvm
/
include
/
llvm
/
IR
/
Constants
.
h
index
710a9142d5f7
.
.
94940c816179
100644
-
-
-
a
/
llvm
/
include
/
llvm
/
IR
/
Constants
.
h
+
+
+
b
/
llvm
/
include
/
llvm
/
IR
/
Constants
.
h
-
1035
6
+
1035
8
public
:
bool
HasNSW
=
false
)
;
static
Constant
*
getMul
(
Constant
*
C1
Constant
*
C2
bool
HasNUW
=
false
bool
HasNSW
=
false
)
;
+
static
Constant
*
getAnd
(
Constant
*
C1
Constant
*
C2
)
;
+
static
Constant
*
getOr
(
Constant
*
C1
Constant
*
C2
)
;
static
Constant
*
getXor
(
Constant
*
C1
Constant
*
C2
)
;
static
Constant
*
getShl
(
Constant
*
C1
Constant
*
C2
bool
HasNUW
=
false
bool
HasNSW
=
false
)
;
diff
-
-
git
a
/
llvm
/
lib
/
Analysis
/
ConstantFolding
.
cpp
b
/
llvm
/
lib
/
Analysis
/
ConstantFolding
.
cpp
index
ac846ce42c70
.
.
2f3a6d4e06ed
100644
-
-
-
a
/
llvm
/
lib
/
Analysis
/
ConstantFolding
.
cpp
+
+
+
b
/
llvm
/
lib
/
Analysis
/
ConstantFolding
.
cpp
-
1257
6
+
1257
19
Constant
*
llvm
:
:
ConstantFoldCompareInstOperands
(
}
}
+
/
/
icmp
eq
(
or
x
y
)
0
-
>
(
icmp
eq
x
0
)
&
(
icmp
eq
y
0
)
+
/
/
icmp
ne
(
or
x
y
)
0
-
>
(
icmp
ne
x
0
)
|
(
icmp
ne
y
0
)
+
if
(
(
Predicate
=
=
ICmpInst
:
:
ICMP_EQ
|
|
Predicate
=
=
ICmpInst
:
:
ICMP_NE
)
&
&
+
CE0
-
>
getOpcode
(
)
=
=
Instruction
:
:
Or
&
&
Ops1
-
>
isNullValue
(
)
)
{
+
Constant
*
LHS
=
ConstantFoldCompareInstOperands
(
+
Predicate
CE0
-
>
getOperand
(
0
)
Ops1
DL
TLI
)
;
+
Constant
*
RHS
=
ConstantFoldCompareInstOperands
(
+
Predicate
CE0
-
>
getOperand
(
1
)
Ops1
DL
TLI
)
;
+
unsigned
OpC
=
+
Predicate
=
=
ICmpInst
:
:
ICMP_EQ
?
Instruction
:
:
And
:
Instruction
:
:
Or
;
+
return
ConstantFoldBinaryOpOperands
(
OpC
LHS
RHS
DL
)
;
+
}
+
/
/
Convert
pointer
comparison
(
base
+
offset1
)
pred
(
base
+
offset2
)
into
/
/
offset1
pred
offset2
for
the
case
where
the
offset
is
inbounds
.
This
/
/
only
works
for
equality
and
unsigned
comparison
as
inbounds
permits
diff
-
-
git
a
/
llvm
/
lib
/
AsmParser
/
LLParser
.
cpp
b
/
llvm
/
lib
/
AsmParser
/
LLParser
.
cpp
index
f1f0cdf746ee
.
.
38c541663c42
100644
-
-
-
a
/
llvm
/
lib
/
AsmParser
/
LLParser
.
cpp
+
+
+
b
/
llvm
/
lib
/
AsmParser
/
LLParser
.
cpp
-
3856
10
+
3856
6
bool
LLParser
:
:
parseValID
(
ValID
&
ID
PerFunctionState
*
PFS
Type
*
ExpectedTy
)
{
return
error
(
ID
.
Loc
"
fdiv
constexprs
are
no
longer
supported
"
)
;
case
lltok
:
:
kw_frem
:
return
error
(
ID
.
Loc
"
frem
constexprs
are
no
longer
supported
"
)
;
-
case
lltok
:
:
kw_and
:
-
return
error
(
ID
.
Loc
"
and
constexprs
are
no
longer
supported
"
)
;
-
case
lltok
:
:
kw_or
:
-
return
error
(
ID
.
Loc
"
or
constexprs
are
no
longer
supported
"
)
;
case
lltok
:
:
kw_fneg
:
return
error
(
ID
.
Loc
"
fneg
constexprs
are
no
longer
supported
"
)
;
case
lltok
:
:
kw_select
:
-
3968
6
+
3964
8
bool
LLParser
:
:
parseValID
(
ValID
&
ID
PerFunctionState
*
PFS
Type
*
ExpectedTy
)
{
}
/
/
Logical
Operations
+
case
lltok
:
:
kw_and
:
+
case
lltok
:
:
kw_or
:
case
lltok
:
:
kw_xor
:
{
unsigned
Opc
=
Lex
.
getUIntVal
(
)
;
Constant
*
Val0
*
Val1
;
diff
-
-
git
a
/
llvm
/
lib
/
IR
/
ConstantFold
.
cpp
b
/
llvm
/
lib
/
IR
/
ConstantFold
.
cpp
index
f9644079f2d2
.
.
04e4217beb08
100644
-
-
-
a
/
llvm
/
lib
/
IR
/
ConstantFold
.
cpp
+
+
+
b
/
llvm
/
lib
/
IR
/
ConstantFold
.
cpp
-
213
6
+
213
35
static
Constant
*
ExtractConstantBytes
(
Constant
*
C
unsigned
ByteStart
switch
(
CE
-
>
getOpcode
(
)
)
{
default
:
return
nullptr
;
+
case
Instruction
:
:
Or
:
{
+
Constant
*
RHS
=
ExtractConstantBytes
(
CE
-
>
getOperand
(
1
)
ByteStart
ByteSize
)
;
+
if
(
!
RHS
)
+
return
nullptr
;
+
+
/
/
X
|
-
1
-
>
-
1
.
+
if
(
ConstantInt
*
RHSC
=
dyn_cast
<
ConstantInt
>
(
RHS
)
)
+
if
(
RHSC
-
>
isMinusOne
(
)
)
+
return
RHSC
;
+
+
Constant
*
LHS
=
ExtractConstantBytes
(
CE
-
>
getOperand
(
0
)
ByteStart
ByteSize
)
;
+
if
(
!
LHS
)
+
return
nullptr
;
+
return
ConstantExpr
:
:
getOr
(
LHS
RHS
)
;
+
}
+
case
Instruction
:
:
And
:
{
+
Constant
*
RHS
=
ExtractConstantBytes
(
CE
-
>
getOperand
(
1
)
ByteStart
ByteSize
)
;
+
if
(
!
RHS
)
+
return
nullptr
;
+
+
/
/
X
&
0
-
>
0
.
+
if
(
RHS
-
>
isNullValue
(
)
)
+
return
RHS
;
+
+
Constant
*
LHS
=
ExtractConstantBytes
(
CE
-
>
getOperand
(
0
)
ByteStart
ByteSize
)
;
+
if
(
!
LHS
)
+
return
nullptr
;
+
return
ConstantExpr
:
:
getAnd
(
LHS
RHS
)
;
+
}
case
Instruction
:
:
LShr
:
{
ConstantInt
*
Amt
=
dyn_cast
<
ConstantInt
>
(
CE
-
>
getOperand
(
1
)
)
;
if
(
!
Amt
)
diff
-
-
git
a
/
llvm
/
lib
/
IR
/
Constants
.
cpp
b
/
llvm
/
lib
/
IR
/
Constants
.
cpp
index
6589bd33be76
.
.
c9b94ba647c7
100644
-
-
-
a
/
llvm
/
lib
/
IR
/
Constants
.
cpp
+
+
+
b
/
llvm
/
lib
/
IR
/
Constants
.
cpp
-
2315
8
+
2315
6
bool
ConstantExpr
:
:
isSupportedBinOp
(
unsigned
Opcode
)
{
case
Instruction
:
:
FMul
:
case
Instruction
:
:
FDiv
:
case
Instruction
:
:
FRem
:
-
case
Instruction
:
:
And
:
-
case
Instruction
:
:
Or
:
return
false
;
case
Instruction
:
:
Add
:
case
Instruction
:
:
Sub
:
-
2324
6
+
2322
8
bool
ConstantExpr
:
:
isSupportedBinOp
(
unsigned
Opcode
)
{
case
Instruction
:
:
Shl
:
case
Instruction
:
:
LShr
:
case
Instruction
:
:
AShr
:
+
case
Instruction
:
:
And
:
+
case
Instruction
:
:
Or
:
case
Instruction
:
:
Xor
:
return
true
;
default
:
-
2584
6
+
2584
14
Constant
*
ConstantExpr
:
:
getMul
(
Constant
*
C1
Constant
*
C2
return
get
(
Instruction
:
:
Mul
C1
C2
Flags
)
;
}
+
Constant
*
ConstantExpr
:
:
getAnd
(
Constant
*
C1
Constant
*
C2
)
{
+
return
get
(
Instruction
:
:
And
C1
C2
)
;
+
}
+
+
Constant
*
ConstantExpr
:
:
getOr
(
Constant
*
C1
Constant
*
C2
)
{
+
return
get
(
Instruction
:
:
Or
C1
C2
)
;
+
}
+
Constant
*
ConstantExpr
:
:
getXor
(
Constant
*
C1
Constant
*
C2
)
{
return
get
(
Instruction
:
:
Xor
C1
C2
)
;
}
diff
-
-
git
a
/
llvm
/
lib
/
IR
/
Core
.
cpp
b
/
llvm
/
lib
/
IR
/
Core
.
cpp
index
17093fa0ac4e
.
.
207d57ecc8b2
100644
-
-
-
a
/
llvm
/
lib
/
IR
/
Core
.
cpp
+
+
+
b
/
llvm
/
lib
/
IR
/
Core
.
cpp
-
1688
6
+
1688
16
LLVMValueRef
LLVMConstNUWMul
(
LLVMValueRef
LHSConstant
unwrap
<
Constant
>
(
RHSConstant
)
)
)
;
}
+
LLVMValueRef
LLVMConstAnd
(
LLVMValueRef
LHSConstant
LLVMValueRef
RHSConstant
)
{
+
return
wrap
(
ConstantExpr
:
:
getAnd
(
unwrap
<
Constant
>
(
LHSConstant
)
+
unwrap
<
Constant
>
(
RHSConstant
)
)
)
;
+
}
+
+
LLVMValueRef
LLVMConstOr
(
LLVMValueRef
LHSConstant
LLVMValueRef
RHSConstant
)
{
+
return
wrap
(
ConstantExpr
:
:
getOr
(
unwrap
<
Constant
>
(
LHSConstant
)
+
unwrap
<
Constant
>
(
RHSConstant
)
)
)
;
+
}
+
LLVMValueRef
LLVMConstXor
(
LLVMValueRef
LHSConstant
LLVMValueRef
RHSConstant
)
{
return
wrap
(
ConstantExpr
:
:
getXor
(
unwrap
<
Constant
>
(
LHSConstant
)
unwrap
<
Constant
>
(
RHSConstant
)
)
)
;
diff
-
-
git
a
/
llvm
/
test
/
Assembler
/
2004
-
03
-
07
-
FunctionAddressAlignment
.
ll
b
/
llvm
/
test
/
Assembler
/
2004
-
03
-
07
-
FunctionAddressAlignment
.
ll
new
file
mode
100644
index
000000000000
.
.
5479500f3fd9
-
-
-
/
dev
/
null
+
+
+
b
/
llvm
/
test
/
Assembler
/
2004
-
03
-
07
-
FunctionAddressAlignment
.
ll
-
0
0
+
1
16
+
;
RUN
:
llvm
-
as
<
%
s
|
llvm
-
dis
|
not
grep
ptrtoint
+
;
RUN
:
verify
-
uselistorder
%
s
+
;
All
of
these
should
be
eliminable
+
+
+
define
i32
foo
(
)
{
+
ret
i32
and
(
i32
ptrtoint
(
ptr
foo
to
i32
)
i32
1
)
+
}
+
+
define
i32
foo2
(
)
{
+
ret
i32
and
(
i32
1
i32
ptrtoint
(
ptr
foo2
to
i32
)
)
+
}
+
+
define
i1
foo3
(
)
{
+
ret
i1
icmp
ne
(
ptr
foo3
ptr
null
)
+
}
diff
-
-
git
a
/
llvm
/
test
/
Assembler
/
ConstantExprFold
.
ll
b
/
llvm
/
test
/
Assembler
/
ConstantExprFold
.
ll
index
b7e4075ea9e1
.
.
4eb9cd01f33b
100644
-
-
-
a
/
llvm
/
test
/
Assembler
/
ConstantExprFold
.
ll
+
+
+
b
/
llvm
/
test
/
Assembler
/
ConstantExprFold
.
ll
-
11
6
+
11
9
add
=
global
ptr
inttoptr
(
i64
add
(
i64
ptrtoint
(
ptr
A
to
i64
)
i64
0
)
to
ptr
)
;
X
+
0
=
=
X
sub
=
global
ptr
inttoptr
(
i64
sub
(
i64
ptrtoint
(
ptr
A
to
i64
)
i64
0
)
to
ptr
)
;
X
-
0
=
=
X
mul
=
global
ptr
inttoptr
(
i64
mul
(
i64
ptrtoint
(
ptr
A
to
i64
)
i64
0
)
to
ptr
)
;
X
*
0
=
=
0
+
and1
=
global
ptr
inttoptr
(
i64
and
(
i64
ptrtoint
(
ptr
A
to
i64
)
i64
0
)
to
ptr
)
;
X
&
0
=
=
0
+
and2
=
global
ptr
inttoptr
(
i64
and
(
i64
ptrtoint
(
ptr
A
to
i64
)
i64
-
1
)
to
ptr
)
;
X
&
-
1
=
=
X
+
or
=
global
i64
or
(
i64
ptrtoint
(
ptr
A
to
i64
)
i64
-
1
)
;
X
|
-
1
=
=
-
1
xor
=
global
ptr
inttoptr
(
i64
xor
(
i64
ptrtoint
(
ptr
A
to
i64
)
i64
0
)
to
ptr
)
;
X
^
0
=
=
X
%
Ty
=
type
{
i32
i32
}
-
25
6
+
28
7
;
PR2206
cons
=
weak
global
i32
0
align
8
;
<
ptr
>
[
#
uses
=
1
]
+
and3
=
global
i64
and
(
i64
ptrtoint
(
ptr
cons
to
i64
)
i64
7
)
gep1
=
global
<
2
x
ptr
>
getelementptr
(
i8
<
2
x
ptr
>
undef
<
2
x
i64
>
<
i64
1
i64
1
>
)
gep2
=
global
<
2
x
ptr
>
getelementptr
(
{
i8
}
<
2
x
ptr
>
undef
<
2
x
i64
>
<
i64
1
i64
1
>
<
2
x
i32
>
<
i32
0
i32
0
>
)
-
38
12
+
42
16
;
CHECK
:
[
[
ADD
:
[
a
-
zA
-
Z0
-
9_
"
\
\
.
-
]
+
]
]
=
global
ptr
A
;
CHECK
:
[
[
SUB
:
[
a
-
zA
-
Z0
-
9_
"
\
\
.
-
]
+
]
]
=
global
ptr
A
;
CHECK
:
[
[
MUL
:
[
a
-
zA
-
Z0
-
9_
"
\
\
.
-
]
+
]
]
=
global
ptr
null
+
;
CHECK
:
[
[
AND1
:
[
a
-
zA
-
Z0
-
9_
"
\
\
.
-
]
+
]
]
=
global
ptr
null
+
;
CHECK
:
[
[
AND2
:
[
a
-
zA
-
Z0
-
9_
"
\
\
.
-
]
+
]
]
=
global
ptr
A
+
;
CHECK
:
[
[
OR
:
[
a
-
zA
-
Z0
-
9_
"
\
\
.
-
]
+
]
]
=
global
i64
-
1
;
CHECK
:
[
[
XOR
:
[
a
-
zA
-
Z0
-
9_
"
\
\
.
-
]
+
]
]
=
global
ptr
A
;
CHECK
:
[
[
B
:
[
a
-
zA
-
Z0
-
9_
"
\
\
.
-
]
+
]
]
=
external
global
[
[
TY
:
%
.
*
]
]
;
CHECK
:
[
[
ICMP_ULT1
:
[
a
-
zA
-
Z0
-
9_
"
\
\
.
-
]
+
]
]
=
global
i1
icmp
ugt
(
ptr
getelementptr
inbounds
(
i64
ptr
A
i64
1
)
ptr
A
)
;
CHECK
:
[
[
ICMP_SLT
:
[
a
-
zA
-
Z0
-
9_
"
\
\
.
-
]
+
]
]
=
global
i1
false
;
CHECK
:
[
[
ICMP_ULT2
:
[
a
-
zA
-
Z0
-
9_
"
\
\
.
-
]
+
]
]
=
global
i1
icmp
ugt
(
ptr
getelementptr
inbounds
(
[
[
TY
:
%
.
*
]
]
ptr
B
i64
0
i32
1
)
ptr
B
)
;
CHECK
:
[
[
CONS
:
[
a
-
zA
-
Z0
-
9_
"
\
\
.
-
]
+
]
]
=
weak
global
i32
0
align
8
+
;
CHECK
:
[
[
AND3
:
[
a
-
zA
-
Z0
-
9_
"
\
\
.
-
]
+
]
]
=
global
i64
0
;
CHECK
:
[
[
GEP1
:
[
a
-
zA
-
Z0
-
9_
"
\
\
.
-
]
+
]
]
=
global
<
2
x
ptr
>
undef
;
CHECK
:
[
[
GEP2
:
[
a
-
zA
-
Z0
-
9_
"
\
\
.
-
]
+
]
]
=
global
<
2
x
ptr
>
undef
;
CHECK
:
[
[
GEP3
:
[
a
-
zA
-
Z0
-
9_
"
\
\
.
-
]
+
]
]
=
global
<
2
x
ptr
>
zeroinitializer
diff
-
-
git
a
/
llvm
/
test
/
Bindings
/
OCaml
/
core
.
ml
b
/
llvm
/
test
/
Bindings
/
OCaml
/
core
.
ml
index
3a9c3c84238d
.
.
d2dd52c07608
100644
-
-
-
a
/
llvm
/
test
/
Bindings
/
OCaml
/
core
.
ml
+
+
+
b
/
llvm
/
test
/
Bindings
/
OCaml
/
core
.
ml
-
263
6
+
263
8
let
test_constants
(
)
=
*
CHECK
:
const_mul
=
global
i64
mul
*
CHECK
:
const_nsw_mul
=
global
i64
mul
nsw
*
CHECK
:
const_nuw_mul
=
global
i64
mul
nuw
+
*
CHECK
:
const_and
=
global
i64
and
+
*
CHECK
:
const_or
=
global
i64
or
*
CHECK
:
const_xor
=
global
i64
xor
*
CHECK
:
const_icmp
=
global
i1
icmp
sle
*
CHECK
:
const_fcmp
=
global
i1
fcmp
ole
-
286
6
+
288
8
let
test_constants
(
)
=
ignore
(
define_global
"
const_mul
"
(
const_mul
foldbomb
five
)
m
)
;
ignore
(
define_global
"
const_nsw_mul
"
(
const_nsw_mul
foldbomb
five
)
m
)
;
ignore
(
define_global
"
const_nuw_mul
"
(
const_nuw_mul
foldbomb
five
)
m
)
;
+
ignore
(
define_global
"
const_and
"
(
const_and
foldbomb
five
)
m
)
;
+
ignore
(
define_global
"
const_or
"
(
const_or
foldbomb
five
)
m
)
;
ignore
(
define_global
"
const_xor
"
(
const_xor
foldbomb
five
)
m
)
;
ignore
(
define_global
"
const_icmp
"
(
const_icmp
Icmp
.
Sle
foldbomb
five
)
m
)
;
ignore
(
define_global
"
const_fcmp
"
(
const_fcmp
Fcmp
.
Ole
ffoldbomb
ffive
)
m
)
;
diff
-
-
git
a
/
llvm
/
test
/
Transforms
/
InstCombine
/
constant
-
fold
-
alias
.
ll
b
/
llvm
/
test
/
Transforms
/
InstCombine
/
constant
-
fold
-
alias
.
ll
index
abca77ec2be7
.
.
4aee78e71ef6
100644
-
-
-
a
/
llvm
/
test
/
Transforms
/
InstCombine
/
constant
-
fold
-
alias
.
ll
+
+
+
b
/
llvm
/
test
/
Transforms
/
InstCombine
/
constant
-
fold
-
alias
.
ll
-
8
15
+
8
14
target
datalayout
=
"
e
-
p1
:
16
:
16
-
p2
:
32
:
32
-
p3
:
64
:
64
"
G3
=
global
[
4
x
i8
]
zeroinitializer
align
1
A1
=
alias
i32
getelementptr
inbounds
(
[
4
x
i8
]
ptr
G3
i32
0
i32
2
)
+
A2
=
alias
i32
inttoptr
(
i64
and
(
i64
ptrtoint
(
ptr
getelementptr
inbounds
(
[
4
x
i8
]
ptr
G3
i32
0
i32
3
)
to
i64
)
i64
-
4
)
to
ptr
)
define
i64
f1
(
)
{
;
This
cannot
be
constant
folded
because
G1
is
underaligned
.
;
CHECK
-
LABEL
:
define
i64
f1
(
)
{
-
;
CHECK
-
NEXT
:
[
[
AND
:
%
.
*
]
]
=
and
i64
ptrtoint
(
ptr
G1
to
i64
)
1
-
;
CHECK
-
NEXT
:
ret
i64
[
[
AND
]
]
+
;
CHECK
-
NEXT
:
ret
i64
and
(
i64
ptrtoint
(
ptr
G1
to
i64
)
i64
1
)
;
-
%
and
=
and
i64
ptrtoint
(
ptr
G1
to
i64
)
1
-
ret
i64
%
and
+
ret
i64
and
(
i64
ptrtoint
(
ptr
G1
to
i64
)
i64
1
)
}
define
i64
f2
(
)
{
-
24
16
+
23
23
define
i64
f2
(
)
{
;
CHECK
-
LABEL
:
define
i64
f2
(
)
{
;
CHECK
-
NEXT
:
ret
i64
0
;
-
%
and
=
and
i64
ptrtoint
(
ptr
G2
to
i64
)
1
-
ret
i64
%
and
+
ret
i64
and
(
i64
ptrtoint
(
ptr
G2
to
i64
)
i64
1
)
}
define
i64
g1
(
)
{
;
This
cannot
be
constant
folded
because
A1
aliases
G3
which
is
underalaigned
.
;
CHECK
-
LABEL
:
define
i64
g1
(
)
{
-
;
CHECK
-
NEXT
:
[
[
AND
:
%
.
*
]
]
=
and
i64
ptrtoint
(
ptr
A1
to
i64
)
1
-
;
CHECK
-
NEXT
:
ret
i64
[
[
AND
]
]
+
;
CHECK
-
NEXT
:
ret
i64
and
(
i64
ptrtoint
(
ptr
A1
to
i64
)
i64
1
)
;
-
%
and
=
and
i64
ptrtoint
(
ptr
A1
to
i64
)
1
-
ret
i64
%
and
+
ret
i64
and
(
i64
ptrtoint
(
ptr
A1
to
i64
)
i64
1
)
}
+
+
define
i64
g2
(
)
{
+
;
While
A2
also
aliases
G3
which
is
underaligned
the
math
of
A2
forces
a
+
;
certain
alignment
allowing
this
to
fold
to
zero
.
+
;
CHECK
-
LABEL
:
define
i64
g2
(
)
{
+
;
CHECK
-
NEXT
:
ret
i64
0
+
;
+
ret
i64
and
(
i64
ptrtoint
(
ptr
A2
to
i64
)
i64
1
)
+
}
+
diff
-
-
git
a
/
llvm
/
test
/
Transforms
/
InstCombine
/
select
-
and
-
or
.
ll
b
/
llvm
/
test
/
Transforms
/
InstCombine
/
select
-
and
-
or
.
ll
index
fb78f0affcb8
.
.
daaf1005ac04
100644
-
-
-
a
/
llvm
/
test
/
Transforms
/
InstCombine
/
select
-
and
-
or
.
ll
+
+
+
b
/
llvm
/
test
/
Transforms
/
InstCombine
/
select
-
and
-
or
.
ll
-
431
11
+
431
11
define
i1
not_false_not_use3
(
i1
%
x
i1
%
y
)
{
define
i1
demorgan_select_infloop1
(
i1
%
L
)
{
;
CHECK
-
LABEL
:
demorgan_select_infloop1
(
;
CHECK
-
NEXT
:
[
[
NOT_L
:
%
.
*
]
]
=
xor
i1
[
[
L
:
%
.
*
]
]
true
-
;
CHECK
-
NEXT
:
[
[
C15
:
%
.
*
]
]
=
select
i1
[
[
NOT_L
]
]
i1
xor
(
i1
icmp
eq
(
ptr
getelementptr
inbounds
(
i16
ptr
g2
i64
1
)
ptr
g1
)
i1
icmp
eq
(
ptr
getelementptr
inbounds
(
i16
ptr
g2
i64
1
)
ptr
g1
)
)
i1
false
+
;
CHECK
-
NEXT
:
[
[
C15
:
%
.
*
]
]
=
select
i1
[
[
NOT_L
]
]
i1
xor
(
i1
and
(
i1
icmp
eq
(
ptr
getelementptr
inbounds
(
i16
ptr
g2
i64
1
)
ptr
g1
)
i1
icmp
ne
(
ptr
getelementptr
inbounds
(
i16
ptr
g2
i64
1
)
ptr
g1
)
)
i1
true
)
i1
false
;
CHECK
-
NEXT
:
ret
i1
[
[
C15
]
]
;
%
not
.
L
=
xor
i1
%
L
true
-
%
C15
=
select
i1
%
not
.
L
i1
xor
(
i1
add
(
i1
icmp
eq
(
ptr
getelementptr
inbounds
(
i16
ptr
g2
i64
1
)
ptr
g1
)
i1
icmp
ne
(
ptr
getelementptr
inbounds
(
i16
ptr
g2
i64
1
)
ptr
g1
)
)
i1
true
)
i1
false
+
%
C15
=
select
i1
%
not
.
L
i1
xor
(
i1
and
(
i1
icmp
eq
(
ptr
getelementptr
inbounds
(
i16
ptr
g2
i64
1
)
ptr
g1
)
i1
icmp
ne
(
ptr
getelementptr
inbounds
(
i16
ptr
g2
i64
1
)
ptr
g1
)
)
i1
true
)
i1
false
ret
i1
%
C15
}
-
443
11
+
443
11
define
i1
demorgan_select_infloop1
(
i1
%
L
)
{
define
i1
demorgan_select_infloop2
(
i1
%
L
)
{
;
CHECK
-
LABEL
:
demorgan_select_infloop2
(
;
CHECK
-
NEXT
:
[
[
NOT_L
:
%
.
*
]
]
=
xor
i1
[
[
L
:
%
.
*
]
]
true
-
;
CHECK
-
NEXT
:
[
[
C15
:
%
.
*
]
]
=
select
i1
[
[
NOT_L
]
]
i1
true
i1
xor
(
i1
icmp
eq
(
ptr
getelementptr
inbounds
(
i16
ptr
g2
i64
1
)
ptr
g1
)
i1
icmp
eq
(
ptr
getelementptr
inbounds
(
i16
ptr
g2
i64
1
)
ptr
g1
)
)
+
;
CHECK
-
NEXT
:
[
[
C15
:
%
.
*
]
]
=
select
i1
[
[
NOT_L
]
]
i1
true
i1
xor
(
i1
and
(
i1
icmp
eq
(
ptr
getelementptr
inbounds
(
i16
ptr
g2
i64
1
)
ptr
g1
)
i1
icmp
ne
(
ptr
getelementptr
inbounds
(
i16
ptr
g2
i64
1
)
ptr
g1
)
)
i1
true
)
;
CHECK
-
NEXT
:
ret
i1
[
[
C15
]
]
;
%
not
.
L
=
xor
i1
%
L
true
-
%
C15
=
select
i1
%
not
.
L
i1
true
i1
xor
(
i1
add
(
i1
icmp
eq
(
ptr
getelementptr
inbounds
(
i16
ptr
g2
i64
1
)
ptr
g1
)
i1
icmp
ne
(
ptr
getelementptr
inbounds
(
i16
ptr
g2
i64
1
)
ptr
g1
)
)
i1
true
)
+
%
C15
=
select
i1
%
not
.
L
i1
true
i1
xor
(
i1
and
(
i1
icmp
eq
(
ptr
getelementptr
inbounds
(
i16
ptr
g2
i64
1
)
ptr
g1
)
i1
icmp
ne
(
ptr
getelementptr
inbounds
(
i16
ptr
g2
i64
1
)
ptr
g1
)
)
i1
true
)
ret
i1
%
C15
}
diff
-
-
git
a
/
llvm
/
test
/
Transforms
/
InstSimplify
/
ConstProp
/
constant
-
expr
.
ll
b
/
llvm
/
test
/
Transforms
/
InstSimplify
/
ConstProp
/
constant
-
expr
.
ll
index
7634a4a120f6
.
.
55ee7b3a6cad
100644
-
-
-
a
/
llvm
/
test
/
Transforms
/
InstSimplify
/
ConstProp
/
constant
-
expr
.
ll
+
+
+
b
/
llvm
/
test
/
Transforms
/
InstSimplify
/
ConstProp
/
constant
-
expr
.
ll
-
31
6
+
31
26
O
=
global
i1
icmp
eq
(
i32
zext
(
i1
icmp
ult
(
ptr
X
ptr
Y
)
to
i32
)
i32
0
)
;
CHECK
:
O
=
global
i1
icmp
uge
(
ptr
X
ptr
Y
)
+
+
+
;
PR5176
+
+
;
CHECK
:
T1
=
global
i1
true
+
T1
=
global
i1
icmp
eq
(
i64
and
(
i64
trunc
(
i256
lshr
(
i256
or
(
i256
and
(
i256
and
(
i256
shl
(
i256
zext
(
i64
ptrtoint
(
ptr
B
to
i64
)
to
i256
)
i256
64
)
i256
-
6277101735386680763495507056286727952638980837032266301441
)
i256
6277101735386680763835789423207666416102355444464034512895
)
i256
shl
(
i256
zext
(
i64
ptrtoint
(
ptr
A
to
i64
)
to
i256
)
i256
192
)
)
i256
64
)
to
i64
)
i64
1
)
i64
0
)
+
+
;
CHECK
:
T2
=
global
ptr
B
+
T2
=
global
ptr
inttoptr
(
i64
add
(
i64
trunc
(
i256
lshr
(
i256
or
(
i256
and
(
i256
and
(
i256
shl
(
i256
zext
(
i64
ptrtoint
(
ptr
A
to
i64
)
to
i256
)
i256
64
)
i256
-
6277101735386680763495507056286727952638980837032266301441
)
i256
6277101735386680763835789423207666416102355444464034512895
)
i256
shl
(
i256
zext
(
i64
ptrtoint
(
ptr
B
to
i64
)
to
i256
)
i256
192
)
)
i256
192
)
to
i64
)
i64
trunc
(
i256
lshr
(
i256
or
(
i256
and
(
i256
and
(
i256
shl
(
i256
zext
(
i64
ptrtoint
(
ptr
A
to
i64
)
to
i256
)
i256
64
)
i256
-
6277101735386680763495507056286727952638980837032266301441
)
i256
6277101735386680763835789423207666416102355444464034512895
)
i256
shl
(
i256
zext
(
i64
ptrtoint
(
ptr
B
to
i64
)
to
i256
)
i256
192
)
)
i256
128
)
to
i64
)
)
to
ptr
)
+
+
;
CHECK
:
T3
=
global
i64
add
(
i64
ptrtoint
(
ptr
B
to
i64
)
i64
-
1
)
+
T3
=
global
i64
add
(
i64
trunc
(
i256
lshr
(
i256
or
(
i256
and
(
i256
and
(
i256
shl
(
i256
zext
(
i64
ptrtoint
(
ptr
B
to
i64
)
to
i256
)
i256
64
)
i256
-
6277101735386680763495507056286727952638980837032266301441
)
i256
6277101735386680763835789423207666416102355444464034512895
)
i256
shl
(
i256
zext
(
i64
ptrtoint
(
ptr
A
to
i64
)
to
i256
)
i256
192
)
)
i256
64
)
to
i64
)
i64
-
1
)
+
+
;
CHECK
:
T4
=
global
ptr
B
+
T4
=
global
ptr
inttoptr
(
i64
trunc
(
i256
lshr
(
i256
or
(
i256
and
(
i256
and
(
i256
shl
(
i256
zext
(
i64
ptrtoint
(
ptr
B
to
i64
)
to
i256
)
i256
64
)
i256
-
6277101735386680763495507056286727952638980837032266301441
)
i256
6277101735386680763835789423207666416102355444464034512895
)
i256
shl
(
i256
zext
(
i64
ptrtoint
(
ptr
A
to
i64
)
to
i256
)
i256
192
)
)
i256
64
)
to
i64
)
to
ptr
)
+
+
;
CHECK
:
T5
=
global
ptr
A
+
T5
=
global
ptr
inttoptr
(
i64
add
(
i64
trunc
(
i256
lshr
(
i256
or
(
i256
and
(
i256
and
(
i256
shl
(
i256
zext
(
i64
ptrtoint
(
ptr
B
to
i64
)
to
i256
)
i256
64
)
i256
-
6277101735386680763495507056286727952638980837032266301441
)
i256
6277101735386680763835789423207666416102355444464034512895
)
i256
shl
(
i256
zext
(
i64
ptrtoint
(
ptr
A
to
i64
)
to
i256
)
i256
192
)
)
i256
192
)
to
i64
)
i64
trunc
(
i256
lshr
(
i256
or
(
i256
and
(
i256
and
(
i256
shl
(
i256
zext
(
i64
ptrtoint
(
ptr
B
to
i64
)
to
i256
)
i256
64
)
i256
-
6277101735386680763495507056286727952638980837032266301441
)
i256
6277101735386680763835789423207666416102355444464034512895
)
i256
shl
(
i256
zext
(
i64
ptrtoint
(
ptr
A
to
i64
)
to
i256
)
i256
192
)
)
i256
128
)
to
i64
)
)
to
ptr
)
+
+
;
PR9011
pr9011_1
=
constant
<
4
x
i32
>
zext
(
<
4
x
i8
>
zeroinitializer
to
<
4
x
i32
>
)
diff
-
-
git
a
/
llvm
/
unittests
/
IR
/
ConstantsTest
.
cpp
b
/
llvm
/
unittests
/
IR
/
ConstantsTest
.
cpp
index
e905452f32b3
.
.
57a0a91086a1
100644
-
-
-
a
/
llvm
/
unittests
/
IR
/
ConstantsTest
.
cpp
+
+
+
b
/
llvm
/
unittests
/
IR
/
ConstantsTest
.
cpp
-
241
6
+
241
8
TEST
(
ConstantsTest
AsInstructionsTest
)
{
"
add
nuw
nsw
i32
"
P0STR
"
"
P0STR
)
;
CHECK
(
ConstantExpr
:
:
getSub
(
P0
P0
)
"
sub
i32
"
P0STR
"
"
P0STR
)
;
CHECK
(
ConstantExpr
:
:
getMul
(
P0
P0
)
"
mul
i32
"
P0STR
"
"
P0STR
)
;
+
CHECK
(
ConstantExpr
:
:
getAnd
(
P0
P0
)
"
and
i32
"
P0STR
"
"
P0STR
)
;
+
CHECK
(
ConstantExpr
:
:
getOr
(
P0
P0
)
"
or
i32
"
P0STR
"
"
P0STR
)
;
CHECK
(
ConstantExpr
:
:
getXor
(
P0
P0
)
"
xor
i32
"
P0STR
"
"
P0STR
)
;
CHECK
(
ConstantExpr
:
:
getShl
(
P0
P0
)
"
shl
i32
"
P0STR
"
"
P0STR
)
;
CHECK
(
ConstantExpr
:
:
getShl
(
P0
P0
true
)
"
shl
nuw
i32
"
P0STR
"
"
P0STR
)
;
-
492
9
+
494
9
bool
foldFuncPtrAndConstToNull
(
LLVMContext
&
Context
Module
*
TheModule
Constant
*
TheConstantExpr
(
ConstantExpr
:
:
getPtrToInt
(
Func
ConstantIntType
)
)
;
-
Constant
*
C
=
ConstantFoldBinaryInstruction
(
Instruction
:
:
And
TheConstantExpr
-
TheConstant
)
;
-
bool
Result
=
C
&
&
C
-
>
isNullValue
(
)
;
+
bool
Result
=
+
ConstantExpr
:
:
get
(
Instruction
:
:
And
TheConstantExpr
TheConstant
)
+
-
>
isNullValue
(
)
;
if
(
!
TheModule
)
{
/
/
If
the
Module
exists
then
it
will
delete
the
Function
.
-
580
8
+
582
7
TEST
(
ConstantsTest
FoldGlobalVariablePtr
)
{
Constant
*
TheConstantExpr
(
ConstantExpr
:
:
getPtrToInt
(
Global
.
get
(
)
IntType
)
)
;
-
ASSERT_TRUE
(
ConstantFoldBinaryInstruction
(
Instruction
:
:
And
TheConstantExpr
-
TheConstant
)
+
ASSERT_TRUE
(
ConstantExpr
:
:
get
(
Instruction
:
:
And
TheConstantExpr
TheConstant
)
-
>
isNullValue
(
)
)
;
}
-
-
2
.
41
.
0
.
3
.
g1cb8d410ac
