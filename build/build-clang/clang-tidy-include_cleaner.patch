[
clang
-
tidy
]
Implement
an
include
-
cleaner
check
.
Differential
Revision
:
https
:
/
/
reviews
.
llvm
.
org
/
D148793
diff
-
-
git
a
/
clang
-
tools
-
extra
/
clang
-
tidy
/
misc
/
CMakeLists
.
txt
b
/
clang
-
tools
-
extra
/
clang
-
tidy
/
misc
/
CMakeLists
.
txt
index
a72362906e0b
.
.
b17c45ee7694
100644
-
-
-
a
/
clang
-
tools
-
extra
/
clang
-
tidy
/
misc
/
CMakeLists
.
txt
+
+
+
b
/
clang
-
tools
-
extra
/
clang
-
tidy
/
misc
/
CMakeLists
.
txt
-
7
6
+
7
7
setup_host_tool
(
clang
-
tidy
-
confusable
-
chars
-
gen
CLANG_TIDY_CONFUSABLE_CHARS_GEN
add_subdirectory
(
ConfusableTable
)
+
include_directories
(
BEFORE
"
{
CMAKE_CURRENT_SOURCE_DIR
}
/
.
.
/
.
.
/
include
-
cleaner
/
include
"
)
add_custom_command
(
OUTPUT
Confusables
.
inc
-
19
6
+
20
7
add_clang_library
(
clangTidyMiscModule
ConstCorrectnessCheck
.
cpp
DefinitionsInHeadersCheck
.
cpp
ConfusableIdentifierCheck
.
cpp
+
IncludeCleanerCheck
.
cpp
MiscTidyModule
.
cpp
MisleadingBidirectional
.
cpp
MisleadingIdentifier
.
cpp
-
53
7
+
55
15
clang_target_link_libraries
(
clangTidyMiscModule
clangAST
clangASTMatchers
clangBasic
+
clangFormat
clangLex
clangSerialization
clangTooling
+
clangToolingInclusions
+
clangToolingInclusionsStdlib
)
+
+
target_link_libraries
(
clangTidyMiscModule
+
PRIVATE
+
clangIncludeCleaner
+
)
\
No
newline
at
end
of
file
diff
-
-
git
a
/
clang
-
tools
-
extra
/
clang
-
tidy
/
misc
/
IncludeCleanerCheck
.
cpp
b
/
clang
-
tools
-
extra
/
clang
-
tidy
/
misc
/
IncludeCleanerCheck
.
cpp
new
file
mode
100644
index
000000000000
.
.
c7aca83f2ca8
-
-
-
/
dev
/
null
+
+
+
b
/
clang
-
tools
-
extra
/
clang
-
tidy
/
misc
/
IncludeCleanerCheck
.
cpp
-
0
0
+
1
202
+
/
/
=
=
=
-
-
-
IncludeCleanerCheck
.
cpp
-
clang
-
tidy
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
=
=
=
/
/
+
/
/
+
/
/
Part
of
the
LLVM
Project
under
the
Apache
License
v2
.
0
with
LLVM
Exceptions
.
+
/
/
See
https
:
/
/
llvm
.
org
/
LICENSE
.
txt
for
license
information
.
+
/
/
SPDX
-
License
-
Identifier
:
Apache
-
2
.
0
WITH
LLVM
-
exception
+
/
/
+
/
/
=
=
=
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
=
=
=
/
/
+
+
#
include
"
IncludeCleanerCheck
.
h
"
+
#
include
"
.
.
/
ClangTidyCheck
.
h
"
+
#
include
"
.
.
/
ClangTidyDiagnosticConsumer
.
h
"
+
#
include
"
.
.
/
ClangTidyOptions
.
h
"
+
#
include
"
.
.
/
utils
/
OptionsUtils
.
h
"
+
#
include
"
clang
-
include
-
cleaner
/
Analysis
.
h
"
+
#
include
"
clang
-
include
-
cleaner
/
Record
.
h
"
+
#
include
"
clang
-
include
-
cleaner
/
Types
.
h
"
+
#
include
"
clang
/
AST
/
ASTContext
.
h
"
+
#
include
"
clang
/
AST
/
Decl
.
h
"
+
#
include
"
clang
/
AST
/
DeclBase
.
h
"
+
#
include
"
clang
/
ASTMatchers
/
ASTMatchFinder
.
h
"
+
#
include
"
clang
/
ASTMatchers
/
ASTMatchers
.
h
"
+
#
include
"
clang
/
Basic
/
Diagnostic
.
h
"
+
#
include
"
clang
/
Basic
/
FileEntry
.
h
"
+
#
include
"
clang
/
Basic
/
LLVM
.
h
"
+
#
include
"
clang
/
Basic
/
LangOptions
.
h
"
+
#
include
"
clang
/
Basic
/
SourceLocation
.
h
"
+
#
include
"
clang
/
Format
/
Format
.
h
"
+
#
include
"
clang
/
Lex
/
Preprocessor
.
h
"
+
#
include
"
clang
/
Tooling
/
Core
/
Replacement
.
h
"
+
#
include
"
clang
/
Tooling
/
Inclusions
/
HeaderIncludes
.
h
"
+
#
include
"
llvm
/
ADT
/
DenseSet
.
h
"
+
#
include
"
llvm
/
ADT
/
STLExtras
.
h
"
+
#
include
"
llvm
/
ADT
/
SmallVector
.
h
"
+
#
include
"
llvm
/
ADT
/
StringRef
.
h
"
+
#
include
"
llvm
/
Support
/
ErrorHandling
.
h
"
+
#
include
"
llvm
/
Support
/
Regex
.
h
"
+
#
include
<
optional
>
+
#
include
<
string
>
+
#
include
<
vector
>
+
+
using
namespace
clang
:
:
ast_matchers
;
+
+
namespace
clang
:
:
tidy
:
:
misc
{
+
+
namespace
{
+
struct
MissingIncludeInfo
{
+
SourceLocation
SymRefLocation
;
+
include_cleaner
:
:
Header
Missing
;
+
}
;
+
}
/
/
namespace
+
+
IncludeCleanerCheck
:
:
IncludeCleanerCheck
(
StringRef
Name
+
ClangTidyContext
*
Context
)
+
:
ClangTidyCheck
(
Name
Context
)
+
IgnoreHeaders
(
utils
:
:
options
:
:
parseStringList
(
+
Options
.
getLocalOrGlobal
(
"
IgnoreHeaders
"
"
"
)
)
)
{
+
for
(
const
auto
&
Header
:
IgnoreHeaders
)
{
+
if
(
!
llvm
:
:
Regex
{
Header
}
.
isValid
(
)
)
+
configurationDiag
(
"
Invalid
ignore
headers
regex
'
%
0
'
"
)
<
<
Header
;
+
std
:
:
string
HeaderSuffix
{
Header
.
str
(
)
}
;
+
if
(
!
Header
.
ends_with
(
"
"
)
)
+
HeaderSuffix
+
=
"
"
;
+
IgnoreHeadersRegex
.
emplace_back
(
HeaderSuffix
)
;
+
}
+
}
+
+
void
IncludeCleanerCheck
:
:
storeOptions
(
ClangTidyOptions
:
:
OptionMap
&
Opts
)
{
+
Options
.
store
(
Opts
"
IgnoreHeaders
"
+
utils
:
:
options
:
:
serializeStringList
(
IgnoreHeaders
)
)
;
+
}
+
+
bool
IncludeCleanerCheck
:
:
isLanguageVersionSupported
(
+
const
LangOptions
&
LangOpts
)
const
{
+
return
!
LangOpts
.
ObjC
;
+
}
+
+
void
IncludeCleanerCheck
:
:
registerMatchers
(
MatchFinder
*
Finder
)
{
+
Finder
-
>
addMatcher
(
translationUnitDecl
(
)
.
bind
(
"
top
"
)
this
)
;
+
}
+
+
void
IncludeCleanerCheck
:
:
registerPPCallbacks
(
const
SourceManager
&
SM
+
Preprocessor
*
PP
+
Preprocessor
*
ModuleExpanderPP
)
{
+
PP
-
>
addPPCallbacks
(
RecordedPreprocessor
.
record
(
*
PP
)
)
;
+
HS
=
&
PP
-
>
getHeaderSearchInfo
(
)
;
+
RecordedPI
.
record
(
*
PP
)
;
+
}
+
+
bool
IncludeCleanerCheck
:
:
shouldIgnore
(
const
include_cleaner
:
:
Header
&
H
)
{
+
return
llvm
:
:
any_of
(
IgnoreHeadersRegex
[
&
H
]
(
const
llvm
:
:
Regex
&
R
)
{
+
switch
(
H
.
kind
(
)
)
{
+
case
include_cleaner
:
:
Header
:
:
Standard
:
+
return
R
.
match
(
H
.
standard
(
)
.
name
(
)
)
;
+
case
include_cleaner
:
:
Header
:
:
Verbatim
:
+
return
R
.
match
(
H
.
verbatim
(
)
)
;
+
case
include_cleaner
:
:
Header
:
:
Physical
:
+
return
R
.
match
(
H
.
physical
(
)
-
>
tryGetRealPathName
(
)
)
;
+
}
+
llvm_unreachable
(
"
Unknown
Header
kind
.
"
)
;
+
}
)
;
+
}
+
+
void
IncludeCleanerCheck
:
:
check
(
const
MatchFinder
:
:
MatchResult
&
Result
)
{
+
const
SourceManager
*
SM
=
Result
.
SourceManager
;
+
const
FileEntry
*
MainFile
=
SM
-
>
getFileEntryForID
(
SM
-
>
getMainFileID
(
)
)
;
+
llvm
:
:
DenseSet
<
const
include_cleaner
:
:
Include
*
>
Used
;
+
std
:
:
vector
<
MissingIncludeInfo
>
Missing
;
+
llvm
:
:
SmallVector
<
Decl
*
>
MainFileDecls
;
+
for
(
Decl
*
D
:
Result
.
Nodes
.
getNodeAs
<
TranslationUnitDecl
>
(
"
top
"
)
-
>
decls
(
)
)
{
+
if
(
!
SM
-
>
isWrittenInMainFile
(
SM
-
>
getExpansionLoc
(
D
-
>
getLocation
(
)
)
)
)
+
continue
;
+
/
/
FIXME
:
Filter
out
implicit
template
specializations
.
+
MainFileDecls
.
push_back
(
D
)
;
+
}
+
/
/
FIXME
:
Find
a
way
to
have
less
code
duplication
between
include
-
cleaner
+
/
/
analysis
implementation
and
the
below
code
.
+
walkUsed
(
MainFileDecls
RecordedPreprocessor
.
MacroReferences
&
RecordedPI
+
*
SM
+
[
&
]
(
const
include_cleaner
:
:
SymbolReference
&
Ref
+
llvm
:
:
ArrayRef
<
include_cleaner
:
:
Header
>
Providers
)
{
+
bool
Satisfied
=
false
;
+
for
(
const
include_cleaner
:
:
Header
&
H
:
Providers
)
{
+
if
(
H
.
kind
(
)
=
=
include_cleaner
:
:
Header
:
:
Physical
&
&
+
H
.
physical
(
)
=
=
MainFile
)
+
Satisfied
=
true
;
+
+
for
(
const
include_cleaner
:
:
Include
*
I
:
+
RecordedPreprocessor
.
Includes
.
match
(
H
)
)
{
+
Used
.
insert
(
I
)
;
+
Satisfied
=
true
;
+
}
+
}
+
if
(
!
Satisfied
&
&
!
Providers
.
empty
(
)
&
&
+
Ref
.
RT
=
=
include_cleaner
:
:
RefType
:
:
Explicit
&
&
+
!
shouldIgnore
(
Providers
.
front
(
)
)
)
+
Missing
.
push_back
(
{
Ref
.
RefLocation
Providers
.
front
(
)
}
)
;
+
}
)
;
+
+
std
:
:
vector
<
const
include_cleaner
:
:
Include
*
>
Unused
;
+
for
(
const
include_cleaner
:
:
Include
&
I
:
+
RecordedPreprocessor
.
Includes
.
all
(
)
)
{
+
if
(
Used
.
contains
(
&
I
)
|
|
!
I
.
Resolved
)
+
continue
;
+
if
(
RecordedPI
.
shouldKeep
(
I
.
Line
)
)
+
continue
;
+
/
/
Check
if
main
file
is
the
public
interface
for
a
private
header
.
If
so
+
/
/
we
shouldn
'
t
diagnose
it
as
unused
.
+
if
(
auto
PHeader
=
RecordedPI
.
getPublic
(
I
.
Resolved
)
;
!
PHeader
.
empty
(
)
)
{
+
PHeader
=
PHeader
.
trim
(
"
<
>
\
"
"
)
;
+
/
/
Since
most
private
-
>
public
mappings
happen
in
a
verbatim
way
we
+
/
/
check
textually
here
.
This
might
go
wrong
in
presence
of
symlinks
or
+
/
/
header
mappings
.
But
that
'
s
not
different
than
rest
of
the
places
.
+
if
(
getCurrentMainFile
(
)
.
endswith
(
PHeader
)
)
+
continue
;
+
}
+
+
if
(
llvm
:
:
none_of
(
IgnoreHeadersRegex
+
[
Resolved
=
I
.
Resolved
-
>
tryGetRealPathName
(
)
]
(
+
const
llvm
:
:
Regex
&
R
)
{
return
R
.
match
(
Resolved
)
;
}
)
)
+
Unused
.
push_back
(
&
I
)
;
+
}
+
+
llvm
:
:
StringRef
Code
=
SM
-
>
getBufferData
(
SM
-
>
getMainFileID
(
)
)
;
+
auto
FileStyle
=
+
format
:
:
getStyle
(
format
:
:
DefaultFormatStyle
getCurrentMainFile
(
)
+
format
:
:
DefaultFallbackStyle
Code
+
&
SM
-
>
getFileManager
(
)
.
getVirtualFileSystem
(
)
)
;
+
if
(
!
FileStyle
)
+
FileStyle
=
format
:
:
getLLVMStyle
(
)
;
+
+
for
(
const
auto
*
Inc
:
Unused
)
{
+
diag
(
Inc
-
>
HashLocation
"
included
header
%
0
is
not
used
directly
"
)
+
<
<
Inc
-
>
quote
(
)
+
<
<
FixItHint
:
:
CreateRemoval
(
CharSourceRange
:
:
getCharRange
(
+
SM
-
>
translateLineCol
(
SM
-
>
getMainFileID
(
)
Inc
-
>
Line
1
)
+
SM
-
>
translateLineCol
(
SM
-
>
getMainFileID
(
)
Inc
-
>
Line
+
1
1
)
)
)
;
+
}
+
+
tooling
:
:
HeaderIncludes
HeaderIncludes
(
getCurrentMainFile
(
)
Code
+
FileStyle
-
>
IncludeStyle
)
;
+
for
(
const
auto
&
Inc
:
Missing
)
{
+
std
:
:
string
Spelling
=
+
include_cleaner
:
:
spellHeader
(
Inc
.
Missing
*
HS
MainFile
)
;
+
bool
Angled
=
llvm
:
:
StringRef
{
Spelling
}
.
starts_with
(
"
<
"
)
;
+
/
/
We
might
suggest
insertion
of
an
existing
include
in
edge
cases
e
.
g
.
+
/
/
include
is
present
in
a
PP
-
disabled
region
or
spelling
of
the
header
+
/
/
turns
out
to
be
the
same
as
one
of
the
unresolved
includes
in
the
+
/
/
main
file
.
+
if
(
auto
Replacement
=
+
HeaderIncludes
.
insert
(
llvm
:
:
StringRef
{
Spelling
}
.
trim
(
"
\
"
<
>
"
)
+
Angled
tooling
:
:
IncludeDirective
:
:
Include
)
)
+
diag
(
SM
-
>
getSpellingLoc
(
Inc
.
SymRefLocation
)
+
"
no
header
providing
%
0
is
directly
included
"
)
+
<
<
Spelling
+
<
<
FixItHint
:
:
CreateInsertion
(
+
SM
-
>
getComposedLoc
(
SM
-
>
getMainFileID
(
)
+
Replacement
-
>
getOffset
(
)
)
+
Replacement
-
>
getReplacementText
(
)
)
;
+
}
+
}
+
+
}
/
/
namespace
clang
:
:
tidy
:
:
misc
diff
-
-
git
a
/
clang
-
tools
-
extra
/
clang
-
tidy
/
misc
/
IncludeCleanerCheck
.
h
b
/
clang
-
tools
-
extra
/
clang
-
tidy
/
misc
/
IncludeCleanerCheck
.
h
new
file
mode
100644
index
000000000000
.
.
d5f75f2b1c7f
-
-
-
/
dev
/
null
+
+
+
b
/
clang
-
tools
-
extra
/
clang
-
tidy
/
misc
/
IncludeCleanerCheck
.
h
-
0
0
+
1
53
+
/
/
=
=
=
-
-
-
IncludeCleanerCheck
.
h
-
clang
-
tidy
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
*
-
C
+
+
-
*
-
=
=
=
/
/
+
/
/
+
/
/
Part
of
the
LLVM
Project
under
the
Apache
License
v2
.
0
with
LLVM
Exceptions
.
+
/
/
See
https
:
/
/
llvm
.
org
/
LICENSE
.
txt
for
license
information
.
+
/
/
SPDX
-
License
-
Identifier
:
Apache
-
2
.
0
WITH
LLVM
-
exception
+
/
/
+
/
/
=
=
=
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
=
=
=
/
/
+
+
#
ifndef
LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_MISC_INCLUDECLEANER_H
+
#
define
LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_MISC_INCLUDECLEANER_H
+
+
#
include
"
.
.
/
ClangTidyCheck
.
h
"
+
#
include
"
.
.
/
ClangTidyDiagnosticConsumer
.
h
"
+
#
include
"
.
.
/
ClangTidyOptions
.
h
"
+
#
include
"
clang
-
include
-
cleaner
/
Record
.
h
"
+
#
include
"
clang
-
include
-
cleaner
/
Types
.
h
"
+
#
include
"
clang
/
ASTMatchers
/
ASTMatchFinder
.
h
"
+
#
include
"
clang
/
Basic
/
LLVM
.
h
"
+
#
include
"
clang
/
Basic
/
SourceLocation
.
h
"
+
#
include
"
clang
/
Lex
/
HeaderSearch
.
h
"
+
#
include
"
llvm
/
Support
/
Regex
.
h
"
+
#
include
<
vector
>
+
+
namespace
clang
:
:
tidy
:
:
misc
{
+
+
/
/
/
Checks
for
unused
and
missing
includes
.
Generates
findings
only
for
+
/
/
/
the
main
file
of
a
translation
unit
.
+
/
/
/
Findings
correspond
to
https
:
/
/
clangd
.
llvm
.
org
/
design
/
include
-
cleaner
.
+
/
/
/
+
/
/
/
For
the
user
-
facing
documentation
see
:
+
/
/
/
http
:
/
/
clang
.
llvm
.
org
/
extra
/
clang
-
tidy
/
checks
/
misc
/
include
-
cleaner
.
html
+
class
IncludeCleanerCheck
:
public
ClangTidyCheck
{
+
public
:
+
IncludeCleanerCheck
(
StringRef
Name
ClangTidyContext
*
Context
)
;
+
void
registerMatchers
(
ast_matchers
:
:
MatchFinder
*
Finder
)
override
;
+
void
check
(
const
ast_matchers
:
:
MatchFinder
:
:
MatchResult
&
Result
)
override
;
+
void
registerPPCallbacks
(
const
SourceManager
&
SM
Preprocessor
*
PP
+
Preprocessor
*
ModuleExpanderPP
)
override
;
+
void
storeOptions
(
ClangTidyOptions
:
:
OptionMap
&
Opts
)
override
;
+
bool
isLanguageVersionSupported
(
const
LangOptions
&
LangOpts
)
const
override
;
+
+
private
:
+
include_cleaner
:
:
RecordedPP
RecordedPreprocessor
;
+
include_cleaner
:
:
PragmaIncludes
RecordedPI
;
+
HeaderSearch
*
HS
;
+
std
:
:
vector
<
StringRef
>
IgnoreHeaders
;
+
llvm
:
:
SmallVector
<
llvm
:
:
Regex
>
IgnoreHeadersRegex
;
+
bool
shouldIgnore
(
const
include_cleaner
:
:
Header
&
H
)
;
+
}
;
+
+
}
/
/
namespace
clang
:
:
tidy
:
:
misc
+
+
#
endif
/
/
LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_MISC_INCLUDECLEANER_H
diff
-
-
git
a
/
clang
-
tools
-
extra
/
clang
-
tidy
/
misc
/
MiscTidyModule
.
cpp
b
/
clang
-
tools
-
extra
/
clang
-
tidy
/
misc
/
MiscTidyModule
.
cpp
index
2ec61f891263
.
.
f63c5ab543fe
100644
-
-
-
a
/
clang
-
tools
-
extra
/
clang
-
tidy
/
misc
/
MiscTidyModule
.
cpp
+
+
+
b
/
clang
-
tools
-
extra
/
clang
-
tidy
/
misc
/
MiscTidyModule
.
cpp
-
12
6
+
12
7
#
include
"
ConfusableIdentifierCheck
.
h
"
#
include
"
ConstCorrectnessCheck
.
h
"
#
include
"
DefinitionsInHeadersCheck
.
h
"
+
#
include
"
IncludeCleanerCheck
.
h
"
#
include
"
MisleadingBidirectional
.
h
"
#
include
"
MisleadingIdentifier
.
h
"
#
include
"
MisplacedConstCheck
.
h
"
-
41
6
+
42
7
public
:
"
misc
-
const
-
correctness
"
)
;
CheckFactories
.
registerCheck
<
DefinitionsInHeadersCheck
>
(
"
misc
-
definitions
-
in
-
headers
"
)
;
+
CheckFactories
.
registerCheck
<
IncludeCleanerCheck
>
(
"
misc
-
include
-
cleaner
"
)
;
CheckFactories
.
registerCheck
<
MisleadingBidirectionalCheck
>
(
"
misc
-
misleading
-
bidirectional
"
)
;
CheckFactories
.
registerCheck
<
MisleadingIdentifierCheck
>
(
diff
-
-
git
a
/
clang
-
tools
-
extra
/
clangd
/
Config
.
h
b
/
clang
-
tools
-
extra
/
clangd
/
Config
.
h
index
f41906b2f0fa
.
.
26f55eda3ef0
100644
-
-
-
a
/
clang
-
tools
-
extra
/
clangd
/
Config
.
h
+
+
+
b
/
clang
-
tools
-
extra
/
clangd
/
Config
.
h
-
88
11
+
88
12
struct
Config
{
bool
StandardLibrary
=
true
;
}
Index
;
-
enum
UnusedIncludesPolicy
{
-
/
/
/
Diagnose
unused
includes
.
+
enum
IncludesPolicy
{
+
/
/
/
Diagnose
missing
and
unused
includes
.
Strict
None
-
/
/
/
The
same
as
Strict
but
using
the
include
-
cleaner
library
.
+
/
/
/
The
same
as
Strict
but
using
the
include
-
cleaner
library
for
+
/
/
/
unused
includes
.
Experiment
}
;
/
/
/
Controls
warnings
and
errors
when
parsing
code
.
-
107
7
+
108
8
struct
Config
{
llvm
:
:
StringMap
<
std
:
:
string
>
CheckOptions
;
}
ClangTidy
;
-
UnusedIncludesPolicy
UnusedIncludes
=
None
;
+
IncludesPolicy
UnusedIncludes
=
IncludesPolicy
:
:
None
;
+
IncludesPolicy
MissingIncludes
=
IncludesPolicy
:
:
None
;
/
/
/
IncludeCleaner
will
not
diagnose
usages
of
these
headers
matched
by
/
/
/
these
regexes
.
diff
-
-
git
a
/
clang
-
tools
-
extra
/
clangd
/
ConfigCompile
.
cpp
b
/
clang
-
tools
-
extra
/
clangd
/
ConfigCompile
.
cpp
index
b1876e21ee30
.
.
d74d8eb9a904
100644
-
-
-
a
/
clang
-
tools
-
extra
/
clangd
/
ConfigCompile
.
cpp
+
+
+
b
/
clang
-
tools
-
extra
/
clangd
/
ConfigCompile
.
cpp
-
431
16
+
431
26
struct
FragmentCompiler
{
}
)
;
if
(
F
.
UnusedIncludes
)
-
if
(
auto
Val
=
-
compileEnum
<
Config
:
:
UnusedIncludesPolicy
>
(
"
UnusedIncludes
"
-
*
*
F
.
UnusedIncludes
)
-
.
map
(
"
Strict
"
Config
:
:
UnusedIncludesPolicy
:
:
Strict
)
-
.
map
(
"
Experiment
"
Config
:
:
UnusedIncludesPolicy
:
:
Experiment
)
-
.
map
(
"
None
"
Config
:
:
UnusedIncludesPolicy
:
:
None
)
-
.
value
(
)
)
+
if
(
auto
Val
=
compileEnum
<
Config
:
:
IncludesPolicy
>
(
"
UnusedIncludes
"
+
*
*
F
.
UnusedIncludes
)
+
.
map
(
"
Strict
"
Config
:
:
IncludesPolicy
:
:
Strict
)
+
.
map
(
"
Experiment
"
Config
:
:
IncludesPolicy
:
:
Experiment
)
+
.
map
(
"
None
"
Config
:
:
IncludesPolicy
:
:
None
)
+
.
value
(
)
)
Out
.
Apply
.
push_back
(
[
Val
]
(
const
Params
&
Config
&
C
)
{
C
.
Diagnostics
.
UnusedIncludes
=
*
Val
;
}
)
;
+
+
if
(
F
.
MissingIncludes
)
+
if
(
auto
Val
=
compileEnum
<
Config
:
:
IncludesPolicy
>
(
"
MissingIncludes
"
+
*
*
F
.
MissingIncludes
)
+
.
map
(
"
Strict
"
Config
:
:
IncludesPolicy
:
:
Strict
)
+
.
map
(
"
None
"
Config
:
:
IncludesPolicy
:
:
None
)
+
.
value
(
)
)
+
Out
.
Apply
.
push_back
(
[
Val
]
(
const
Params
&
Config
&
C
)
{
+
C
.
Diagnostics
.
MissingIncludes
=
*
Val
;
+
}
)
;
+
compile
(
std
:
:
move
(
F
.
Includes
)
)
;
compile
(
std
:
:
move
(
F
.
ClangTidy
)
)
;
diff
-
-
git
a
/
clang
-
tools
-
extra
/
clangd
/
ConfigFragment
.
h
b
/
clang
-
tools
-
extra
/
clangd
/
ConfigFragment
.
h
index
bcd1a05b4a99
.
.
a499ce577c58
100644
-
-
-
a
/
clang
-
tools
-
extra
/
clangd
/
ConfigFragment
.
h
+
+
+
b
/
clang
-
tools
-
extra
/
clangd
/
ConfigFragment
.
h
-
235
6
+
235
19
struct
Fragment
{
/
/
/
-
None
std
:
:
optional
<
Located
<
std
:
:
string
>
>
UnusedIncludes
;
+
/
/
/
Controls
if
clangd
should
analyze
missing
#
include
directives
.
+
/
/
/
clangd
will
warn
if
no
header
providing
a
symbol
is
#
include
d
+
/
/
/
(
missing
)
directly
and
suggest
adding
it
.
+
/
/
/
+
/
/
/
Strict
means
a
header
providing
a
symbol
is
missing
if
it
is
not
+
/
/
/
*
directly
#
include
'
d
.
The
file
might
still
compile
if
the
header
is
+
/
/
/
included
transitively
.
+
/
/
/
+
/
/
/
Valid
values
are
:
+
/
/
/
-
Strict
+
/
/
/
-
None
+
std
:
:
optional
<
Located
<
std
:
:
string
>
>
MissingIncludes
;
+
/
/
/
Controls
IncludeCleaner
diagnostics
.
struct
IncludesBlock
{
/
/
/
Regexes
that
will
be
used
to
avoid
diagnosing
certain
includes
as
diff
-
-
git
a
/
clang
-
tools
-
extra
/
clangd
/
ConfigYAML
.
cpp
b
/
clang
-
tools
-
extra
/
clangd
/
ConfigYAML
.
cpp
index
ee91753dd88d
.
.
c017fb88a592
100644
-
-
-
a
/
clang
-
tools
-
extra
/
clangd
/
ConfigYAML
.
cpp
+
+
+
b
/
clang
-
tools
-
extra
/
clangd
/
ConfigYAML
.
cpp
-
128
6
+
128
9
private
:
Dict
.
handle
(
"
UnusedIncludes
"
[
&
]
(
Node
&
N
)
{
F
.
UnusedIncludes
=
scalarValue
(
N
"
UnusedIncludes
"
)
;
}
)
;
+
Dict
.
handle
(
"
MissingIncludes
"
[
&
]
(
Node
&
N
)
{
+
F
.
MissingIncludes
=
scalarValue
(
N
"
MissingIncludes
"
)
;
+
}
)
;
Dict
.
handle
(
"
Includes
"
[
&
]
(
Node
&
N
)
{
parse
(
F
.
Includes
N
)
;
}
)
;
Dict
.
handle
(
"
ClangTidy
"
[
&
]
(
Node
&
N
)
{
parse
(
F
.
ClangTidy
N
)
;
}
)
;
Dict
.
parse
(
N
)
;
diff
-
-
git
a
/
clang
-
tools
-
extra
/
clangd
/
IncludeCleaner
.
cpp
b
/
clang
-
tools
-
extra
/
clangd
/
IncludeCleaner
.
cpp
index
5a7df2fc33f6
.
.
8873a432ddc4
100644
-
-
-
a
/
clang
-
tools
-
extra
/
clangd
/
IncludeCleaner
.
cpp
+
+
+
b
/
clang
-
tools
-
extra
/
clangd
/
IncludeCleaner
.
cpp
-
8
32
+
8
55
#
include
"
IncludeCleaner
.
h
"
#
include
"
Config
.
h
"
+
#
include
"
Diagnostics
.
h
"
#
include
"
Headers
.
h
"
#
include
"
ParsedAST
.
h
"
#
include
"
Protocol
.
h
"
#
include
"
SourceCode
.
h
"
+
#
include
"
URI
.
h
"
#
include
"
clang
-
include
-
cleaner
/
Analysis
.
h
"
#
include
"
clang
-
include
-
cleaner
/
Types
.
h
"
#
include
"
index
/
CanonicalIncludes
.
h
"
#
include
"
support
/
Logger
.
h
"
+
#
include
"
support
/
Path
.
h
"
#
include
"
support
/
Trace
.
h
"
#
include
"
clang
/
AST
/
ASTContext
.
h
"
+
#
include
"
clang
/
AST
/
DeclCXX
.
h
"
+
#
include
"
clang
/
AST
/
Expr
.
h
"
#
include
"
clang
/
AST
/
ExprCXX
.
h
"
#
include
"
clang
/
AST
/
RecursiveASTVisitor
.
h
"
+
#
include
"
clang
/
AST
/
TemplateName
.
h
"
+
#
include
"
clang
/
AST
/
Type
.
h
"
+
#
include
"
clang
/
Basic
/
Diagnostic
.
h
"
+
#
include
"
clang
/
Basic
/
LLVM
.
h
"
#
include
"
clang
/
Basic
/
SourceLocation
.
h
"
#
include
"
clang
/
Basic
/
SourceManager
.
h
"
+
#
include
"
clang
/
Format
/
Format
.
h
"
#
include
"
clang
/
Lex
/
HeaderSearch
.
h
"
#
include
"
clang
/
Lex
/
Preprocessor
.
h
"
+
#
include
"
clang
/
Tooling
/
Core
/
Replacement
.
h
"
+
#
include
"
clang
/
Tooling
/
Inclusions
/
HeaderIncludes
.
h
"
+
#
include
"
clang
/
Tooling
/
Inclusions
/
IncludeStyle
.
h
"
+
#
include
"
clang
/
Tooling
/
Inclusions
/
StandardLibrary
.
h
"
#
include
"
clang
/
Tooling
/
Syntax
/
Tokens
.
h
"
#
include
"
llvm
/
ADT
/
ArrayRef
.
h
"
+
#
include
"
llvm
/
ADT
/
DenseSet
.
h
"
+
#
include
"
llvm
/
ADT
/
STLExtras
.
h
"
#
include
"
llvm
/
ADT
/
STLFunctionalExtras
.
h
"
#
include
"
llvm
/
ADT
/
SmallString
.
h
"
+
#
include
"
llvm
/
ADT
/
SmallVector
.
h
"
+
#
include
"
llvm
/
ADT
/
StringRef
.
h
"
#
include
"
llvm
/
ADT
/
StringSet
.
h
"
+
#
include
"
llvm
/
Support
/
Casting
.
h
"
+
#
include
"
llvm
/
Support
/
Error
.
h
"
+
#
include
"
llvm
/
Support
/
ErrorHandling
.
h
"
#
include
"
llvm
/
Support
/
FormatVariadic
.
h
"
#
include
"
llvm
/
Support
/
Path
.
h
"
#
include
"
llvm
/
Support
/
Regex
.
h
"
-
#
include
<
functional
>
+
#
include
<
iterator
>
#
include
<
optional
>
+
#
include
<
string
>
+
#
include
<
vector
>
namespace
clang
{
namespace
clangd
{
-
258
6
+
281
17
void
findReferencedMacros
(
const
SourceManager
&
SM
Preprocessor
&
PP
}
}
+
bool
isFilteredByConfig
(
const
Config
&
Cfg
llvm
:
:
StringRef
HeaderPath
)
{
+
/
/
Convert
the
path
to
Unix
slashes
and
try
to
match
against
the
filter
.
+
llvm
:
:
SmallString
<
64
>
NormalizedPath
(
HeaderPath
)
;
+
llvm
:
:
sys
:
:
path
:
:
native
(
NormalizedPath
llvm
:
:
sys
:
:
path
:
:
Style
:
:
posix
)
;
+
for
(
auto
&
Filter
:
Cfg
.
Diagnostics
.
Includes
.
IgnoreHeader
)
{
+
if
(
Filter
(
NormalizedPath
)
)
+
return
true
;
+
}
+
return
false
;
+
}
+
static
bool
mayConsiderUnused
(
const
Inclusion
&
Inc
ParsedAST
&
AST
const
Config
&
Cfg
)
{
if
(
Inc
.
BehindPragmaKeep
)
-
288
14
+
322
9
static
bool
mayConsiderUnused
(
const
Inclusion
&
Inc
ParsedAST
&
AST
FE
-
>
getName
(
)
)
;
return
false
;
}
-
for
(
auto
&
Filter
:
Cfg
.
Diagnostics
.
Includes
.
IgnoreHeader
)
{
-
/
/
Convert
the
path
to
Unix
slashes
and
try
to
match
against
the
filter
.
-
llvm
:
:
SmallString
<
64
>
Path
(
Inc
.
Resolved
)
;
-
llvm
:
:
sys
:
:
path
:
:
native
(
Path
llvm
:
:
sys
:
:
path
:
:
Style
:
:
posix
)
;
-
if
(
Filter
(
Inc
.
Resolved
)
)
{
-
dlog
(
"
{
0
}
header
is
filtered
out
by
the
configuration
"
FE
-
>
getName
(
)
)
;
-
return
false
;
-
}
+
if
(
isFilteredByConfig
(
Cfg
Inc
.
Resolved
)
)
{
+
dlog
(
"
{
0
}
header
is
filtered
out
by
the
configuration
"
FE
-
>
getName
(
)
)
;
+
return
false
;
}
return
true
;
}
-
325
6
+
354
195
FileID
headerResponsible
(
FileID
ID
const
SourceManager
&
SM
return
ID
;
}
+
include_cleaner
:
:
Includes
+
convertIncludes
(
const
SourceManager
&
SM
+
const
llvm
:
:
ArrayRef
<
Inclusion
>
MainFileIncludes
)
{
+
include_cleaner
:
:
Includes
Includes
;
+
for
(
const
Inclusion
&
Inc
:
MainFileIncludes
)
{
+
include_cleaner
:
:
Include
TransformedInc
;
+
llvm
:
:
StringRef
WrittenRef
=
llvm
:
:
StringRef
(
Inc
.
Written
)
;
+
TransformedInc
.
Spelled
=
WrittenRef
.
trim
(
"
\
"
<
>
"
)
;
+
TransformedInc
.
HashLocation
=
+
SM
.
getComposedLoc
(
SM
.
getMainFileID
(
)
Inc
.
HashOffset
)
;
+
TransformedInc
.
Line
=
Inc
.
HashLine
+
1
;
+
TransformedInc
.
Angled
=
WrittenRef
.
starts_with
(
"
<
"
)
;
+
auto
FE
=
SM
.
getFileManager
(
)
.
getFile
(
Inc
.
Resolved
)
;
+
if
(
!
FE
)
{
+
elog
(
"
IncludeCleaner
:
Failed
to
get
an
entry
for
resolved
path
{
0
}
:
{
1
}
"
+
Inc
.
Resolved
FE
.
getError
(
)
.
message
(
)
)
;
+
continue
;
+
}
+
TransformedInc
.
Resolved
=
*
FE
;
+
Includes
.
add
(
std
:
:
move
(
TransformedInc
)
)
;
+
}
+
return
Includes
;
+
}
+
+
std
:
:
string
spellHeader
(
ParsedAST
&
AST
const
FileEntry
*
MainFile
+
include_cleaner
:
:
Header
Provider
)
{
+
if
(
Provider
.
kind
(
)
=
=
include_cleaner
:
:
Header
:
:
Physical
)
{
+
if
(
auto
CanonicalPath
=
+
getCanonicalPath
(
Provider
.
physical
(
)
AST
.
getSourceManager
(
)
)
)
{
+
std
:
:
string
SpelledHeader
=
+
llvm
:
:
cantFail
(
URI
:
:
includeSpelling
(
URI
:
:
create
(
*
CanonicalPath
)
)
)
;
+
if
(
!
SpelledHeader
.
empty
(
)
)
+
return
SpelledHeader
;
+
}
+
}
+
return
include_cleaner
:
:
spellHeader
(
+
Provider
AST
.
getPreprocessor
(
)
.
getHeaderSearchInfo
(
)
MainFile
)
;
+
}
+
+
std
:
:
vector
<
include_cleaner
:
:
SymbolReference
>
+
collectMacroReferences
(
ParsedAST
&
AST
)
{
+
const
auto
&
SM
=
AST
.
getSourceManager
(
)
;
+
/
/
FIXME
:
!
!
this
is
a
hacky
way
to
collect
macro
references
.
+
std
:
:
vector
<
include_cleaner
:
:
SymbolReference
>
Macros
;
+
auto
&
PP
=
AST
.
getPreprocessor
(
)
;
+
for
(
const
syntax
:
:
Token
&
Tok
:
+
AST
.
getTokens
(
)
.
spelledTokens
(
SM
.
getMainFileID
(
)
)
)
{
+
auto
Macro
=
locateMacroAt
(
Tok
PP
)
;
+
if
(
!
Macro
)
+
continue
;
+
if
(
auto
DefLoc
=
Macro
-
>
Info
-
>
getDefinitionLoc
(
)
;
DefLoc
.
isValid
(
)
)
+
Macros
.
push_back
(
+
{
Tok
.
location
(
)
+
include_cleaner
:
:
Macro
{
/
*
Name
=
*
/
PP
.
getIdentifierInfo
(
Tok
.
text
(
SM
)
)
+
DefLoc
}
+
include_cleaner
:
:
RefType
:
:
Explicit
}
)
;
+
}
+
return
Macros
;
+
}
+
+
llvm
:
:
StringRef
getResolvedPath
(
const
include_cleaner
:
:
Header
&
SymProvider
)
{
+
switch
(
SymProvider
.
kind
(
)
)
{
+
case
include_cleaner
:
:
Header
:
:
Physical
:
+
return
SymProvider
.
physical
(
)
-
>
tryGetRealPathName
(
)
;
+
case
include_cleaner
:
:
Header
:
:
Standard
:
+
return
SymProvider
.
standard
(
)
.
name
(
)
.
trim
(
"
<
>
\
"
"
)
;
+
case
include_cleaner
:
:
Header
:
:
Verbatim
:
+
return
SymProvider
.
verbatim
(
)
.
trim
(
"
<
>
\
"
"
)
;
+
}
+
llvm_unreachable
(
"
Unknown
header
kind
"
)
;
+
}
+
+
std
:
:
string
getSymbolName
(
const
include_cleaner
:
:
Symbol
&
Sym
)
{
+
switch
(
Sym
.
kind
(
)
)
{
+
case
include_cleaner
:
:
Symbol
:
:
Macro
:
+
return
Sym
.
macro
(
)
.
Name
-
>
getName
(
)
.
str
(
)
;
+
case
include_cleaner
:
:
Symbol
:
:
Declaration
:
+
return
llvm
:
:
dyn_cast
<
NamedDecl
>
(
&
Sym
.
declaration
(
)
)
+
-
>
getQualifiedNameAsString
(
)
;
+
}
+
llvm_unreachable
(
"
Unknown
symbol
kind
"
)
;
+
}
+
+
std
:
:
vector
<
Diag
>
generateMissingIncludeDiagnostics
(
+
ParsedAST
&
AST
llvm
:
:
ArrayRef
<
MissingIncludeDiagInfo
>
MissingIncludes
+
llvm
:
:
StringRef
Code
)
{
+
std
:
:
vector
<
Diag
>
Result
;
+
const
Config
&
Cfg
=
Config
:
:
current
(
)
;
+
if
(
Cfg
.
Diagnostics
.
MissingIncludes
!
=
Config
:
:
IncludesPolicy
:
:
Strict
|
|
+
Cfg
.
Diagnostics
.
SuppressAll
|
|
+
Cfg
.
Diagnostics
.
Suppress
.
contains
(
"
missing
-
includes
"
)
)
{
+
return
Result
;
+
}
+
+
const
SourceManager
&
SM
=
AST
.
getSourceManager
(
)
;
+
const
FileEntry
*
MainFile
=
SM
.
getFileEntryForID
(
SM
.
getMainFileID
(
)
)
;
+
+
auto
FileStyle
=
format
:
:
getStyle
(
+
format
:
:
DefaultFormatStyle
AST
.
tuPath
(
)
format
:
:
DefaultFallbackStyle
+
Code
&
SM
.
getFileManager
(
)
.
getVirtualFileSystem
(
)
)
;
+
if
(
!
FileStyle
)
{
+
elog
(
"
Couldn
'
t
infer
style
"
FileStyle
.
takeError
(
)
)
;
+
FileStyle
=
format
:
:
getLLVMStyle
(
)
;
+
}
+
+
tooling
:
:
HeaderIncludes
HeaderIncludes
(
AST
.
tuPath
(
)
Code
+
FileStyle
-
>
IncludeStyle
)
;
+
for
(
const
auto
&
SymbolWithMissingInclude
:
MissingIncludes
)
{
+
llvm
:
:
StringRef
ResolvedPath
=
+
getResolvedPath
(
SymbolWithMissingInclude
.
Providers
.
front
(
)
)
;
+
if
(
isFilteredByConfig
(
Cfg
ResolvedPath
)
)
{
+
dlog
(
"
IncludeCleaner
:
not
diagnosing
missing
include
{
0
}
filtered
by
"
+
"
config
"
+
ResolvedPath
)
;
+
continue
;
+
}
+
+
std
:
:
string
Spelling
=
+
spellHeader
(
AST
MainFile
SymbolWithMissingInclude
.
Providers
.
front
(
)
)
;
+
llvm
:
:
StringRef
HeaderRef
{
Spelling
}
;
+
bool
Angled
=
HeaderRef
.
starts_with
(
"
<
"
)
;
+
/
/
We
might
suggest
insertion
of
an
existing
include
in
edge
cases
e
.
g
.
+
/
/
include
is
present
in
a
PP
-
disabled
region
or
spelling
of
the
header
+
/
/
turns
out
to
be
the
same
as
one
of
the
unresolved
includes
in
the
+
/
/
main
file
.
+
std
:
:
optional
<
tooling
:
:
Replacement
>
Replacement
=
HeaderIncludes
.
insert
(
+
HeaderRef
.
trim
(
"
\
"
<
>
"
)
Angled
tooling
:
:
IncludeDirective
:
:
Include
)
;
+
if
(
!
Replacement
.
has_value
(
)
)
+
continue
;
+
+
Diag
&
D
=
Result
.
emplace_back
(
)
;
+
D
.
Message
=
+
llvm
:
:
formatv
(
"
No
header
providing
\
"
{
0
}
\
"
is
directly
included
"
+
getSymbolName
(
SymbolWithMissingInclude
.
Symbol
)
)
;
+
D
.
Name
=
"
missing
-
includes
"
;
+
D
.
Source
=
Diag
:
:
DiagSource
:
:
Clangd
;
+
D
.
File
=
AST
.
tuPath
(
)
;
+
D
.
InsideMainFile
=
true
;
+
D
.
Severity
=
DiagnosticsEngine
:
:
Warning
;
+
D
.
Range
=
clangd
:
:
Range
{
+
offsetToPosition
(
Code
+
SymbolWithMissingInclude
.
SymRefRange
.
beginOffset
(
)
)
+
offsetToPosition
(
Code
+
SymbolWithMissingInclude
.
SymRefRange
.
endOffset
(
)
)
}
;
+
auto
&
F
=
D
.
Fixes
.
emplace_back
(
)
;
+
F
.
Message
=
"
#
include
"
+
Spelling
;
+
TextEdit
Edit
=
replacementToEdit
(
Code
*
Replacement
)
;
+
F
.
Edits
.
emplace_back
(
std
:
:
move
(
Edit
)
)
;
+
}
+
return
Result
;
+
}
+
+
std
:
:
vector
<
Diag
>
generateUnusedIncludeDiagnostics
(
+
PathRef
FileName
llvm
:
:
ArrayRef
<
const
Inclusion
*
>
UnusedIncludes
+
llvm
:
:
StringRef
Code
)
{
+
std
:
:
vector
<
Diag
>
Result
;
+
const
Config
&
Cfg
=
Config
:
:
current
(
)
;
+
if
(
Cfg
.
Diagnostics
.
UnusedIncludes
=
=
Config
:
:
IncludesPolicy
:
:
None
|
|
+
Cfg
.
Diagnostics
.
SuppressAll
|
|
+
Cfg
.
Diagnostics
.
Suppress
.
contains
(
"
unused
-
includes
"
)
)
{
+
return
Result
;
+
}
+
for
(
const
auto
*
Inc
:
UnusedIncludes
)
{
+
Diag
&
D
=
Result
.
emplace_back
(
)
;
+
D
.
Message
=
+
llvm
:
:
formatv
(
"
included
header
{
0
}
is
not
used
directly
"
+
llvm
:
:
sys
:
:
path
:
:
filename
(
+
Inc
-
>
Written
.
substr
(
1
Inc
-
>
Written
.
size
(
)
-
2
)
+
llvm
:
:
sys
:
:
path
:
:
Style
:
:
posix
)
)
;
+
D
.
Name
=
"
unused
-
includes
"
;
+
D
.
Source
=
Diag
:
:
DiagSource
:
:
Clangd
;
+
D
.
File
=
FileName
;
+
D
.
InsideMainFile
=
true
;
+
D
.
Severity
=
DiagnosticsEngine
:
:
Warning
;
+
D
.
Tags
.
push_back
(
Unnecessary
)
;
+
D
.
Range
=
getDiagnosticRange
(
Code
Inc
-
>
HashOffset
)
;
+
/
/
FIXME
(
kirillbobyrev
)
:
Removing
inclusion
might
break
the
code
if
the
+
/
/
used
headers
are
only
reachable
transitively
through
this
one
.
Suggest
+
/
/
including
them
directly
instead
.
+
/
/
FIXME
(
kirillbobyrev
)
:
Add
fix
suggestion
for
adding
IWYU
pragmas
+
/
/
(
keep
/
export
)
remove
the
warning
once
we
support
IWYU
pragmas
.
+
auto
&
F
=
D
.
Fixes
.
emplace_back
(
)
;
+
F
.
Message
=
"
remove
#
include
directive
"
;
+
F
.
Edits
.
emplace_back
(
)
;
+
F
.
Edits
.
back
(
)
.
range
.
start
.
line
=
Inc
-
>
HashLine
;
+
F
.
Edits
.
back
(
)
.
range
.
end
.
line
=
Inc
-
>
HashLine
+
1
;
+
}
+
return
Result
;
+
}
}
/
/
namespace
ReferencedLocations
findReferencedLocations
(
ASTContext
&
Ctx
Preprocessor
&
PP
-
474
105
+
692
85
std
:
:
vector
<
const
Inclusion
*
>
computeUnusedIncludes
(
ParsedAST
&
AST
)
{
translateToHeaderIDs
(
ReferencedFiles
AST
.
getIncludeStructure
(
)
SM
)
;
return
getUnused
(
AST
ReferencedHeaders
ReferencedFiles
.
SpelledUmbrellas
)
;
}
-
std
:
:
vector
<
const
Inclusion
*
>
computeUnusedIncludesExperimental
(
ParsedAST
&
AST
)
{
+
IncludeCleanerFindings
computeIncludeCleanerFindings
(
ParsedAST
&
AST
)
{
const
auto
&
SM
=
AST
.
getSourceManager
(
)
;
const
auto
&
Includes
=
AST
.
getIncludeStructure
(
)
;
-
/
/
FIXME
:
this
map
should
probably
be
in
IncludeStructure
.
-
llvm
:
:
StringMap
<
llvm
:
:
SmallVector
<
IncludeStructure
:
:
HeaderID
>
>
BySpelling
;
-
for
(
const
auto
&
Inc
:
Includes
.
MainFileIncludes
)
{
-
if
(
Inc
.
HeaderID
)
-
BySpelling
.
try_emplace
(
Inc
.
Written
)
-
.
first
-
>
second
.
push_back
(
-
static_cast
<
IncludeStructure
:
:
HeaderID
>
(
*
Inc
.
HeaderID
)
)
;
-
}
-
/
/
FIXME
:
!
!
this
is
a
hacky
way
to
collect
macro
references
.
-
std
:
:
vector
<
include_cleaner
:
:
SymbolReference
>
Macros
;
-
auto
&
PP
=
AST
.
getPreprocessor
(
)
;
-
for
(
const
syntax
:
:
Token
&
Tok
:
-
AST
.
getTokens
(
)
.
spelledTokens
(
SM
.
getMainFileID
(
)
)
)
{
-
auto
Macro
=
locateMacroAt
(
Tok
PP
)
;
-
if
(
!
Macro
)
-
continue
;
-
if
(
auto
DefLoc
=
Macro
-
>
Info
-
>
getDefinitionLoc
(
)
;
DefLoc
.
isValid
(
)
)
-
Macros
.
push_back
(
-
{
Tok
.
location
(
)
-
include_cleaner
:
:
Macro
{
/
*
Name
=
*
/
PP
.
getIdentifierInfo
(
Tok
.
text
(
SM
)
)
-
DefLoc
}
-
include_cleaner
:
:
RefType
:
:
Explicit
}
)
;
-
}
-
llvm
:
:
DenseSet
<
IncludeStructure
:
:
HeaderID
>
Used
;
-
include_cleaner
:
:
walkUsed
(
-
AST
.
getLocalTopLevelDecls
(
)
/
*
MacroRefs
=
*
/
Macros
-
AST
.
getPragmaIncludes
(
)
SM
-
[
&
]
(
const
include_cleaner
:
:
SymbolReference
&
Ref
-
llvm
:
:
ArrayRef
<
include_cleaner
:
:
Header
>
Providers
)
{
-
for
(
const
auto
&
H
:
Providers
)
{
-
switch
(
H
.
kind
(
)
)
{
-
case
include_cleaner
:
:
Header
:
:
Physical
:
-
if
(
auto
HeaderID
=
Includes
.
getID
(
H
.
physical
(
)
)
)
-
Used
.
insert
(
*
HeaderID
)
;
-
break
;
-
case
include_cleaner
:
:
Header
:
:
Standard
:
-
for
(
auto
HeaderID
:
Includes
.
StdlibHeaders
.
lookup
(
H
.
standard
(
)
)
)
-
Used
.
insert
(
HeaderID
)
;
-
break
;
-
case
include_cleaner
:
:
Header
:
:
Verbatim
:
-
for
(
auto
HeaderID
:
BySpelling
.
lookup
(
H
.
verbatim
(
)
)
)
-
Used
.
insert
(
HeaderID
)
;
-
break
;
-
}
-
}
-
}
)
;
-
return
getUnused
(
AST
Used
/
*
ReferencedPublicHeaders
*
/
{
}
)
;
+
include_cleaner
:
:
Includes
ConvertedIncludes
=
+
convertIncludes
(
SM
Includes
.
MainFileIncludes
)
;
+
const
FileEntry
*
MainFile
=
SM
.
getFileEntryForID
(
SM
.
getMainFileID
(
)
)
;
+
+
std
:
:
vector
<
include_cleaner
:
:
SymbolReference
>
Macros
=
+
collectMacroReferences
(
AST
)
;
+
std
:
:
vector
<
MissingIncludeDiagInfo
>
MissingIncludes
;
+
llvm
:
:
DenseSet
<
IncludeStructure
:
:
HeaderID
>
Used
;
+
trace
:
:
Span
Tracer
(
"
include_cleaner
:
:
walkUsed
"
)
;
+
include_cleaner
:
:
walkUsed
(
+
AST
.
getLocalTopLevelDecls
(
)
/
*
MacroRefs
=
*
/
Macros
+
AST
.
getPragmaIncludes
(
)
SM
+
[
&
]
(
const
include_cleaner
:
:
SymbolReference
&
Ref
+
llvm
:
:
ArrayRef
<
include_cleaner
:
:
Header
>
Providers
)
{
+
bool
Satisfied
=
false
;
+
for
(
const
auto
&
H
:
Providers
)
{
+
if
(
H
.
kind
(
)
=
=
include_cleaner
:
:
Header
:
:
Physical
&
&
+
H
.
physical
(
)
=
=
MainFile
)
{
+
Satisfied
=
true
;
+
continue
;
+
}
+
for
(
auto
*
Inc
:
ConvertedIncludes
.
match
(
H
)
)
{
+
Satisfied
=
true
;
+
auto
HeaderID
=
Includes
.
getID
(
Inc
-
>
Resolved
)
;
+
assert
(
HeaderID
.
has_value
(
)
&
&
+
"
ConvertedIncludes
only
contains
resolved
includes
.
"
)
;
+
Used
.
insert
(
*
HeaderID
)
;
+
}
+
}
+
+
if
(
Satisfied
|
|
Providers
.
empty
(
)
|
|
+
Ref
.
RT
!
=
include_cleaner
:
:
RefType
:
:
Explicit
)
+
return
;
+
+
auto
&
Tokens
=
AST
.
getTokens
(
)
;
+
auto
SpelledForExpanded
=
+
Tokens
.
spelledForExpanded
(
Tokens
.
expandedTokens
(
Ref
.
RefLocation
)
)
;
+
if
(
!
SpelledForExpanded
)
+
return
;
+
+
auto
Range
=
syntax
:
:
Token
:
:
range
(
SM
SpelledForExpanded
-
>
front
(
)
+
SpelledForExpanded
-
>
back
(
)
)
;
+
MissingIncludeDiagInfo
DiagInfo
{
Ref
.
Target
Range
Providers
}
;
+
MissingIncludes
.
push_back
(
std
:
:
move
(
DiagInfo
)
)
;
+
}
)
;
+
std
:
:
vector
<
const
Inclusion
*
>
UnusedIncludes
=
+
getUnused
(
AST
Used
/
*
ReferencedPublicHeaders
*
/
{
}
)
;
+
return
{
std
:
:
move
(
UnusedIncludes
)
std
:
:
move
(
MissingIncludes
)
}
;
}
-
std
:
:
vector
<
Diag
>
issueUnusedIncludesDiagnostics
(
ParsedAST
&
AST
+
std
:
:
vector
<
Diag
>
issueIncludeCleanerDiagnostics
(
ParsedAST
&
AST
llvm
:
:
StringRef
Code
)
{
-
const
Config
&
Cfg
=
Config
:
:
current
(
)
;
-
if
(
Cfg
.
Diagnostics
.
UnusedIncludes
=
=
Config
:
:
UnusedIncludesPolicy
:
:
None
|
|
-
Cfg
.
Diagnostics
.
SuppressAll
|
|
-
Cfg
.
Diagnostics
.
Suppress
.
contains
(
"
unused
-
includes
"
)
)
-
return
{
}
;
/
/
Interaction
is
only
polished
for
C
/
CPP
.
if
(
AST
.
getLangOpts
(
)
.
ObjC
)
return
{
}
;
-
trace
:
:
Span
Tracer
(
"
IncludeCleaner
:
:
issueUnusedIncludesDiagnostics
"
)
;
-
std
:
:
vector
<
Diag
>
Result
;
-
std
:
:
string
FileName
=
-
AST
.
getSourceManager
(
)
-
.
getFileEntryRefForID
(
AST
.
getSourceManager
(
)
.
getMainFileID
(
)
)
-
-
>
getName
(
)
-
.
str
(
)
;
-
const
auto
&
UnusedIncludes
=
-
Cfg
.
Diagnostics
.
UnusedIncludes
=
=
Config
:
:
UnusedIncludesPolicy
:
:
Experiment
-
?
computeUnusedIncludesExperimental
(
AST
)
-
:
computeUnusedIncludes
(
AST
)
;
-
for
(
const
auto
*
Inc
:
UnusedIncludes
)
{
-
Diag
D
;
-
D
.
Message
=
-
llvm
:
:
formatv
(
"
included
header
{
0
}
is
not
used
directly
"
-
llvm
:
:
sys
:
:
path
:
:
filename
(
-
Inc
-
>
Written
.
substr
(
1
Inc
-
>
Written
.
size
(
)
-
2
)
-
llvm
:
:
sys
:
:
path
:
:
Style
:
:
posix
)
)
;
-
D
.
Name
=
"
unused
-
includes
"
;
-
D
.
Source
=
Diag
:
:
DiagSource
:
:
Clangd
;
-
D
.
File
=
FileName
;
-
D
.
Severity
=
DiagnosticsEngine
:
:
Warning
;
-
D
.
Tags
.
push_back
(
Unnecessary
)
;
-
D
.
Range
=
getDiagnosticRange
(
Code
Inc
-
>
HashOffset
)
;
-
/
/
FIXME
(
kirillbobyrev
)
:
Removing
inclusion
might
break
the
code
if
the
-
/
/
used
headers
are
only
reachable
transitively
through
this
one
.
Suggest
-
/
/
including
them
directly
instead
.
-
/
/
FIXME
(
kirillbobyrev
)
:
Add
fix
suggestion
for
adding
IWYU
pragmas
-
/
/
(
keep
/
export
)
remove
the
warning
once
we
support
IWYU
pragmas
.
-
D
.
Fixes
.
emplace_back
(
)
;
-
D
.
Fixes
.
back
(
)
.
Message
=
"
remove
#
include
directive
"
;
-
D
.
Fixes
.
back
(
)
.
Edits
.
emplace_back
(
)
;
-
D
.
Fixes
.
back
(
)
.
Edits
.
back
(
)
.
range
.
start
.
line
=
Inc
-
>
HashLine
;
-
D
.
Fixes
.
back
(
)
.
Edits
.
back
(
)
.
range
.
end
.
line
=
Inc
-
>
HashLine
+
1
;
-
D
.
InsideMainFile
=
true
;
-
Result
.
push_back
(
std
:
:
move
(
D
)
)
;
+
+
trace
:
:
Span
Tracer
(
"
IncludeCleaner
:
:
issueIncludeCleanerDiagnostics
"
)
;
+
+
const
Config
&
Cfg
=
Config
:
:
current
(
)
;
+
IncludeCleanerFindings
Findings
;
+
if
(
Cfg
.
Diagnostics
.
MissingIncludes
=
=
Config
:
:
IncludesPolicy
:
:
Strict
|
|
+
Cfg
.
Diagnostics
.
UnusedIncludes
=
=
Config
:
:
IncludesPolicy
:
:
Experiment
)
{
+
/
/
will
need
include
-
cleaner
results
call
it
once
+
Findings
=
computeIncludeCleanerFindings
(
AST
)
;
}
+
+
std
:
:
vector
<
Diag
>
Result
=
generateUnusedIncludeDiagnostics
(
+
AST
.
tuPath
(
)
+
Cfg
.
Diagnostics
.
UnusedIncludes
=
=
Config
:
:
IncludesPolicy
:
:
Strict
+
?
computeUnusedIncludes
(
AST
)
+
:
Findings
.
UnusedIncludes
+
Code
)
;
+
llvm
:
:
move
(
+
generateMissingIncludeDiagnostics
(
AST
Findings
.
MissingIncludes
Code
)
+
std
:
:
back_inserter
(
Result
)
)
;
+
return
Result
;
}
diff
-
-
git
a
/
clang
-
tools
-
extra
/
clangd
/
IncludeCleaner
.
h
b
/
clang
-
tools
-
extra
/
clangd
/
IncludeCleaner
.
h
index
a7beb9c3c9d4
.
.
989067e3d84f
100644
-
-
-
a
/
clang
-
tools
-
extra
/
clangd
/
IncludeCleaner
.
h
+
+
+
b
/
clang
-
tools
-
extra
/
clangd
/
IncludeCleaner
.
h
-
20
18
+
20
38
#
include
"
Headers
.
h
"
#
include
"
ParsedAST
.
h
"
+
#
include
"
clang
-
include
-
cleaner
/
Types
.
h
"
#
include
"
index
/
CanonicalIncludes
.
h
"
#
include
"
clang
/
Basic
/
SourceLocation
.
h
"
#
include
"
clang
/
Tooling
/
Inclusions
/
StandardLibrary
.
h
"
+
#
include
"
clang
/
Tooling
/
Syntax
/
Tokens
.
h
"
#
include
"
llvm
/
ADT
/
DenseSet
.
h
"
#
include
"
llvm
/
ADT
/
STLFunctionalExtras
.
h
"
#
include
"
llvm
/
ADT
/
StringSet
.
h
"
#
include
<
optional
>
+
#
include
<
tuple
>
#
include
<
vector
>
namespace
clang
{
namespace
clangd
{
+
/
/
Data
needed
for
missing
include
diagnostics
.
+
struct
MissingIncludeDiagInfo
{
+
include_cleaner
:
:
Symbol
Symbol
;
+
syntax
:
:
FileRange
SymRefRange
;
+
std
:
:
vector
<
include_cleaner
:
:
Header
>
Providers
;
+
+
bool
operator
=
=
(
const
MissingIncludeDiagInfo
&
Other
)
const
{
+
return
std
:
:
tie
(
SymRefRange
Providers
Symbol
)
=
=
+
std
:
:
tie
(
Other
.
SymRefRange
Other
.
Providers
Other
.
Symbol
)
;
+
}
+
}
;
+
+
struct
IncludeCleanerFindings
{
+
std
:
:
vector
<
const
Inclusion
*
>
UnusedIncludes
;
+
std
:
:
vector
<
MissingIncludeDiagInfo
>
MissingIncludes
;
+
}
;
+
struct
ReferencedLocations
{
llvm
:
:
DenseSet
<
SourceLocation
>
User
;
llvm
:
:
DenseSet
<
tooling
:
:
stdlib
:
:
Symbol
>
Stdlib
;
-
96
13
+
116
10
getUnused
(
ParsedAST
&
AST
const
llvm
:
:
DenseSet
<
IncludeStructure
:
:
HeaderID
>
&
ReferencedFiles
const
llvm
:
:
StringSet
<
>
&
ReferencedPublicHeaders
)
;
+
IncludeCleanerFindings
computeIncludeCleanerFindings
(
ParsedAST
&
AST
)
;
std
:
:
vector
<
const
Inclusion
*
>
computeUnusedIncludes
(
ParsedAST
&
AST
)
;
-
/
/
The
same
as
computeUnusedIncludes
but
it
is
an
experimental
and
-
/
/
include
-
cleaner
-
lib
-
based
implementation
.
-
std
:
:
vector
<
const
Inclusion
*
>
-
computeUnusedIncludesExperimental
(
ParsedAST
&
AST
)
;
-
std
:
:
vector
<
Diag
>
issueUnusedIncludesDiagnostics
(
ParsedAST
&
AST
+
std
:
:
vector
<
Diag
>
issueIncludeCleanerDiagnostics
(
ParsedAST
&
AST
llvm
:
:
StringRef
Code
)
;
/
/
/
Affects
whether
standard
library
includes
should
be
considered
for
diff
-
-
git
a
/
clang
-
tools
-
extra
/
clangd
/
ParsedAST
.
cpp
b
/
clang
-
tools
-
extra
/
clangd
/
ParsedAST
.
cpp
index
bf639a6fb58e
.
.
e0d385acf73a
100644
-
-
-
a
/
clang
-
tools
-
extra
/
clangd
/
ParsedAST
.
cpp
+
+
+
b
/
clang
-
tools
-
extra
/
clangd
/
ParsedAST
.
cpp
-
688
13
+
688
9
ParsedAST
:
:
build
(
llvm
:
:
StringRef
Filename
const
ParseInputs
&
Inputs
std
:
:
move
(
Macros
)
std
:
:
move
(
Marks
)
std
:
:
move
(
ParsedDecls
)
std
:
:
move
(
Diags
)
std
:
:
move
(
Includes
)
std
:
:
move
(
CanonIncludes
)
)
;
-
if
(
Result
.
Diags
)
{
-
auto
UnusedHeadersDiags
=
-
issueUnusedIncludesDiagnostics
(
Result
Inputs
.
Contents
)
;
-
Result
.
Diags
-
>
insert
(
Result
.
Diags
-
>
end
(
)
-
make_move_iterator
(
UnusedHeadersDiags
.
begin
(
)
)
-
make_move_iterator
(
UnusedHeadersDiags
.
end
(
)
)
)
;
-
}
+
if
(
Result
.
Diags
)
+
llvm
:
:
move
(
issueIncludeCleanerDiagnostics
(
Result
Inputs
.
Contents
)
+
std
:
:
back_inserter
(
*
Result
.
Diags
)
)
;
return
std
:
:
move
(
Result
)
;
}
diff
-
-
git
a
/
clang
-
tools
-
extra
/
clangd
/
Preamble
.
cpp
b
/
clang
-
tools
-
extra
/
clangd
/
Preamble
.
cpp
index
15eea9bb036b
.
.
b960f7765cb7
100644
-
-
-
a
/
clang
-
tools
-
extra
/
clangd
/
Preamble
.
cpp
+
+
+
b
/
clang
-
tools
-
extra
/
clangd
/
Preamble
.
cpp
-
123
7
+
123
9
public
:
SourceMgr
=
&
CI
.
getSourceManager
(
)
;
Includes
.
collect
(
CI
)
;
if
(
Config
:
:
current
(
)
.
Diagnostics
.
UnusedIncludes
=
=
-
Config
:
:
UnusedIncludesPolicy
:
:
Experiment
)
+
Config
:
:
IncludesPolicy
:
:
Experiment
|
|
+
Config
:
:
current
(
)
.
Diagnostics
.
MissingIncludes
=
=
+
Config
:
:
IncludesPolicy
:
:
Strict
)
Pragmas
.
record
(
CI
)
;
if
(
BeforeExecuteCallback
)
BeforeExecuteCallback
(
CI
)
;
diff
-
-
git
a
/
clang
-
tools
-
extra
/
clangd
/
TidyProvider
.
cpp
b
/
clang
-
tools
-
extra
/
clangd
/
TidyProvider
.
cpp
index
f3ed6f08a9ac
.
.
bdf4c7d94a0b
100644
-
-
-
a
/
clang
-
tools
-
extra
/
clangd
/
TidyProvider
.
cpp
+
+
+
b
/
clang
-
tools
-
extra
/
clangd
/
TidyProvider
.
cpp
-
195
32
+
195
35
TidyProvider
addTidyChecks
(
llvm
:
:
StringRef
Checks
TidyProvider
disableUnusableChecks
(
llvm
:
:
ArrayRef
<
std
:
:
string
>
ExtraBadChecks
)
{
constexpr
llvm
:
:
StringLiteral
Seperator
(
"
"
)
;
-
static
const
std
:
:
string
BadChecks
=
-
llvm
:
:
join_items
(
Seperator
-
/
/
We
want
this
list
to
start
with
a
seperator
to
-
/
/
simplify
appending
in
the
lambda
.
So
including
an
-
/
/
empty
string
here
will
force
that
.
-
"
"
-
/
/
-
-
-
-
-
False
Positives
-
-
-
-
-
-
-
/
/
Check
relies
on
seeing
ifndef
/
define
/
endif
directives
-
/
/
clangd
doesn
'
t
replay
those
when
using
a
preamble
.
-
"
-
llvm
-
header
-
guard
"
"
-
modernize
-
macro
-
to
-
enum
"
-
-
/
/
-
-
-
-
-
Crashing
Checks
-
-
-
-
-
-
-
/
/
Check
can
choke
on
invalid
(
intermediate
)
c
+
+
-
/
/
code
which
is
often
the
case
when
clangd
-
/
/
tries
to
build
an
AST
.
-
"
-
bugprone
-
use
-
after
-
move
"
-
/
/
Alias
for
bugprone
-
use
-
after
-
move
.
-
"
-
hicpp
-
invalid
-
access
-
moved
"
-
-
/
/
-
-
-
-
-
Performance
problems
-
-
-
-
-
-
-
/
/
This
check
runs
expensive
analysis
for
each
variable
.
-
/
/
It
has
been
observed
to
increase
reparse
time
by
10x
.
-
"
-
misc
-
const
-
correctness
"
)
;
+
static
const
std
:
:
string
BadChecks
=
llvm
:
:
join_items
(
+
Seperator
+
/
/
We
want
this
list
to
start
with
a
seperator
to
+
/
/
simplify
appending
in
the
lambda
.
So
including
an
+
/
/
empty
string
here
will
force
that
.
+
"
"
+
/
/
include
-
cleaner
is
directly
integrated
in
IncludeCleaner
.
cpp
+
"
-
misc
-
include
-
cleaner
"
+
+
/
/
-
-
-
-
-
False
Positives
-
-
-
-
-
+
+
/
/
Check
relies
on
seeing
ifndef
/
define
/
endif
directives
+
/
/
clangd
doesn
'
t
replay
those
when
using
a
preamble
.
+
"
-
llvm
-
header
-
guard
"
"
-
modernize
-
macro
-
to
-
enum
"
+
+
/
/
-
-
-
-
-
Crashing
Checks
-
-
-
-
-
+
+
/
/
Check
can
choke
on
invalid
(
intermediate
)
c
+
+
+
/
/
code
which
is
often
the
case
when
clangd
+
/
/
tries
to
build
an
AST
.
+
"
-
bugprone
-
use
-
after
-
move
"
+
/
/
Alias
for
bugprone
-
use
-
after
-
move
.
+
"
-
hicpp
-
invalid
-
access
-
moved
"
+
+
/
/
-
-
-
-
-
Performance
problems
-
-
-
-
-
+
+
/
/
This
check
runs
expensive
analysis
for
each
variable
.
+
/
/
It
has
been
observed
to
increase
reparse
time
by
10x
.
+
"
-
misc
-
const
-
correctness
"
)
;
size_t
Size
=
BadChecks
.
size
(
)
;
for
(
const
std
:
:
string
&
Str
:
ExtraBadChecks
)
{
diff
-
-
git
a
/
clang
-
tools
-
extra
/
clangd
/
unittests
/
ConfigCompileTests
.
cpp
b
/
clang
-
tools
-
extra
/
clangd
/
unittests
/
ConfigCompileTests
.
cpp
index
427409bfe634
.
.
e6e9eff78f52
100644
-
-
-
a
/
clang
-
tools
-
extra
/
clangd
/
unittests
/
ConfigCompileTests
.
cpp
+
+
+
b
/
clang
-
tools
-
extra
/
clangd
/
unittests
/
ConfigCompileTests
.
cpp
-
249
19
+
249
19
TEST_F
(
ConfigCompileTests
DiagnosticsIncludeCleaner
)
{
/
/
Defaults
to
None
.
EXPECT_TRUE
(
compileAndApply
(
)
)
;
EXPECT_EQ
(
Conf
.
Diagnostics
.
UnusedIncludes
-
Config
:
:
UnusedIncludesPolicy
:
:
None
)
;
+
Config
:
:
IncludesPolicy
:
:
None
)
;
Frag
=
{
}
;
Frag
.
Diagnostics
.
UnusedIncludes
.
emplace
(
"
None
"
)
;
EXPECT_TRUE
(
compileAndApply
(
)
)
;
EXPECT_EQ
(
Conf
.
Diagnostics
.
UnusedIncludes
-
Config
:
:
UnusedIncludesPolicy
:
:
None
)
;
+
Config
:
:
IncludesPolicy
:
:
None
)
;
Frag
=
{
}
;
Frag
.
Diagnostics
.
UnusedIncludes
.
emplace
(
"
Strict
"
)
;
EXPECT_TRUE
(
compileAndApply
(
)
)
;
EXPECT_EQ
(
Conf
.
Diagnostics
.
UnusedIncludes
-
Config
:
:
UnusedIncludesPolicy
:
:
Strict
)
;
+
Config
:
:
IncludesPolicy
:
:
Strict
)
;
Frag
=
{
}
;
EXPECT_TRUE
(
Conf
.
Diagnostics
.
Includes
.
IgnoreHeader
.
empty
(
)
)
diff
-
-
git
a
/
clang
-
tools
-
extra
/
clangd
/
unittests
/
DiagnosticsTests
.
cpp
b
/
clang
-
tools
-
extra
/
clangd
/
unittests
/
DiagnosticsTests
.
cpp
index
610a290f834a
.
.
45bd8ba9f5b6
100644
-
-
-
a
/
clang
-
tools
-
extra
/
clangd
/
unittests
/
DiagnosticsTests
.
cpp
+
+
+
b
/
clang
-
tools
-
extra
/
clangd
/
unittests
/
DiagnosticsTests
.
cpp
-
1897
7
+
1897
7
fix
[
[
diag
[
[
#
include
"
unused
.
h
"
]
]
/
/
Off
by
default
.
EXPECT_THAT
(
*
TU
.
build
(
)
.
getDiagnostics
(
)
IsEmpty
(
)
)
;
Config
Cfg
;
-
Cfg
.
Diagnostics
.
UnusedIncludes
=
Config
:
:
UnusedIncludesPolicy
:
:
Strict
;
+
Cfg
.
Diagnostics
.
UnusedIncludes
=
Config
:
:
IncludesPolicy
:
:
Strict
;
/
/
Set
filtering
.
Cfg
.
Diagnostics
.
Includes
.
IgnoreHeader
.
emplace_back
(
[
]
(
llvm
:
:
StringRef
Header
)
{
return
Header
.
endswith
(
"
ignore
.
h
"
)
;
}
)
;
diff
-
-
git
a
/
clang
-
tools
-
extra
/
docs
/
ReleaseNotes
.
rst
b
/
clang
-
tools
-
extra
/
docs
/
ReleaseNotes
.
rst
index
434dcd955679
.
.
ddb64014ef78
100644
-
-
-
a
/
clang
-
tools
-
extra
/
docs
/
ReleaseNotes
.
rst
+
+
+
b
/
clang
-
tools
-
extra
/
docs
/
ReleaseNotes
.
rst
-
141
6
+
141
11
New
checks
Warns
when
empty
(
)
is
used
on
a
range
and
the
result
is
ignored
.
Suggests
clear
(
)
if
it
is
an
existing
member
function
.
+
-
New
:
doc
:
misc
-
include
-
cleaner
+
<
clang
-
tidy
/
checks
/
misc
/
include
-
cleaner
>
check
.
+
+
Checks
for
unused
and
missing
includes
.
+
New
check
aliases
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
^
diff
-
-
git
a
/
clang
-
tools
-
extra
/
docs
/
clang
-
tidy
/
checks
/
list
.
rst
b
/
clang
-
tools
-
extra
/
docs
/
clang
-
tidy
/
checks
/
list
.
rst
index
ec59eb87ad13
.
.
7500d2ee07c6
100644
-
-
-
a
/
clang
-
tools
-
extra
/
docs
/
clang
-
tidy
/
checks
/
list
.
rst
+
+
+
b
/
clang
-
tools
-
extra
/
docs
/
clang
-
tidy
/
checks
/
list
.
rst
-
246
6
+
246
7
Clang
-
Tidy
Checks
misc
-
confusable
-
identifiers
<
misc
/
confusable
-
identifiers
.
html
>
_
misc
-
const
-
correctness
<
misc
/
const
-
correctness
.
html
>
_
"
Yes
"
misc
-
definitions
-
in
-
headers
<
misc
/
definitions
-
in
-
headers
.
html
>
_
"
Yes
"
+
misc
-
include
-
cleaner
<
misc
/
include
-
cleaner
.
html
>
_
"
Yes
"
misc
-
misleading
-
bidirectional
<
misc
/
misleading
-
bidirectional
.
html
>
_
misc
-
misleading
-
identifier
<
misc
/
misleading
-
identifier
.
html
>
_
misc
-
misplaced
-
const
<
misc
/
misplaced
-
const
.
html
>
_
diff
-
-
git
a
/
clang
-
tools
-
extra
/
docs
/
clang
-
tidy
/
checks
/
misc
/
include
-
cleaner
.
rst
b
/
clang
-
tools
-
extra
/
docs
/
clang
-
tidy
/
checks
/
misc
/
include
-
cleaner
.
rst
new
file
mode
100644
index
000000000000
.
.
5c34df2563ff
-
-
-
/
dev
/
null
+
+
+
b
/
clang
-
tools
-
extra
/
docs
/
clang
-
tidy
/
checks
/
misc
/
include
-
cleaner
.
rst
-
0
0
+
1
34
+
.
.
title
:
:
clang
-
tidy
-
misc
-
include
-
cleaner
+
+
misc
-
include
-
cleaner
+
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
+
+
Checks
for
unused
and
missing
includes
.
Generates
findings
only
for
+
the
main
file
of
a
translation
unit
.
+
Findings
correspond
to
https
:
/
/
clangd
.
llvm
.
org
/
design
/
include
-
cleaner
.
+
+
Example
:
+
+
.
.
code
-
block
:
:
c
+
+
+
/
/
foo
.
h
+
class
Foo
{
}
;
+
/
/
bar
.
h
+
#
include
"
baz
.
h
"
+
class
Bar
{
}
;
+
/
/
baz
.
h
+
class
Baz
{
}
;
+
/
/
main
.
cc
+
#
include
"
bar
.
h
"
/
/
OK
:
uses
class
Bar
from
bar
.
h
+
#
include
"
foo
.
h
"
/
/
warning
:
unused
include
"
foo
.
h
"
+
Bar
bar
;
+
Baz
baz
;
/
/
warning
:
missing
include
"
baz
.
h
"
+
+
Options
+
-
-
-
-
-
-
-
+
+
.
.
option
:
:
IgnoreHeaders
+
+
A
semicolon
-
separated
list
of
regexes
to
disable
insertion
/
removal
of
header
+
files
that
match
this
regex
as
a
suffix
.
E
.
g
.
foo
/
.
*
disables
+
insertion
/
removal
for
all
headers
under
the
directory
foo
.
By
default
no
+
headers
will
be
ignored
.
diff
-
-
git
a
/
clang
-
tools
-
extra
/
include
-
cleaner
/
include
/
clang
-
include
-
cleaner
/
Analysis
.
h
b
/
clang
-
tools
-
extra
/
include
-
cleaner
/
include
/
clang
-
include
-
cleaner
/
Analysis
.
h
index
f6afaff09cfd
.
.
0365a7a5be1e
100644
-
-
-
a
/
clang
-
tools
-
extra
/
include
-
cleaner
/
include
/
clang
-
include
-
cleaner
/
Analysis
.
h
+
+
+
b
/
clang
-
tools
-
extra
/
include
-
cleaner
/
include
/
clang
-
include
-
cleaner
/
Analysis
.
h
-
73
6
+
73
9
AnalysisResults
analyze
(
llvm
:
:
ArrayRef
<
Decl
*
>
ASTRoots
std
:
:
string
fixIncludes
(
const
AnalysisResults
&
Results
llvm
:
:
StringRef
Code
const
format
:
:
FormatStyle
&
IncludeStyle
)
;
+
+
std
:
:
string
spellHeader
(
const
Header
&
H
HeaderSearch
&
HS
+
const
FileEntry
*
Main
)
;
}
/
/
namespace
include_cleaner
}
/
/
namespace
clang
diff
-
-
git
a
/
clang
-
tools
-
extra
/
include
-
cleaner
/
include
/
clang
-
include
-
cleaner
/
Record
.
h
b
/
clang
-
tools
-
extra
/
include
-
cleaner
/
include
/
clang
-
include
-
cleaner
/
Record
.
h
index
140713bf1280
.
.
0cbfe4b8f157
100644
-
-
-
a
/
clang
-
tools
-
extra
/
include
-
cleaner
/
include
/
clang
-
include
-
cleaner
/
Record
.
h
+
+
+
b
/
clang
-
tools
-
extra
/
include
-
cleaner
/
include
/
clang
-
include
-
cleaner
/
Record
.
h
-
18
6
+
18
7
#
define
CLANG_INCLUDE_CLEANER_RECORD_H
#
include
"
clang
-
include
-
cleaner
/
Types
.
h
"
+
#
include
"
clang
/
Basic
/
SourceLocation
.
h
"
#
include
"
llvm
/
ADT
/
DenseMap
.
h
"
#
include
"
llvm
/
ADT
/
DenseSet
.
h
"
#
include
"
llvm
/
ADT
/
SmallVector
.
h
"
-
52
6
+
53
10
public
:
/
/
/
to
the
structure
.
void
record
(
const
CompilerInstance
&
CI
)
;
+
/
/
/
Installs
an
analysing
PPCallback
and
CommentHandler
and
populates
results
+
/
/
/
to
the
structure
.
+
void
record
(
Preprocessor
&
P
)
;
+
/
/
/
Returns
true
if
the
given
#
include
of
the
main
-
file
should
never
be
/
/
/
removed
.
bool
shouldKeep
(
unsigned
HashLineNumber
)
const
{
diff
-
-
git
a
/
clang
-
tools
-
extra
/
include
-
cleaner
/
lib
/
Analysis
.
cpp
b
/
clang
-
tools
-
extra
/
include
-
cleaner
/
lib
/
Analysis
.
cpp
index
c5559db57e14
.
.
6237bdb46bab
100644
-
-
-
a
/
clang
-
tools
-
extra
/
include
-
cleaner
/
lib
/
Analysis
.
cpp
+
+
+
b
/
clang
-
tools
-
extra
/
include
-
cleaner
/
lib
/
Analysis
.
cpp
-
49
8
+
49
8
void
walkUsed
(
llvm
:
:
ArrayRef
<
Decl
*
>
ASTRoots
}
}
-
static
std
:
:
string
spellHeader
(
const
Header
&
H
HeaderSearch
&
HS
-
const
FileEntry
*
Main
)
{
+
std
:
:
string
spellHeader
(
const
Header
&
H
HeaderSearch
&
HS
+
const
FileEntry
*
Main
)
{
switch
(
H
.
kind
(
)
)
{
case
Header
:
:
Physical
:
{
bool
IsSystem
=
false
;
diff
-
-
git
a
/
clang
-
tools
-
extra
/
include
-
cleaner
/
lib
/
Record
.
cpp
b
/
clang
-
tools
-
extra
/
include
-
cleaner
/
lib
/
Record
.
cpp
index
51fd39300d7c
.
.
089d7ea749ca
100644
-
-
-
a
/
clang
-
tools
-
extra
/
include
-
cleaner
/
lib
/
Record
.
cpp
+
+
+
b
/
clang
-
tools
-
extra
/
include
-
cleaner
/
lib
/
Record
.
cpp
-
19
6
+
19
8
#
include
"
clang
/
Lex
/
Preprocessor
.
h
"
#
include
"
clang
/
Tooling
/
Inclusions
/
HeaderAnalysis
.
h
"
#
include
"
clang
/
Tooling
/
Inclusions
/
StandardLibrary
.
h
"
+
#
include
<
memory
>
+
#
include
<
utility
>
namespace
clang
:
:
include_cleaner
{
namespace
{
-
148
8
+
150
9
private
:
class
PragmaIncludes
:
:
RecordPragma
:
public
PPCallbacks
public
CommentHandler
{
public
:
RecordPragma
(
const
CompilerInstance
&
CI
PragmaIncludes
*
Out
)
-
:
SM
(
CI
.
getSourceManager
(
)
)
-
HeaderInfo
(
CI
.
getPreprocessor
(
)
.
getHeaderSearchInfo
(
)
)
Out
(
Out
)
+
:
RecordPragma
(
CI
.
getPreprocessor
(
)
Out
)
{
}
+
RecordPragma
(
const
Preprocessor
&
P
PragmaIncludes
*
Out
)
+
:
SM
(
P
.
getSourceManager
(
)
)
HeaderInfo
(
P
.
getHeaderSearchInfo
(
)
)
Out
(
Out
)
UniqueStrings
(
Arena
)
{
}
void
FileChanged
(
SourceLocation
Loc
FileChangeReason
Reason
-
342
6
+
345
12
void
PragmaIncludes
:
:
record
(
const
CompilerInstance
&
CI
)
{
CI
.
getPreprocessor
(
)
.
addPPCallbacks
(
std
:
:
move
(
Record
)
)
;
}
+
void
PragmaIncludes
:
:
record
(
Preprocessor
&
P
)
{
+
auto
Record
=
std
:
:
make_unique
<
RecordPragma
>
(
P
this
)
;
+
P
.
addCommentHandler
(
Record
.
get
(
)
)
;
+
P
.
addPPCallbacks
(
std
:
:
move
(
Record
)
)
;
+
}
+
llvm
:
:
StringRef
PragmaIncludes
:
:
getPublic
(
const
FileEntry
*
F
)
const
{
auto
It
=
IWYUPublic
.
find
(
F
-
>
getUniqueID
(
)
)
;
if
(
It
=
=
IWYUPublic
.
end
(
)
)
-
350
8
+
359
8
llvm
:
:
StringRef
PragmaIncludes
:
:
getPublic
(
const
FileEntry
*
F
)
const
{
}
static
llvm
:
:
SmallVector
<
const
FileEntry
*
>
-
toFileEntries
(
llvm
:
:
ArrayRef
<
StringRef
>
FileNames
FileManager
&
FM
)
{
-
llvm
:
:
SmallVector
<
const
FileEntry
*
>
Results
;
+
toFileEntries
(
llvm
:
:
ArrayRef
<
StringRef
>
FileNames
FileManager
&
FM
)
{
+
llvm
:
:
SmallVector
<
const
FileEntry
*
>
Results
;
for
(
auto
FName
:
FileNames
)
{
/
/
FIMXE
:
log
the
failing
cases
?
