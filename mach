#
!
/
usr
/
bin
/
env
python3
#
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
#
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
#
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
from
__future__
import
absolute_import
print_function
unicode_literals
import
os
import
sys
def
load_mach
(
dir_path
mach_path
)
:
import
importlib
.
util
spec
=
importlib
.
util
.
spec_from_file_location
(
'
mach_initialize
'
mach_path
)
mach_initialize
=
importlib
.
util
.
module_from_spec
(
spec
)
spec
.
loader
.
exec_module
(
mach_initialize
)
return
mach_initialize
.
initialize
(
dir_path
)
def
check_and_get_mach
(
dir_path
)
:
initialize_paths
=
(
#
Run
Thunderbird
'
s
mach_initialize
.
py
if
it
exists
'
comm
/
build
/
mach_initialize
.
py
'
'
build
/
mach_initialize
.
py
'
#
test
package
initialize
'
tools
/
mach_initialize
.
py
'
)
for
initialize_path
in
initialize_paths
:
mach_path
=
os
.
path
.
join
(
dir_path
initialize_path
)
if
os
.
path
.
isfile
(
mach_path
)
:
return
load_mach
(
dir_path
mach_path
)
return
None
def
main
(
args
)
:
#
XCode
python
sets
__PYVENV_LAUNCHER__
which
overrides
the
executable
#
used
when
a
python
subprocess
is
created
.
This
is
an
issue
when
we
want
#
to
run
using
our
virtualenv
python
executables
.
#
In
future
Python
relases
__PYVENV_LAUNCHER__
will
be
cleared
before
#
application
code
(
mach
)
is
started
.
#
https
:
/
/
github
.
com
/
python
/
cpython
/
pull
/
9516
os
.
environ
.
pop
(
"
__PYVENV_LAUNCHER__
"
None
)
mach
=
check_and_get_mach
(
os
.
path
.
dirname
(
os
.
path
.
realpath
(
__file__
)
)
)
if
not
mach
:
print
(
'
Could
not
run
mach
:
No
mach
source
directory
found
.
'
)
sys
.
exit
(
1
)
sys
.
exit
(
mach
.
run
(
args
)
)
if
__name__
=
=
'
__main__
'
:
main
(
sys
.
argv
[
1
:
]
)
