/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
"
use
strict
"
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
EventDispatcher
:
"
resource
:
/
/
gre
/
modules
/
Messaging
.
jsm
"
}
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
GeckoViewUtils
"
]
;
var
GeckoViewUtils
=
{
/
*
*
*
Define
a
lazy
getter
that
loads
an
object
from
external
code
and
*
optionally
handles
observer
and
/
or
message
manager
notifications
for
the
*
object
so
the
object
only
loads
when
a
notification
is
received
.
*
*
param
scope
Scope
for
holding
the
loaded
object
.
*
param
name
Name
of
the
object
to
load
.
*
param
script
If
specified
load
the
object
from
a
JS
subscript
.
*
param
service
If
specified
load
the
object
from
a
JS
component
;
the
*
component
must
include
the
line
*
"
this
.
wrappedJSObject
=
this
;
"
in
its
constructor
.
*
param
module
If
specified
load
the
object
from
a
JS
module
.
*
param
init
For
non
-
scripts
optional
post
-
load
initialization
function
.
*
param
observers
If
specified
listen
to
specified
observer
notifications
.
*
param
ppmm
If
specified
listen
to
specified
process
messages
.
*
param
mm
If
specified
listen
to
specified
frame
messages
.
*
param
ged
If
specified
listen
to
specified
global
EventDispatcher
events
.
*
param
once
If
specified
only
listen
to
the
specified
*
notifications
/
messages
once
.
*
/
addLazyGetter
:
function
(
scope
name
{
script
service
module
handler
observers
ppmm
mm
ged
init
once
}
)
{
if
(
script
)
{
XPCOMUtils
.
defineLazyScriptGetter
(
scope
name
script
)
;
}
else
{
XPCOMUtils
.
defineLazyGetter
(
scope
name
_
=
>
{
let
ret
=
undefined
;
if
(
module
)
{
ret
=
Cu
.
import
(
module
{
}
)
[
name
]
;
}
else
if
(
service
)
{
ret
=
Cc
[
service
]
.
getService
(
Ci
.
nsISupports
)
.
wrappedJSObject
;
}
else
if
(
typeof
handler
=
=
=
"
function
"
)
{
ret
=
{
handleEvent
:
handler
observe
:
handler
onEvent
:
handler
receiveMessage
:
handler
}
;
}
else
if
(
handler
)
{
ret
=
handler
;
}
if
(
ret
&
&
init
)
{
init
.
call
(
scope
ret
)
;
}
return
ret
;
}
)
;
}
if
(
observers
)
{
let
observer
=
(
subject
topic
data
)
=
>
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
if
(
!
once
)
{
Services
.
obs
.
addObserver
(
scope
[
name
]
topic
)
;
}
scope
[
name
]
.
observe
(
subject
topic
data
)
;
/
/
Explicitly
notify
new
observer
}
;
observers
.
forEach
(
topic
=
>
Services
.
obs
.
addObserver
(
observer
topic
)
)
;
}
if
(
ppmm
|
|
mm
)
{
let
target
=
ppmm
?
Services
.
ppmm
:
Services
.
mm
;
let
listener
=
msg
=
>
{
target
.
removeMessageListener
(
msg
.
name
listener
)
;
if
(
!
once
)
{
target
.
addMessageListener
(
msg
.
name
scope
[
name
]
)
;
}
scope
[
name
]
.
receiveMessage
(
msg
)
;
}
;
(
ppmm
|
|
mm
)
.
forEach
(
msg
=
>
target
.
addMessageListener
(
msg
listener
)
)
;
}
if
(
ged
)
{
let
listener
=
(
event
data
callback
)
=
>
{
EventDispatcher
.
instance
.
unregisterListener
(
listener
event
)
;
if
(
!
once
)
{
EventDispatcher
.
instance
.
registerListener
(
scope
[
name
]
event
)
;
}
scope
[
name
]
.
onEvent
(
event
data
callback
)
;
}
;
EventDispatcher
.
instance
.
registerListener
(
listener
ged
)
;
}
}
/
*
*
*
Add
lazy
event
listeners
that
only
load
the
actual
handler
when
an
event
*
is
being
handled
.
*
*
param
target
Event
target
for
the
event
listeners
.
*
param
events
Event
name
as
a
string
or
array
.
*
param
handler
If
specified
function
that
for
a
given
event
returns
the
*
actual
event
handler
as
an
object
or
an
array
of
objects
.
*
If
handler
is
not
specified
the
actual
event
handler
is
*
specified
using
the
scope
and
name
pair
.
*
param
scope
See
handler
.
*
param
name
See
handler
.
*
param
options
Options
for
addEventListener
.
*
/
addLazyEventListener
:
function
(
target
events
{
handler
scope
name
options
}
)
{
if
(
!
handler
)
{
handler
=
(
_
=
>
Array
.
isArray
(
name
)
?
name
.
map
(
n
=
>
scope
[
n
]
)
:
scope
[
name
]
)
;
}
let
listener
=
event
=
>
{
let
handlers
=
handler
(
event
)
;
if
(
!
handlers
)
{
return
;
}
if
(
!
Array
.
isArray
(
handlers
)
)
{
handlers
=
[
handlers
]
;
}
if
(
!
options
|
|
!
options
.
once
)
{
target
.
removeEventListener
(
event
.
type
listener
options
)
;
handlers
.
forEach
(
handler
=
>
target
.
addEventListener
(
event
.
type
handler
options
)
)
;
}
handlers
.
forEach
(
handler
=
>
handler
.
handleEvent
(
event
)
)
;
}
;
if
(
Array
.
isArray
(
events
)
)
{
events
.
forEach
(
event
=
>
target
.
addEventListener
(
event
listener
options
)
)
;
}
else
{
target
.
addEventListener
(
events
listener
options
)
;
}
}
/
*
*
*
Return
the
outermost
chrome
DOM
window
(
the
XUL
window
)
for
a
given
DOM
*
window
.
*
*
param
aWin
a
DOM
window
.
*
/
getChromeWindow
:
function
(
aWin
)
{
return
aWin
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDocShell
)
.
QueryInterface
(
Ci
.
nsIDocShellTreeItem
)
.
rootTreeItem
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
}
/
*
*
*
Return
the
per
-
nsWindow
EventDispatcher
for
a
given
DOM
window
.
*
*
param
aWin
a
DOM
window
.
*
/
getDispatcherForWindow
:
function
(
aWin
)
{
let
win
=
this
.
getChromeWindow
(
aWin
.
top
)
;
return
win
.
WindowEventDispatcher
|
|
EventDispatcher
.
for
(
win
)
;
}
}
;
