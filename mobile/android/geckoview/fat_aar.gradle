/
/
Produce
a
multi
-
architecture
universal
"
fat
AAR
"
.
/
/
/
/
This
uses
Gradle
to
:
/
/
/
/
1
)
download
per
-
architecture
AARs
/
/
2
)
ensure
that
they
are
"
compatible
"
/
/
3
)
pack
the
per
-
architecture
JNI
libraries
into
the
GeckoView
library
import
org
.
gradle
.
api
.
file
.
FileTree
Set
contentHashes
(
FileTree
tree
)
{
def
Set
hashes
=
[
]
tree
.
visit
{
if
(
!
it
.
isDirectory
(
)
)
{
hashes
<
<
[
it
.
relativePath
.
pathString
ext
.
DigestUtils
.
md5Hex
(
it
.
open
(
)
)
]
}
}
return
hashes
}
Set
contentDiff
(
FileTree
left
FileTree
right
)
{
def
Set
hleft
=
contentHashes
(
left
)
def
Set
hright
=
contentHashes
(
right
)
return
(
hleft
+
hright
)
-
hleft
.
intersect
(
hright
)
}
def
ANDROID_CPU_ARCH
=
mozconfig
.
substs
.
ANDROID_CPU_ARCH
def
MOZ_ANDROID_FAT_AAR_TARGETS
=
mozconfig
.
substs
.
MOZ_ANDROID_FAT_AAR_TARGETS
task
downloadMavenZips
task
unpackMavenZips
/
/
Turn
[
"
arch1
=
url1
"
"
arch2
=
url2
"
]
into
[
"
arch1
"
:
"
url1
"
"
arch2
"
:
"
url2
"
]
.
def
srcs
=
MOZ_ANDROID_FAT_AAR_TARGETS
.
collectEntries
{
def
pair
=
it
.
split
(
'
=
'
)
[
(
pair
.
first
(
)
)
:
pair
.
last
(
)
]
}
if
(
!
srcs
.
containsKey
(
ANDROID_CPU_ARCH
)
)
{
throw
new
GradleException
(
"
MOZ_ANDROID_FAT_AAR_TARGETS
set
but
current
architecture
(
{
ANDROID_CPU_ARCH
}
)
not
included
:
'
{
MOZ_ANDROID_FAT_AAR_TARGETS
}
'
"
)
}
for
(
s
in
srcs
)
{
def
downloadMavenZipTask
=
task
"
downloadMavenZip
{
s
.
key
.
capitalize
(
)
}
"
(
type
:
Download
)
{
src
s
.
value
dest
file
(
"
{
buildDir
}
/
fat_aar
/
{
s
.
key
}
-
{
s
.
value
.
hashCode
(
)
}
.
maven
.
zip
"
)
doFirst
{
if
(
it
.
dest
.
exists
(
)
)
{
throw
new
StopExecutionException
(
"
File
to
download
already
exists
:
{
it
.
dest
.
path
}
"
)
}
}
overwrite
true
}
downloadMavenZips
.
dependsOn
(
downloadMavenZipTask
)
/
/
This
is
awkward
but
extracting
from
nested
zipTree
instances
seems
to
be
/
/
very
challenging
:
Gradle
really
really
really
wants
to
resolve
the
/
/
internal
zipTree
dependencies
at
configure
time
before
the
outer
zipTree
/
/
has
been
downloaded
.
def
unpackMavenZipTask
=
task
"
unpackMavenZip
{
s
.
key
.
capitalize
(
)
}
"
(
dependsOn
:
downloadMavenZipTask
)
{
inputs
.
files
downloadMavenZipTask
.
dest
outputs
.
dir
file
(
"
{
buildDir
}
/
fat_aar
/
{
s
.
key
}
"
)
/
/
Capture
for
the
closure
below
.
def
key
=
s
.
key
/
/
sync
{
.
.
.
}
from
zipTree
doesn
'
t
seem
to
be
supported
.
doFirst
{
delete
file
(
"
{
buildDir
}
/
fat_aar
/
{
key
}
"
)
}
doLast
{
copy
{
from
zipTree
(
zipTree
(
tasks
[
"
downloadMavenZip
{
key
.
capitalize
(
)
}
"
]
.
dest
)
.
files
.
find
{
it
.
name
.
endsWith
(
'
.
aar
'
)
}
)
into
file
(
"
{
buildDir
}
/
fat_aar
/
{
key
}
"
)
}
}
}
unpackMavenZips
.
dependsOn
(
unpackMavenZipTask
)
}
task
checkAARs
(
dependsOn
:
unpackMavenZips
)
{
inputs
.
files
unpackMavenZips
.
outputs
.
files
doFirst
{
def
base
=
fileTree
(
"
{
buildDir
}
/
fat_aar
/
{
ANDROID_CPU_ARCH
}
"
)
for
(
s
in
srcs
)
{
if
(
s
.
key
=
=
ANDROID_CPU_ARCH
)
{
continue
}
def
other
=
fileTree
(
"
{
buildDir
}
/
fat_aar
/
{
s
.
key
}
"
)
/
/
So
:
/
/
-
obviously
the
JNI
libraries
themselves
are
different
across
architectures
/
/
-
AndroidManifest
.
xml
embeds
MIN_SDK_VERSION
which
differs
on
64
-
bit
/
/
architectures
(
21
)
vs
non
-
64
-
bit
architectures
(
15
)
/
/
-
classes
.
jar
also
embeds
MIN_SDK_VERSION
which
differs
on
64
-
bit
/
/
architectures
(
21
)
vs
non
-
64
-
bit
architectures
(
15
)
/
/
-
annotations
.
zip
doesn
'
t
have
constant
timestamps
/
/
-
assets
/
omni
.
ja
is
actually
different
(
buildconfig
.
html
embeds
target
architecture
)
/
/
/
/
For
reasons
unknown
AARs
have
an
empty
top
-
level
ARCH
/
/
directory
but
we
ignore
directories
so
it
needs
no
special
/
/
accommodation
.
def
diff
=
contentDiff
(
base
.
exclude
(
'
jni
/
*
*
'
)
.
exclude
(
'
AndroidManifest
.
xml
'
)
.
exclude
(
'
classes
.
jar
'
)
.
exclude
(
'
annotations
.
zip
'
)
.
exclude
(
'
assets
/
omni
.
ja
'
)
other
.
exclude
(
'
jni
/
*
*
'
)
.
exclude
(
'
AndroidManifest
.
xml
'
)
.
exclude
(
'
classes
.
jar
'
)
.
exclude
(
'
annotations
.
zip
'
)
.
exclude
(
'
assets
/
omni
.
ja
'
)
)
if
(
!
diff
.
isEmpty
(
)
)
{
throw
new
GradleException
(
"
{
ANDROID_CPU_ARCH
}
AAR
and
{
s
.
key
}
AAR
disagree
:
{
diff
}
"
)
}
def
classes
=
contentDiff
(
zipTree
(
"
{
buildDir
}
/
fat_aar
/
{
ANDROID_CPU_ARCH
}
/
classes
.
jar
"
)
.
matching
{
exclude
(
'
org
/
mozilla
/
geckoview
/
BuildConfig
.
class
'
)
exclude
(
'
org
/
mozilla
/
gecko
/
util
/
HardwareUtils
.
class
'
)
}
zipTree
(
"
{
buildDir
}
/
fat_aar
/
{
s
.
key
}
/
classes
.
jar
"
)
.
matching
{
exclude
(
'
org
/
mozilla
/
geckoview
/
BuildConfig
.
class
'
)
exclude
(
'
org
/
mozilla
/
gecko
/
util
/
HardwareUtils
.
class
'
)
}
)
if
(
!
classes
.
isEmpty
(
)
)
{
throw
new
GradleException
(
"
{
buildDir
}
/
fat_aar
/
{
ANDROID_CPU_ARCH
}
/
classes
.
jar
and
{
buildDir
}
/
fat_aar
/
{
s
.
key
}
/
classes
.
jar
disagree
:
{
classes
}
"
)
}
def
annotations
=
contentDiff
(
zipTree
(
"
{
buildDir
}
/
fat_aar
/
{
ANDROID_CPU_ARCH
}
/
annotations
.
zip
"
)
zipTree
(
"
{
buildDir
}
/
fat_aar
/
{
s
.
key
}
/
annotations
.
zip
"
)
)
if
(
!
annotations
.
isEmpty
(
)
)
{
throw
new
GradleException
(
"
{
buildDir
}
/
fat_aar
/
{
ANDROID_CPU_ARCH
}
/
annotations
.
zip
and
{
buildDir
}
/
fat_aar
/
{
s
.
key
}
/
annotations
.
zip
disagree
:
{
annotations
}
"
)
}
/
/
buildconfig
.
html
is
special
.
def
omnijar
=
contentDiff
(
zipTree
(
"
{
buildDir
}
/
fat_aar
/
{
ANDROID_CPU_ARCH
}
/
assets
/
omni
.
ja
"
)
.
matching
{
exclude
(
'
*
*
/
buildconfig
.
html
'
)
}
zipTree
(
"
{
buildDir
}
/
fat_aar
/
{
s
.
key
}
/
assets
/
omni
.
ja
"
)
.
matching
{
exclude
(
'
*
*
/
buildconfig
.
html
'
)
}
)
if
(
!
omnijar
.
isEmpty
(
)
)
{
/
/
Let
'
s
make
this
easy
to
debug
locally
at
least
.
def
relPaths
=
omnijar
.
collectEntries
(
)
.
keySet
(
)
copy
{
from
zipTree
(
"
{
buildDir
}
/
fat_aar
/
{
ANDROID_CPU_ARCH
}
/
assets
/
omni
.
ja
"
)
into
file
(
"
{
buildDir
}
/
fat_aar
/
{
ANDROID_CPU_ARCH
}
/
omnijar
"
)
for
(
relPath
in
relPaths
)
{
include
relPath
}
}
copy
{
from
zipTree
(
"
{
buildDir
}
/
fat_aar
/
{
s
.
key
}
/
assets
/
omni
.
ja
"
)
into
file
(
"
{
buildDir
}
/
fat_aar
/
{
s
.
key
}
/
omnijar
"
)
for
(
relPath
in
relPaths
)
{
include
relPath
}
}
def
pairs
=
relPaths
.
collect
{
relPath
-
>
"
(
{
buildDir
}
/
fat_aar
/
{
ANDROID_CPU_ARCH
}
/
omnijar
/
{
relPath
}
{
buildDir
}
/
fat_aar
/
{
s
.
key
}
/
omnijar
/
{
relPath
}
)
"
}
throw
new
GradleException
(
"
{
buildDir
}
/
fat_aar
/
{
ANDROID_CPU_ARCH
}
/
assets
/
omni
.
ja
and
{
buildDir
}
/
fat_aar
/
{
s
.
key
}
/
assets
/
omni
.
ja
disagree
:
{
pairs
}
"
)
}
}
}
}
android
.
libraryVariants
.
all
{
variant
-
>
if
(
(
variant
.
productFlavors
*
.
name
)
.
contains
(
'
withGeckoBinaries
'
)
)
{
def
assetGenTask
=
tasks
.
findByName
(
"
generate
{
variant
.
name
.
capitalize
(
)
}
Assets
"
)
assetGenTask
.
dependsOn
checkAARs
for
(
s
in
srcs
)
{
/
/
We
want
to
ensure
that
nothing
changed
between
this
build
and
/
/
the
upstream
AAR
but
don
'
t
want
to
pack
the
binaries
/
/
corresponding
to
this
build
'
s
architecture
twice
.
if
(
s
.
key
=
=
ANDROID_CPU_ARCH
)
{
continue
}
android
.
sourceSets
.
"
{
variant
.
name
}
"
.
jniLibs
.
srcDir
"
{
buildDir
}
/
fat_aar
/
{
s
.
key
}
/
jni
"
}
}
}
