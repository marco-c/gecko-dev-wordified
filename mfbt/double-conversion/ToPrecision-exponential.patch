diff
-
-
git
a
/
mfbt
/
double
-
conversion
/
double
-
conversion
/
double
-
to
-
string
.
cc
b
/
mfbt
/
double
-
conversion
/
double
-
conversion
/
double
-
to
-
string
.
cc
index
9255bce1713e9
.
.
1437e48bfd870
100644
-
-
-
a
/
mfbt
/
double
-
conversion
/
double
-
conversion
/
double
-
to
-
string
.
cc
+
+
+
b
/
mfbt
/
double
-
conversion
/
double
-
conversion
/
double
-
to
-
string
.
cc
-
290
17
+
290
19
bool
DoubleToStringConverter
:
:
ToExponential
(
exponent
result_builder
)
;
return
true
;
}
bool
DoubleToStringConverter
:
:
ToPrecision
(
double
value
int
precision
+
bool
*
used_exponential_notation
StringBuilder
*
result_builder
)
const
{
+
*
used_exponential_notation
=
false
;
if
(
Double
(
value
)
.
IsSpecial
(
)
)
{
return
HandleSpecialValues
(
value
result_builder
)
;
}
if
(
precision
<
kMinPrecisionDigits
|
|
precision
>
kMaxPrecisionDigits
)
{
return
false
;
}
-
344
16
+
346
17
bool
DoubleToStringConverter
:
:
ToPrecision
(
double
value
if
(
as_exponential
)
{
/
/
Fill
buffer
to
contain
'
precision
'
digits
.
/
/
Usually
the
buffer
is
already
at
the
correct
length
but
'
DoubleToAscii
'
/
/
is
allowed
to
return
less
characters
.
for
(
int
i
=
decimal_rep_length
;
i
<
precision
;
+
+
i
)
{
decimal_rep
[
i
]
=
'
0
'
;
}
+
*
used_exponential_notation
=
true
;
CreateExponentialRepresentation
(
decimal_rep
precision
exponent
result_builder
)
;
}
else
{
CreateDecimalRepresentation
(
decimal_rep
decimal_rep_length
decimal_point
(
std
:
:
max
)
(
0
precision
-
decimal_point
)
result_builder
)
;
diff
-
-
git
a
/
mfbt
/
double
-
conversion
/
double
-
conversion
/
double
-
to
-
string
.
h
b
/
mfbt
/
double
-
conversion
/
double
-
conversion
/
double
-
to
-
string
.
h
index
52d7986fe9048
.
.
a335f5c1ae55d
100644
-
-
-
a
/
mfbt
/
double
-
conversion
/
double
-
conversion
/
double
-
to
-
string
.
h
+
+
+
b
/
mfbt
/
double
-
conversion
/
double
-
conversion
/
double
-
to
-
string
.
h
-
330
16
+
330
17
class
DoubleToStringConverter
{
/
/
-
precision
>
kMaxPrecisionDigits
/
/
/
/
The
last
condition
implies
that
the
result
never
contains
more
than
/
/
kMaxPrecisionDigits
+
7
characters
(
the
sign
the
decimal
point
the
/
/
exponent
character
the
exponent
'
s
sign
and
at
most
3
exponent
digits
)
.
/
/
In
addition
the
buffer
must
be
able
to
hold
the
trailing
'
\
0
'
character
.
MFBT_API
bool
ToPrecision
(
double
value
int
precision
+
bool
*
used_exponential_notation
StringBuilder
*
result_builder
)
const
;
enum
DtoaMode
{
/
/
Produce
the
shortest
correct
representation
.
/
/
For
example
the
output
of
0
.
299999999999999988897
is
(
the
less
accurate
/
/
but
correct
)
0
.
3
.
SHORTEST
/
/
Same
as
SHORTEST
but
for
single
-
precision
floats
.
