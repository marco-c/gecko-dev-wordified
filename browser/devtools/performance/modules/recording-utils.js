/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
file
*
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
"
use
strict
"
;
const
{
Cc
Ci
Cu
Cr
}
=
require
(
"
chrome
"
)
;
/
*
*
*
Utility
functions
for
managing
recording
models
and
their
internal
data
*
such
as
filtering
profile
samples
or
offsetting
timestamps
.
*
/
exports
.
RecordingUtils
=
{
}
;
/
*
*
*
Filters
all
the
samples
in
the
provided
profiler
data
to
be
more
recent
*
than
the
specified
start
time
.
*
*
param
object
profile
*
The
profiler
data
received
from
the
backend
.
*
param
number
profilerStartTime
*
The
earliest
acceptable
sample
time
(
in
milliseconds
)
.
*
/
exports
.
RecordingUtils
.
filterSamples
=
function
(
profile
profilerStartTime
)
{
let
firstThread
=
profile
.
threads
[
0
]
;
const
TIME_SLOT
=
firstThread
.
samples
.
schema
.
time
;
firstThread
.
samples
.
data
=
firstThread
.
samples
.
data
.
filter
(
e
=
>
{
return
e
[
TIME_SLOT
]
>
=
profilerStartTime
;
}
)
;
}
/
*
*
*
Offsets
all
the
samples
in
the
provided
profiler
data
by
the
specified
time
.
*
*
param
object
profile
*
The
profiler
data
received
from
the
backend
.
*
param
number
timeOffset
*
The
amount
of
time
to
offset
by
(
in
milliseconds
)
.
*
/
exports
.
RecordingUtils
.
offsetSampleTimes
=
function
(
profile
timeOffset
)
{
let
firstThread
=
profile
.
threads
[
0
]
;
const
TIME_SLOT
=
firstThread
.
samples
.
schema
.
time
;
let
samplesData
=
firstThread
.
samples
.
data
;
for
(
let
i
=
0
;
i
<
samplesData
.
length
;
i
+
+
)
{
samplesData
[
i
]
[
TIME_SLOT
]
-
=
timeOffset
;
}
}
/
*
*
*
Offsets
all
the
markers
in
the
provided
timeline
data
by
the
specified
time
.
*
*
param
array
markers
*
The
markers
array
received
from
the
backend
.
*
param
number
timeOffset
*
The
amount
of
time
to
offset
by
(
in
milliseconds
)
.
*
/
exports
.
RecordingUtils
.
offsetMarkerTimes
=
function
(
markers
timeOffset
)
{
for
(
let
marker
of
markers
)
{
marker
.
start
-
=
timeOffset
;
marker
.
end
-
=
timeOffset
;
}
}
/
*
*
*
Offsets
and
scales
all
the
timestamps
in
the
provided
array
by
the
*
specified
time
and
scale
factor
.
*
*
param
array
array
*
A
list
of
timestamps
received
from
the
backend
.
*
param
number
timeOffset
*
The
amount
of
time
to
offset
by
(
in
milliseconds
)
.
*
param
number
timeScale
*
The
factor
to
scale
by
after
offsetting
.
*
/
exports
.
RecordingUtils
.
offsetAndScaleTimestamps
=
function
(
timestamps
timeOffset
timeScale
)
{
for
(
let
i
=
0
len
=
timestamps
.
length
;
i
<
len
;
i
+
+
)
{
timestamps
[
i
]
-
=
timeOffset
;
timestamps
[
i
]
/
=
timeScale
;
}
}
/
*
*
*
Cache
used
in
RecordingUtils
.
getSamplesFromAllocations
.
*
/
let
gSamplesFromAllocationCache
=
new
WeakMap
(
)
;
/
*
*
*
Converts
allocation
data
from
the
memory
actor
to
something
that
follows
*
the
same
structure
as
the
samples
data
received
from
the
profiler
.
*
*
see
MemoryActor
.
prototype
.
getAllocations
for
more
information
.
*
*
param
object
allocations
*
A
list
of
{
sites
timestamps
frames
counts
}
arrays
.
*
return
array
*
The
samples
data
.
*
/
exports
.
RecordingUtils
.
getSamplesFromAllocations
=
function
(
allocations
)
{
let
cached
=
gSamplesFromAllocationCache
.
get
(
allocations
)
;
if
(
cached
)
{
return
cached
;
}
let
{
sites
timestamps
frames
counts
}
=
allocations
;
let
samples
=
[
]
;
for
(
let
i
=
0
len
=
sites
.
length
;
i
<
len
;
i
+
+
)
{
let
site
=
sites
[
i
]
;
let
timestamp
=
timestamps
[
i
]
;
let
frame
=
frames
[
site
]
;
let
count
=
counts
[
site
]
;
let
sample
=
{
time
:
timestamp
frames
:
[
]
}
;
samples
.
push
(
sample
)
;
while
(
frame
)
{
let
source
=
frame
.
source
+
"
:
"
+
frame
.
line
+
"
:
"
+
frame
.
column
;
let
funcName
=
frame
.
functionDisplayName
|
|
"
"
;
sample
.
frames
.
push
(
{
location
:
funcName
?
funcName
+
"
(
"
+
source
+
"
)
"
:
source
allocations
:
count
}
)
;
site
=
frame
.
parent
;
frame
=
frames
[
site
]
;
count
=
counts
[
site
]
;
}
sample
.
frames
.
reverse
(
)
;
}
gSamplesFromAllocationCache
.
set
(
allocations
samples
)
;
return
samples
;
}
/
*
*
*
Gets
the
current
timeline
blueprint
without
the
hidden
markers
.
*
*
param
blueprint
*
The
default
timeline
blueprint
.
*
param
array
hiddenMarkers
*
A
list
of
hidden
markers
'
names
.
*
return
object
*
The
filtered
timeline
blueprint
.
*
/
exports
.
RecordingUtils
.
getFilteredBlueprint
=
function
(
{
blueprint
hiddenMarkers
}
)
{
let
filteredBlueprint
=
Cu
.
cloneInto
(
blueprint
{
}
)
;
let
maybeRemovedGroups
=
new
Set
(
)
;
let
removedGroups
=
new
Set
(
)
;
/
/
1
.
Remove
hidden
markers
from
the
blueprint
.
for
(
let
hiddenMarkerName
of
hiddenMarkers
)
{
maybeRemovedGroups
.
add
(
filteredBlueprint
[
hiddenMarkerName
]
.
group
)
;
delete
filteredBlueprint
[
hiddenMarkerName
]
;
}
/
/
2
.
Get
a
list
of
all
the
groups
that
will
be
removed
.
for
(
let
maybeRemovedGroup
of
maybeRemovedGroups
)
{
let
markerNames
=
Object
.
keys
(
filteredBlueprint
)
;
let
isGroupRemoved
=
markerNames
.
every
(
e
=
>
filteredBlueprint
[
e
]
.
group
!
=
maybeRemovedGroup
)
;
if
(
isGroupRemoved
)
{
removedGroups
.
add
(
maybeRemovedGroup
)
;
}
}
/
/
3
.
Offset
groups
so
that
their
indices
are
consecutive
.
for
(
let
removedGroup
of
removedGroups
)
{
let
markerNames
=
Object
.
keys
(
filteredBlueprint
)
;
for
(
let
markerName
of
markerNames
)
{
let
markerDetails
=
filteredBlueprint
[
markerName
]
;
if
(
markerDetails
.
group
>
removedGroup
)
{
markerDetails
.
group
-
-
;
}
}
}
return
filteredBlueprint
;
}
;
/
*
*
*
Deduplicates
a
profile
by
deduplicating
stacks
frames
and
strings
.
*
*
This
is
used
to
adapt
version
2
profiles
from
the
backend
to
version
3
for
*
use
with
older
Geckos
(
like
B2G
)
.
*
*
Note
that
the
schemas
used
by
this
must
be
kept
in
sync
with
schemas
used
*
by
the
C
+
+
UniqueStacks
class
in
tools
/
profiler
/
ProfileEntry
.
cpp
.
*
*
param
object
profile
*
A
profile
with
version
2
.
*
/
exports
.
RecordingUtils
.
deflateProfile
=
function
deflateProfile
(
profile
)
{
profile
.
threads
=
profile
.
threads
.
map
(
(
thread
)
=
>
{
let
uniqueStacks
=
new
UniqueStacks
(
)
;
return
deflateThread
(
thread
uniqueStacks
)
;
}
)
;
profile
.
meta
.
version
=
3
;
}
;
/
*
*
*
Given
an
array
of
frame
objects
deduplicates
each
frame
as
well
as
all
*
prefixes
in
the
stack
.
Returns
the
index
of
the
deduplicated
stack
.
*
*
param
object
frames
*
Array
of
frame
objects
.
*
param
UniqueStacks
uniqueStacks
*
return
number
index
*
/
function
deflateStack
(
frames
uniqueStacks
)
{
/
/
Deduplicate
every
prefix
in
the
stack
by
keeping
track
of
the
current
/
/
prefix
hash
.
let
prefixIndex
=
null
;
for
(
let
i
=
0
;
i
<
frames
.
length
;
i
+
+
)
{
let
frameIndex
=
uniqueStacks
.
getOrAddFrameIndex
(
frames
[
i
]
)
;
prefixIndex
=
uniqueStacks
.
getOrAddStackIndex
(
prefixIndex
frameIndex
)
;
}
return
prefixIndex
;
}
/
*
*
*
Given
an
array
of
sample
objects
deduplicate
each
sample
'
s
stack
and
*
convert
the
samples
to
a
table
with
a
schema
.
Returns
the
deflated
samples
.
*
*
param
object
samples
*
Array
of
samples
*
param
UniqueStacks
uniqueStacks
*
return
object
*
/
function
deflateSamples
(
samples
uniqueStacks
)
{
/
/
Schema
:
/
/
[
stack
time
responsiveness
rss
uss
frameNumber
power
]
let
deflatedSamples
=
new
Array
(
samples
.
length
)
;
for
(
let
i
=
0
;
i
<
samples
.
length
;
i
+
+
)
{
let
sample
=
samples
[
i
]
;
deflatedSamples
[
i
]
=
[
deflateStack
(
sample
.
frames
uniqueStacks
)
sample
.
time
sample
.
responsiveness
sample
.
rss
sample
.
uss
sample
.
frameNumber
sample
.
power
]
;
}
let
slot
=
0
;
return
{
schema
:
{
stack
:
slot
+
+
time
:
slot
+
+
responsiveness
:
slot
+
+
rss
:
slot
+
+
uss
:
slot
+
+
frameNumber
:
slot
+
+
power
:
slot
+
+
}
data
:
deflatedSamples
}
;
}
/
*
*
*
Given
an
array
of
marker
objects
convert
the
markers
to
a
table
with
a
*
schema
.
Returns
the
deflated
markers
.
*
*
If
a
marker
contains
a
backtrace
as
its
payload
the
backtrace
stack
is
*
deduplicated
in
the
context
of
the
profile
it
'
s
in
.
*
*
param
object
markers
*
Array
of
markers
*
param
UniqueStacks
uniqueStacks
*
return
object
*
/
function
deflateMarkers
(
markers
uniqueStacks
)
{
/
/
Schema
:
/
/
[
name
time
data
]
let
deflatedMarkers
=
new
Array
(
markers
.
length
)
;
for
(
let
i
=
0
;
i
<
markers
.
length
;
i
+
+
)
{
let
marker
=
markers
[
i
]
;
if
(
marker
.
data
&
&
marker
.
data
.
type
=
=
=
"
tracing
"
&
&
marker
.
data
.
stack
)
{
marker
.
data
.
stack
=
deflateThread
(
marker
.
data
.
stack
uniqueStacks
)
;
}
deflatedMarkers
[
i
]
=
[
uniqueStacks
.
getOrAddStringIndex
(
marker
.
name
)
marker
.
time
marker
.
data
]
;
}
let
slot
=
0
;
return
{
schema
:
{
name
:
slot
+
+
time
:
slot
+
+
data
:
slot
+
+
}
data
:
deflatedMarkers
}
;
}
/
*
*
*
Deflate
a
thread
.
*
*
param
object
thread
*
The
profile
thread
.
*
param
UniqueStacks
uniqueStacks
*
return
object
*
/
function
deflateThread
(
thread
uniqueStacks
)
{
return
{
name
:
thread
.
name
tid
:
thread
.
tid
samples
:
deflateSamples
(
thread
.
samples
uniqueStacks
)
markers
:
deflateMarkers
(
thread
.
markers
uniqueStacks
)
stackTable
:
uniqueStacks
.
getStackTableWithSchema
(
)
frameTable
:
uniqueStacks
.
getFrameTableWithSchema
(
)
stringTable
:
uniqueStacks
.
stringTable
}
;
}
/
*
*
*
A
helper
class
to
deduplicate
old
-
version
profiles
.
*
*
The
main
functionality
provided
is
deduplicating
frames
and
stacks
.
*
*
For
example
given
2
stacks
*
[
A
B
C
]
*
and
*
[
A
B
D
]
*
*
There
are
4
unique
frames
:
A
B
C
and
D
.
*
There
are
4
unique
prefixes
:
[
A
]
[
A
B
]
[
A
B
C
]
[
A
B
D
]
*
*
For
the
example
the
output
of
using
UniqueStacks
is
:
*
*
Frame
table
:
*
[
A
B
C
D
]
*
*
That
is
A
has
id
0
B
has
id
1
etc
.
*
*
Since
stack
prefixes
are
themselves
deduplicated
(
shared
)
stacks
are
*
represented
as
a
tree
or
more
concretely
a
pair
of
ids
the
prefix
and
*
the
leaf
.
*
*
Stack
table
:
*
[
*
[
null
0
]
*
[
0
1
]
*
[
1
2
]
*
[
1
3
]
*
]
*
*
That
is
[
A
]
has
id
0
and
value
[
null
0
]
.
This
means
it
has
no
prefix
and
*
has
the
leaf
frame
0
which
resolves
to
A
in
the
frame
table
.
*
*
[
A
B
]
has
id
1
and
value
[
0
1
]
.
This
means
it
has
prefix
0
which
is
[
A
]
*
and
leaf
1
thus
[
A
B
]
.
*
*
[
A
B
C
]
has
id
2
and
value
[
1
2
]
.
This
means
it
has
prefix
1
which
in
*
turn
is
[
A
B
]
and
leaf
2
thus
[
A
B
C
]
.
*
*
[
A
B
D
]
has
id
3
and
value
[
1
3
]
.
Note
how
it
shares
the
prefix
1
with
*
[
A
B
C
]
.
*
/
function
UniqueStacks
(
)
{
this
.
_frameTable
=
[
]
;
this
.
_stackTable
=
[
]
;
this
.
stringTable
=
[
]
;
this
.
_frameHash
=
Object
.
create
(
null
)
;
this
.
_stackHash
=
Object
.
create
(
null
)
;
this
.
_stringHash
=
Object
.
create
(
null
)
;
}
UniqueStacks
.
prototype
.
getStackTableWithSchema
=
function
(
)
{
let
slot
=
0
;
return
{
schema
:
{
prefix
:
slot
+
+
frame
:
slot
+
+
}
data
:
this
.
_stackTable
}
;
}
;
UniqueStacks
.
prototype
.
getFrameTableWithSchema
=
function
(
)
{
let
slot
=
0
;
return
{
schema
:
{
location
:
slot
+
+
implementation
:
slot
+
+
optimizations
:
slot
+
+
line
:
slot
+
+
category
:
slot
+
+
}
data
:
this
.
_frameTable
}
;
}
UniqueStacks
.
prototype
.
getOrAddFrameIndex
=
function
(
frame
)
{
/
/
Schema
:
/
/
[
location
implementation
optimizations
line
category
]
let
frameHash
=
this
.
_frameHash
;
let
frameTable
=
this
.
_frameTable
;
let
locationIndex
=
this
.
getOrAddStringIndex
(
frame
.
location
)
;
let
implementationIndex
=
this
.
getOrAddStringIndex
(
frame
.
implementation
)
;
/
/
Super
dumb
.
let
hash
=
{
locationIndex
}
{
implementationIndex
|
|
"
"
}
{
frame
.
line
|
|
"
"
}
{
frame
.
category
|
|
"
"
}
;
let
index
=
frameHash
[
hash
]
;
if
(
index
!
=
=
undefined
)
{
return
index
;
}
index
=
frameTable
.
length
;
frameHash
[
hash
]
=
index
;
frameTable
.
push
(
[
this
.
getOrAddStringIndex
(
frame
.
location
)
this
.
getOrAddStringIndex
(
frame
.
implementation
)
/
/
Don
'
t
bother
with
JIT
optimization
info
for
deflating
old
profile
data
/
/
format
to
the
new
format
.
null
frame
.
line
frame
.
category
]
)
;
return
index
;
}
;
UniqueStacks
.
prototype
.
getOrAddStackIndex
=
function
(
prefixIndex
frameIndex
)
{
/
/
Schema
:
/
/
[
prefix
frame
]
let
stackHash
=
this
.
_stackHash
;
let
stackTable
=
this
.
_stackTable
;
/
/
Also
super
dumb
.
let
hash
=
prefixIndex
+
"
"
+
frameIndex
;
let
index
=
stackHash
[
hash
]
;
if
(
index
!
=
=
undefined
)
{
return
index
;
}
index
=
stackTable
.
length
;
stackHash
[
hash
]
=
index
;
stackTable
.
push
(
[
prefixIndex
frameIndex
]
)
;
return
index
;
}
;
UniqueStacks
.
prototype
.
getOrAddStringIndex
=
function
(
s
)
{
if
(
!
s
)
{
return
null
;
}
let
stringHash
=
this
.
_stringHash
;
let
stringTable
=
this
.
stringTable
;
let
index
=
stringHash
[
s
]
;
if
(
index
!
=
=
undefined
)
{
return
index
;
}
index
=
stringTable
.
length
;
stringHash
[
s
]
=
index
;
stringTable
.
push
(
s
)
;
return
index
;
}
;
