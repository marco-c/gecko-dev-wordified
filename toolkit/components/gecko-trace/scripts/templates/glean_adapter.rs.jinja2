/
/
-
*
-
mode
:
Rust
-
*
-
/
/
vim
:
set
ft
=
rust
:
/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
*
file
You
can
obtain
one
at
https
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
/
/
AUTOGENERATED
BY
toolkit
/
components
/
gecko_trace
/
scripts
/
codegen
.
py
DO
NOT
EDIT
.
{
%
macro
rust_field_name
(
attribute_name
)
-
%
}
{
{
attribute_name
|
snake_case
}
}
{
%
-
endmacro
-
%
}
{
%
macro
protobuf_value_variant
(
data_type
)
-
%
}
{
%
-
if
data_type
=
=
'
boolean
'
-
%
}
BoolValue
{
%
-
elif
data_type
=
=
'
integer
'
-
%
}
IntValue
{
%
-
elif
data_type
=
=
'
string
'
-
%
}
StringValue
{
%
-
elif
data_type
=
=
'
array
'
-
%
}
ArrayValue
{
%
-
else
-
%
}
{
%
raise
"
Unsupported
attribute
type
:
%
s
"
%
data_type
%
}
{
%
-
endif
-
%
}
{
%
-
endmacro
-
%
}
mod
generated
{
use
crate
:
:
proto
:
:
opentelemetry
:
:
proto
:
:
common
:
:
v1
:
:
any_value
:
:
Value
;
#
[
allow
(
unused_imports
)
]
use
crate
:
:
proto
:
:
opentelemetry
:
:
proto
:
:
common
:
:
v1
:
:
{
AnyValue
ArrayValue
KeyValue
}
;
pub
use
firefox_on_glean
:
:
metrics
:
:
gecko_trace
:
:
{
TracesObjectItemResourceSpansItemItemScopeSpansItemItemSpansItemItemEventsItem
as
SpanEvent
TracesObjectItemResourceSpansItemItemScopeSpansItemItemSpansItemItemEventsItemItemAttributesObject
as
EventAttributesObject
}
;
pub
(
crate
)
fn
inject_event_attributes
(
mut
span_event
:
SpanEvent
attributes
:
Vec
<
KeyValue
>
)
-
>
SpanEvent
{
let
mut
event_attributes
=
EventAttributesObject
{
{
%
for
event_definition
in
events
.
values
(
)
%
}
{
%
for
attribute_name
attribute
in
event_definition
.
attributes
.
items
(
)
%
}
{
{
rust_field_name
(
attribute_name
)
}
}
:
{
{
-
"
vec
!
[
]
"
if
attribute
.
type
=
=
"
array
"
else
"
None
"
}
}
{
%
endfor
%
}
{
%
endfor
%
}
}
;
for
KeyValue
{
key
value
}
in
attributes
{
match
(
key
.
as_ref
(
)
value
)
{
{
%
for
event
in
events
.
values
(
)
%
}
{
%
for
attribute_name
attribute
in
event
.
attributes
.
items
(
)
%
}
(
"
{
{
attribute_name
}
}
"
Some
(
AnyValue
{
value
:
Some
(
Value
:
:
{
{
protobuf_value_variant
(
attribute
.
type
)
}
}
(
{
%
-
if
attribute
.
type
=
=
"
array
"
-
%
}
ArrayValue
{
values
}
{
%
-
else
-
%
}
value
{
%
-
endif
%
}
)
)
}
)
)
=
>
{
%
-
if
attribute
.
type
=
=
"
array
"
-
%
}
{
{
"
"
}
}
{
event_attributes
.
{
{
rust_field_name
(
attribute_name
)
}
}
=
values
.
into_iter
(
)
.
filter_map
(
|
AnyValue
{
value
}
|
match
value
{
Some
(
Value
:
:
{
{
-
protobuf_value_variant
(
attribute
[
"
items
"
]
.
type
)
-
}
}
(
value
)
)
=
>
Some
(
value
)
_
=
>
{
log
:
:
error
!
(
"
Expected
array
item
of
type
{
{
attribute
[
"
items
"
]
.
type
}
}
but
got
{
}
"
std
:
:
any
:
:
type_name_of_val
(
&
value
)
)
;
None
}
}
)
.
collect
(
)
;
}
{
%
else
-
%
}
{
{
"
"
}
}
event_attributes
.
{
{
rust_field_name
(
attribute_name
)
}
}
=
Some
(
value
)
{
%
endif
%
}
(
"
{
{
attribute_name
}
}
"
value
)
=
>
{
log
:
:
error
!
(
"
Unexpected
attribute
{
{
attribute_name
}
}
of
type
{
}
expected
{
{
attribute
.
type
}
}
"
std
:
:
any
:
:
type_name_of_val
(
&
value
)
)
;
continue
;
}
{
%
endfor
%
}
{
%
endfor
%
}
(
_
value
)
=
>
{
log
:
:
error
!
(
"
Unexpected
attribute
{
{
attribute_name
}
}
of
type
{
}
"
std
:
:
any
:
:
type_name_of_val
(
&
value
)
)
;
continue
;
}
}
}
span_event
.
attributes
=
Some
(
event_attributes
)
;
span_event
}
}
