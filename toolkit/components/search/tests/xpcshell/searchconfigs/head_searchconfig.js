/
*
Any
copyright
is
dedicated
to
the
Public
Domain
.
http
:
/
/
creativecommons
.
org
/
publicdomain
/
zero
/
1
.
0
/
*
/
"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
AddonTestUtils
:
"
resource
:
/
/
testing
-
common
/
AddonTestUtils
.
jsm
"
OS
:
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
SearchTestUtils
:
"
resource
:
/
/
testing
-
common
/
SearchTestUtils
.
jsm
"
Services
:
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
}
)
;
const
GLOBAL_SCOPE
=
this
;
/
*
*
*
This
class
implements
the
test
harness
for
search
configuration
tests
.
*
These
tests
are
designed
to
ensure
that
the
correct
search
engines
are
*
loaded
for
the
various
region
/
locale
configurations
.
*
*
The
configuration
for
each
test
is
represented
by
an
object
having
the
*
following
properties
:
*
*
-
identifier
(
string
)
*
The
identifier
for
the
search
engine
under
test
.
*
-
default
(
object
)
*
An
inclusion
/
exclusion
configuration
(
see
below
)
to
detail
when
this
engine
*
should
be
listed
as
default
.
*
*
The
inclusion
/
exclusion
configuration
is
represented
as
an
object
having
the
*
following
properties
:
*
*
-
included
(
array
)
*
An
optional
array
of
region
/
locale
pairs
.
*
-
excluded
(
array
)
*
An
optional
array
of
region
/
locale
pairs
.
*
*
If
the
object
is
empty
the
engine
is
assumed
not
to
be
part
of
any
locale
/
region
*
pair
.
*
If
the
object
has
excluded
but
not
included
then
the
engine
is
assumed
to
*
be
part
of
every
locale
/
region
pair
except
for
where
it
matches
the
exclusions
.
*
*
The
region
/
locale
pairs
are
represented
as
an
object
having
the
following
*
properties
:
*
*
-
region
(
array
)
*
An
array
of
two
-
letter
region
codes
.
*
-
locale
(
object
)
*
A
locale
object
which
may
consist
of
:
*
-
matches
(
array
)
*
An
array
of
locale
strings
which
should
exactly
match
the
locale
.
*
-
startsWith
(
array
)
*
An
array
of
locale
strings
which
the
locale
should
start
with
.
*
/
class
SearchConfigTest
{
/
*
*
*
param
{
object
}
config
*
The
initial
configuration
for
this
test
see
above
.
*
/
constructor
(
config
=
{
}
)
{
this
.
_config
=
config
;
/
/
This
is
intended
for
development
-
only
.
Setting
it
to
true
restricts
the
/
/
set
of
locales
and
regions
that
are
covered
to
provide
tests
that
are
/
/
quicker
to
run
.
/
/
Turning
it
on
will
generate
one
error
at
the
end
of
the
test
as
a
reminder
/
/
that
it
needs
to
be
changed
back
before
shipping
.
this
.
_testDebug
=
false
;
}
/
*
*
*
Sets
up
the
test
.
*
/
async
setup
(
)
{
AddonTestUtils
.
init
(
GLOBAL_SCOPE
)
;
AddonTestUtils
.
createAppInfo
(
"
xpcshell
tests
.
mozilla
.
org
"
"
XPCShell
"
"
42
"
"
42
"
)
;
/
/
Disable
region
checks
.
Services
.
prefs
.
setBoolPref
(
"
browser
.
search
.
geoSpecificDefaults
"
false
)
;
Services
.
prefs
.
setCharPref
(
"
browser
.
search
.
geoip
.
url
"
"
"
)
;
await
AddonTestUtils
.
promiseStartupManager
(
)
;
await
Services
.
search
.
init
(
)
;
Assert
.
ok
(
Services
.
search
.
isInitialized
"
Should
have
correctly
initialized
the
search
service
"
)
;
}
/
*
*
*
Runs
the
test
.
*
/
async
run
(
)
{
const
locales
=
await
this
.
_getLocales
(
)
;
const
regions
=
this
.
_regions
;
/
/
We
loop
on
region
and
then
locale
so
that
we
always
cause
a
re
-
init
/
/
when
updating
the
requested
/
available
locales
.
for
(
let
region
of
regions
)
{
for
(
let
locale
of
locales
)
{
info
(
Checking
region
:
"
{
region
}
"
locale
:
"
{
locale
}
"
)
;
await
this
.
_reinit
(
region
locale
)
;
this
.
_assertDefaultEngines
(
region
locale
)
;
await
this
.
_assertAvailableEngines
(
region
locale
)
;
}
}
Assert
.
ok
(
!
this
.
_testDebug
"
Should
not
have
test
debug
turned
on
in
production
"
)
;
}
/
*
*
*
Causes
re
-
initialization
of
the
SearchService
with
the
new
region
and
locale
.
*
*
param
{
string
}
region
*
The
two
-
letter
region
code
.
*
param
{
string
}
locale
*
The
two
-
letter
locale
code
.
*
/
async
_reinit
(
region
locale
)
{
Services
.
prefs
.
setStringPref
(
"
browser
.
search
.
region
"
region
.
toUpperCase
(
)
)
;
const
reinitCompletePromise
=
SearchTestUtils
.
promiseSearchNotification
(
"
reinit
-
complete
"
)
;
Services
.
locale
.
availableLocales
=
[
locale
]
;
Services
.
locale
.
requestedLocales
=
[
locale
]
;
Services
.
search
.
reInit
(
)
;
await
reinitCompletePromise
;
Assert
.
ok
(
Services
.
search
.
isInitialized
"
Should
have
completely
re
-
initialization
if
it
fails
check
logs
for
if
reinit
was
successful
"
)
;
}
/
*
*
*
returns
{
Set
}
the
list
of
regions
for
the
tests
to
run
with
.
*
/
get
_regions
(
)
{
if
(
this
.
_testDebug
)
{
return
new
Set
(
[
"
by
"
"
cn
"
"
kz
"
"
us
"
"
ru
"
"
tr
"
]
)
;
}
return
Services
.
intl
.
getAvailableLocaleDisplayNames
(
"
region
"
)
;
}
/
*
*
*
returns
{
array
}
the
list
of
locales
for
the
tests
to
run
with
.
*
/
async
_getLocales
(
)
{
if
(
this
.
_testDebug
)
{
return
[
"
be
"
"
en
-
US
"
"
kk
"
"
tr
"
"
ru
"
"
zh
-
CN
"
]
;
}
const
data
=
await
OS
.
File
.
read
(
do_get_file
(
"
all
-
locales
"
)
.
path
{
encoding
:
"
utf
-
8
"
}
)
;
return
data
.
split
(
"
\
n
"
)
.
filter
(
e
=
>
e
!
=
"
"
)
;
}
/
*
*
*
Determines
if
a
locale
matches
with
a
locales
section
in
the
configuration
.
*
*
param
{
object
}
locales
*
param
{
array
}
[
locales
.
matches
]
*
Array
of
locale
names
to
match
exactly
.
*
param
{
array
}
[
locales
.
startsWith
]
*
Array
of
locale
names
to
match
the
start
.
*
param
{
string
}
locale
*
The
two
-
letter
locale
code
.
*
returns
{
boolean
}
*
True
if
the
locale
matches
.
*
/
_localeIncludes
(
locales
locale
)
{
if
(
"
matches
"
in
locales
&
&
locales
.
matches
.
includes
(
locale
)
)
{
return
true
;
}
if
(
"
startsWith
"
in
locales
)
{
return
!
!
locales
.
startsWith
.
find
(
element
=
>
locale
.
startsWith
(
element
)
)
;
}
return
false
;
}
/
*
*
*
Determines
if
a
locale
/
region
pair
match
a
section
of
the
configuration
.
*
*
param
{
object
}
section
*
The
configuration
section
to
match
against
.
*
param
{
string
}
region
*
The
two
-
letter
region
code
.
*
param
{
string
}
locale
*
The
two
-
letter
locale
code
.
*
returns
{
boolean
}
*
True
if
the
locale
/
region
pair
matches
the
section
.
*
/
_localeRegionInSection
(
section
region
locale
)
{
for
(
const
{
regions
locales
}
of
section
)
{
/
/
If
we
only
specify
a
regions
or
locales
section
then
/
/
it
is
always
considered
included
in
the
other
section
.
const
inRegions
=
!
regions
|
|
regions
.
includes
(
region
)
;
const
inLocales
=
!
locales
|
|
this
.
_localeIncludes
(
locales
locale
)
;
if
(
inRegions
&
&
inLocales
)
{
return
true
;
}
}
return
false
;
}
/
*
*
*
Asserts
whether
the
engines
rules
defined
in
the
configuration
are
met
.
*
*
param
{
Array
}
engines
*
The
list
of
engines
to
check
.
*
param
{
string
}
region
*
The
two
-
letter
region
code
.
*
param
{
string
}
locale
*
The
two
-
letter
locale
code
.
*
param
{
string
}
section
*
The
section
of
the
configuration
to
check
.
*
/
_assertEngineRules
(
engines
region
locale
section
)
{
const
infoString
=
region
:
"
{
region
}
"
locale
:
"
{
locale
}
"
;
const
config
=
this
.
_config
[
section
]
;
const
hasIncluded
=
"
included
"
in
config
;
const
hasExcluded
=
"
excluded
"
in
config
;
/
/
If
there
'
s
not
included
/
excluded
then
this
shouldn
'
t
be
the
default
anywhere
.
if
(
section
=
=
"
default
"
&
&
!
hasIncluded
&
&
!
hasExcluded
)
{
Assert
.
ok
(
!
engines
.
includes
(
this
.
_config
.
identifier
)
Should
not
be
{
section
}
for
any
locale
/
region
currently
set
for
{
infoString
}
)
;
return
;
}
/
/
If
there
'
s
no
included
section
we
assume
the
engine
is
default
everywhere
/
/
and
we
should
apply
the
exclusions
instead
.
let
included
=
(
hasIncluded
&
&
this
.
_localeRegionInSection
(
config
.
included
region
locale
)
)
;
let
notExcluded
=
(
hasExcluded
&
&
!
this
.
_localeRegionInSection
(
config
.
excluded
region
locale
)
)
;
if
(
included
|
|
notExcluded
)
{
Assert
.
ok
(
engines
.
includes
(
this
.
_config
.
identifier
)
Should
be
{
section
}
for
{
infoString
}
)
;
return
;
}
Assert
.
ok
(
!
engines
.
includes
(
this
.
_config
.
identifier
)
Should
not
be
{
section
}
for
{
infoString
}
)
;
}
/
*
*
*
Asserts
whether
the
engine
is
correctly
set
as
default
or
not
.
*
*
param
{
string
}
region
*
The
two
-
letter
region
code
.
*
param
{
string
}
locale
*
The
two
-
letter
locale
code
.
*
/
_assertDefaultEngines
(
region
locale
)
{
const
identifier
=
Services
.
search
.
originalDefaultEngine
.
identifier
;
this
.
_assertEngineRules
(
[
identifier
]
region
locale
"
default
"
)
;
}
/
*
*
*
Asserts
whether
the
engine
is
correctly
available
or
not
.
*
*
param
{
string
}
region
*
The
two
-
letter
region
code
.
*
param
{
string
}
locale
*
The
two
-
letter
locale
code
.
*
/
async
_assertAvailableEngines
(
region
locale
)
{
const
engines
=
await
Services
.
search
.
getVisibleEngines
(
)
;
const
engineNames
=
engines
.
map
(
engine
=
>
engine
.
_shortName
)
;
this
.
_assertEngineRules
(
engineNames
region
locale
"
available
"
)
;
}
}
