/
/
-
*
-
mode
:
C
+
+
-
*
-
/
/
AUTOGENERATED
BY
glean_parser
.
DO
NOT
EDIT
.
{
#
The
rendered
source
is
autogenerated
but
this
Jinja2
template
is
not
.
Please
file
bugs
!
#
}
/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
#
ifndef
mozilla_Glean
{
{
options
.
header_name
}
}
_h
#
define
mozilla_Glean
{
{
options
.
header_name
}
}
_h
{
%
if
all_objs
|
has_structure
%
}
#
include
"
mozilla
/
JSONStringWriteFuncs
.
h
"
{
%
endif
%
}
#
include
"
mozilla
/
glean
/
bindings
/
MetricTypes
.
h
"
namespace
mozilla
:
:
glean
{
{
%
-
macro
structure_to_json
(
struct
property_name
value
)
-
%
}
{
%
if
struct
.
type
=
=
"
array
"
and
property_name
%
}
if
(
{
{
value
}
}
.
isSome
(
)
)
{
writer
.
StartArrayProperty
(
"
{
{
property_name
}
}
"
)
;
{
%
set
valuename
=
value
|
replace
(
"
-
>
"
"
"
)
|
camelize
~
"
Item
"
%
}
for
(
const
auto
&
{
{
valuename
}
}
:
*
{
{
value
}
}
)
{
{
{
structure_to_json
(
struct
[
"
items
"
]
None
valuename
)
|
indent
(
4
)
}
}
}
writer
.
EndArray
(
)
;
}
{
%
elif
struct
.
type
=
=
"
array
"
and
not
property_name
%
}
writer
.
StartArrayElement
(
)
;
{
{
%
set
valuename
=
value
|
replace
(
"
-
>
"
"
"
)
|
camelize
~
"
Item
"
%
}
for
(
const
auto
&
{
{
valuename
}
}
:
{
{
value
}
}
)
{
{
{
structure_to_json
(
struct
[
"
items
"
]
None
valuename
)
|
indent
(
4
)
}
}
}
}
writer
.
EndArray
(
)
;
{
%
elif
struct
.
type
=
=
"
object
"
and
property_name
%
}
if
(
{
{
value
}
}
.
isSome
(
)
)
{
writer
.
StartObjectProperty
(
"
{
{
property_name
}
}
"
)
;
{
%
for
propname
val
in
struct
.
properties
.
items
(
)
%
}
{
{
structure_to_json
(
val
propname
value
~
"
-
>
"
~
propname
)
|
indent
(
2
)
}
}
{
%
-
endfor
%
}
writer
.
EndObject
(
)
;
}
{
%
elif
struct
.
type
=
=
"
object
"
and
not
property_name
%
}
writer
.
StartObjectElement
(
)
;
{
{
%
for
propname
val
in
struct
.
properties
.
items
(
)
%
}
{
{
structure_to_json
(
val
propname
value
~
"
.
"
~
propname
)
|
indent
(
2
)
}
}
{
%
-
endfor
%
}
}
writer
.
EndObject
(
)
;
{
%
elif
property_name
%
}
if
(
{
{
value
}
}
.
isSome
(
)
)
{
writer
.
{
{
struct
.
type
|
jsonwriter_prefix
}
}
Property
(
"
{
{
property_name
}
}
"
*
(
{
{
value
}
}
)
)
;
}
{
%
else
%
}
writer
.
{
{
struct
.
type
|
jsonwriter_prefix
}
}
Element
(
{
{
value
}
}
)
;
{
%
endif
%
}
{
%
-
endmacro
-
%
}
{
%
-
macro
generate_structure
(
name
struct
)
-
%
}
{
%
if
struct
.
type
=
=
"
array
"
%
}
{
%
if
struct
[
"
items
"
]
.
type
not
in
(
"
array
"
"
object
"
)
%
}
using
{
{
name
}
}
=
nsTArray
<
{
{
struct
[
"
items
"
]
.
type
|
structure_type_name
}
}
>
;
{
%
else
%
}
{
{
generate_structure
(
name
~
"
Item
"
struct
[
"
items
"
]
)
}
}
using
{
{
name
}
}
=
nsTArray
<
{
{
name
}
}
Item
>
;
{
%
endif
%
}
{
%
elif
struct
.
type
=
=
"
object
"
%
}
{
%
for
itemname
val
in
struct
.
properties
.
items
(
)
%
}
{
%
if
val
.
type
in
(
"
array
"
"
object
"
)
%
}
{
{
generate_structure
(
name
~
itemname
|
Camelize
val
)
}
}
{
%
endif
%
}
{
%
endfor
%
}
struct
{
{
name
}
}
{
{
%
for
itemname
val
in
struct
.
properties
.
items
(
)
%
}
{
%
if
val
.
type
not
in
(
"
array
"
"
object
"
)
%
}
Maybe
<
{
{
val
.
type
|
structure_type_name
}
}
>
{
{
itemname
}
}
;
{
%
else
%
}
Maybe
<
{
{
name
~
itemname
|
Camelize
}
}
>
{
{
itemname
}
}
;
{
%
endif
%
}
{
%
endfor
%
}
}
;
{
%
endif
%
}
{
%
-
endmacro
-
%
}
{
%
-
macro
generate_extra_keys
(
obj
)
-
%
}
{
%
for
name
suffix
in
obj
[
"
_generate_enums
"
]
%
}
{
#
we
always
use
the
extra
suffix
because
we
only
expose
the
new
event
API
#
}
{
%
set
suffix
=
"
Extra
"
%
}
{
%
if
obj
|
attr
(
name
)
|
length
%
}
{
{
extra_keys_with_types
(
obj
name
suffix
)
|
indent
(
2
)
}
}
{
%
endif
%
}
{
%
endfor
%
}
{
%
-
endmacro
-
%
}
{
%
-
macro
extra_keys_with_types
(
obj
name
suffix
)
-
%
}
struct
{
{
obj
.
name
|
Camelize
}
}
{
{
suffix
}
}
{
{
%
for
item
type
in
obj
|
attr
(
name
)
%
}
mozilla
:
:
Maybe
<
{
{
type
|
extra_type_name
}
}
>
{
{
item
|
camelize
}
}
;
{
%
endfor
%
}
std
:
:
tuple
<
nsTArray
<
nsCString
>
nsTArray
<
nsCString
>
>
ToFfiExtra
(
)
const
{
nsTArray
<
nsCString
>
extraKeys
;
nsTArray
<
nsCString
>
extraValues
;
{
%
for
item
type
in
obj
|
attr
(
name
)
%
}
if
(
{
{
item
|
camelize
}
}
)
{
extraKeys
.
AppendElement
(
)
-
>
AssignASCII
(
"
{
{
item
}
}
"
)
;
{
%
if
type
=
=
"
string
"
%
}
extraValues
.
EmplaceBack
(
{
{
item
|
camelize
}
}
.
value
(
)
)
;
{
%
elif
type
=
=
"
boolean
"
%
}
extraValues
.
AppendElement
(
)
-
>
AssignASCII
(
{
{
item
|
camelize
}
}
.
value
(
)
?
"
true
"
:
"
false
"
)
;
{
%
elif
type
=
=
"
quantity
"
%
}
extraValues
.
AppendElement
(
)
-
>
AppendInt
(
{
{
item
|
camelize
}
}
.
value
(
)
)
;
{
%
else
%
}
#
error
"
Glean
:
Invalid
extra
key
type
for
metric
{
{
obj
.
category
}
}
.
{
{
obj
.
name
}
}
defined
in
:
{
{
obj
.
defined_in
[
'
filepath
'
]
}
}
:
{
{
obj
.
defined_in
[
'
line
'
]
}
}
)
"
{
%
endif
%
}
}
{
%
endfor
%
}
return
std
:
:
make_tuple
(
std
:
:
move
(
extraKeys
)
std
:
:
move
(
extraValues
)
)
;
}
}
;
{
%
-
endmacro
-
%
}
{
#
Okay
so
though
enum
class
means
we
can
'
t
pollute
the
namespace
with
the
enum
variants
'
identifiers
there
'
s
no
guarantee
there
isn
'
t
some
preprocessor
#
define
lying
in
wait
to
collide
with
us
.
Using
CamelCase
helps
but
isn
'
t
foolproof
(
X11
/
X
.
h
has
#
define
Success
0
)
.
So
we
prefix
it
.
I
chose
e
(
for
enum
)
for
the
prefix
.
#
}
{
%
-
macro
generate_label_enum
(
obj
)
-
%
}
enum
class
{
{
obj
.
name
|
Camelize
}
}
Label
:
uint16_t
{
{
%
for
label
in
obj
.
ordered_labels
%
}
e
{
{
label
|
Camelize
}
}
=
{
{
loop
.
index0
}
}
{
%
endfor
%
}
e__Other__
}
;
{
%
-
endmacro
%
}
{
%
for
category_name
objs
in
all_objs
.
items
(
)
%
}
namespace
{
{
category_name
|
snake_case
}
}
{
{
%
for
obj
in
objs
.
values
(
)
%
}
/
*
*
*
generated
from
{
{
category_name
}
}
.
{
{
obj
.
name
}
}
{
%
if
obj
|
attr
(
"
_generate_enums
"
)
or
(
obj
.
labeled
and
obj
.
labels
and
obj
.
labels
|
length
)
or
obj
|
attr
(
"
_generate_structure
"
)
%
}
*
/
{
%
if
obj
|
attr
(
"
_generate_structure
"
)
%
}
{
{
generate_structure
(
obj
.
name
|
Camelize
~
"
Object
"
obj
.
_generate_structure
)
}
}
{
%
-
endif
%
}
{
%
if
obj
|
attr
(
"
_generate_enums
"
)
%
}
{
{
generate_extra_keys
(
obj
)
}
}
{
%
-
endif
%
}
{
%
if
obj
.
labeled
and
obj
.
labels
and
obj
.
labels
|
length
%
}
{
{
generate_label_enum
(
obj
)
|
indent
(
2
)
}
}
{
%
endif
%
}
/
*
*
{
%
endif
%
}
*
{
{
obj
.
description
|
trim
|
replace
(
'
\
n
'
'
\
n
*
'
)
}
}
*
/
constexpr
impl
:
:
{
{
obj
|
type_name
}
}
{
{
obj
.
name
|
snake_case
}
}
(
{
{
obj
|
metric_id
}
}
)
;
{
%
if
not
loop
.
last
%
}
{
%
endif
%
}
{
%
endfor
%
}
}
{
%
for
obj
in
objs
.
values
(
)
%
}
{
%
if
obj
|
attr
(
"
_generate_structure
"
)
%
}
{
%
set
typename_t
=
category_name
|
snake_case
~
"
:
:
"
~
obj
.
name
|
Camelize
~
"
Object
"
%
}
template
<
>
inline
void
impl
:
:
ObjectMetric
<
{
{
typename_t
}
}
{
{
typename_t
}
}
Tag
>
:
:
Set
(
const
{
{
typename_t
}
}
&
aObj
)
const
{
nsCString
json
;
JSONStringRefWriteFunc
writeFunc
(
json
)
;
JSONWriter
writer
(
writeFunc
JSONWriter
:
:
CollectionStyle
:
:
SingleLineStyle
)
;
{
{
structure_to_json
(
obj
.
_generate_structure
None
"
aObj
"
)
|
indent
(
2
)
}
}
SetStr
(
json
)
;
}
{
%
endif
%
}
{
%
endfor
%
}
{
%
endfor
%
}
}
/
/
namespace
mozilla
:
:
glean
#
endif
/
/
mozilla_Glean
{
{
options
.
header_name
}
}
_h
