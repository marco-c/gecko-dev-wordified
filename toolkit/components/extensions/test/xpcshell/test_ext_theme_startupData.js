/
*
Any
copyright
is
dedicated
to
the
Public
Domain
.
http
:
/
/
creativecommons
.
org
/
publicdomain
/
zero
/
1
.
0
/
*
/
"
use
strict
"
;
AddonTestUtils
.
init
(
this
)
;
AddonTestUtils
.
overrideCertDB
(
)
;
/
/
Simulates
opening
a
browser
window
and
retrieves
the
color
.
async
function
getColorFromAppliedTheme
(
)
{
const
{
LightweightThemeConsumer
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
LightweightThemeConsumer
.
sys
.
mjs
"
)
;
/
/
The
LightweightThemeConsumer
class
expects
a
document
(
browser
.
xhtml
)
so
/
/
create
a
minimal
one
that
looks
like
it
.
A
blank
document
works
because
the
/
/
module
does
not
have
any
other
requirements
for
the
document
-
the
last
/
/
requirement
(
expecting
some
elements
to
exist
)
was
removed
in
bug
1905726
.
const
browser
=
Services
.
appShell
.
createWindowlessBrowser
(
true
)
;
const
document
=
browser
.
document
;
let
promise
=
new
Promise
(
resolve
=
>
{
/
/
Will
be
invoked
by
LightweightThemeConsumer
document
.
defaultView
.
addEventListener
(
"
windowlwthemeupdate
"
resolve
{
once
:
true
}
)
;
}
)
;
new
LightweightThemeConsumer
(
document
)
;
info
(
"
Waiting
for
windowlwthemeupdate
from
LightweightThemeConsumer
"
)
;
await
promise
;
info
(
"
Got
windowlwthemeupdate
from
LightweightThemeConsumer
"
)
;
/
/
This
is
the
color
for
"
colors
.
frame
"
.
let
accentcolor
=
document
.
documentElement
.
style
.
getPropertyValue
(
"
-
-
lwt
-
accent
-
color
"
)
;
browser
.
close
(
)
;
return
accentcolor
;
}
function
loadStaticThemeExtension
(
manifest
)
{
const
extensionId
=
manifest
.
browser_specific_settings
.
gecko
.
id
;
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
useAddonManager
:
"
permanent
"
}
)
;
/
/
When
a
theme
is
installed
it
starts
off
in
disabled
mode
as
seen
in
/
/
toolkit
/
mozapps
/
extensions
/
test
/
xpcshell
/
test_update_theme
.
js
.
/
/
To
make
sure
that
ExtensionTestUtils
.
loadExtension
resolves
enable
it
/
/
during
installation
.
extension
.
onInstalling
=
function
(
addon
)
{
if
(
addon
.
id
=
=
=
extensionId
)
{
equal
(
addon
.
userDisabled
true
"
Static
theme
is
disabled
at
install
"
)
;
/
/
We
'
re
modifying
the
AddonInternal
'
s
userDisabled
flag
instead
of
/
/
calling
addon
.
enable
(
)
because
using
addon
.
enable
(
)
during
/
/
onInstalling
results
in
the
Extension
'
s
startup
(
)
to
be
called
twice
/
/
which
is
not
realistic
in
the
real
world
.
addon
.
__AddonInternal__
.
userDisabled
=
false
;
equal
(
addon
.
userDisabled
false
"
Static
theme
force
enabled
at
install
"
)
;
}
}
;
return
extension
;
}
add_setup
(
async
(
)
=
>
{
await
ExtensionTestUtils
.
startAddonManager
(
)
;
}
)
;
add_task
(
async
function
test_static_theme_startupData
(
)
{
const
DUMMY_COLOR
=
"
rgb
(
12
34
56
)
"
;
let
extension
=
loadStaticThemeExtension
(
{
browser_specific_settings
:
{
gecko
:
{
id
:
"
my
-
theme
"
}
}
theme
:
{
colors
:
{
frame
:
DUMMY_COLOR
}
}
}
)
;
await
extension
.
startup
(
)
;
let
startupDataOriginal
=
extension
.
extension
.
startupData
;
let
startupDataCopy
=
structuredClone
(
extension
.
extension
.
startupData
)
;
equal
(
await
getColorFromAppliedTheme
(
)
DUMMY_COLOR
"
Theme
applied
to
simulated
browser
window
"
)
;
equal
(
extension
.
extension
.
startupData
startupDataOriginal
"
startupData
should
be
the
same
value
(
extension
not
unloaded
)
"
)
;
Assert
.
deepEqual
(
extension
.
extension
.
startupData
startupDataCopy
"
startupData
should
not
have
been
changed
when
a
browser
window
was
opened
"
)
;
let
readyPromise
=
AddonTestUtils
.
promiseWebExtensionStartup
(
"
my
-
theme
"
)
;
info
(
"
Simulating
browser
restart
"
)
;
await
AddonTestUtils
.
promiseRestartManager
(
)
;
info
(
"
Waiting
for
theme
to
have
started
again
"
)
;
await
readyPromise
;
let
startupData
=
extension
.
extension
.
startupData
;
/
/
It
cannot
be
the
same
object
because
it
should
have
been
loaded
from
disk
.
notEqual
(
startupData
startupDataOriginal
"
Not
trivially
equal
"
)
;
Assert
.
deepEqual
(
startupDataCopy
startupData
"
startupData
should
be
identical
when
the
theme
loads
again
"
)
;
ok
(
startupData
.
lwtData
"
startupData
.
lwtData
should
be
set
"
)
;
await
extension
.
unload
(
)
;
}
)
;
/
/
Regression
test
for
bug
1830144
.
add_task
(
async
function
test_dynamic_theme_startupData
(
)
{
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
manifest_version
:
3
browser_specific_settings
:
{
gecko
:
{
id
:
"
my
-
dynamic
-
theme
"
}
}
permissions
:
[
"
theme
"
]
}
useAddonManager
:
"
permanent
"
background
(
)
{
browser
.
runtime
.
onInstalled
.
addListener
(
async
(
)
=
>
{
await
browser
.
theme
.
update
(
{
colors
:
{
frame
:
"
rgb
(
7
8
9
)
"
}
}
)
;
browser
.
test
.
sendMessage
(
"
onInstalled
"
)
;
}
)
;
}
}
)
;
await
extension
.
startup
(
)
;
await
extension
.
awaitMessage
(
"
onInstalled
"
)
;
equal
(
await
getColorFromAppliedTheme
(
)
"
rgb
(
7
8
9
)
"
"
Dynamic
theme
applies
to
simulated
browser
window
"
)
;
let
startupData
=
extension
.
extension
.
startupData
;
/
/
Notably
startupData
.
lwtData
(
among
other
properties
)
is
not
set
.
In
a
/
/
previous
test
(
test_static_theme_startupData
)
we
have
confirmed
that
this
/
/
property
is
present
in
startupData
of
static
themes
.
Assert
.
deepEqual
(
Object
.
keys
(
startupData
)
[
"
persistentListeners
"
]
"
startupData
should
not
have
unexpected
properties
from
ext
-
theme
.
js
"
)
;
assertPersistentListeners
(
extension
"
runtime
"
"
onInstalled
"
{
primed
:
false
persisted
:
true
}
)
;
await
extension
.
unload
(
)
;
}
)
;
