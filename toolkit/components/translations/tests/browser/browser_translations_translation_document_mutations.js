/
*
Any
copyright
is
dedicated
to
the
Public
Domain
.
https
:
/
/
creativecommons
.
org
/
publicdomain
/
zero
/
1
.
0
/
*
/
"
use
strict
"
;
/
*
*
*
Request
2x
longer
timeout
for
this
test
.
*
There
are
lot
of
test
cases
in
this
file
but
they
are
all
of
the
same
nature
*
and
it
makes
the
most
sense
to
have
them
all
in
this
single
test
file
.
*
/
requestLongerTimeout
(
2
)
;
/
*
*
*
typedef
{
{
*
engineStatusCount
:
number
*
cancelCount
:
number
*
passthroughCount
:
number
*
cachedCount
:
number
*
requestCount
:
number
*
}
}
PortData
*
/
/
*
*
*
Creates
a
TranslationsDocument
with
a
mocked
port
that
"
translates
"
*
by
adding
diacritical
marks
above
text
in
addition
to
appending
the
*
translationId
for
the
request
at
the
end
of
the
"
translated
"
text
.
*
*
In
this
way
you
can
tell
A
)
how
many
times
the
text
has
been
translated
*
based
on
how
many
diacritical
marks
are
above
each
letter
and
B
)
which
*
translationId
fulfilled
each
translation
request
.
*
*
The
mocked
port
used
by
this
function
also
has
special
hooks
to
help
*
control
the
flow
of
translation
requests
and
also
assert
information
*
about
the
requests
that
were
sent
over
the
port
.
*
*
No
translation
requests
will
be
fulfilled
until
the
resolveRequests
*
function
is
invoked
.
*
*
The
collectPortData
function
will
return
a
set
of
counters
for
each
*
type
of
request
that
was
sent
over
the
report
see
PortData
and
then
*
reset
the
state
of
the
counters
.
This
way
if
you
are
expecting
5
requests
*
and
3
cancellations
you
can
assert
exactly
that
.
*
*
param
{
string
}
html
*
/
async
function
setupMutationsTest
(
html
)
{
const
{
mockedTranslatorPort
resolveRequests
collectPortData
}
=
createControlledTranslatorPort
(
)
;
const
translationsDoc
=
await
createTranslationsDoc
(
html
{
mockedTranslatorPort
}
)
;
return
{
resolveRequests
collectPortData
.
.
.
translationsDoc
}
;
}
/
*
*
*
Assert
that
collected
port
-
request
counters
meet
the
expectations
.
*
*
If
an
expectation
is
a
number
then
the
count
must
match
exactly
.
*
If
an
expectation
is
a
function
then
the
returned
boolean
must
be
true
.
*
*
param
{
(
)
=
>
PortData
}
collectPortData
*
param
{
object
}
portDataExpectations
*
param
{
number
|
(
number
)
=
>
boolean
}
[
portDataExpectations
.
expectedEngineStatusCount
=
0
]
*
param
{
number
|
(
number
)
=
>
boolean
}
[
portDataExpectations
.
expectedCancelCount
=
0
]
*
param
{
number
|
(
number
)
=
>
boolean
}
[
portDataExpectations
.
expectedPassthroughCount
=
0
]
*
param
{
number
|
(
number
)
=
>
boolean
}
[
portDataExpectations
.
expectedCachedCount
=
0
]
*
param
{
number
|
(
number
)
=
>
boolean
}
[
portDataExpectations
.
expectedRequestCount
=
0
]
*
param
{
string
}
[
infoMessage
]
*
/
function
assertPortData
(
collectPortData
{
expectedEngineStatusCount
=
0
expectedCancelCount
=
0
expectedPassthroughCount
=
0
expectedCachedCount
=
0
expectedRequestCount
=
0
}
=
{
}
infoMessage
)
{
const
{
engineStatusCount
cancelCount
passthroughCount
cachedCount
requestCount
}
=
collectPortData
(
)
;
if
(
infoMessage
)
{
info
(
infoMessage
)
;
}
const
assertCount
=
(
actual
expected
description
)
=
>
{
const
message
=
The
count
of
{
description
}
should
match
the
expectation
.
;
if
(
typeof
expected
=
=
=
"
function
"
)
{
ok
(
expected
(
actual
)
message
)
;
}
else
{
is
(
actual
expected
message
)
;
}
}
;
assertCount
(
engineStatusCount
expectedEngineStatusCount
"
engine
status
requests
"
)
;
assertCount
(
cancelCount
expectedCancelCount
"
cancel
requests
"
)
;
assertCount
(
passthroughCount
expectedPassthroughCount
"
passthrough
requests
"
)
;
assertCount
(
cachedCount
expectedCachedCount
"
cached
translation
requests
"
)
;
assertCount
(
requestCount
expectedRequestCount
"
translation
requests
"
)
;
}
function
isInRange
(
lower
upper
number
)
{
return
lower
<
=
number
&
&
number
<
=
upper
;
}
/
*
*
*
This
test
case
ensures
that
translating
a
node
then
rapidly
mutating
its
*
content
N
times
will
not
necessarily
produce
N
translation
requests
rather
*
the
cumulative
mutations
will
be
batched
and
produce
only
a
single
new
translation
.
*
/
add_task
(
async
function
test_rapid_mutation_after_initial_translation
(
)
{
const
{
translate
htmlMatches
cleanup
document
resolveRequests
collectPortData
}
=
await
setupMutationsTest
(
/
*
html
*
/
<
div
title
=
"
This
is
a
simple
title
translation
"
>
This
is
a
simple
content
translation
.
<
/
div
>
)
;
translate
(
)
;
await
htmlMatches
(
"
It
translates
.
"
/
*
html
*
/
<
div
title
=
"
T
h
i
s
i
s
a
s
i
m
p
l
e
t
i
t
l
e
t
r
a
n
s
l
a
t
i
o
n
(
id
:
2
)
"
>
T
h
i
s
i
s
a
s
i
m
p
l
e
c
o
n
t
e
n
t
t
r
a
n
s
l
a
t
i
o
n
.
(
id
:
1
)
<
/
div
>
document
resolveRequests
)
;
assertPortData
(
collectPortData
{
expectedEngineStatusCount
:
1
expectedRequestCount
:
2
}
)
;
const
divElement
=
document
.
querySelector
(
"
div
"
)
;
const
textNode
=
divElement
.
firstChild
;
info
(
"
Mutating
the
DOM
node
5
times
"
)
;
for
(
let
i
=
1
;
i
<
=
5
;
i
+
+
)
{
textNode
.
nodeValue
=
Mutation
{
i
}
on
element
;
}
info
(
"
Mutating
the
DOM
node
'
s
title
attribute
5
times
"
)
;
for
(
let
i
=
1
;
i
<
=
5
;
i
+
+
)
{
divElement
.
setAttribute
(
"
title
"
Mutation
{
i
}
on
title
)
;
}
await
htmlMatches
(
"
The
changed
node
gets
translated
"
/
*
html
*
/
<
div
title
=
"
M
u
t
a
t
i
o
n
5
o
n
t
i
t
l
e
(
id
:
{
{
[
4
-
9
]
|
1
[
0
-
4
]
}
}
)
"
>
M
u
t
a
t
i
o
n
5
o
n
e
l
e
m
e
n
t
(
id
:
{
{
[
3
-
9
]
|
1
[
0
-
3
]
}
}
)
<
/
div
>
document
resolveRequests
)
;
assertPortData
(
collectPortData
{
expectedRequestCount
:
2
}
"
The
5
mutations
are
batched
and
only
1
is
sent
for
translation
.
"
)
;
cleanup
(
)
;
}
)
;
/
*
*
*
This
test
case
ensures
that
triggering
a
translation
and
then
then
rapidly
mutating
*
a
node
'
s
content
N
times
will
not
necessarily
produce
N
translation
requests
rather
*
the
cumulative
mutations
will
be
batched
and
produce
only
a
single
new
translation
.
*
/
add_task
(
async
function
test_rapid_mutation_before_initial_translation
(
)
{
const
{
translate
htmlMatches
cleanup
document
resolveRequests
collectPortData
}
=
await
setupMutationsTest
(
/
*
html
*
/
<
div
title
=
"
This
is
a
simple
title
translation
"
>
This
is
a
simple
content
translation
.
<
/
div
>
)
;
translate
(
)
;
const
divElement
=
document
.
querySelector
(
"
div
"
)
;
const
textNode
=
divElement
.
firstChild
;
info
(
"
Mutating
the
DOM
node
5
times
"
)
;
for
(
let
i
=
1
;
i
<
=
5
;
i
+
+
)
{
textNode
.
nodeValue
=
Mutation
{
i
}
on
element
;
}
info
(
"
Mutating
the
DOM
node
'
s
title
attribute
5
times
"
)
;
for
(
let
i
=
1
;
i
<
=
5
;
i
+
+
)
{
divElement
.
setAttribute
(
"
title
"
Mutation
{
i
}
on
title
)
;
}
await
htmlMatches
(
"
The
changed
node
gets
translated
"
/
*
html
*
/
<
div
title
=
"
M
u
t
a
t
i
o
n
5
o
n
t
i
t
l
e
(
id
:
{
{
[
2
-
9
]
|
1
[
0
-
4
]
}
}
)
"
>
M
u
t
a
t
i
o
n
5
o
n
e
l
e
m
e
n
t
(
id
:
{
{
[
1
-
9
]
|
1
[
0
-
3
]
}
}
)
<
/
div
>
document
resolveRequests
)
;
assertPortData
(
collectPortData
{
expectedEngineStatusCount
:
1
expectedRequestCount
:
2
}
"
The
5
mutations
are
batched
and
only
1
is
sent
for
translation
.
"
)
;
cleanup
(
)
;
}
)
;
/
*
*
*
This
test
case
rapidly
mutates
a
node
while
fulfilling
and
cancelling
*
requests
as
they
come
to
ensure
that
the
final
state
matches
the
final
*
mutation
no
matter
how
many
requests
were
fulfilled
or
cancelled
.
*
/
add_task
(
async
function
test_intermittent_mutations_during_pending_requests
(
)
{
const
{
translate
htmlMatches
cleanup
document
resolveRequests
collectPortData
}
=
await
setupMutationsTest
(
/
*
html
*
/
<
div
title
=
"
This
is
a
simple
title
translation
"
>
This
is
a
simple
content
translation
.
<
/
div
>
)
;
const
translationsDoc
=
translate
(
)
;
await
htmlMatches
(
"
It
translates
.
"
/
*
html
*
/
<
div
title
=
"
T
h
i
s
i
s
a
s
i
m
p
l
e
t
i
t
l
e
t
r
a
n
s
l
a
t
i
o
n
(
id
:
2
)
"
>
T
h
i
s
i
s
a
s
i
m
p
l
e
c
o
n
t
e
n
t
t
r
a
n
s
l
a
t
i
o
n
.
(
id
:
1
)
<
/
div
>
document
resolveRequests
)
;
assertPortData
(
collectPortData
{
expectedEngineStatusCount
:
1
expectedRequestCount
:
2
}
)
;
info
(
"
Mutating
the
DOM
node
and
title
attribute
15
times
"
)
;
for
(
let
i
=
1
;
i
<
=
15
;
i
+
+
)
{
const
divElement
=
document
.
querySelector
(
"
div
"
)
;
const
textNode
=
divElement
.
firstChild
;
textNode
.
nodeValue
=
Mutation
{
i
}
on
element
;
divElement
.
setAttribute
(
"
title
"
Mutation
{
i
}
on
title
)
;
for
(
let
j
=
0
;
j
<
Math
.
floor
(
Math
.
random
(
)
*
2
)
;
j
+
+
)
{
await
doubleRaf
(
document
)
;
}
translationsDoc
.
simulateIntersectionObservationForNonPendingNodes
(
)
;
for
(
let
j
=
0
;
j
<
Math
.
floor
(
Math
.
random
(
)
*
2
)
;
j
+
+
)
{
await
doubleRaf
(
document
)
;
}
resolveRequests
(
)
;
}
await
htmlMatches
(
"
The
final
translated
mutations
'
ids
are
between
3
to
33
"
/
*
html
*
/
<
div
title
=
"
M
u
t
a
t
i
o
n
15
o
n
t
i
t
l
e
(
id
:
{
{
(
[
3
-
9
]
|
[
1
-
2
]
[
0
-
9
]
|
3
[
0
-
3
]
)
}
}
)
"
>
M
u
t
a
t
i
o
n
15
o
n
e
l
e
m
e
n
t
(
id
:
{
{
(
[
3
-
9
]
|
[
1
-
2
]
[
0
-
9
]
|
3
[
0
-
3
]
)
}
}
)
<
/
div
>
document
resolveRequests
)
;
const
{
requestCount
cancelCount
}
=
collectPortData
(
/
*
resetCounters
*
/
false
)
;
Assert
.
greater
(
requestCount
cancelCount
"
There
should
be
more
requests
than
cancellations
.
"
)
;
assertPortData
(
collectPortData
{
expectedRequestCount
:
count
=
>
isInRange
(
2
30
count
)
expectedCancelCount
:
count
=
>
isInRange
(
0
28
count
)
}
"
The
request
and
cancel
counts
are
within
the
expected
ranges
.
"
)
;
cleanup
(
)
;
}
)
;
/
*
*
*
This
test
case
ensures
that
sequential
mutations
that
are
each
given
the
*
time
to
fully
complete
the
translation
request
that
they
generate
will
*
each
update
the
node
as
expected
.
*
/
add_task
(
async
function
test_sequential_mutations
(
)
{
const
{
translate
htmlMatches
cleanup
document
resolveRequests
collectPortData
}
=
await
setupMutationsTest
(
/
*
html
*
/
<
div
title
=
"
This
is
a
simple
title
translation
"
>
This
is
a
simple
content
translation
.
<
/
div
>
)
;
translate
(
)
;
await
htmlMatches
(
"
It
translates
.
"
/
*
html
*
/
<
div
title
=
"
T
h
i
s
i
s
a
s
i
m
p
l
e
t
i
t
l
e
t
r
a
n
s
l
a
t
i
o
n
(
id
:
2
)
"
>
T
h
i
s
i
s
a
s
i
m
p
l
e
c
o
n
t
e
n
t
t
r
a
n
s
l
a
t
i
o
n
.
(
id
:
1
)
<
/
div
>
document
resolveRequests
)
;
assertPortData
(
collectPortData
{
expectedEngineStatusCount
:
1
expectedRequestCount
:
2
}
)
;
const
divElement
=
document
.
querySelector
(
"
div
"
)
;
const
textNode
=
document
.
querySelector
(
"
div
"
)
.
firstChild
;
info
(
"
Mutating
the
DOM
node
5
times
"
)
;
for
(
let
i
=
1
;
i
<
=
5
;
i
+
+
)
{
textNode
.
nodeValue
=
Mutation
{
i
}
on
element
;
await
htmlMatches
(
"
The
changed
node
gets
translated
"
/
*
html
*
/
<
div
title
=
"
T
h
i
s
i
s
a
s
i
m
p
l
e
t
i
t
l
e
t
r
a
n
s
l
a
t
i
o
n
(
id
:
2
)
"
>
M
u
t
a
t
i
o
n
{
i
}
o
n
e
l
e
m
e
n
t
(
id
:
{
i
+
2
}
)
<
/
div
>
document
resolveRequests
)
;
}
assertPortData
(
collectPortData
{
expectedRequestCount
:
5
}
"
There
should
be
exactly
one
request
for
each
mutation
.
"
)
;
info
(
"
Mutating
the
DOM
node
'
s
title
attribute
5
times
"
)
;
for
(
let
i
=
1
;
i
<
=
5
;
i
+
+
)
{
divElement
.
setAttribute
(
"
title
"
Mutation
{
i
}
on
title
)
;
await
htmlMatches
(
"
The
changed
node
gets
translated
"
/
*
html
*
/
<
div
title
=
"
M
u
t
a
t
i
o
n
{
i
}
o
n
t
i
t
l
e
(
id
:
{
i
+
7
}
)
"
>
M
u
t
a
t
i
o
n
5
o
n
e
l
e
m
e
n
t
(
id
:
7
)
<
/
div
>
document
resolveRequests
)
;
}
assertPortData
(
collectPortData
{
expectedRequestCount
:
5
}
"
There
should
be
exactly
one
request
for
each
mutation
.
"
)
;
cleanup
(
)
;
}
)
;
/
*
*
*
Test
what
happens
when
an
inline
element
is
mutated
inside
of
a
block
element
.
*
/
add_task
(
async
function
test_inline_elements
(
)
{
const
{
translate
htmlMatches
cleanup
document
resolveRequests
collectPortData
}
=
await
setupMutationsTest
(
/
*
html
*
/
<
div
>
<
span
>
inline
one
<
/
span
>
<
span
title
=
"
Title
attribute
"
>
inline
two
<
/
span
>
<
span
>
inline
three
<
/
span
>
<
/
div
>
)
;
translate
(
)
;
await
htmlMatches
(
"
The
block
element
gets
translated
as
one
logical
unit
.
"
/
*
html
*
/
<
div
>
<
span
>
i
n
l
i
n
e
o
n
e
<
/
span
>
<
span
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
(
id
:
2
)
"
>
i
n
l
i
n
e
t
w
o
<
/
span
>
<
span
>
i
n
l
i
n
e
t
h
r
e
e
<
/
span
>
(
id
:
1
)
<
/
div
>
document
resolveRequests
)
;
assertPortData
(
collectPortData
{
expectedEngineStatusCount
:
1
expectedRequestCount
:
2
}
"
The
whole
block
is
sent
as
one
translation
and
the
title
attribute
was
sent
separately
"
)
;
info
(
"
Mutating
the
text
of
span
2
"
)
;
/
*
*
type
{
HTMLSpanElement
}
*
/
const
secondSpan
=
document
.
querySelectorAll
(
"
span
"
)
[
1
]
;
secondSpan
.
innerText
=
"
setting
the
innerText
hits
the
childList
mutation
type
"
;
await
htmlMatches
(
"
The
changed
node
gets
translated
"
/
*
html
*
/
<
div
>
<
span
>
i
n
l
i
n
e
o
n
e
<
/
span
>
<
span
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
(
id
:
2
)
"
>
s
e
t
t
i
n
g
t
h
e
i
n
n
e
r
T
e
x
t
h
i
t
s
t
h
e
c
h
i
l
d
L
i
s
t
m
u
t
a
t
i
o
n
t
y
p
e
(
id
:
3
)
<
/
span
>
<
span
>
i
n
l
i
n
e
t
h
r
e
e
<
/
span
>
(
id
:
1
)
<
/
div
>
document
resolveRequests
)
;
assertPortData
(
collectPortData
{
expectedRequestCount
:
1
}
)
;
secondSpan
.
firstChild
.
nodeValue
=
"
Change
the
character
data
for
a
specific
node
"
;
await
htmlMatches
(
"
The
changed
node
gets
translated
"
/
*
html
*
/
<
div
>
<
span
>
i
n
l
i
n
e
o
n
e
<
/
span
>
<
span
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
(
id
:
2
)
"
>
C
h
a
n
g
e
t
h
e
c
h
a
r
a
c
t
e
r
d
a
t
a
f
o
r
a
s
p
e
c
i
f
i
c
n
o
d
e
(
id
:
4
)
<
/
span
>
<
span
>
i
n
l
i
n
e
t
h
r
e
e
<
/
span
>
(
id
:
1
)
<
/
div
>
document
resolveRequests
)
;
assertPortData
(
collectPortData
{
expectedRequestCount
:
1
}
)
;
secondSpan
.
setAttribute
(
"
title
"
"
Mutate
the
title
attribute
"
)
;
await
htmlMatches
(
"
The
changed
node
gets
translated
"
/
*
html
*
/
<
div
>
<
span
>
i
n
l
i
n
e
o
n
e
<
/
span
>
<
span
title
=
"
M
u
t
a
t
e
t
h
e
t
i
t
l
e
a
t
t
r
i
b
u
t
e
(
id
:
5
)
"
>
C
h
a
n
g
e
t
h
e
c
h
a
r
a
c
t
e
r
d
a
t
a
f
o
r
a
s
p
e
c
i
f
i
c
n
o
d
e
(
id
:
4
)
<
/
span
>
<
span
>
i
n
l
i
n
e
t
h
r
e
e
<
/
span
>
(
id
:
1
)
<
/
div
>
document
resolveRequests
)
;
assertPortData
(
collectPortData
{
expectedRequestCount
:
1
}
)
;
cleanup
(
)
;
}
)
;
/
*
*
*
Test
the
same
behavior
as
test_inline_elements
but
with
individual
block
*
elements
.
*
/
add_task
(
async
function
test_block_elements
(
)
{
const
{
translate
htmlMatches
cleanup
document
resolveRequests
collectPortData
}
=
await
setupMutationsTest
(
/
*
html
*
/
<
section
>
<
div
>
block
one
<
/
div
>
<
div
title
=
"
Title
attribute
"
>
block
two
<
/
div
>
<
div
>
block
three
<
/
div
>
<
/
section
>
)
;
translate
(
)
;
await
htmlMatches
(
"
Each
div
block
gets
translated
separately
"
/
*
html
*
/
<
section
>
<
div
>
b
l
o
c
k
o
n
e
(
id
:
1
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
(
id
:
4
)
"
>
b
l
o
c
k
t
w
o
(
id
:
2
)
<
/
div
>
<
div
>
b
l
o
c
k
t
h
r
e
e
(
id
:
3
)
<
/
div
>
<
/
section
>
document
resolveRequests
)
;
assertPortData
(
collectPortData
{
expectedEngineStatusCount
:
1
expectedRequestCount
:
4
}
"
The
whole
block
is
translated
including
the
title
attribute
.
"
)
;
info
(
"
Mutating
the
text
of
div
2
"
)
;
/
*
*
type
{
HTMLSpanElement
}
*
/
const
secondDiv
=
document
.
querySelectorAll
(
"
div
"
)
[
1
]
;
secondDiv
.
innerText
=
"
setting
the
innerText
hits
the
childList
mutation
type
"
;
await
htmlMatches
(
"
The
changed
node
gets
translated
"
/
*
html
*
/
<
section
>
<
div
>
b
l
o
c
k
o
n
e
(
id
:
1
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
(
id
:
4
)
"
>
s
e
t
t
i
n
g
t
h
e
i
n
n
e
r
T
e
x
t
h
i
t
s
t
h
e
c
h
i
l
d
L
i
s
t
m
u
t
a
t
i
o
n
t
y
p
e
(
id
:
5
)
<
/
div
>
<
div
>
b
l
o
c
k
t
h
r
e
e
(
id
:
3
)
<
/
div
>
<
/
section
>
document
resolveRequests
)
;
assertPortData
(
collectPortData
{
expectedRequestCount
:
1
}
)
;
secondDiv
.
firstChild
.
nodeValue
=
"
Change
the
character
data
for
a
specific
node
"
;
await
htmlMatches
(
"
The
changed
node
gets
translated
"
/
*
html
*
/
<
section
>
<
div
>
b
l
o
c
k
o
n
e
(
id
:
1
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
(
id
:
4
)
"
>
C
h
a
n
g
e
t
h
e
c
h
a
r
a
c
t
e
r
d
a
t
a
f
o
r
a
s
p
e
c
i
f
i
c
n
o
d
e
(
id
:
6
)
<
/
div
>
<
div
>
b
l
o
c
k
t
h
r
e
e
(
id
:
3
)
<
/
div
>
<
/
section
>
document
resolveRequests
)
;
assertPortData
(
collectPortData
{
expectedRequestCount
:
1
}
)
;
secondDiv
.
setAttribute
(
"
title
"
"
Mutate
the
title
attribute
"
)
;
await
htmlMatches
(
"
The
changed
node
gets
translated
"
/
*
html
*
/
<
section
>
<
div
>
b
l
o
c
k
o
n
e
(
id
:
1
)
<
/
div
>
<
div
title
=
"
M
u
t
a
t
e
t
h
e
t
i
t
l
e
a
t
t
r
i
b
u
t
e
(
id
:
7
)
"
>
C
h
a
n
g
e
t
h
e
c
h
a
r
a
c
t
e
r
d
a
t
a
f
o
r
a
s
p
e
c
i
f
i
c
n
o
d
e
(
id
:
6
)
<
/
div
>
<
div
>
b
l
o
c
k
t
h
r
e
e
(
id
:
3
)
<
/
div
>
<
/
section
>
document
resolveRequests
)
;
assertPortData
(
collectPortData
{
expectedRequestCount
:
1
}
)
;
cleanup
(
)
;
}
)
;
add_task
(
async
function
test_removing_elements
(
)
{
const
{
translate
htmlMatches
cleanup
document
resolveRequests
collectPortData
}
=
await
setupMutationsTest
(
/
*
html
*
/
<
section
>
<
div
>
block
one
<
/
div
>
<
div
title
=
"
Title
attribute
"
>
block
two
<
/
div
>
<
div
>
block
three
<
/
div
>
<
/
section
>
)
;
translate
(
)
;
info
(
"
Removing
two
divs
"
)
;
const
elements
=
document
.
querySelectorAll
(
"
div
"
)
;
elements
[
0
]
.
remove
(
)
;
elements
[
1
]
.
remove
(
)
;
await
htmlMatches
(
"
Only
one
element
is
translated
"
/
*
html
*
/
<
section
>
<
div
>
b
l
o
c
k
t
h
r
e
e
(
id
:
{
{
[
1
-
4
]
}
}
)
<
/
div
>
<
/
section
>
document
resolveRequests
)
;
assertPortData
(
collectPortData
{
expectedEngineStatusCount
:
1
expectedRequestCount
:
1
}
)
;
cleanup
(
)
;
}
)
;
add_task
(
async
function
test_mixed_block_inline
(
)
{
const
{
translate
htmlMatches
cleanup
document
resolveRequests
collectPortData
}
=
await
setupMutationsTest
(
/
*
html
*
/
<
section
>
first
text
node
<
div
>
block
one
<
/
div
>
second
text
node
<
span
>
with
inline
element
<
/
span
>
<
div
>
block
two
<
/
div
>
third
text
node
<
div
>
block
three
<
/
div
>
<
/
section
>
)
;
translate
(
)
;
await
htmlMatches
(
"
The
algorithm
to
chop
of
the
nodes
runs
.
"
/
*
html
*
/
<
section
>
f
i
r
s
t
t
e
x
t
n
o
d
e
(
id
:
1
)
<
div
>
b
l
o
c
k
o
n
e
(
id
:
4
)
<
/
div
>
s
e
c
o
n
d
t
e
x
t
n
o
d
e
(
id
:
2
)
<
span
>
w
i
t
h
i
n
l
i
n
e
e
l
e
m
e
n
t
(
id
:
5
)
<
/
span
>
<
div
>
b
l
o
c
k
t
w
o
(
id
:
6
)
<
/
div
>
t
h
i
r
d
t
e
x
t
n
o
d
e
(
id
:
3
)
<
div
>
b
l
o
c
k
t
h
r
e
e
(
id
:
7
)
<
/
div
>
<
/
section
>
document
resolveRequests
)
;
assertPortData
(
collectPortData
{
expectedEngineStatusCount
:
1
expectedRequestCount
:
7
}
)
;
info
(
"
Mutating
the
<
section
>
'
s
text
nodes
"
)
;
const
section
=
document
.
querySelector
(
"
section
"
)
;
for
(
let
i
=
0
;
i
<
section
.
childNodes
.
length
;
i
+
+
)
{
const
node
=
section
.
childNodes
[
i
]
;
if
(
node
.
nodeType
=
=
=
Node
.
TEXT_NODE
&
&
node
.
nodeValue
.
trim
(
)
)
{
node
.
nodeValue
=
Mutating
{
i
}
text
node
;
}
}
await
htmlMatches
(
"
"
/
*
html
*
/
<
section
>
M
u
t
a
t
i
n
g
0
t
e
x
t
n
o
d
e
(
id
:
8
)
<
div
>
b
l
o
c
k
o
n
e
(
id
:
4
)
<
/
div
>
M
u
t
a
t
i
n
g
2
t
e
x
t
n
o
d
e
(
id
:
9
)
<
span
>
w
i
t
h
i
n
l
i
n
e
e
l
e
m
e
n
t
(
id
:
5
)
<
/
span
>
<
div
>
b
l
o
c
k
t
w
o
(
id
:
6
)
<
/
div
>
M
u
t
a
t
i
n
g
6
t
e
x
t
n
o
d
e
(
id
:
10
)
<
div
>
b
l
o
c
k
t
h
r
e
e
(
id
:
7
)
<
/
div
>
<
/
section
>
document
resolveRequests
)
;
assertPortData
(
collectPortData
{
expectedRequestCount
:
3
}
)
;
cleanup
(
)
;
}
)
;
add_task
(
async
function
test_appending_element
(
)
{
const
{
translate
htmlMatches
cleanup
document
resolveRequests
collectPortData
}
=
await
setupMutationsTest
(
/
*
html
*
/
<
section
>
<
div
>
block
one
<
/
div
>
<
div
>
block
two
<
/
div
>
<
div
>
block
three
<
/
div
>
<
/
section
>
)
;
translate
(
)
;
await
htmlMatches
(
"
The
blocks
are
translated
"
/
*
html
*
/
<
section
>
<
div
>
b
l
o
c
k
o
n
e
(
id
:
1
)
<
/
div
>
<
div
>
b
l
o
c
k
t
w
o
(
id
:
2
)
<
/
div
>
<
div
>
b
l
o
c
k
t
h
r
e
e
(
id
:
3
)
<
/
div
>
<
/
section
>
document
resolveRequests
)
;
assertPortData
(
collectPortData
{
expectedEngineStatusCount
:
1
expectedRequestCount
:
3
}
)
;
const
fragment
=
document
.
createDocumentFragment
(
)
;
const
subDiv1
=
document
.
createElement
(
"
div
"
)
;
const
subDiv2
=
document
.
createElement
(
"
div
"
)
;
subDiv1
.
innerHTML
=
"
Adding
multiple
elements
at
once
"
;
subDiv2
.
innerHTML
=
"
<
div
>
It
even
has
<
span
>
nested
<
/
span
>
elements
<
/
div
>
"
;
fragment
.
append
(
subDiv1
)
;
fragment
.
append
(
subDiv2
)
;
const
section
=
document
.
querySelector
(
"
section
"
)
;
const
secondDiv
=
document
.
querySelectorAll
(
"
div
"
)
[
1
]
;
section
.
insertBefore
(
fragment
secondDiv
)
;
await
htmlMatches
(
"
Multiple
elements
are
inserted
at
once
"
/
*
html
*
/
<
section
>
<
div
>
b
l
o
c
k
o
n
e
(
id
:
1
)
<
/
div
>
<
div
>
A
d
d
i
n
g
m
u
l
t
i
p
l
e
e
l
e
m
e
n
t
s
a
t
o
n
c
e
(
id
:
4
)
<
/
div
>
<
div
>
<
div
>
I
t
e
v
e
n
h
a
s
<
span
>
n
e
s
t
e
d
<
/
span
>
e
l
e
m
e
n
t
s
(
id
:
5
)
<
/
div
>
<
/
div
>
<
div
>
b
l
o
c
k
t
w
o
(
id
:
2
)
<
/
div
>
<
div
>
b
l
o
c
k
t
h
r
e
e
(
id
:
3
)
<
/
div
>
<
/
section
>
document
resolveRequests
)
;
assertPortData
(
collectPortData
{
expectedRequestCount
:
2
}
)
;
cleanup
(
)
;
}
)
;
add_task
(
async
function
test_mutating_comments
(
)
{
const
{
translate
htmlMatches
cleanup
document
resolveRequests
collectPortData
}
=
await
setupMutationsTest
(
/
*
html
*
/
<
section
>
<
!
-
-
this
is
a
comment
-
-
>
<
div
>
block
one
<
/
div
>
<
/
section
>
)
;
translate
(
)
;
await
htmlMatches
(
"
The
blocks
are
translated
"
/
*
html
*
/
<
section
>
<
!
-
-
this
is
a
comment
-
-
>
<
div
>
b
l
o
c
k
o
n
e
(
id
:
1
)
<
/
div
>
<
/
section
>
document
resolveRequests
)
;
assertPortData
(
collectPortData
{
expectedEngineStatusCount
:
1
expectedRequestCount
:
1
}
)
;
/
/
Mutate
the
comment
'
s
contents
.
const
section
=
document
.
querySelector
(
"
section
"
)
;
const
commentNode
=
[
.
.
.
section
.
childNodes
]
.
find
(
node
=
>
node
.
nodeType
=
=
=
Node
.
COMMENT_NODE
)
;
commentNode
.
nodeValue
=
"
Change
the
comment
"
;
await
htmlMatches
(
"
The
comment
is
untranslated
in
a
mutation
"
/
*
html
*
/
<
section
>
<
!
-
-
Change
the
comment
-
-
>
<
div
>
b
l
o
c
k
o
n
e
(
id
:
1
)
<
/
div
>
<
/
section
>
)
;
assertPortData
(
collectPortData
{
}
"
No
data
is
sent
over
the
port
.
"
)
;
cleanup
(
)
;
}
)
;
/
*
*
*
This
test
case
tests
the
behavior
of
*
*
cached
translations
*
*
for
both
*
attributes
and
text
content
.
After
translating
some
content
we
re
-
insert
*
the
*
original
*
source
-
language
text
.
Because
the
engine
has
already
cached
*
translations
for
those
strings
they
should
be
re
-
translated
from
the
cache
*
without
sending
any
new
translation
requests
.
*
/
add_task
(
async
function
test_cache_within_document
(
)
{
const
{
translate
htmlMatches
cleanup
document
resolveRequests
collectPortData
}
=
await
setupMutationsTest
(
/
*
html
*
/
<
div
title
=
"
Title
attribute
1
"
>
This
is
block
1
<
/
div
>
<
div
title
=
"
Title
attribute
2
"
>
This
is
block
2
<
/
div
>
<
div
title
=
"
Title
attribute
3
"
>
This
is
block
3
<
/
div
>
<
div
title
=
"
Title
attribute
4
"
>
This
is
block
4
<
/
div
>
)
;
/
/
Capture
the
original
source
-
language
strings
so
we
can
restore
them
later
.
const
divs
=
Array
.
from
(
document
.
querySelectorAll
(
"
div
"
)
)
;
const
originalTitles
=
divs
.
map
(
div
=
>
div
.
getAttribute
(
"
title
"
)
)
;
const
originalTexts
=
divs
.
map
(
div
=
>
div
.
textContent
)
;
translate
(
)
;
await
htmlMatches
(
"
Each
div
block
gets
translated
separately
"
/
*
html
*
/
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
1
(
id
:
5
)
"
>
T
h
i
s
i
s
b
l
o
c
k
1
(
id
:
1
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
2
(
id
:
6
)
"
>
T
h
i
s
i
s
b
l
o
c
k
2
(
id
:
2
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
3
(
id
:
7
)
"
>
T
h
i
s
i
s
b
l
o
c
k
3
(
id
:
3
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
4
(
id
:
8
)
"
>
T
h
i
s
i
s
b
l
o
c
k
4
(
id
:
4
)
<
/
div
>
document
resolveRequests
)
;
assertPortData
(
collectPortData
{
expectedEngineStatusCount
:
1
expectedRequestCount
:
8
}
)
;
info
(
"
Restoring
all
div
titles
and
text
content
back
to
their
original
source
language
"
)
;
divs
.
forEach
(
(
div
idx
)
=
>
{
div
.
setAttribute
(
"
title
"
originalTitles
[
idx
]
)
;
div
.
textContent
=
originalTexts
[
idx
]
;
}
)
;
/
/
Add
brand
-
new
uncached
content
and
attribute
.
const
newDiv
=
document
.
createElement
(
"
div
"
)
;
newDiv
.
setAttribute
(
"
title
"
"
Title
attribute
5
"
)
;
newDiv
.
textContent
=
"
This
is
block
5
"
;
document
.
body
.
appendChild
(
newDiv
)
;
await
htmlMatches
(
"
Restored
blocks
are
served
from
cache
and
the
new
block
is
translated
with
new
IDs
"
/
*
html
*
/
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
1
(
id
:
5
)
"
>
T
h
i
s
i
s
b
l
o
c
k
1
(
id
:
1
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
2
(
id
:
6
)
"
>
T
h
i
s
i
s
b
l
o
c
k
2
(
id
:
2
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
3
(
id
:
7
)
"
>
T
h
i
s
i
s
b
l
o
c
k
3
(
id
:
3
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
4
(
id
:
8
)
"
>
T
h
i
s
i
s
b
l
o
c
k
4
(
id
:
4
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
5
(
id
:
14
)
"
>
T
h
i
s
i
s
b
l
o
c
k
5
(
id
:
13
)
<
/
div
>
document
resolveRequests
)
;
assertPortData
(
collectPortData
{
expectedRequestCount
:
2
}
)
;
cleanup
(
)
;
}
)
;
/
*
*
*
This
test
case
tests
the
behavior
of
translations
cacheing
specifically
*
after
all
nodes
have
been
submitted
to
the
scheduler
.
In
this
scenario
*
the
scheduler
may
realize
that
it
has
alredy
translated
this
exact
text
*
and
skip
a
new
CPU
-
bound
translation
request
resulting
in
the
same
id
*
showing
in
the
result
mock
-
translated
text
.
*
/
add_task
(
async
function
test_cache_within_scheduler
(
)
{
const
{
translate
htmlMatches
cleanup
document
resolveRequests
collectPortData
}
=
await
setupMutationsTest
(
/
*
html
*
/
<
div
title
=
"
Title
attribute
1
"
>
This
is
block
1
<
/
div
>
<
div
title
=
"
Title
attribute
2
"
>
This
is
block
2
<
/
div
>
<
div
title
=
"
Title
attribute
3
"
>
This
is
block
3
<
/
div
>
<
div
title
=
"
Title
attribute
4
"
>
This
is
block
4
<
/
div
>
<
div
title
=
"
Title
attribute
5
"
>
This
is
block
5
<
/
div
>
<
div
title
=
"
Title
attribute
1
"
>
This
is
block
1
<
/
div
>
<
div
title
=
"
Title
attribute
2
"
>
This
is
block
2
<
/
div
>
<
div
title
=
"
Title
attribute
3
"
>
This
is
block
3
<
/
div
>
<
div
title
=
"
Title
attribute
4
"
>
This
is
block
4
<
/
div
>
<
div
title
=
"
Title
attribute
5
"
>
This
is
block
5
<
/
div
>
<
div
title
=
"
Title
attribute
1
"
>
This
is
block
1
<
/
div
>
<
div
title
=
"
Title
attribute
2
"
>
This
is
block
2
<
/
div
>
<
div
title
=
"
Title
attribute
3
"
>
This
is
block
3
<
/
div
>
<
div
title
=
"
Title
attribute
4
"
>
This
is
block
4
<
/
div
>
<
div
title
=
"
Title
attribute
5
"
>
This
is
block
5
<
/
div
>
)
;
translate
(
)
;
await
htmlMatches
(
"
Each
div
block
gets
translated
separately
"
/
*
html
*
/
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
1
(
id
:
26
)
"
>
T
h
i
s
i
s
b
l
o
c
k
1
(
id
:
11
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
2
(
id
:
27
)
"
>
T
h
i
s
i
s
b
l
o
c
k
2
(
id
:
12
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
3
(
id
:
28
)
"
>
T
h
i
s
i
s
b
l
o
c
k
3
(
id
:
13
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
4
(
id
:
29
)
"
>
T
h
i
s
i
s
b
l
o
c
k
4
(
id
:
14
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
5
(
id
:
30
)
"
>
T
h
i
s
i
s
b
l
o
c
k
5
(
id
:
15
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
1
(
id
:
26
)
"
>
T
h
i
s
i
s
b
l
o
c
k
1
(
id
:
11
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
2
(
id
:
27
)
"
>
T
h
i
s
i
s
b
l
o
c
k
2
(
id
:
12
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
3
(
id
:
28
)
"
>
T
h
i
s
i
s
b
l
o
c
k
3
(
id
:
13
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
4
(
id
:
29
)
"
>
T
h
i
s
i
s
b
l
o
c
k
4
(
id
:
14
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
5
(
id
:
30
)
"
>
T
h
i
s
i
s
b
l
o
c
k
5
(
id
:
15
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
1
(
id
:
26
)
"
>
T
h
i
s
i
s
b
l
o
c
k
1
(
id
:
11
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
2
(
id
:
27
)
"
>
T
h
i
s
i
s
b
l
o
c
k
2
(
id
:
12
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
3
(
id
:
28
)
"
>
T
h
i
s
i
s
b
l
o
c
k
3
(
id
:
13
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
4
(
id
:
29
)
"
>
T
h
i
s
i
s
b
l
o
c
k
4
(
id
:
14
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
5
(
id
:
30
)
"
>
T
h
i
s
i
s
b
l
o
c
k
5
(
id
:
15
)
<
/
div
>
document
resolveRequests
)
;
assertPortData
(
collectPortData
{
expectedEngineStatusCount
:
1
expectedRequestCount
:
10
expectedCachedCount
:
20
}
)
;
cleanup
(
)
;
}
)
;
/
*
*
*
This
test
case
tests
the
behavior
of
passthrough
translations
*
both
for
attributes
and
text
content
where
a
node
is
mutated
*
with
text
that
we
know
is
already
in
the
target
language
because
*
it
is
hot
in
the
cache
.
In
such
a
case
it
should
not
be
re
-
translated
.
*
/
add_task
(
async
function
test_passthrough_within_document
(
)
{
const
{
translate
htmlMatches
cleanup
document
resolveRequests
collectPortData
}
=
await
setupMutationsTest
(
/
*
html
*
/
<
div
title
=
"
Title
attribute
1
"
>
This
is
block
1
<
/
div
>
<
div
title
=
"
Title
attribute
2
"
>
This
is
block
2
<
/
div
>
<
div
title
=
"
Title
attribute
3
"
>
This
is
block
3
<
/
div
>
<
div
title
=
"
Title
attribute
4
"
>
This
is
block
4
<
/
div
>
)
;
translate
(
)
;
await
htmlMatches
(
"
Each
div
block
gets
translated
separately
"
/
*
html
*
/
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
1
(
id
:
5
)
"
>
T
h
i
s
i
s
b
l
o
c
k
1
(
id
:
1
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
2
(
id
:
6
)
"
>
T
h
i
s
i
s
b
l
o
c
k
2
(
id
:
2
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
3
(
id
:
7
)
"
>
T
h
i
s
i
s
b
l
o
c
k
3
(
id
:
3
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
4
(
id
:
8
)
"
>
T
h
i
s
i
s
b
l
o
c
k
4
(
id
:
4
)
<
/
div
>
document
resolveRequests
)
;
assertPortData
(
collectPortData
{
expectedEngineStatusCount
:
1
expectedRequestCount
:
8
}
)
;
info
(
"
Circularly
rotating
all
divs
and
titles
"
)
;
const
divs
=
Array
.
from
(
document
.
querySelectorAll
(
"
div
"
)
)
;
const
titles
=
divs
.
map
(
div
=
>
div
.
getAttribute
(
"
title
"
)
)
;
const
texts
=
divs
.
map
(
div
=
>
div
.
textContent
)
;
divs
.
forEach
(
(
div
idx
)
=
>
{
const
nextIdx
=
(
idx
+
1
)
%
divs
.
length
;
div
.
setAttribute
(
"
title
"
titles
[
nextIdx
]
)
;
div
.
textContent
=
texts
[
nextIdx
]
;
}
)
;
/
/
Add
brand
-
new
uncached
content
and
attribute
.
const
newDiv
=
document
.
createElement
(
"
div
"
)
;
newDiv
.
setAttribute
(
"
title
"
"
Title
attribute
5
"
)
;
newDiv
.
textContent
=
"
This
is
block
5
"
;
document
.
body
.
appendChild
(
newDiv
)
;
await
htmlMatches
(
"
Rotated
blocks
are
still
translated
from
the
cache
and
the
new
block
is
translated
with
new
IDs
"
/
*
html
*
/
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
2
(
id
:
6
)
"
>
T
h
i
s
i
s
b
l
o
c
k
2
(
id
:
2
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
3
(
id
:
7
)
"
>
T
h
i
s
i
s
b
l
o
c
k
3
(
id
:
3
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
4
(
id
:
8
)
"
>
T
h
i
s
i
s
b
l
o
c
k
4
(
id
:
4
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
1
(
id
:
5
)
"
>
T
h
i
s
i
s
b
l
o
c
k
1
(
id
:
1
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
5
(
id
:
14
)
"
>
T
h
i
s
i
s
b
l
o
c
k
5
(
id
:
13
)
<
/
div
>
document
resolveRequests
)
;
assertPortData
(
collectPortData
{
expectedRequestCount
:
2
}
)
;
cleanup
(
)
;
}
)
;
add_task
(
async
function
test_passthrough_within_scheduler
(
)
{
const
{
translate
htmlMatches
cleanup
document
resolveRequests
collectPortData
}
=
await
setupMutationsTest
(
/
*
html
*
/
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
1
(
id
:
26
)
"
>
T
h
i
s
i
s
b
l
o
c
k
1
(
id
:
11
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
2
(
id
:
27
)
"
>
T
h
i
s
i
s
b
l
o
c
k
2
(
id
:
12
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
3
(
id
:
28
)
"
>
T
h
i
s
i
s
b
l
o
c
k
3
(
id
:
13
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
4
(
id
:
29
)
"
>
T
h
i
s
i
s
b
l
o
c
k
4
(
id
:
14
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
5
(
id
:
30
)
"
>
T
h
i
s
i
s
b
l
o
c
k
5
(
id
:
15
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
1
(
id
:
26
)
"
>
T
h
i
s
i
s
b
l
o
c
k
1
(
id
:
11
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
2
(
id
:
27
)
"
>
T
h
i
s
i
s
b
l
o
c
k
2
(
id
:
12
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
3
(
id
:
28
)
"
>
T
h
i
s
i
s
b
l
o
c
k
3
(
id
:
13
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
4
(
id
:
29
)
"
>
T
h
i
s
i
s
b
l
o
c
k
4
(
id
:
14
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
5
(
id
:
30
)
"
>
T
h
i
s
i
s
b
l
o
c
k
5
(
id
:
15
)
<
/
div
>
<
div
title
=
"
Title
attribute
1
"
>
This
is
block
1
<
/
div
>
<
div
title
=
"
Title
attribute
2
"
>
This
is
block
2
<
/
div
>
<
div
title
=
"
Title
attribute
3
"
>
This
is
block
3
<
/
div
>
<
div
title
=
"
Title
attribute
4
"
>
This
is
block
4
<
/
div
>
<
div
title
=
"
Title
attribute
5
"
>
This
is
block
5
<
/
div
>
)
;
translate
(
)
;
await
htmlMatches
(
"
Each
div
block
gets
translated
separately
"
/
*
html
*
/
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
1
(
id
:
26
)
"
>
T
h
i
s
i
s
b
l
o
c
k
1
(
id
:
11
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
2
(
id
:
27
)
"
>
T
h
i
s
i
s
b
l
o
c
k
2
(
id
:
12
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
3
(
id
:
28
)
"
>
T
h
i
s
i
s
b
l
o
c
k
3
(
id
:
13
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
4
(
id
:
29
)
"
>
T
h
i
s
i
s
b
l
o
c
k
4
(
id
:
14
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
5
(
id
:
30
)
"
>
T
h
i
s
i
s
b
l
o
c
k
5
(
id
:
15
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
1
(
id
:
26
)
"
>
T
h
i
s
i
s
b
l
o
c
k
1
(
id
:
11
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
2
(
id
:
27
)
"
>
T
h
i
s
i
s
b
l
o
c
k
2
(
id
:
12
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
3
(
id
:
28
)
"
>
T
h
i
s
i
s
b
l
o
c
k
3
(
id
:
13
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
4
(
id
:
29
)
"
>
T
h
i
s
i
s
b
l
o
c
k
4
(
id
:
14
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
5
(
id
:
30
)
"
>
T
h
i
s
i
s
b
l
o
c
k
5
(
id
:
15
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
1
(
id
:
26
)
"
>
T
h
i
s
i
s
b
l
o
c
k
1
(
id
:
11
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
2
(
id
:
27
)
"
>
T
h
i
s
i
s
b
l
o
c
k
2
(
id
:
12
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
3
(
id
:
28
)
"
>
T
h
i
s
i
s
b
l
o
c
k
3
(
id
:
13
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
4
(
id
:
29
)
"
>
T
h
i
s
i
s
b
l
o
c
k
4
(
id
:
14
)
<
/
div
>
<
div
title
=
"
T
i
t
l
e
a
t
t
r
i
b
u
t
e
5
(
id
:
30
)
"
>
T
h
i
s
i
s
b
l
o
c
k
5
(
id
:
15
)
<
/
div
>
document
resolveRequests
)
;
assertPortData
(
collectPortData
{
expectedEngineStatusCount
:
1
expectedRequestCount
:
10
expectedPassthroughCount
:
20
}
)
;
cleanup
(
)
;
}
)
;
