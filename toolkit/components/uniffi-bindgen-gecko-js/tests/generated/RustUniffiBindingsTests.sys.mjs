/
/
This
file
was
autogenerated
by
the
uniffi
-
bindgen
-
gecko
-
js
crate
.
/
/
Trust
me
you
don
'
t
want
to
mess
with
it
!
import
{
UniFFITypeError
}
from
"
moz
-
src
:
/
/
/
toolkit
/
components
/
uniffi
-
js
/
js
/
UniFFI
.
sys
.
mjs
"
;
/
/
Objects
intended
to
be
used
in
the
unit
tests
export
var
UnitTestObjs
=
{
}
;
/
*
*
*
Handler
for
a
single
UniFFI
CallbackInterface
*
*
This
class
stores
objects
that
implement
a
callback
interface
in
a
handle
*
map
allowing
them
to
be
referenced
by
the
Rust
code
using
an
integer
*
handle
.
*
*
While
the
callback
object
is
stored
in
the
map
it
allows
the
Rust
code
to
*
call
methods
on
the
object
using
the
callback
object
handle
a
method
id
*
and
an
ArrayBuffer
packed
with
the
method
arguments
.
*
*
When
the
Rust
code
drops
its
reference
it
sends
a
call
with
the
methodId
=
0
*
which
causes
callback
object
to
be
removed
from
the
map
.
*
/
class
UniFFICallbackHandler
{
#
name
;
#
interfaceId
;
#
handleCounter
;
#
handleMap
;
#
methodHandlers
;
#
allowNewCallbacks
/
*
*
*
Create
a
UniFFICallbackHandler
*
param
{
string
}
name
-
Human
-
friendly
name
for
this
callback
interface
*
param
{
int
}
interfaceId
-
Interface
ID
for
this
CallbackInterface
.
*
param
{
UniFFICallbackMethodHandler
[
]
}
methodHandlers
-
-
UniFFICallbackHandler
for
each
method
in
the
same
order
as
the
UDL
file
*
/
constructor
(
name
interfaceId
methodHandlers
)
{
this
.
#
name
=
name
;
this
.
#
interfaceId
=
interfaceId
;
this
.
#
handleCounter
=
0
;
this
.
#
handleMap
=
new
Map
(
)
;
this
.
#
methodHandlers
=
methodHandlers
;
this
.
#
allowNewCallbacks
=
true
;
UniFFIScaffolding
.
registerCallbackHandler
(
this
.
#
interfaceId
this
)
;
Services
.
obs
.
addObserver
(
this
"
xpcom
-
shutdown
"
)
;
}
/
*
*
*
Store
a
callback
object
in
the
handle
map
and
return
the
handle
*
*
param
{
obj
}
callbackObj
-
Object
that
implements
the
callback
interface
*
returns
{
int
}
-
Handle
for
this
callback
object
this
is
what
gets
passed
back
to
Rust
.
*
/
storeCallbackObj
(
callbackObj
)
{
if
(
!
this
.
#
allowNewCallbacks
)
{
throw
new
UniFFIError
(
No
new
callbacks
allowed
for
{
this
.
#
name
}
)
;
}
const
handle
=
this
.
#
handleCounter
;
this
.
#
handleCounter
+
=
1
;
this
.
#
handleMap
.
set
(
handle
new
UniFFICallbackHandleMapEntry
(
callbackObj
Components
.
stack
.
caller
.
formattedStack
.
trim
(
)
)
)
;
return
handle
;
}
/
*
*
*
Get
a
previously
stored
callback
object
*
*
param
{
int
}
handle
-
Callback
object
handle
returned
from
storeCallbackObj
(
)
*
returns
{
obj
}
-
Callback
object
*
/
getCallbackObj
(
handle
)
{
return
this
.
#
handleMap
.
get
(
handle
)
.
callbackObj
;
}
/
*
*
*
Set
if
new
callbacks
are
allowed
for
this
handler
*
*
This
is
called
with
false
during
shutdown
to
ensure
the
callback
maps
don
'
t
*
prevent
JS
objects
from
being
GCed
.
*
/
setAllowNewCallbacks
(
allow
)
{
this
.
#
allowNewCallbacks
=
allow
}
/
*
*
*
Check
that
no
callbacks
are
currently
registered
*
*
If
there
are
callbacks
registered
a
UniFFIError
will
be
thrown
.
This
is
*
called
during
shutdown
to
generate
an
alert
if
there
are
leaked
callback
*
interfaces
.
*
/
assertNoRegisteredCallbacks
(
)
{
if
(
this
.
#
handleMap
.
size
>
0
)
{
const
entry
=
this
.
#
handleMap
.
values
(
)
.
next
(
)
.
value
;
throw
new
UniFFIError
(
UniFFI
interface
{
this
.
#
name
}
has
{
this
.
#
handleMap
.
size
}
registered
callbacks
at
xpcom
-
shutdown
.
This
likely
indicates
a
UniFFI
callback
leak
.
\
nStack
trace
for
the
first
leaked
callback
:
\
n
{
entry
.
stackTrace
}
.
)
;
}
}
/
*
*
*
Invoke
a
method
on
a
stored
callback
object
*
param
{
int
}
handle
-
Object
handle
*
param
{
int
}
methodId
-
Method
index
(
0
-
based
)
*
param
{
UniFFIScaffoldingValue
[
]
}
args
-
Arguments
to
pass
to
the
method
*
/
call
(
handle
methodId
.
.
.
args
)
{
try
{
this
.
#
invokeCallbackInner
(
handle
methodId
args
)
;
}
catch
(
e
)
{
console
.
error
(
internal
error
invoking
callback
:
{
e
}
)
}
}
/
*
*
*
Destroy
a
stored
callback
object
*
param
{
int
}
handle
-
Object
handle
*
/
destroy
(
handle
)
{
this
.
#
handleMap
.
delete
(
handle
)
;
}
#
invokeCallbackInner
(
handle
methodId
args
)
{
const
callbackObj
=
this
.
getCallbackObj
(
handle
)
;
if
(
callbackObj
=
=
=
undefined
)
{
throw
new
UniFFIError
(
{
this
.
#
name
}
:
invalid
callback
handle
id
:
{
handle
}
)
;
}
/
/
Get
the
method
data
converting
from
1
-
based
indexing
const
methodHandler
=
this
.
#
methodHandlers
[
methodId
]
;
if
(
methodHandler
=
=
=
undefined
)
{
throw
new
UniFFIError
(
{
this
.
#
name
}
:
invalid
method
id
:
{
methodId
}
)
}
methodHandler
.
call
(
callbackObj
args
)
;
}
/
*
*
*
xpcom
-
shutdown
observer
method
*
*
This
handles
:
*
-
Deregistering
ourselves
as
the
UniFFI
callback
handler
*
-
Checks
for
any
leftover
stored
callbacks
which
indicate
memory
leaks
*
/
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
xpcom
-
shutdown
"
)
{
try
{
this
.
setAllowNewCallbacks
(
false
)
;
this
.
assertNoRegisteredCallbacks
(
)
;
UniFFIScaffolding
.
deregisterCallbackHandler
(
this
.
#
interfaceId
)
;
}
catch
(
ex
)
{
console
.
error
(
UniFFI
Callback
interface
error
during
xpcom
-
shutdown
:
{
ex
}
)
;
Cc
[
"
mozilla
.
org
/
xpcom
/
debug
;
1
"
]
.
getService
(
Ci
.
nsIDebug2
)
.
abort
(
ex
.
filename
ex
.
lineNumber
)
;
}
}
}
}
/
*
*
*
Handles
calling
a
single
method
for
a
callback
interface
*
/
class
UniFFICallbackMethodHandler
{
#
name
;
#
argsConverters
;
/
*
*
*
Create
a
UniFFICallbackMethodHandler
*
param
{
string
}
name
-
-
Name
of
the
method
to
call
on
the
callback
object
*
param
{
FfiConverter
[
]
}
argsConverters
-
FfiConverter
for
each
argument
type
*
/
constructor
(
name
argsConverters
)
{
this
.
#
name
=
name
;
this
.
#
argsConverters
=
argsConverters
;
}
/
*
*
*
Invoke
the
method
*
*
param
{
obj
}
callbackObj
-
-
Object
implementing
the
callback
interface
for
this
method
*
param
{
ArrayBuffer
}
argsArrayBuffer
-
-
Arguments
for
the
method
packed
in
an
ArrayBuffer
*
/
call
(
callbackObj
args
)
{
const
convertedArgs
=
this
.
#
argsConverters
.
map
(
(
converter
i
)
=
>
converter
.
lift
(
args
[
i
]
)
)
;
return
callbackObj
[
this
.
#
name
]
(
.
.
.
convertedArgs
)
;
}
}
/
*
*
*
UniFFICallbackHandler
.
handleMap
entry
*
*
property
callbackObj
-
Callback
object
this
must
implement
the
callback
interface
.
*
property
{
string
}
stackTrace
-
Stack
trace
from
when
the
callback
object
was
registered
.
This
is
used
to
proved
extra
context
when
debugging
leaked
callback
objects
.
*
/
class
UniFFICallbackHandleMapEntry
{
constructor
(
callbackObj
stackTrace
)
{
this
.
callbackObj
=
callbackObj
;
this
.
stackTrace
=
stackTrace
}
}
let
lazy
=
{
}
;
ChromeUtils
.
defineLazyGetter
(
lazy
"
decoder
"
(
)
=
>
new
TextDecoder
(
)
)
;
ChromeUtils
.
defineLazyGetter
(
lazy
"
encoder
"
(
)
=
>
new
TextEncoder
(
)
)
;
/
/
Write
/
Read
data
to
/
from
an
ArrayBuffer
class
ArrayBufferDataStream
{
constructor
(
arrayBuffer
)
{
this
.
dataView
=
new
DataView
(
arrayBuffer
)
;
this
.
pos
=
0
;
}
readUint8
(
)
{
let
rv
=
this
.
dataView
.
getUint8
(
this
.
pos
)
;
this
.
pos
+
=
1
;
return
rv
;
}
writeUint8
(
value
)
{
this
.
dataView
.
setUint8
(
this
.
pos
value
)
;
this
.
pos
+
=
1
;
}
readUint16
(
)
{
let
rv
=
this
.
dataView
.
getUint16
(
this
.
pos
)
;
this
.
pos
+
=
2
;
return
rv
;
}
writeUint16
(
value
)
{
this
.
dataView
.
setUint16
(
this
.
pos
value
)
;
this
.
pos
+
=
2
;
}
readUint32
(
)
{
let
rv
=
this
.
dataView
.
getUint32
(
this
.
pos
)
;
this
.
pos
+
=
4
;
return
rv
;
}
writeUint32
(
value
)
{
this
.
dataView
.
setUint32
(
this
.
pos
value
)
;
this
.
pos
+
=
4
;
}
readUint64
(
)
{
let
rv
=
this
.
dataView
.
getBigUint64
(
this
.
pos
)
;
this
.
pos
+
=
8
;
return
Number
(
rv
)
;
}
writeUint64
(
value
)
{
this
.
dataView
.
setBigUint64
(
this
.
pos
BigInt
(
value
)
)
;
this
.
pos
+
=
8
;
}
readInt8
(
)
{
let
rv
=
this
.
dataView
.
getInt8
(
this
.
pos
)
;
this
.
pos
+
=
1
;
return
rv
;
}
writeInt8
(
value
)
{
this
.
dataView
.
setInt8
(
this
.
pos
value
)
;
this
.
pos
+
=
1
;
}
readInt16
(
)
{
let
rv
=
this
.
dataView
.
getInt16
(
this
.
pos
)
;
this
.
pos
+
=
2
;
return
rv
;
}
writeInt16
(
value
)
{
this
.
dataView
.
setInt16
(
this
.
pos
value
)
;
this
.
pos
+
=
2
;
}
readInt32
(
)
{
let
rv
=
this
.
dataView
.
getInt32
(
this
.
pos
)
;
this
.
pos
+
=
4
;
return
rv
;
}
writeInt32
(
value
)
{
this
.
dataView
.
setInt32
(
this
.
pos
value
)
;
this
.
pos
+
=
4
;
}
readInt64
(
)
{
let
rv
=
this
.
dataView
.
getBigInt64
(
this
.
pos
)
;
this
.
pos
+
=
8
;
return
Number
(
rv
)
;
}
writeInt64
(
value
)
{
this
.
dataView
.
setBigInt64
(
this
.
pos
BigInt
(
value
)
)
;
this
.
pos
+
=
8
;
}
readFloat32
(
)
{
let
rv
=
this
.
dataView
.
getFloat32
(
this
.
pos
)
;
this
.
pos
+
=
4
;
return
rv
;
}
writeFloat32
(
value
)
{
this
.
dataView
.
setFloat32
(
this
.
pos
value
)
;
this
.
pos
+
=
4
;
}
readFloat64
(
)
{
let
rv
=
this
.
dataView
.
getFloat64
(
this
.
pos
)
;
this
.
pos
+
=
8
;
return
rv
;
}
writeFloat64
(
value
)
{
this
.
dataView
.
setFloat64
(
this
.
pos
value
)
;
this
.
pos
+
=
8
;
}
writeString
(
value
)
{
/
/
Note
:
in
order
to
efficiently
write
this
data
we
first
write
the
/
/
string
data
reserving
4
bytes
for
the
size
.
const
dest
=
new
Uint8Array
(
this
.
dataView
.
buffer
this
.
pos
+
4
)
;
const
encodeResult
=
lazy
.
encoder
.
encodeInto
(
value
dest
)
;
if
(
encodeResult
.
read
!
=
value
.
length
)
{
throw
new
UniFFIError
(
"
writeString
:
out
of
space
when
writing
to
ArrayBuffer
.
Did
the
computeSize
(
)
method
returned
the
wrong
result
?
"
)
;
}
const
size
=
encodeResult
.
written
;
/
/
Next
go
back
and
write
the
size
before
the
string
data
this
.
dataView
.
setUint32
(
this
.
pos
size
)
;
/
/
Finally
advance
our
position
past
both
the
size
and
string
data
this
.
pos
+
=
size
+
4
;
}
readString
(
)
{
const
size
=
this
.
readUint32
(
)
;
const
source
=
new
Uint8Array
(
this
.
dataView
.
buffer
this
.
pos
size
)
const
value
=
lazy
.
decoder
.
decode
(
source
)
;
this
.
pos
+
=
size
;
return
value
;
}
readBytes
(
)
{
const
size
=
this
.
readInt32
(
)
;
const
bytes
=
new
Uint8Array
(
this
.
dataView
.
buffer
this
.
pos
size
)
;
this
.
pos
+
=
size
;
return
bytes
}
writeBytes
(
value
)
{
this
.
writeUint32
(
value
.
length
)
;
value
.
forEach
(
(
elt
)
=
>
{
this
.
writeUint8
(
elt
)
;
}
)
}
/
/
Reads
a
pointer
from
the
data
stream
/
/
UniFFI
Pointers
are
*
*
always
*
*
8
bytes
long
.
That
is
enforced
/
/
by
the
C
+
+
and
Rust
Scaffolding
code
.
readPointer
(
pointerId
)
{
const
res
=
UniFFIScaffolding
.
readPointer
(
pointerId
this
.
dataView
.
buffer
this
.
pos
)
;
this
.
pos
+
=
8
;
return
res
;
}
/
/
Writes
a
pointer
into
the
data
stream
/
/
UniFFI
Pointers
are
*
*
always
*
*
8
bytes
long
.
That
is
enforced
/
/
by
the
C
+
+
and
Rust
Scaffolding
code
.
writePointer
(
pointerId
value
)
{
UniFFIScaffolding
.
writePointer
(
pointerId
value
this
.
dataView
.
buffer
this
.
pos
)
;
this
.
pos
+
=
8
;
}
}
function
handleRustResult
(
result
liftCallback
liftErrCallback
)
{
switch
(
result
.
code
)
{
case
"
success
"
:
return
liftCallback
(
result
.
data
)
;
case
"
error
"
:
throw
liftErrCallback
(
result
.
data
)
;
case
"
internal
-
error
"
:
if
(
result
.
data
)
{
throw
new
UniFFIInternalError
(
FfiConverterString
.
lift
(
result
.
data
)
)
;
}
else
{
throw
new
UniFFIInternalError
(
"
Unknown
error
"
)
;
}
default
:
throw
new
UniFFIError
(
Unexpected
status
code
:
{
result
.
code
}
)
;
}
}
class
UniFFIError
{
constructor
(
message
)
{
this
.
message
=
message
;
}
toString
(
)
{
return
UniFFIError
:
{
this
.
message
}
}
}
class
UniFFIInternalError
extends
UniFFIError
{
}
/
/
Base
class
for
FFI
converters
class
FfiConverter
{
/
/
throw
UniFFITypeError
if
a
value
to
be
converted
has
an
invalid
type
static
checkType
(
value
)
{
if
(
value
=
=
=
undefined
)
{
throw
new
UniFFITypeError
(
undefined
)
;
}
if
(
value
=
=
=
null
)
{
throw
new
UniFFITypeError
(
null
)
;
}
}
}
/
/
Base
class
for
FFI
converters
that
lift
/
lower
by
reading
/
writing
to
an
ArrayBuffer
class
FfiConverterArrayBuffer
extends
FfiConverter
{
static
lift
(
buf
)
{
return
this
.
read
(
new
ArrayBufferDataStream
(
buf
)
)
;
}
static
lower
(
value
)
{
const
buf
=
new
ArrayBuffer
(
this
.
computeSize
(
value
)
)
;
const
dataStream
=
new
ArrayBufferDataStream
(
buf
)
;
this
.
write
(
dataStream
value
)
;
return
buf
;
}
/
*
*
*
Computes
the
size
of
the
value
.
*
*
param
{
*
}
_value
*
return
{
number
}
*
/
static
computeSize
(
_value
)
{
throw
new
UniFFIInternalError
(
"
computeSize
(
)
should
be
declared
in
the
derived
class
"
)
;
}
/
*
*
*
Reads
the
type
from
a
data
stream
.
*
*
param
{
ArrayBufferDataStream
}
_dataStream
*
returns
{
any
}
*
/
static
read
(
_dataStream
)
{
throw
new
UniFFIInternalError
(
"
read
(
)
should
be
declared
in
the
derived
class
"
)
;
}
/
*
*
*
Writes
the
type
to
a
data
stream
.
*
*
param
{
ArrayBufferDataStream
}
_dataStream
*
param
{
any
}
_value
*
/
static
write
(
_dataStream
_value
)
{
throw
new
UniFFIInternalError
(
"
write
(
)
should
be
declared
in
the
derived
class
"
)
;
}
}
/
/
Symbols
that
are
used
to
ensure
that
Object
constructors
/
/
can
only
be
used
with
a
proper
UniFFI
pointer
const
uniffiObjectPtr
=
Symbol
(
"
uniffiObjectPtr
"
)
;
const
constructUniffiObject
=
Symbol
(
"
constructUniffiObject
"
)
;
UnitTestObjs
.
uniffiObjectPtr
=
uniffiObjectPtr
;
/
*
*
*
asyncRoundtripF32
*
/
export
async
function
asyncRoundtripF32
(
v
)
{
FfiConverterFloat32
.
checkType
(
v
)
;
const
result
=
await
UniFFIScaffolding
.
callAsync
(
110
/
/
uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_f32
FfiConverterFloat32
.
lower
(
v
)
)
return
handleRustResult
(
result
FfiConverterFloat32
.
lift
.
bind
(
FfiConverterFloat32
)
null
)
}
/
*
*
*
asyncRoundtripF64
*
/
export
async
function
asyncRoundtripF64
(
v
)
{
FfiConverterFloat64
.
checkType
(
v
)
;
const
result
=
await
UniFFIScaffolding
.
callAsync
(
111
/
/
uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_f64
FfiConverterFloat64
.
lower
(
v
)
)
return
handleRustResult
(
result
FfiConverterFloat64
.
lift
.
bind
(
FfiConverterFloat64
)
null
)
}
/
*
*
*
asyncRoundtripI16
*
/
export
async
function
asyncRoundtripI16
(
v
)
{
FfiConverterInt16
.
checkType
(
v
)
;
const
result
=
await
UniFFIScaffolding
.
callAsync
(
112
/
/
uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i16
FfiConverterInt16
.
lower
(
v
)
)
return
handleRustResult
(
result
FfiConverterInt16
.
lift
.
bind
(
FfiConverterInt16
)
null
)
}
/
*
*
*
asyncRoundtripI32
*
/
export
async
function
asyncRoundtripI32
(
v
)
{
FfiConverterInt32
.
checkType
(
v
)
;
const
result
=
await
UniFFIScaffolding
.
callAsync
(
113
/
/
uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i32
FfiConverterInt32
.
lower
(
v
)
)
return
handleRustResult
(
result
FfiConverterInt32
.
lift
.
bind
(
FfiConverterInt32
)
null
)
}
/
*
*
*
asyncRoundtripI64
*
/
export
async
function
asyncRoundtripI64
(
v
)
{
FfiConverterInt64
.
checkType
(
v
)
;
const
result
=
await
UniFFIScaffolding
.
callAsync
(
114
/
/
uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i64
FfiConverterInt64
.
lower
(
v
)
)
return
handleRustResult
(
result
FfiConverterInt64
.
lift
.
bind
(
FfiConverterInt64
)
null
)
}
/
*
*
*
asyncRoundtripI8
*
/
export
async
function
asyncRoundtripI8
(
v
)
{
FfiConverterInt8
.
checkType
(
v
)
;
const
result
=
await
UniFFIScaffolding
.
callAsync
(
115
/
/
uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i8
FfiConverterInt8
.
lower
(
v
)
)
return
handleRustResult
(
result
FfiConverterInt8
.
lift
.
bind
(
FfiConverterInt8
)
null
)
}
/
*
*
*
asyncRoundtripMap
*
/
export
async
function
asyncRoundtripMap
(
v
)
{
FfiConverterMapStringString
.
checkType
(
v
)
;
const
result
=
await
UniFFIScaffolding
.
callAsync
(
116
/
/
uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_map
FfiConverterMapStringString
.
lower
(
v
)
)
return
handleRustResult
(
result
FfiConverterMapStringString
.
lift
.
bind
(
FfiConverterMapStringString
)
null
)
}
/
*
*
*
asyncRoundtripObj
*
/
export
async
function
asyncRoundtripObj
(
v
)
{
FfiConverterTypeAsyncInterface
.
checkType
(
v
)
;
const
result
=
await
UniFFIScaffolding
.
callAsync
(
117
/
/
uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_obj
FfiConverterTypeAsyncInterface
.
lower
(
v
)
)
return
handleRustResult
(
result
FfiConverterTypeAsyncInterface
.
lift
.
bind
(
FfiConverterTypeAsyncInterface
)
null
)
}
/
*
*
*
asyncRoundtripString
*
/
export
async
function
asyncRoundtripString
(
v
)
{
FfiConverterString
.
checkType
(
v
)
;
const
result
=
await
UniFFIScaffolding
.
callAsync
(
118
/
/
uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_string
FfiConverterString
.
lower
(
v
)
)
return
handleRustResult
(
result
FfiConverterString
.
lift
.
bind
(
FfiConverterString
)
null
)
}
/
*
*
*
asyncRoundtripU16
*
/
export
async
function
asyncRoundtripU16
(
v
)
{
FfiConverterUInt16
.
checkType
(
v
)
;
const
result
=
await
UniFFIScaffolding
.
callAsync
(
119
/
/
uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u16
FfiConverterUInt16
.
lower
(
v
)
)
return
handleRustResult
(
result
FfiConverterUInt16
.
lift
.
bind
(
FfiConverterUInt16
)
null
)
}
/
*
*
*
asyncRoundtripU32
*
/
export
async
function
asyncRoundtripU32
(
v
)
{
FfiConverterUInt32
.
checkType
(
v
)
;
const
result
=
await
UniFFIScaffolding
.
callAsync
(
120
/
/
uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u32
FfiConverterUInt32
.
lower
(
v
)
)
return
handleRustResult
(
result
FfiConverterUInt32
.
lift
.
bind
(
FfiConverterUInt32
)
null
)
}
/
*
*
*
asyncRoundtripU64
*
/
export
async
function
asyncRoundtripU64
(
v
)
{
FfiConverterUInt64
.
checkType
(
v
)
;
const
result
=
await
UniFFIScaffolding
.
callAsync
(
121
/
/
uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u64
FfiConverterUInt64
.
lower
(
v
)
)
return
handleRustResult
(
result
FfiConverterUInt64
.
lift
.
bind
(
FfiConverterUInt64
)
null
)
}
/
*
*
*
asyncRoundtripU8
*
/
export
async
function
asyncRoundtripU8
(
v
)
{
FfiConverterUInt8
.
checkType
(
v
)
;
const
result
=
await
UniFFIScaffolding
.
callAsync
(
122
/
/
uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u8
FfiConverterUInt8
.
lower
(
v
)
)
return
handleRustResult
(
result
FfiConverterUInt8
.
lift
.
bind
(
FfiConverterUInt8
)
null
)
}
/
*
*
*
asyncRoundtripVec
*
/
export
async
function
asyncRoundtripVec
(
v
)
{
FfiConverterSequenceUInt32
.
checkType
(
v
)
;
const
result
=
await
UniFFIScaffolding
.
callAsync
(
123
/
/
uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_vec
FfiConverterSequenceUInt32
.
lower
(
v
)
)
return
handleRustResult
(
result
FfiConverterSequenceUInt32
.
lift
.
bind
(
FfiConverterSequenceUInt32
)
null
)
}
/
*
*
*
cloneInterface
*
/
export
function
cloneInterface
(
int
)
{
FfiConverterTypeTestInterface
.
checkType
(
int
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
124
/
/
uniffi_uniffi_bindings_tests_fn_func_clone_interface
FfiConverterTypeTestInterface
.
lower
(
int
)
)
return
handleRustResult
(
result
FfiConverterTypeTestInterface
.
lift
.
bind
(
FfiConverterTypeTestInterface
)
null
)
}
/
*
*
*
funcWithDefault
*
/
export
function
funcWithDefault
(
arg
=
"
DEFAULT
"
)
{
FfiConverterString
.
checkType
(
arg
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
125
/
/
uniffi_uniffi_bindings_tests_fn_func_func_with_default
FfiConverterString
.
lower
(
arg
)
)
return
handleRustResult
(
result
FfiConverterString
.
lift
.
bind
(
FfiConverterString
)
null
)
}
/
*
*
*
funcWithError
*
/
export
function
funcWithError
(
input
)
{
FfiConverterUInt32
.
checkType
(
input
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
126
/
/
uniffi_uniffi_bindings_tests_fn_func_func_with_error
FfiConverterUInt32
.
lower
(
input
)
)
return
handleRustResult
(
result
(
result
)
=
>
undefined
FfiConverterTypeTestError
.
lift
.
bind
(
FfiConverterTypeTestError
)
)
}
/
*
*
*
funcWithFlatError
*
/
export
function
funcWithFlatError
(
input
)
{
FfiConverterUInt32
.
checkType
(
input
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
127
/
/
uniffi_uniffi_bindings_tests_fn_func_func_with_flat_error
FfiConverterUInt32
.
lower
(
input
)
)
return
handleRustResult
(
result
(
result
)
=
>
undefined
FfiConverterTypeTestFlatError
.
lift
.
bind
(
FfiConverterTypeTestFlatError
)
)
}
/
*
*
*
Test
a
multi
-
word
argument
.
the_argument
should
be
normalized
to
the
naming
style
of
the
*
foreign
language
.
*
/
export
function
funcWithMultiWordArg
(
theArgument
)
{
FfiConverterString
.
checkType
(
theArgument
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
128
/
/
uniffi_uniffi_bindings_tests_fn_func_func_with_multi_word_arg
FfiConverterString
.
lower
(
theArgument
)
)
return
handleRustResult
(
result
FfiConverterString
.
lift
.
bind
(
FfiConverterString
)
null
)
}
/
*
*
*
invokeTestCallbackInterfaceMethod
*
/
export
function
invokeTestCallbackInterfaceMethod
(
cbi
)
{
FfiConverterTypeTestCallbackInterface
.
checkType
(
cbi
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
129
/
/
uniffi_uniffi_bindings_tests_fn_func_invoke_test_callback_interface_method
FfiConverterTypeTestCallbackInterface
.
lower
(
cbi
)
)
return
handleRustResult
(
result
FfiConverterUInt32
.
lift
.
bind
(
FfiConverterUInt32
)
null
)
}
/
*
*
*
roundtripBool
*
/
export
function
roundtripBool
(
a
)
{
FfiConverterBoolean
.
checkType
(
a
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
130
/
/
uniffi_uniffi_bindings_tests_fn_func_roundtrip_bool
FfiConverterBoolean
.
lower
(
a
)
)
return
handleRustResult
(
result
FfiConverterBoolean
.
lift
.
bind
(
FfiConverterBoolean
)
null
)
}
/
*
*
*
roundtripComplexCompound
*
/
export
function
roundtripComplexCompound
(
a
)
{
FfiConverterOptionalSequenceMapStringUInt32
.
checkType
(
a
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
131
/
/
uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_compound
FfiConverterOptionalSequenceMapStringUInt32
.
lower
(
a
)
)
return
handleRustResult
(
result
FfiConverterOptionalSequenceMapStringUInt32
.
lift
.
bind
(
FfiConverterOptionalSequenceMapStringUInt32
)
null
)
}
/
*
*
*
roundtripComplexEnum
*
/
export
function
roundtripComplexEnum
(
en
)
{
FfiConverterTypeComplexEnum
.
checkType
(
en
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
132
/
/
uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_enum
FfiConverterTypeComplexEnum
.
lower
(
en
)
)
return
handleRustResult
(
result
FfiConverterTypeComplexEnum
.
lift
.
bind
(
FfiConverterTypeComplexEnum
)
null
)
}
/
*
*
*
roundtripComplexRec
*
/
export
function
roundtripComplexRec
(
rec
)
{
FfiConverterTypeComplexRec
.
checkType
(
rec
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
133
/
/
uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_rec
FfiConverterTypeComplexRec
.
lower
(
rec
)
)
return
handleRustResult
(
result
FfiConverterTypeComplexRec
.
lift
.
bind
(
FfiConverterTypeComplexRec
)
null
)
}
/
*
*
*
roundtripCustomType
*
/
export
function
roundtripCustomType
(
handle
)
{
FfiConverterTypeHandle
.
checkType
(
handle
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
134
/
/
uniffi_uniffi_bindings_tests_fn_func_roundtrip_custom_type
FfiConverterTypeHandle
.
lower
(
handle
)
)
return
handleRustResult
(
result
FfiConverterTypeHandle
.
lift
.
bind
(
FfiConverterTypeHandle
)
null
)
}
/
*
*
*
roundtripEnumNoData
*
/
export
function
roundtripEnumNoData
(
en
)
{
FfiConverterTypeEnumNoData
.
checkType
(
en
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
135
/
/
uniffi_uniffi_bindings_tests_fn_func_roundtrip_enum_no_data
FfiConverterTypeEnumNoData
.
lower
(
en
)
)
return
handleRustResult
(
result
FfiConverterTypeEnumNoData
.
lift
.
bind
(
FfiConverterTypeEnumNoData
)
null
)
}
/
*
*
*
roundtripEnumWithData
*
/
export
function
roundtripEnumWithData
(
en
)
{
FfiConverterTypeEnumWithData
.
checkType
(
en
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
136
/
/
uniffi_uniffi_bindings_tests_fn_func_roundtrip_enum_with_data
FfiConverterTypeEnumWithData
.
lower
(
en
)
)
return
handleRustResult
(
result
FfiConverterTypeEnumWithData
.
lift
.
bind
(
FfiConverterTypeEnumWithData
)
null
)
}
/
*
*
*
roundtripF32
*
/
export
function
roundtripF32
(
a
)
{
FfiConverterFloat32
.
checkType
(
a
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
137
/
/
uniffi_uniffi_bindings_tests_fn_func_roundtrip_f32
FfiConverterFloat32
.
lower
(
a
)
)
return
handleRustResult
(
result
FfiConverterFloat32
.
lift
.
bind
(
FfiConverterFloat32
)
null
)
}
/
*
*
*
roundtripF64
*
/
export
function
roundtripF64
(
a
)
{
FfiConverterFloat64
.
checkType
(
a
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
138
/
/
uniffi_uniffi_bindings_tests_fn_func_roundtrip_f64
FfiConverterFloat64
.
lower
(
a
)
)
return
handleRustResult
(
result
FfiConverterFloat64
.
lift
.
bind
(
FfiConverterFloat64
)
null
)
}
/
*
*
*
roundtripHashMap
*
/
export
function
roundtripHashMap
(
a
)
{
FfiConverterMapStringUInt32
.
checkType
(
a
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
139
/
/
uniffi_uniffi_bindings_tests_fn_func_roundtrip_hash_map
FfiConverterMapStringUInt32
.
lower
(
a
)
)
return
handleRustResult
(
result
FfiConverterMapStringUInt32
.
lift
.
bind
(
FfiConverterMapStringUInt32
)
null
)
}
/
*
*
*
roundtripI16
*
/
export
function
roundtripI16
(
a
)
{
FfiConverterInt16
.
checkType
(
a
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
140
/
/
uniffi_uniffi_bindings_tests_fn_func_roundtrip_i16
FfiConverterInt16
.
lower
(
a
)
)
return
handleRustResult
(
result
FfiConverterInt16
.
lift
.
bind
(
FfiConverterInt16
)
null
)
}
/
*
*
*
roundtripI32
*
/
export
function
roundtripI32
(
a
)
{
FfiConverterInt32
.
checkType
(
a
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
141
/
/
uniffi_uniffi_bindings_tests_fn_func_roundtrip_i32
FfiConverterInt32
.
lower
(
a
)
)
return
handleRustResult
(
result
FfiConverterInt32
.
lift
.
bind
(
FfiConverterInt32
)
null
)
}
/
*
*
*
roundtripI64
*
/
export
function
roundtripI64
(
a
)
{
FfiConverterInt64
.
checkType
(
a
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
142
/
/
uniffi_uniffi_bindings_tests_fn_func_roundtrip_i64
FfiConverterInt64
.
lower
(
a
)
)
return
handleRustResult
(
result
FfiConverterInt64
.
lift
.
bind
(
FfiConverterInt64
)
null
)
}
/
*
*
*
roundtripI8
*
/
export
function
roundtripI8
(
a
)
{
FfiConverterInt8
.
checkType
(
a
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
143
/
/
uniffi_uniffi_bindings_tests_fn_func_roundtrip_i8
FfiConverterInt8
.
lower
(
a
)
)
return
handleRustResult
(
result
FfiConverterInt8
.
lift
.
bind
(
FfiConverterInt8
)
null
)
}
/
*
*
*
roundtripOption
*
/
export
function
roundtripOption
(
a
)
{
FfiConverterOptionalUInt32
.
checkType
(
a
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
144
/
/
uniffi_uniffi_bindings_tests_fn_func_roundtrip_option
FfiConverterOptionalUInt32
.
lower
(
a
)
)
return
handleRustResult
(
result
FfiConverterOptionalUInt32
.
lift
.
bind
(
FfiConverterOptionalUInt32
)
null
)
}
/
*
*
*
roundtripSimpleRec
*
/
export
async
function
roundtripSimpleRec
(
rec
)
{
FfiConverterTypeSimpleRec
.
checkType
(
rec
)
;
const
result
=
await
UniFFIScaffolding
.
callAsyncWrapper
(
145
/
/
uniffi_uniffi_bindings_tests_fn_func_roundtrip_simple_rec
FfiConverterTypeSimpleRec
.
lower
(
rec
)
)
return
handleRustResult
(
result
FfiConverterTypeSimpleRec
.
lift
.
bind
(
FfiConverterTypeSimpleRec
)
null
)
}
/
*
*
*
roundtripString
*
/
export
function
roundtripString
(
a
)
{
FfiConverterString
.
checkType
(
a
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
146
/
/
uniffi_uniffi_bindings_tests_fn_func_roundtrip_string
FfiConverterString
.
lower
(
a
)
)
return
handleRustResult
(
result
FfiConverterString
.
lift
.
bind
(
FfiConverterString
)
null
)
}
/
*
*
*
roundtripU16
*
/
export
function
roundtripU16
(
a
)
{
FfiConverterUInt16
.
checkType
(
a
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
147
/
/
uniffi_uniffi_bindings_tests_fn_func_roundtrip_u16
FfiConverterUInt16
.
lower
(
a
)
)
return
handleRustResult
(
result
FfiConverterUInt16
.
lift
.
bind
(
FfiConverterUInt16
)
null
)
}
/
*
*
*
roundtripU32
*
/
export
function
roundtripU32
(
a
)
{
FfiConverterUInt32
.
checkType
(
a
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
148
/
/
uniffi_uniffi_bindings_tests_fn_func_roundtrip_u32
FfiConverterUInt32
.
lower
(
a
)
)
return
handleRustResult
(
result
FfiConverterUInt32
.
lift
.
bind
(
FfiConverterUInt32
)
null
)
}
/
*
*
*
roundtripU64
*
/
export
function
roundtripU64
(
a
)
{
FfiConverterUInt64
.
checkType
(
a
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
149
/
/
uniffi_uniffi_bindings_tests_fn_func_roundtrip_u64
FfiConverterUInt64
.
lower
(
a
)
)
return
handleRustResult
(
result
FfiConverterUInt64
.
lift
.
bind
(
FfiConverterUInt64
)
null
)
}
/
*
*
*
roundtripU8
*
/
export
function
roundtripU8
(
a
)
{
FfiConverterUInt8
.
checkType
(
a
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
150
/
/
uniffi_uniffi_bindings_tests_fn_func_roundtrip_u8
FfiConverterUInt8
.
lower
(
a
)
)
return
handleRustResult
(
result
FfiConverterUInt8
.
lift
.
bind
(
FfiConverterUInt8
)
null
)
}
/
*
*
*
roundtripVec
*
/
export
function
roundtripVec
(
a
)
{
FfiConverterSequenceUInt32
.
checkType
(
a
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
151
/
/
uniffi_uniffi_bindings_tests_fn_func_roundtrip_vec
FfiConverterSequenceUInt32
.
lower
(
a
)
)
return
handleRustResult
(
result
FfiConverterSequenceUInt32
.
lift
.
bind
(
FfiConverterSequenceUInt32
)
null
)
}
/
*
*
*
Complex
test
:
input
a
bunch
of
different
values
and
add
them
together
*
/
export
function
sumWithManyTypes
(
a
b
c
d
e
f
g
h
i
j
negate
)
{
FfiConverterUInt8
.
checkType
(
a
)
;
FfiConverterInt8
.
checkType
(
b
)
;
FfiConverterUInt16
.
checkType
(
c
)
;
FfiConverterInt16
.
checkType
(
d
)
;
FfiConverterUInt32
.
checkType
(
e
)
;
FfiConverterInt32
.
checkType
(
f
)
;
FfiConverterUInt64
.
checkType
(
g
)
;
FfiConverterInt64
.
checkType
(
h
)
;
FfiConverterFloat32
.
checkType
(
i
)
;
FfiConverterFloat64
.
checkType
(
j
)
;
FfiConverterBoolean
.
checkType
(
negate
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
152
/
/
uniffi_uniffi_bindings_tests_fn_func_sum_with_many_types
FfiConverterUInt8
.
lower
(
a
)
FfiConverterInt8
.
lower
(
b
)
FfiConverterUInt16
.
lower
(
c
)
FfiConverterInt16
.
lower
(
d
)
FfiConverterUInt32
.
lower
(
e
)
FfiConverterInt32
.
lower
(
f
)
FfiConverterUInt64
.
lower
(
g
)
FfiConverterInt64
.
lower
(
h
)
FfiConverterFloat32
.
lower
(
i
)
FfiConverterFloat64
.
lower
(
j
)
FfiConverterBoolean
.
lower
(
negate
)
)
return
handleRustResult
(
result
FfiConverterFloat64
.
lift
.
bind
(
FfiConverterFloat64
)
null
)
}
/
*
*
*
swapTestInterfaces
*
/
export
function
swapTestInterfaces
(
interfaces
)
{
FfiConverterTypeTwoTestInterfaces
.
checkType
(
interfaces
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
153
/
/
uniffi_uniffi_bindings_tests_fn_func_swap_test_interfaces
FfiConverterTypeTwoTestInterfaces
.
lower
(
interfaces
)
)
return
handleRustResult
(
result
FfiConverterTypeTwoTestInterfaces
.
lift
.
bind
(
FfiConverterTypeTwoTestInterfaces
)
null
)
}
/
*
*
*
testFunc
*
/
export
function
testFunc
(
)
{
const
result
=
UniFFIScaffolding
.
callSync
(
154
/
/
uniffi_uniffi_bindings_tests_fn_func_test_func
)
return
handleRustResult
(
result
(
result
)
=
>
undefined
null
)
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterUInt8
extends
FfiConverter
{
static
checkType
(
value
)
{
super
.
checkType
(
value
)
;
if
(
!
Number
.
isInteger
(
value
)
)
{
throw
new
UniFFITypeError
(
{
value
}
is
not
an
integer
)
;
}
if
(
value
<
0
|
|
value
>
256
)
{
throw
new
UniFFITypeError
(
{
value
}
exceeds
the
U8
bounds
)
;
}
}
static
computeSize
(
_value
)
{
return
1
;
}
static
lift
(
value
)
{
return
value
;
}
static
lower
(
value
)
{
return
value
;
}
static
write
(
dataStream
value
)
{
dataStream
.
writeUint8
(
value
)
}
static
read
(
dataStream
)
{
return
dataStream
.
readUint8
(
)
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterInt8
extends
FfiConverter
{
static
checkType
(
value
)
{
super
.
checkType
(
value
)
;
if
(
!
Number
.
isInteger
(
value
)
)
{
throw
new
UniFFITypeError
(
{
value
}
is
not
an
integer
)
;
}
if
(
value
<
-
128
|
|
value
>
127
)
{
throw
new
UniFFITypeError
(
{
value
}
exceeds
the
I8
bounds
)
;
}
}
static
computeSize
(
_value
)
{
return
1
;
}
static
lift
(
value
)
{
return
value
;
}
static
lower
(
value
)
{
return
value
;
}
static
write
(
dataStream
value
)
{
dataStream
.
writeInt8
(
value
)
}
static
read
(
dataStream
)
{
return
dataStream
.
readInt8
(
)
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterUInt16
extends
FfiConverter
{
static
checkType
(
value
)
{
super
.
checkType
(
value
)
;
if
(
!
Number
.
isInteger
(
value
)
)
{
throw
new
UniFFITypeError
(
{
value
}
is
not
an
integer
)
;
}
if
(
value
<
0
|
|
value
>
65535
)
{
throw
new
UniFFITypeError
(
{
value
}
exceeds
the
U16
bounds
)
;
}
}
static
computeSize
(
_value
)
{
return
2
;
}
static
lift
(
value
)
{
return
value
;
}
static
lower
(
value
)
{
return
value
;
}
static
write
(
dataStream
value
)
{
dataStream
.
writeUint16
(
value
)
}
static
read
(
dataStream
)
{
return
dataStream
.
readUint16
(
)
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterInt16
extends
FfiConverter
{
static
checkType
(
value
)
{
super
.
checkType
(
value
)
;
if
(
!
Number
.
isInteger
(
value
)
)
{
throw
new
UniFFITypeError
(
{
value
}
is
not
an
integer
)
;
}
if
(
value
<
-
32768
|
|
value
>
32767
)
{
throw
new
UniFFITypeError
(
{
value
}
exceeds
the
I16
bounds
)
;
}
}
static
computeSize
(
_value
)
{
return
2
;
}
static
lift
(
value
)
{
return
value
;
}
static
lower
(
value
)
{
return
value
;
}
static
write
(
dataStream
value
)
{
dataStream
.
writeInt16
(
value
)
}
static
read
(
dataStream
)
{
return
dataStream
.
readInt16
(
)
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterUInt32
extends
FfiConverter
{
static
checkType
(
value
)
{
super
.
checkType
(
value
)
;
if
(
!
Number
.
isInteger
(
value
)
)
{
throw
new
UniFFITypeError
(
{
value
}
is
not
an
integer
)
;
}
if
(
value
<
0
|
|
value
>
4294967295
)
{
throw
new
UniFFITypeError
(
{
value
}
exceeds
the
U32
bounds
)
;
}
}
static
computeSize
(
_value
)
{
return
4
;
}
static
lift
(
value
)
{
return
value
;
}
static
lower
(
value
)
{
return
value
;
}
static
write
(
dataStream
value
)
{
dataStream
.
writeUint32
(
value
)
}
static
read
(
dataStream
)
{
return
dataStream
.
readUint32
(
)
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterInt32
extends
FfiConverter
{
static
checkType
(
value
)
{
super
.
checkType
(
value
)
;
if
(
!
Number
.
isInteger
(
value
)
)
{
throw
new
UniFFITypeError
(
{
value
}
is
not
an
integer
)
;
}
if
(
value
<
-
2147483648
|
|
value
>
2147483647
)
{
throw
new
UniFFITypeError
(
{
value
}
exceeds
the
I32
bounds
)
;
}
}
static
computeSize
(
_value
)
{
return
4
;
}
static
lift
(
value
)
{
return
value
;
}
static
lower
(
value
)
{
return
value
;
}
static
write
(
dataStream
value
)
{
dataStream
.
writeInt32
(
value
)
}
static
read
(
dataStream
)
{
return
dataStream
.
readInt32
(
)
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterUInt64
extends
FfiConverter
{
static
checkType
(
value
)
{
super
.
checkType
(
value
)
;
if
(
!
Number
.
isSafeInteger
(
value
)
)
{
throw
new
UniFFITypeError
(
{
value
}
exceeds
the
safe
integer
bounds
)
;
}
if
(
value
<
0
)
{
throw
new
UniFFITypeError
(
{
value
}
exceeds
the
U64
bounds
)
;
}
}
static
computeSize
(
_value
)
{
return
8
;
}
static
lift
(
value
)
{
return
value
;
}
static
lower
(
value
)
{
return
value
;
}
static
write
(
dataStream
value
)
{
dataStream
.
writeUint64
(
value
)
}
static
read
(
dataStream
)
{
return
dataStream
.
readUint64
(
)
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterInt64
extends
FfiConverter
{
static
checkType
(
value
)
{
super
.
checkType
(
value
)
;
if
(
!
Number
.
isSafeInteger
(
value
)
)
{
throw
new
UniFFITypeError
(
{
value
}
exceeds
the
safe
integer
bounds
)
;
}
}
static
computeSize
(
_value
)
{
return
8
;
}
static
lift
(
value
)
{
return
value
;
}
static
lower
(
value
)
{
return
value
;
}
static
write
(
dataStream
value
)
{
dataStream
.
writeInt64
(
value
)
}
static
read
(
dataStream
)
{
return
dataStream
.
readInt64
(
)
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterFloat32
extends
FfiConverter
{
static
computeSize
(
_value
)
{
return
4
;
}
static
lift
(
value
)
{
return
value
;
}
static
lower
(
value
)
{
return
value
;
}
static
write
(
dataStream
value
)
{
dataStream
.
writeFloat32
(
value
)
}
static
read
(
dataStream
)
{
return
dataStream
.
readFloat32
(
)
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterFloat64
extends
FfiConverter
{
static
computeSize
(
_value
)
{
return
8
;
}
static
lift
(
value
)
{
return
value
;
}
static
lower
(
value
)
{
return
value
;
}
static
write
(
dataStream
value
)
{
dataStream
.
writeFloat64
(
value
)
}
static
read
(
dataStream
)
{
return
dataStream
.
readFloat64
(
)
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterString
extends
FfiConverter
{
static
checkType
(
value
)
{
super
.
checkType
(
value
)
;
if
(
typeof
value
!
=
=
"
string
"
)
{
throw
new
UniFFITypeError
(
{
value
}
is
not
a
string
)
;
}
}
static
lift
(
buf
)
{
const
utf8Arr
=
new
Uint8Array
(
buf
)
;
return
lazy
.
decoder
.
decode
(
utf8Arr
)
;
}
static
lower
(
value
)
{
return
lazy
.
encoder
.
encode
(
value
)
.
buffer
;
}
static
write
(
dataStream
value
)
{
dataStream
.
writeString
(
value
)
;
}
static
read
(
dataStream
)
{
return
dataStream
.
readString
(
)
;
}
static
computeSize
(
value
)
{
return
4
+
lazy
.
encoder
.
encode
(
value
)
.
length
}
}
/
*
*
*
SimpleRec
*
/
export
class
SimpleRec
{
constructor
(
{
a
}
=
{
a
:
undefined
}
)
{
try
{
FfiConverterUInt8
.
checkType
(
a
)
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
a
"
)
;
}
throw
e
;
}
/
*
*
*
a
*
/
this
.
a
=
a
;
}
equals
(
other
)
{
return
(
this
.
a
=
=
other
.
a
)
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterTypeSimpleRec
extends
FfiConverterArrayBuffer
{
static
read
(
dataStream
)
{
return
new
SimpleRec
(
{
a
:
FfiConverterUInt8
.
read
(
dataStream
)
}
)
;
}
static
write
(
dataStream
value
)
{
FfiConverterUInt8
.
write
(
dataStream
value
.
a
)
;
}
static
computeSize
(
value
)
{
let
totalSize
=
0
;
totalSize
+
=
FfiConverterUInt8
.
computeSize
(
value
.
a
)
;
return
totalSize
}
static
checkType
(
value
)
{
super
.
checkType
(
value
)
;
if
(
!
(
value
instanceof
SimpleRec
)
)
{
throw
new
UniFFITypeError
(
Expected
'
SimpleRec
'
found
'
{
typeof
value
}
'
)
;
}
try
{
FfiConverterUInt8
.
checkType
(
value
.
a
)
;
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
.
a
"
)
;
}
throw
e
;
}
}
}
/
*
*
*
ComplexRec
*
/
export
class
ComplexRec
{
constructor
(
{
fieldU8
fieldI8
fieldU16
fieldI16
fieldU32
fieldI32
fieldU64
fieldI64
fieldF32
fieldF64
fieldString
=
"
DefaultString
"
fieldRec
}
=
{
fieldU8
:
undefined
fieldI8
:
undefined
fieldU16
:
undefined
fieldI16
:
undefined
fieldU32
:
undefined
fieldI32
:
undefined
fieldU64
:
undefined
fieldI64
:
undefined
fieldF32
:
undefined
fieldF64
:
undefined
fieldString
:
undefined
fieldRec
:
undefined
}
)
{
try
{
FfiConverterUInt8
.
checkType
(
fieldU8
)
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
fieldU8
"
)
;
}
throw
e
;
}
try
{
FfiConverterInt8
.
checkType
(
fieldI8
)
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
fieldI8
"
)
;
}
throw
e
;
}
try
{
FfiConverterUInt16
.
checkType
(
fieldU16
)
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
fieldU16
"
)
;
}
throw
e
;
}
try
{
FfiConverterInt16
.
checkType
(
fieldI16
)
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
fieldI16
"
)
;
}
throw
e
;
}
try
{
FfiConverterUInt32
.
checkType
(
fieldU32
)
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
fieldU32
"
)
;
}
throw
e
;
}
try
{
FfiConverterInt32
.
checkType
(
fieldI32
)
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
fieldI32
"
)
;
}
throw
e
;
}
try
{
FfiConverterUInt64
.
checkType
(
fieldU64
)
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
fieldU64
"
)
;
}
throw
e
;
}
try
{
FfiConverterInt64
.
checkType
(
fieldI64
)
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
fieldI64
"
)
;
}
throw
e
;
}
try
{
FfiConverterFloat32
.
checkType
(
fieldF32
)
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
fieldF32
"
)
;
}
throw
e
;
}
try
{
FfiConverterFloat64
.
checkType
(
fieldF64
)
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
fieldF64
"
)
;
}
throw
e
;
}
try
{
FfiConverterString
.
checkType
(
fieldString
)
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
fieldString
"
)
;
}
throw
e
;
}
try
{
FfiConverterTypeSimpleRec
.
checkType
(
fieldRec
)
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
fieldRec
"
)
;
}
throw
e
;
}
/
*
*
*
fieldU8
*
/
this
.
fieldU8
=
fieldU8
;
/
*
*
*
fieldI8
*
/
this
.
fieldI8
=
fieldI8
;
/
*
*
*
fieldU16
*
/
this
.
fieldU16
=
fieldU16
;
/
*
*
*
fieldI16
*
/
this
.
fieldI16
=
fieldI16
;
/
*
*
*
fieldU32
*
/
this
.
fieldU32
=
fieldU32
;
/
*
*
*
fieldI32
*
/
this
.
fieldI32
=
fieldI32
;
/
*
*
*
fieldU64
*
/
this
.
fieldU64
=
fieldU64
;
/
*
*
*
fieldI64
*
/
this
.
fieldI64
=
fieldI64
;
/
*
*
*
fieldF32
*
/
this
.
fieldF32
=
fieldF32
;
/
*
*
*
fieldF64
*
/
this
.
fieldF64
=
fieldF64
;
/
*
*
*
fieldString
*
/
this
.
fieldString
=
fieldString
;
/
*
*
*
fieldRec
*
/
this
.
fieldRec
=
fieldRec
;
}
equals
(
other
)
{
return
(
this
.
fieldU8
=
=
other
.
fieldU8
&
&
this
.
fieldI8
=
=
other
.
fieldI8
&
&
this
.
fieldU16
=
=
other
.
fieldU16
&
&
this
.
fieldI16
=
=
other
.
fieldI16
&
&
this
.
fieldU32
=
=
other
.
fieldU32
&
&
this
.
fieldI32
=
=
other
.
fieldI32
&
&
this
.
fieldU64
=
=
other
.
fieldU64
&
&
this
.
fieldI64
=
=
other
.
fieldI64
&
&
this
.
fieldF32
=
=
other
.
fieldF32
&
&
this
.
fieldF64
=
=
other
.
fieldF64
&
&
this
.
fieldString
=
=
other
.
fieldString
&
&
this
.
fieldRec
.
equals
(
other
.
fieldRec
)
)
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterTypeComplexRec
extends
FfiConverterArrayBuffer
{
static
read
(
dataStream
)
{
return
new
ComplexRec
(
{
fieldU8
:
FfiConverterUInt8
.
read
(
dataStream
)
fieldI8
:
FfiConverterInt8
.
read
(
dataStream
)
fieldU16
:
FfiConverterUInt16
.
read
(
dataStream
)
fieldI16
:
FfiConverterInt16
.
read
(
dataStream
)
fieldU32
:
FfiConverterUInt32
.
read
(
dataStream
)
fieldI32
:
FfiConverterInt32
.
read
(
dataStream
)
fieldU64
:
FfiConverterUInt64
.
read
(
dataStream
)
fieldI64
:
FfiConverterInt64
.
read
(
dataStream
)
fieldF32
:
FfiConverterFloat32
.
read
(
dataStream
)
fieldF64
:
FfiConverterFloat64
.
read
(
dataStream
)
fieldString
:
FfiConverterString
.
read
(
dataStream
)
fieldRec
:
FfiConverterTypeSimpleRec
.
read
(
dataStream
)
}
)
;
}
static
write
(
dataStream
value
)
{
FfiConverterUInt8
.
write
(
dataStream
value
.
fieldU8
)
;
FfiConverterInt8
.
write
(
dataStream
value
.
fieldI8
)
;
FfiConverterUInt16
.
write
(
dataStream
value
.
fieldU16
)
;
FfiConverterInt16
.
write
(
dataStream
value
.
fieldI16
)
;
FfiConverterUInt32
.
write
(
dataStream
value
.
fieldU32
)
;
FfiConverterInt32
.
write
(
dataStream
value
.
fieldI32
)
;
FfiConverterUInt64
.
write
(
dataStream
value
.
fieldU64
)
;
FfiConverterInt64
.
write
(
dataStream
value
.
fieldI64
)
;
FfiConverterFloat32
.
write
(
dataStream
value
.
fieldF32
)
;
FfiConverterFloat64
.
write
(
dataStream
value
.
fieldF64
)
;
FfiConverterString
.
write
(
dataStream
value
.
fieldString
)
;
FfiConverterTypeSimpleRec
.
write
(
dataStream
value
.
fieldRec
)
;
}
static
computeSize
(
value
)
{
let
totalSize
=
0
;
totalSize
+
=
FfiConverterUInt8
.
computeSize
(
value
.
fieldU8
)
;
totalSize
+
=
FfiConverterInt8
.
computeSize
(
value
.
fieldI8
)
;
totalSize
+
=
FfiConverterUInt16
.
computeSize
(
value
.
fieldU16
)
;
totalSize
+
=
FfiConverterInt16
.
computeSize
(
value
.
fieldI16
)
;
totalSize
+
=
FfiConverterUInt32
.
computeSize
(
value
.
fieldU32
)
;
totalSize
+
=
FfiConverterInt32
.
computeSize
(
value
.
fieldI32
)
;
totalSize
+
=
FfiConverterUInt64
.
computeSize
(
value
.
fieldU64
)
;
totalSize
+
=
FfiConverterInt64
.
computeSize
(
value
.
fieldI64
)
;
totalSize
+
=
FfiConverterFloat32
.
computeSize
(
value
.
fieldF32
)
;
totalSize
+
=
FfiConverterFloat64
.
computeSize
(
value
.
fieldF64
)
;
totalSize
+
=
FfiConverterString
.
computeSize
(
value
.
fieldString
)
;
totalSize
+
=
FfiConverterTypeSimpleRec
.
computeSize
(
value
.
fieldRec
)
;
return
totalSize
}
static
checkType
(
value
)
{
super
.
checkType
(
value
)
;
if
(
!
(
value
instanceof
ComplexRec
)
)
{
throw
new
UniFFITypeError
(
Expected
'
ComplexRec
'
found
'
{
typeof
value
}
'
)
;
}
try
{
FfiConverterUInt8
.
checkType
(
value
.
fieldU8
)
;
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
.
fieldU8
"
)
;
}
throw
e
;
}
try
{
FfiConverterInt8
.
checkType
(
value
.
fieldI8
)
;
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
.
fieldI8
"
)
;
}
throw
e
;
}
try
{
FfiConverterUInt16
.
checkType
(
value
.
fieldU16
)
;
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
.
fieldU16
"
)
;
}
throw
e
;
}
try
{
FfiConverterInt16
.
checkType
(
value
.
fieldI16
)
;
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
.
fieldI16
"
)
;
}
throw
e
;
}
try
{
FfiConverterUInt32
.
checkType
(
value
.
fieldU32
)
;
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
.
fieldU32
"
)
;
}
throw
e
;
}
try
{
FfiConverterInt32
.
checkType
(
value
.
fieldI32
)
;
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
.
fieldI32
"
)
;
}
throw
e
;
}
try
{
FfiConverterUInt64
.
checkType
(
value
.
fieldU64
)
;
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
.
fieldU64
"
)
;
}
throw
e
;
}
try
{
FfiConverterInt64
.
checkType
(
value
.
fieldI64
)
;
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
.
fieldI64
"
)
;
}
throw
e
;
}
try
{
FfiConverterFloat32
.
checkType
(
value
.
fieldF32
)
;
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
.
fieldF32
"
)
;
}
throw
e
;
}
try
{
FfiConverterFloat64
.
checkType
(
value
.
fieldF64
)
;
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
.
fieldF64
"
)
;
}
throw
e
;
}
try
{
FfiConverterString
.
checkType
(
value
.
fieldString
)
;
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
.
fieldString
"
)
;
}
throw
e
;
}
try
{
FfiConverterTypeSimpleRec
.
checkType
(
value
.
fieldRec
)
;
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
.
fieldRec
"
)
;
}
throw
e
;
}
}
}
/
*
*
*
RecWithDefault
*
/
export
class
RecWithDefault
{
constructor
(
{
a
=
42
}
=
{
a
:
undefined
}
)
{
try
{
FfiConverterUInt8
.
checkType
(
a
)
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
a
"
)
;
}
throw
e
;
}
/
*
*
*
a
*
/
this
.
a
=
a
;
}
equals
(
other
)
{
return
(
this
.
a
=
=
other
.
a
)
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterTypeRecWithDefault
extends
FfiConverterArrayBuffer
{
static
read
(
dataStream
)
{
return
new
RecWithDefault
(
{
a
:
FfiConverterUInt8
.
read
(
dataStream
)
}
)
;
}
static
write
(
dataStream
value
)
{
FfiConverterUInt8
.
write
(
dataStream
value
.
a
)
;
}
static
computeSize
(
value
)
{
let
totalSize
=
0
;
totalSize
+
=
FfiConverterUInt8
.
computeSize
(
value
.
a
)
;
return
totalSize
}
static
checkType
(
value
)
{
super
.
checkType
(
value
)
;
if
(
!
(
value
instanceof
RecWithDefault
)
)
{
throw
new
UniFFITypeError
(
Expected
'
RecWithDefault
'
found
'
{
typeof
value
}
'
)
;
}
try
{
FfiConverterUInt8
.
checkType
(
value
.
a
)
;
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
.
a
"
)
;
}
throw
e
;
}
}
}
/
*
*
*
TestInterface
*
/
export
class
TestInterface
{
/
/
Use
init
to
instantiate
this
class
.
/
/
DO
NOT
USE
THIS
CONSTRUCTOR
DIRECTLY
constructor
(
opts
)
{
if
(
!
Object
.
prototype
.
hasOwnProperty
.
call
(
opts
constructUniffiObject
)
)
{
throw
new
UniFFIError
(
"
Attempting
to
construct
an
int
using
the
JavaScript
constructor
directly
"
+
"
Please
use
a
UDL
defined
constructor
or
the
init
function
for
the
primary
constructor
"
)
}
if
(
!
(
opts
[
constructUniffiObject
]
instanceof
UniFFIPointer
)
)
{
throw
new
UniFFIError
(
"
Attempting
to
create
a
UniFFI
object
with
a
pointer
that
is
not
an
instance
of
UniFFIPointer
"
)
}
this
[
uniffiObjectPtr
]
=
opts
[
constructUniffiObject
]
;
}
static
init
(
value
)
{
FfiConverterUInt32
.
checkType
(
value
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
155
/
/
uniffi_uniffi_bindings_tests_fn_constructor_testinterface_new
FfiConverterUInt32
.
lower
(
value
)
)
return
handleRustResult
(
result
FfiConverterTypeTestInterface
.
lift
.
bind
(
FfiConverterTypeTestInterface
)
null
)
}
/
*
*
*
getValue
*
/
getValue
(
)
{
const
result
=
UniFFIScaffolding
.
callSync
(
156
/
/
uniffi_uniffi_bindings_tests_fn_method_testinterface_get_value
FfiConverterTypeTestInterface
.
lower
(
this
)
)
return
handleRustResult
(
result
FfiConverterUInt32
.
lift
.
bind
(
FfiConverterUInt32
)
null
)
}
/
*
*
*
Get
the
current
reference
count
for
this
object
*
*
The
count
does
not
include
the
extra
reference
needed
to
call
this
method
.
*
/
refCount
(
)
{
const
result
=
UniFFIScaffolding
.
callSync
(
157
/
/
uniffi_uniffi_bindings_tests_fn_method_testinterface_ref_count
FfiConverterTypeTestInterface
.
lower
(
this
)
)
return
handleRustResult
(
result
FfiConverterUInt32
.
lift
.
bind
(
FfiConverterUInt32
)
null
)
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterTypeTestInterface
extends
FfiConverter
{
static
lift
(
value
)
{
const
opts
=
{
}
;
opts
[
constructUniffiObject
]
=
value
;
return
new
TestInterface
(
opts
)
;
}
static
lower
(
value
)
{
const
ptr
=
value
[
uniffiObjectPtr
]
;
if
(
!
(
ptr
instanceof
UniFFIPointer
)
)
{
throw
new
UniFFITypeError
(
"
Object
is
not
a
'
TestInterface
'
instance
"
)
;
}
return
ptr
;
}
static
read
(
dataStream
)
{
return
this
.
lift
(
dataStream
.
readPointer
(
14
)
)
;
}
static
write
(
dataStream
value
)
{
dataStream
.
writePointer
(
14
this
.
lower
(
value
)
)
;
}
static
computeSize
(
value
)
{
return
8
;
}
}
/
*
*
*
TwoTestInterfaces
*
/
export
class
TwoTestInterfaces
{
constructor
(
{
first
second
}
=
{
first
:
undefined
second
:
undefined
}
)
{
try
{
FfiConverterTypeTestInterface
.
checkType
(
first
)
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
first
"
)
;
}
throw
e
;
}
try
{
FfiConverterTypeTestInterface
.
checkType
(
second
)
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
second
"
)
;
}
throw
e
;
}
/
*
*
*
first
*
/
this
.
first
=
first
;
/
*
*
*
second
*
/
this
.
second
=
second
;
}
equals
(
other
)
{
return
(
this
.
first
=
=
other
.
first
&
&
this
.
second
=
=
other
.
second
)
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterTypeTwoTestInterfaces
extends
FfiConverterArrayBuffer
{
static
read
(
dataStream
)
{
return
new
TwoTestInterfaces
(
{
first
:
FfiConverterTypeTestInterface
.
read
(
dataStream
)
second
:
FfiConverterTypeTestInterface
.
read
(
dataStream
)
}
)
;
}
static
write
(
dataStream
value
)
{
FfiConverterTypeTestInterface
.
write
(
dataStream
value
.
first
)
;
FfiConverterTypeTestInterface
.
write
(
dataStream
value
.
second
)
;
}
static
computeSize
(
value
)
{
let
totalSize
=
0
;
totalSize
+
=
FfiConverterTypeTestInterface
.
computeSize
(
value
.
first
)
;
totalSize
+
=
FfiConverterTypeTestInterface
.
computeSize
(
value
.
second
)
;
return
totalSize
}
static
checkType
(
value
)
{
super
.
checkType
(
value
)
;
if
(
!
(
value
instanceof
TwoTestInterfaces
)
)
{
throw
new
UniFFITypeError
(
Expected
'
TwoTestInterfaces
'
found
'
{
typeof
value
}
'
)
;
}
try
{
FfiConverterTypeTestInterface
.
checkType
(
value
.
first
)
;
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
.
first
"
)
;
}
throw
e
;
}
try
{
FfiConverterTypeTestInterface
.
checkType
(
value
.
second
)
;
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
.
second
"
)
;
}
throw
e
;
}
}
}
/
*
*
*
EnumNoData
*
/
export
const
EnumNoData
=
{
/
*
*
*
A
*
/
A
:
0
/
*
*
*
B
*
/
B
:
1
/
*
*
*
C
*
/
C
:
2
}
;
Object
.
freeze
(
EnumNoData
)
;
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterTypeEnumNoData
extends
FfiConverterArrayBuffer
{
static
read
(
dataStream
)
{
/
/
Use
sequential
indices
(
1
-
based
)
for
the
wire
format
to
match
the
Rust
scaffolding
switch
(
dataStream
.
readInt32
(
)
)
{
case
1
:
return
EnumNoData
.
A
case
2
:
return
EnumNoData
.
B
case
3
:
return
EnumNoData
.
C
default
:
throw
new
UniFFITypeError
(
"
Unknown
EnumNoData
variant
"
)
;
}
}
static
write
(
dataStream
value
)
{
/
/
Use
sequential
indices
(
1
-
based
)
for
the
wire
format
to
match
the
Rust
scaffolding
if
(
value
=
=
=
EnumNoData
.
A
)
{
dataStream
.
writeInt32
(
1
)
;
return
;
}
if
(
value
=
=
=
EnumNoData
.
B
)
{
dataStream
.
writeInt32
(
2
)
;
return
;
}
if
(
value
=
=
=
EnumNoData
.
C
)
{
dataStream
.
writeInt32
(
3
)
;
return
;
}
throw
new
UniFFITypeError
(
"
Unknown
EnumNoData
variant
"
)
;
}
static
computeSize
(
value
)
{
return
4
;
}
static
checkType
(
value
)
{
if
(
!
Number
.
isInteger
(
value
)
|
|
value
<
1
|
|
value
>
3
)
{
throw
new
UniFFITypeError
(
{
value
}
is
not
a
valid
value
for
EnumNoData
)
;
}
}
}
/
*
*
*
EnumWithData
*
/
export
class
EnumWithData
{
}
/
*
*
*
A
*
/
EnumWithData
.
A
=
class
extends
EnumWithData
{
constructor
(
value
)
{
super
(
)
;
this
.
value
=
value
;
}
}
/
*
*
*
B
*
/
EnumWithData
.
B
=
class
extends
EnumWithData
{
constructor
(
value
)
{
super
(
)
;
this
.
value
=
value
;
}
}
/
*
*
*
C
*
/
EnumWithData
.
C
=
class
extends
EnumWithData
{
constructor
(
)
{
super
(
)
;
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterTypeEnumWithData
extends
FfiConverterArrayBuffer
{
static
read
(
dataStream
)
{
/
/
Use
sequential
indices
(
1
-
based
)
for
the
wire
format
to
match
the
Rust
scaffolding
switch
(
dataStream
.
readInt32
(
)
)
{
case
1
:
return
new
EnumWithData
.
A
(
FfiConverterUInt8
.
read
(
dataStream
)
)
;
case
2
:
return
new
EnumWithData
.
B
(
FfiConverterString
.
read
(
dataStream
)
)
;
case
3
:
return
new
EnumWithData
.
C
(
)
;
default
:
throw
new
UniFFITypeError
(
"
Unknown
EnumWithData
variant
"
)
;
}
}
static
write
(
dataStream
value
)
{
/
/
Use
sequential
indices
(
1
-
based
)
for
the
wire
format
to
match
the
Rust
scaffolding
if
(
value
instanceof
EnumWithData
.
A
)
{
dataStream
.
writeInt32
(
1
)
;
FfiConverterUInt8
.
write
(
dataStream
value
.
value
)
;
return
;
}
if
(
value
instanceof
EnumWithData
.
B
)
{
dataStream
.
writeInt32
(
2
)
;
FfiConverterString
.
write
(
dataStream
value
.
value
)
;
return
;
}
if
(
value
instanceof
EnumWithData
.
C
)
{
dataStream
.
writeInt32
(
3
)
;
return
;
}
throw
new
UniFFITypeError
(
"
Unknown
EnumWithData
variant
"
)
;
}
static
computeSize
(
value
)
{
/
/
Size
of
the
Int
indicating
the
variant
let
totalSize
=
4
;
if
(
value
instanceof
EnumWithData
.
A
)
{
totalSize
+
=
FfiConverterUInt8
.
computeSize
(
value
.
value
)
;
return
totalSize
;
}
if
(
value
instanceof
EnumWithData
.
B
)
{
totalSize
+
=
FfiConverterString
.
computeSize
(
value
.
value
)
;
return
totalSize
;
}
if
(
value
instanceof
EnumWithData
.
C
)
{
return
totalSize
;
}
throw
new
UniFFITypeError
(
"
Unknown
EnumWithData
variant
"
)
;
}
static
checkType
(
value
)
{
if
(
!
(
value
instanceof
EnumWithData
)
)
{
throw
new
UniFFITypeError
(
{
value
}
is
not
a
subclass
instance
of
EnumWithData
)
;
}
}
}
/
*
*
*
ComplexEnum
*
/
export
class
ComplexEnum
{
}
/
*
*
*
A
*
/
ComplexEnum
.
A
=
class
extends
ComplexEnum
{
constructor
(
value
)
{
super
(
)
;
this
.
value
=
value
;
}
}
/
*
*
*
B
*
/
ComplexEnum
.
B
=
class
extends
ComplexEnum
{
constructor
(
value
)
{
super
(
)
;
this
.
value
=
value
;
}
}
/
*
*
*
C
*
/
ComplexEnum
.
C
=
class
extends
ComplexEnum
{
constructor
(
value
)
{
super
(
)
;
this
.
value
=
value
;
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterTypeComplexEnum
extends
FfiConverterArrayBuffer
{
static
read
(
dataStream
)
{
/
/
Use
sequential
indices
(
1
-
based
)
for
the
wire
format
to
match
the
Rust
scaffolding
switch
(
dataStream
.
readInt32
(
)
)
{
case
1
:
return
new
ComplexEnum
.
A
(
FfiConverterTypeEnumNoData
.
read
(
dataStream
)
)
;
case
2
:
return
new
ComplexEnum
.
B
(
FfiConverterTypeEnumWithData
.
read
(
dataStream
)
)
;
case
3
:
return
new
ComplexEnum
.
C
(
FfiConverterTypeSimpleRec
.
read
(
dataStream
)
)
;
default
:
throw
new
UniFFITypeError
(
"
Unknown
ComplexEnum
variant
"
)
;
}
}
static
write
(
dataStream
value
)
{
/
/
Use
sequential
indices
(
1
-
based
)
for
the
wire
format
to
match
the
Rust
scaffolding
if
(
value
instanceof
ComplexEnum
.
A
)
{
dataStream
.
writeInt32
(
1
)
;
FfiConverterTypeEnumNoData
.
write
(
dataStream
value
.
value
)
;
return
;
}
if
(
value
instanceof
ComplexEnum
.
B
)
{
dataStream
.
writeInt32
(
2
)
;
FfiConverterTypeEnumWithData
.
write
(
dataStream
value
.
value
)
;
return
;
}
if
(
value
instanceof
ComplexEnum
.
C
)
{
dataStream
.
writeInt32
(
3
)
;
FfiConverterTypeSimpleRec
.
write
(
dataStream
value
.
value
)
;
return
;
}
throw
new
UniFFITypeError
(
"
Unknown
ComplexEnum
variant
"
)
;
}
static
computeSize
(
value
)
{
/
/
Size
of
the
Int
indicating
the
variant
let
totalSize
=
4
;
if
(
value
instanceof
ComplexEnum
.
A
)
{
totalSize
+
=
FfiConverterTypeEnumNoData
.
computeSize
(
value
.
value
)
;
return
totalSize
;
}
if
(
value
instanceof
ComplexEnum
.
B
)
{
totalSize
+
=
FfiConverterTypeEnumWithData
.
computeSize
(
value
.
value
)
;
return
totalSize
;
}
if
(
value
instanceof
ComplexEnum
.
C
)
{
totalSize
+
=
FfiConverterTypeSimpleRec
.
computeSize
(
value
.
value
)
;
return
totalSize
;
}
throw
new
UniFFITypeError
(
"
Unknown
ComplexEnum
variant
"
)
;
}
static
checkType
(
value
)
{
if
(
!
(
value
instanceof
ComplexEnum
)
)
{
throw
new
UniFFITypeError
(
{
value
}
is
not
a
subclass
instance
of
ComplexEnum
)
;
}
}
}
/
*
*
*
ExplicitValuedEnum
*
/
export
const
ExplicitValuedEnum
=
{
/
*
*
*
FIRST
*
/
FIRST
:
1
/
*
*
*
SECOND
*
/
SECOND
:
2
/
*
*
*
FOURTH
*
/
FOURTH
:
4
/
*
*
*
TENTH
*
/
TENTH
:
10
/
*
*
*
ELEVENTH
*
/
ELEVENTH
:
11
/
*
*
*
THIRTEENTH
*
/
THIRTEENTH
:
13
}
;
Object
.
freeze
(
ExplicitValuedEnum
)
;
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterTypeExplicitValuedEnum
extends
FfiConverterArrayBuffer
{
static
read
(
dataStream
)
{
/
/
Use
sequential
indices
(
1
-
based
)
for
the
wire
format
to
match
the
Rust
scaffolding
switch
(
dataStream
.
readInt32
(
)
)
{
case
1
:
return
ExplicitValuedEnum
.
FIRST
case
2
:
return
ExplicitValuedEnum
.
SECOND
case
3
:
return
ExplicitValuedEnum
.
FOURTH
case
4
:
return
ExplicitValuedEnum
.
TENTH
case
5
:
return
ExplicitValuedEnum
.
ELEVENTH
case
6
:
return
ExplicitValuedEnum
.
THIRTEENTH
default
:
throw
new
UniFFITypeError
(
"
Unknown
ExplicitValuedEnum
variant
"
)
;
}
}
static
write
(
dataStream
value
)
{
/
/
Use
sequential
indices
(
1
-
based
)
for
the
wire
format
to
match
the
Rust
scaffolding
if
(
value
=
=
=
ExplicitValuedEnum
.
FIRST
)
{
dataStream
.
writeInt32
(
1
)
;
return
;
}
if
(
value
=
=
=
ExplicitValuedEnum
.
SECOND
)
{
dataStream
.
writeInt32
(
2
)
;
return
;
}
if
(
value
=
=
=
ExplicitValuedEnum
.
FOURTH
)
{
dataStream
.
writeInt32
(
3
)
;
return
;
}
if
(
value
=
=
=
ExplicitValuedEnum
.
TENTH
)
{
dataStream
.
writeInt32
(
4
)
;
return
;
}
if
(
value
=
=
=
ExplicitValuedEnum
.
ELEVENTH
)
{
dataStream
.
writeInt32
(
5
)
;
return
;
}
if
(
value
=
=
=
ExplicitValuedEnum
.
THIRTEENTH
)
{
dataStream
.
writeInt32
(
6
)
;
return
;
}
throw
new
UniFFITypeError
(
"
Unknown
ExplicitValuedEnum
variant
"
)
;
}
static
computeSize
(
value
)
{
return
4
;
}
static
checkType
(
value
)
{
if
(
!
Number
.
isInteger
(
value
)
|
|
value
<
1
|
|
value
>
6
)
{
throw
new
UniFFITypeError
(
{
value
}
is
not
a
valid
value
for
ExplicitValuedEnum
)
;
}
}
}
/
*
*
*
GappedEnum
*
/
export
const
GappedEnum
=
{
/
*
*
*
ONE
*
/
ONE
:
10
/
*
*
*
TWO
*
/
TWO
:
11
/
*
*
*
THREE
*
/
THREE
:
14
}
;
Object
.
freeze
(
GappedEnum
)
;
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterTypeGappedEnum
extends
FfiConverterArrayBuffer
{
static
read
(
dataStream
)
{
/
/
Use
sequential
indices
(
1
-
based
)
for
the
wire
format
to
match
the
Rust
scaffolding
switch
(
dataStream
.
readInt32
(
)
)
{
case
1
:
return
GappedEnum
.
ONE
case
2
:
return
GappedEnum
.
TWO
case
3
:
return
GappedEnum
.
THREE
default
:
throw
new
UniFFITypeError
(
"
Unknown
GappedEnum
variant
"
)
;
}
}
static
write
(
dataStream
value
)
{
/
/
Use
sequential
indices
(
1
-
based
)
for
the
wire
format
to
match
the
Rust
scaffolding
if
(
value
=
=
=
GappedEnum
.
ONE
)
{
dataStream
.
writeInt32
(
1
)
;
return
;
}
if
(
value
=
=
=
GappedEnum
.
TWO
)
{
dataStream
.
writeInt32
(
2
)
;
return
;
}
if
(
value
=
=
=
GappedEnum
.
THREE
)
{
dataStream
.
writeInt32
(
3
)
;
return
;
}
throw
new
UniFFITypeError
(
"
Unknown
GappedEnum
variant
"
)
;
}
static
computeSize
(
value
)
{
return
4
;
}
static
checkType
(
value
)
{
if
(
!
Number
.
isInteger
(
value
)
|
|
value
<
1
|
|
value
>
3
)
{
throw
new
UniFFITypeError
(
{
value
}
is
not
a
valid
value
for
GappedEnum
)
;
}
}
}
/
*
*
*
Error
enum
*
/
export
class
TestError
extends
Error
{
}
/
*
*
*
Failure1
*
/
export
class
Failure1
extends
TestError
{
constructor
(
.
.
.
params
)
{
super
(
.
.
.
params
)
;
}
toString
(
)
{
return
Failure1
:
{
super
.
toString
(
)
}
}
}
/
*
*
*
Failure2
*
/
export
class
Failure2
extends
TestError
{
constructor
(
data
.
.
.
params
)
{
const
message
=
data
:
{
data
}
;
super
(
message
.
.
.
params
)
;
this
.
data
=
data
;
}
toString
(
)
{
return
Failure2
:
{
super
.
toString
(
)
}
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterTypeTestError
extends
FfiConverterArrayBuffer
{
static
read
(
dataStream
)
{
switch
(
dataStream
.
readInt32
(
)
)
{
case
1
:
return
new
Failure1
(
)
;
case
2
:
return
new
Failure2
(
FfiConverterString
.
read
(
dataStream
)
)
;
default
:
throw
new
UniFFITypeError
(
"
Unknown
TestError
variant
"
)
;
}
}
static
computeSize
(
value
)
{
/
/
Size
of
the
Int
indicating
the
variant
let
totalSize
=
4
;
if
(
value
instanceof
Failure1
)
{
return
totalSize
;
}
if
(
value
instanceof
Failure2
)
{
totalSize
+
=
FfiConverterString
.
computeSize
(
value
.
data
)
;
return
totalSize
;
}
throw
new
UniFFITypeError
(
"
Unknown
TestError
variant
"
)
;
}
static
write
(
dataStream
value
)
{
if
(
value
instanceof
Failure1
)
{
dataStream
.
writeInt32
(
1
)
;
return
;
}
if
(
value
instanceof
Failure2
)
{
dataStream
.
writeInt32
(
2
)
;
FfiConverterString
.
write
(
dataStream
value
.
data
)
;
return
;
}
throw
new
UniFFITypeError
(
"
Unknown
TestError
variant
"
)
;
}
static
errorClass
=
TestError
;
}
/
*
*
*
Flat
error
enum
*
*
The
associated
data
for
this
won
'
t
be
across
the
FFI
.
Flat
errors
are
mostly
just
a
historical
*
artifact
but
there
are
some
use
-
cases
for
them
-
-
for
example
variants
that
wrap
errors
from
*
other
crates
.
*
/
export
class
TestFlatError
extends
Error
{
}
/
*
*
*
Here
'
s
an
example
of
a
variant
that
only
works
with
a
flat
error
io
:
:
Error
is
not
*
UniFFI
compatible
and
can
'
t
be
passed
across
the
FFI
.
*
/
export
class
IoError
extends
TestFlatError
{
constructor
(
message
.
.
.
params
)
{
super
(
.
.
.
params
)
;
this
.
message
=
message
;
}
toString
(
)
{
return
IoError
:
{
super
.
toString
(
)
}
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterTypeTestFlatError
extends
FfiConverterArrayBuffer
{
static
read
(
dataStream
)
{
switch
(
dataStream
.
readInt32
(
)
)
{
case
1
:
return
new
IoError
(
FfiConverterString
.
read
(
dataStream
)
)
;
default
:
throw
new
UniFFITypeError
(
"
Unknown
TestFlatError
variant
"
)
;
}
}
static
computeSize
(
value
)
{
/
/
Size
of
the
Int
indicating
the
variant
let
totalSize
=
4
;
if
(
value
instanceof
IoError
)
{
return
totalSize
;
}
throw
new
UniFFITypeError
(
"
Unknown
TestFlatError
variant
"
)
;
}
static
write
(
dataStream
value
)
{
if
(
value
instanceof
IoError
)
{
dataStream
.
writeInt32
(
1
)
;
return
;
}
throw
new
UniFFITypeError
(
"
Unknown
TestFlatError
variant
"
)
;
}
static
errorClass
=
TestFlatError
;
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterTypeHandle
extends
FfiConverter
{
static
lift
(
buf
)
{
return
FfiConverterUInt64
.
lift
(
buf
)
;
}
static
lower
(
buf
)
{
return
FfiConverterUInt64
.
lower
(
buf
)
;
}
static
write
(
dataStream
value
)
{
FfiConverterUInt64
.
write
(
dataStream
value
)
;
}
static
read
(
buf
)
{
return
FfiConverterUInt64
.
read
(
buf
)
;
}
static
computeSize
(
value
)
{
return
FfiConverterUInt64
.
computeSize
(
value
)
;
}
}
/
/
TODO
:
We
should
also
allow
JS
to
customize
the
type
eventually
.
/
*
*
*
AsyncInterface
*
/
export
class
AsyncInterface
{
/
/
Use
init
to
instantiate
this
class
.
/
/
DO
NOT
USE
THIS
CONSTRUCTOR
DIRECTLY
constructor
(
opts
)
{
if
(
!
Object
.
prototype
.
hasOwnProperty
.
call
(
opts
constructUniffiObject
)
)
{
throw
new
UniFFIError
(
"
Attempting
to
construct
an
int
using
the
JavaScript
constructor
directly
"
+
"
Please
use
a
UDL
defined
constructor
or
the
init
function
for
the
primary
constructor
"
)
}
if
(
!
(
opts
[
constructUniffiObject
]
instanceof
UniFFIPointer
)
)
{
throw
new
UniFFIError
(
"
Attempting
to
create
a
UniFFI
object
with
a
pointer
that
is
not
an
instance
of
UniFFIPointer
"
)
}
this
[
uniffiObjectPtr
]
=
opts
[
constructUniffiObject
]
;
}
static
init
(
name
)
{
FfiConverterString
.
checkType
(
name
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
158
/
/
uniffi_uniffi_bindings_tests_fn_constructor_asyncinterface_new
FfiConverterString
.
lower
(
name
)
)
return
handleRustResult
(
result
FfiConverterTypeAsyncInterface
.
lift
.
bind
(
FfiConverterTypeAsyncInterface
)
null
)
}
/
*
*
*
name
*
/
async
name
(
)
{
const
result
=
await
UniFFIScaffolding
.
callAsync
(
159
/
/
uniffi_uniffi_bindings_tests_fn_method_asyncinterface_name
FfiConverterTypeAsyncInterface
.
lower
(
this
)
)
return
handleRustResult
(
result
FfiConverterString
.
lift
.
bind
(
FfiConverterString
)
null
)
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterTypeAsyncInterface
extends
FfiConverter
{
static
lift
(
value
)
{
const
opts
=
{
}
;
opts
[
constructUniffiObject
]
=
value
;
return
new
AsyncInterface
(
opts
)
;
}
static
lower
(
value
)
{
const
ptr
=
value
[
uniffiObjectPtr
]
;
if
(
!
(
ptr
instanceof
UniFFIPointer
)
)
{
throw
new
UniFFITypeError
(
"
Object
is
not
a
'
AsyncInterface
'
instance
"
)
;
}
return
ptr
;
}
static
read
(
dataStream
)
{
return
this
.
lift
(
dataStream
.
readPointer
(
15
)
)
;
}
static
write
(
dataStream
value
)
{
dataStream
.
writePointer
(
15
this
.
lower
(
value
)
)
;
}
static
computeSize
(
value
)
{
return
8
;
}
}
/
*
*
*
ComplexMethods
*
/
export
class
ComplexMethods
{
/
/
Use
init
to
instantiate
this
class
.
/
/
DO
NOT
USE
THIS
CONSTRUCTOR
DIRECTLY
constructor
(
opts
)
{
if
(
!
Object
.
prototype
.
hasOwnProperty
.
call
(
opts
constructUniffiObject
)
)
{
throw
new
UniFFIError
(
"
Attempting
to
construct
an
int
using
the
JavaScript
constructor
directly
"
+
"
Please
use
a
UDL
defined
constructor
or
the
init
function
for
the
primary
constructor
"
)
}
if
(
!
(
opts
[
constructUniffiObject
]
instanceof
UniFFIPointer
)
)
{
throw
new
UniFFIError
(
"
Attempting
to
create
a
UniFFI
object
with
a
pointer
that
is
not
an
instance
of
UniFFIPointer
"
)
}
this
[
uniffiObjectPtr
]
=
opts
[
constructUniffiObject
]
;
}
static
init
(
)
{
const
result
=
UniFFIScaffolding
.
callSync
(
160
/
/
uniffi_uniffi_bindings_tests_fn_constructor_complexmethods_new
)
return
handleRustResult
(
result
FfiConverterTypeComplexMethods
.
lift
.
bind
(
FfiConverterTypeComplexMethods
)
null
)
}
/
*
*
*
methodWithDefault
*
/
methodWithDefault
(
arg
=
"
DEFAULT
"
)
{
FfiConverterString
.
checkType
(
arg
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
161
/
/
uniffi_uniffi_bindings_tests_fn_method_complexmethods_method_with_default
FfiConverterTypeComplexMethods
.
lower
(
this
)
FfiConverterString
.
lower
(
arg
)
)
return
handleRustResult
(
result
FfiConverterString
.
lift
.
bind
(
FfiConverterString
)
null
)
}
/
*
*
*
methodWithMultiWordArg
*
/
methodWithMultiWordArg
(
theArgument
)
{
FfiConverterString
.
checkType
(
theArgument
)
;
const
result
=
UniFFIScaffolding
.
callSync
(
162
/
/
uniffi_uniffi_bindings_tests_fn_method_complexmethods_method_with_multi_word_arg
FfiConverterTypeComplexMethods
.
lower
(
this
)
FfiConverterString
.
lower
(
theArgument
)
)
return
handleRustResult
(
result
FfiConverterString
.
lift
.
bind
(
FfiConverterString
)
null
)
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterTypeComplexMethods
extends
FfiConverter
{
static
lift
(
value
)
{
const
opts
=
{
}
;
opts
[
constructUniffiObject
]
=
value
;
return
new
ComplexMethods
(
opts
)
;
}
static
lower
(
value
)
{
const
ptr
=
value
[
uniffiObjectPtr
]
;
if
(
!
(
ptr
instanceof
UniFFIPointer
)
)
{
throw
new
UniFFITypeError
(
"
Object
is
not
a
'
ComplexMethods
'
instance
"
)
;
}
return
ptr
;
}
static
read
(
dataStream
)
{
return
this
.
lift
(
dataStream
.
readPointer
(
16
)
)
;
}
static
write
(
dataStream
value
)
{
dataStream
.
writePointer
(
16
this
.
lower
(
value
)
)
;
}
static
computeSize
(
value
)
{
return
8
;
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterTypeTestCallbackInterface
extends
FfiConverter
{
static
lower
(
callbackObj
)
{
return
uniffiCallbackHandlerTestCallbackInterface
.
storeCallbackObj
(
callbackObj
)
}
static
lift
(
handleId
)
{
return
uniffiCallbackHandlerTestCallbackInterface
.
getCallbackObj
(
handleId
)
}
static
read
(
dataStream
)
{
return
this
.
lift
(
dataStream
.
readInt64
(
)
)
}
static
write
(
dataStream
callbackObj
)
{
dataStream
.
writeInt64
(
this
.
lower
(
callbackObj
)
)
}
static
computeSize
(
callbackObj
)
{
return
8
;
}
}
const
uniffiCallbackHandlerTestCallbackInterface
=
new
UniFFICallbackHandler
(
"
TestCallbackInterface
"
3
[
new
UniFFICallbackMethodHandler
(
"
getValue
"
[
]
)
]
)
;
/
/
Allow
the
shutdown
-
related
functionality
to
be
tested
in
the
unit
tests
UnitTestObjs
.
uniffiCallbackHandlerTestCallbackInterface
=
uniffiCallbackHandlerTestCallbackInterface
;
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterMapStringString
extends
FfiConverterArrayBuffer
{
static
read
(
dataStream
)
{
const
len
=
dataStream
.
readInt32
(
)
;
const
map
=
new
Map
(
)
;
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
const
key
=
FfiConverterString
.
read
(
dataStream
)
;
const
value
=
FfiConverterString
.
read
(
dataStream
)
;
map
.
set
(
key
value
)
;
}
return
map
;
}
static
write
(
dataStream
map
)
{
dataStream
.
writeInt32
(
map
.
size
)
;
for
(
const
[
key
value
]
of
map
)
{
FfiConverterString
.
write
(
dataStream
key
)
;
FfiConverterString
.
write
(
dataStream
value
)
;
}
}
static
computeSize
(
map
)
{
/
/
The
size
of
the
length
let
size
=
4
;
for
(
const
[
key
value
]
of
map
)
{
size
+
=
FfiConverterString
.
computeSize
(
key
)
;
size
+
=
FfiConverterString
.
computeSize
(
value
)
;
}
return
size
;
}
static
checkType
(
map
)
{
for
(
const
[
key
value
]
of
map
)
{
try
{
FfiConverterString
.
checkType
(
key
)
;
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
(
key
)
"
)
;
}
throw
e
;
}
try
{
FfiConverterString
.
checkType
(
value
)
;
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
[
{
key
}
]
)
;
}
throw
e
;
}
}
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterSequenceUInt32
extends
FfiConverterArrayBuffer
{
static
read
(
dataStream
)
{
const
len
=
dataStream
.
readInt32
(
)
;
const
arr
=
[
]
;
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
arr
.
push
(
FfiConverterUInt32
.
read
(
dataStream
)
)
;
}
return
arr
;
}
static
write
(
dataStream
value
)
{
dataStream
.
writeInt32
(
value
.
length
)
;
value
.
forEach
(
(
innerValue
)
=
>
{
FfiConverterUInt32
.
write
(
dataStream
innerValue
)
;
}
)
}
static
computeSize
(
value
)
{
/
/
The
size
of
the
length
let
size
=
4
;
for
(
const
innerValue
of
value
)
{
size
+
=
FfiConverterUInt32
.
computeSize
(
innerValue
)
;
}
return
size
;
}
static
checkType
(
value
)
{
if
(
!
Array
.
isArray
(
value
)
)
{
throw
new
UniFFITypeError
(
{
value
}
is
not
an
array
)
;
}
value
.
forEach
(
(
innerValue
idx
)
=
>
{
try
{
FfiConverterUInt32
.
checkType
(
innerValue
)
;
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
[
{
idx
}
]
)
;
}
throw
e
;
}
}
)
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterBoolean
extends
FfiConverter
{
static
computeSize
(
_value
)
{
return
1
;
}
static
lift
(
value
)
{
return
value
=
=
1
;
}
static
lower
(
value
)
{
if
(
value
)
{
return
1
;
}
else
{
return
0
;
}
}
static
write
(
dataStream
value
)
{
dataStream
.
writeUint8
(
this
.
lower
(
value
)
)
}
static
read
(
dataStream
)
{
return
this
.
lift
(
dataStream
.
readUint8
(
)
)
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterMapStringUInt32
extends
FfiConverterArrayBuffer
{
static
read
(
dataStream
)
{
const
len
=
dataStream
.
readInt32
(
)
;
const
map
=
new
Map
(
)
;
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
const
key
=
FfiConverterString
.
read
(
dataStream
)
;
const
value
=
FfiConverterUInt32
.
read
(
dataStream
)
;
map
.
set
(
key
value
)
;
}
return
map
;
}
static
write
(
dataStream
map
)
{
dataStream
.
writeInt32
(
map
.
size
)
;
for
(
const
[
key
value
]
of
map
)
{
FfiConverterString
.
write
(
dataStream
key
)
;
FfiConverterUInt32
.
write
(
dataStream
value
)
;
}
}
static
computeSize
(
map
)
{
/
/
The
size
of
the
length
let
size
=
4
;
for
(
const
[
key
value
]
of
map
)
{
size
+
=
FfiConverterString
.
computeSize
(
key
)
;
size
+
=
FfiConverterUInt32
.
computeSize
(
value
)
;
}
return
size
;
}
static
checkType
(
map
)
{
for
(
const
[
key
value
]
of
map
)
{
try
{
FfiConverterString
.
checkType
(
key
)
;
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
"
(
key
)
"
)
;
}
throw
e
;
}
try
{
FfiConverterUInt32
.
checkType
(
value
)
;
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
[
{
key
}
]
)
;
}
throw
e
;
}
}
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterSequenceMapStringUInt32
extends
FfiConverterArrayBuffer
{
static
read
(
dataStream
)
{
const
len
=
dataStream
.
readInt32
(
)
;
const
arr
=
[
]
;
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
arr
.
push
(
FfiConverterMapStringUInt32
.
read
(
dataStream
)
)
;
}
return
arr
;
}
static
write
(
dataStream
value
)
{
dataStream
.
writeInt32
(
value
.
length
)
;
value
.
forEach
(
(
innerValue
)
=
>
{
FfiConverterMapStringUInt32
.
write
(
dataStream
innerValue
)
;
}
)
}
static
computeSize
(
value
)
{
/
/
The
size
of
the
length
let
size
=
4
;
for
(
const
innerValue
of
value
)
{
size
+
=
FfiConverterMapStringUInt32
.
computeSize
(
innerValue
)
;
}
return
size
;
}
static
checkType
(
value
)
{
if
(
!
Array
.
isArray
(
value
)
)
{
throw
new
UniFFITypeError
(
{
value
}
is
not
an
array
)
;
}
value
.
forEach
(
(
innerValue
idx
)
=
>
{
try
{
FfiConverterMapStringUInt32
.
checkType
(
innerValue
)
;
}
catch
(
e
)
{
if
(
e
instanceof
UniFFITypeError
)
{
e
.
addItemDescriptionPart
(
[
{
idx
}
]
)
;
}
throw
e
;
}
}
)
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterOptionalSequenceMapStringUInt32
extends
FfiConverterArrayBuffer
{
static
checkType
(
value
)
{
if
(
value
!
=
=
undefined
&
&
value
!
=
=
null
)
{
FfiConverterSequenceMapStringUInt32
.
checkType
(
value
)
}
}
static
read
(
dataStream
)
{
const
code
=
dataStream
.
readUint8
(
0
)
;
switch
(
code
)
{
case
0
:
return
null
case
1
:
return
FfiConverterSequenceMapStringUInt32
.
read
(
dataStream
)
default
:
throw
new
UniFFIError
(
Unexpected
code
:
{
code
}
)
;
}
}
static
write
(
dataStream
value
)
{
if
(
value
=
=
=
null
|
|
value
=
=
=
undefined
)
{
dataStream
.
writeUint8
(
0
)
;
return
;
}
dataStream
.
writeUint8
(
1
)
;
FfiConverterSequenceMapStringUInt32
.
write
(
dataStream
value
)
}
static
computeSize
(
value
)
{
if
(
value
=
=
=
null
|
|
value
=
=
=
undefined
)
{
return
1
;
}
return
1
+
FfiConverterSequenceMapStringUInt32
.
computeSize
(
value
)
}
}
/
/
Export
the
FFIConverter
object
to
make
external
types
work
.
export
class
FfiConverterOptionalUInt32
extends
FfiConverterArrayBuffer
{
static
checkType
(
value
)
{
if
(
value
!
=
=
undefined
&
&
value
!
=
=
null
)
{
FfiConverterUInt32
.
checkType
(
value
)
}
}
static
read
(
dataStream
)
{
const
code
=
dataStream
.
readUint8
(
0
)
;
switch
(
code
)
{
case
0
:
return
null
case
1
:
return
FfiConverterUInt32
.
read
(
dataStream
)
default
:
throw
new
UniFFIError
(
Unexpected
code
:
{
code
}
)
;
}
}
static
write
(
dataStream
value
)
{
if
(
value
=
=
=
null
|
|
value
=
=
=
undefined
)
{
dataStream
.
writeUint8
(
0
)
;
return
;
}
dataStream
.
writeUint8
(
1
)
;
FfiConverterUInt32
.
write
(
dataStream
value
)
}
static
computeSize
(
value
)
{
if
(
value
=
=
=
null
|
|
value
=
=
=
undefined
)
{
return
1
;
}
return
1
+
FfiConverterUInt32
.
computeSize
(
value
)
}
}
