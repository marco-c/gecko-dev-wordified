<
?
xml
version
=
"
1
.
0
"
?
>
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
bindings
id
=
"
tabBindings
"
xmlns
=
"
http
:
/
/
www
.
mozilla
.
org
/
xbl
"
xmlns
:
xul
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
xmlns
:
xbl
=
"
http
:
/
/
www
.
mozilla
.
org
/
xbl
"
>
<
binding
id
=
"
tabs
"
extends
=
"
chrome
:
/
/
global
/
content
/
bindings
/
general
.
xml
#
basecontrol
"
>
<
content
>
<
xul
:
spacer
class
=
"
tabs
-
left
"
/
>
<
children
/
>
<
xul
:
spacer
class
=
"
tabs
-
right
"
flex
=
"
1
"
/
>
<
/
content
>
<
implementation
implements
=
"
nsIDOMXULSelectControlElement
nsIDOMXULRelatedElement
"
>
<
constructor
>
<
!
[
CDATA
[
if
(
!
this
.
hasAttribute
(
"
orient
"
)
)
this
.
setAttribute
(
"
orient
"
"
horizontal
"
)
;
if
(
this
.
tabbox
&
&
this
.
tabbox
.
hasAttribute
(
"
selectedIndex
"
)
)
{
let
selectedIndex
=
parseInt
(
this
.
tabbox
.
getAttribute
(
"
selectedIndex
"
)
)
;
this
.
selectedIndex
=
selectedIndex
>
0
?
selectedIndex
:
0
;
return
;
}
var
children
=
this
.
children
;
var
length
=
children
.
length
;
for
(
var
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
children
[
i
]
.
getAttribute
(
"
selected
"
)
=
=
"
true
"
)
{
this
.
selectedIndex
=
i
;
return
;
}
}
var
value
=
this
.
value
;
if
(
value
)
this
.
value
=
value
;
else
this
.
selectedIndex
=
0
;
]
]
>
<
/
constructor
>
<
property
name
=
"
allTabs
"
>
<
getter
>
return
this
.
children
;
<
/
getter
>
<
/
property
>
<
!
-
-
nsIDOMXULRelatedElement
-
-
>
<
method
name
=
"
getRelatedElement
"
>
<
parameter
name
=
"
aTabElm
"
/
>
<
body
>
<
!
[
CDATA
[
if
(
!
aTabElm
)
return
null
;
let
tabboxElm
=
this
.
tabbox
;
if
(
!
tabboxElm
)
return
null
;
let
tabpanelsElm
=
tabboxElm
.
tabpanels
;
if
(
!
tabpanelsElm
)
return
null
;
/
/
Get
linked
tab
panel
by
'
linkedpanel
'
attribute
on
the
given
tab
/
/
element
.
let
linkedPanelId
=
aTabElm
.
linkedPanel
;
if
(
linkedPanelId
)
{
let
ownerDoc
=
this
.
ownerDocument
;
/
/
XXX
bug
565858
:
if
XUL
tab
element
is
anonymous
element
then
/
/
suppose
linked
tab
panel
is
hosted
within
the
same
XBL
binding
/
/
and
search
it
by
ID
attribute
inside
an
anonymous
content
of
/
/
the
binding
.
This
is
not
robust
assumption
since
tab
elements
may
/
/
live
outside
a
tabbox
element
so
that
for
example
tab
elements
/
/
can
be
explicit
content
but
tab
panels
can
be
anonymous
.
let
bindingParent
=
ownerDoc
.
getBindingParent
(
aTabElm
)
;
if
(
bindingParent
)
return
ownerDoc
.
getAnonymousElementByAttribute
(
bindingParent
"
id
"
linkedPanelId
)
;
return
ownerDoc
.
getElementById
(
linkedPanelId
)
;
}
/
/
otherwise
linked
tabpanel
element
has
the
same
index
as
the
given
/
/
tab
element
.
let
tabElmIdx
=
this
.
getIndexOfItem
(
aTabElm
)
;
return
tabpanelsElm
.
children
[
tabElmIdx
]
;
]
]
>
<
/
body
>
<
/
method
>
<
!
-
-
nsIDOMXULSelectControlElement
-
-
>
<
property
name
=
"
itemCount
"
readonly
=
"
true
"
onget
=
"
return
this
.
children
.
length
"
/
>
<
property
name
=
"
value
"
onget
=
"
return
this
.
getAttribute
(
'
value
'
)
;
"
>
<
setter
>
<
!
[
CDATA
[
this
.
setAttribute
(
"
value
"
val
)
;
var
children
=
this
.
children
;
for
(
var
c
=
children
.
length
-
1
;
c
>
=
0
;
c
-
-
)
{
if
(
children
[
c
]
.
value
=
=
val
)
{
this
.
selectedIndex
=
c
;
break
;
}
}
return
val
;
]
]
>
<
/
setter
>
<
/
property
>
<
field
name
=
"
_tabbox
"
>
null
<
/
field
>
<
property
name
=
"
tabbox
"
readonly
=
"
true
"
>
<
getter
>
<
!
[
CDATA
[
/
/
Memoize
the
result
in
a
field
rather
than
replacing
this
property
/
/
so
that
it
can
be
reset
along
with
the
binding
.
if
(
this
.
_tabbox
)
{
return
this
.
_tabbox
;
}
let
parent
=
this
.
parentNode
;
while
(
parent
)
{
if
(
parent
.
localName
=
=
"
tabbox
"
)
{
break
;
}
parent
=
parent
.
parentNode
;
}
return
this
.
_tabbox
=
parent
;
]
]
>
<
/
getter
>
<
/
property
>
<
!
-
-
_tabbox
is
deprecated
it
exists
only
for
backwards
compatibility
.
-
-
>
<
field
name
=
"
_tabbox
"
readonly
=
"
true
"
>
<
!
[
CDATA
[
this
.
tabbox
;
]
]
>
<
/
field
>
<
field
name
=
"
_prefService
"
readonly
=
"
true
"
>
<
!
[
CDATA
[
Cc
[
"
mozilla
.
org
/
preferences
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrefBranch
)
;
]
]
>
<
/
field
>
<
property
name
=
"
selectedIndex
"
>
<
getter
>
<
!
[
CDATA
[
const
tabs
=
this
.
children
;
for
(
var
i
=
0
;
i
<
tabs
.
length
;
i
+
+
)
{
if
(
tabs
[
i
]
.
selected
)
return
i
;
}
return
-
1
;
]
]
>
<
/
getter
>
<
setter
>
<
!
[
CDATA
[
var
tab
=
this
.
getItemAtIndex
(
val
)
;
if
(
tab
)
{
for
(
let
otherTab
of
this
.
children
)
{
if
(
otherTab
!
=
tab
&
&
otherTab
.
selected
)
{
otherTab
.
_selected
=
false
;
}
}
tab
.
_selected
=
true
;
this
.
setAttribute
(
"
value
"
tab
.
value
)
;
let
linkedPanel
=
this
.
getRelatedElement
(
tab
)
;
if
(
linkedPanel
)
{
this
.
tabbox
.
setAttribute
(
"
selectedIndex
"
val
)
;
/
/
This
will
cause
an
onselect
event
to
fire
for
the
tabpanel
/
/
element
.
this
.
tabbox
.
tabpanels
.
selectedPanel
=
linkedPanel
;
}
}
return
val
;
]
]
>
<
/
setter
>
<
/
property
>
<
property
name
=
"
selectedItem
"
>
<
getter
>
<
!
[
CDATA
[
const
tabs
=
this
.
children
;
for
(
var
i
=
0
;
i
<
tabs
.
length
;
i
+
+
)
{
if
(
tabs
[
i
]
.
selected
)
return
tabs
[
i
]
;
}
return
null
;
]
]
>
<
/
getter
>
<
setter
>
<
!
[
CDATA
[
if
(
val
&
&
!
val
.
selected
)
/
/
The
selectedIndex
setter
ignores
invalid
values
/
/
such
as
-
1
if
|
val
|
isn
'
t
one
of
our
child
nodes
.
this
.
selectedIndex
=
this
.
getIndexOfItem
(
val
)
;
return
val
;
]
]
>
<
/
setter
>
<
/
property
>
<
field
name
=
"
ACTIVE_DESCENDANT_ID
"
readonly
=
"
true
"
>
<
!
[
CDATA
[
"
keyboard
-
focused
-
tab
-
"
+
Math
.
trunc
(
Math
.
random
(
)
*
1000000
)
;
]
]
>
<
/
field
>
<
property
name
=
"
ariaFocusedIndex
"
readonly
=
"
true
"
>
<
getter
>
<
!
[
CDATA
[
const
tabs
=
this
.
children
;
for
(
var
i
=
0
;
i
<
tabs
.
length
;
i
+
+
)
{
if
(
tabs
[
i
]
.
id
=
=
this
.
ACTIVE_DESCENDANT_ID
)
return
i
;
}
return
-
1
;
]
]
>
<
/
getter
>
<
/
property
>
<
property
name
=
"
ariaFocusedItem
"
>
<
getter
>
<
!
[
CDATA
[
return
document
.
getElementById
(
this
.
ACTIVE_DESCENDANT_ID
)
;
]
]
>
<
/
getter
>
<
setter
>
<
!
[
CDATA
[
let
setNewItem
=
val
&
&
this
.
getIndexOfItem
(
val
)
!
=
-
1
;
let
clearExistingItem
=
this
.
ariaFocusedItem
&
&
(
!
val
|
|
setNewItem
)
;
if
(
clearExistingItem
)
{
let
ariaFocusedItem
=
this
.
ariaFocusedItem
;
ariaFocusedItem
.
classList
.
remove
(
"
keyboard
-
focused
-
tab
"
)
;
ariaFocusedItem
.
id
=
"
"
;
this
.
selectedItem
.
removeAttribute
(
"
aria
-
activedescendant
"
)
;
}
if
(
setNewItem
)
{
this
.
ariaFocusedItem
=
null
;
val
.
id
=
this
.
ACTIVE_DESCENDANT_ID
;
val
.
classList
.
add
(
"
keyboard
-
focused
-
tab
"
)
;
this
.
selectedItem
.
setAttribute
(
"
aria
-
activedescendant
"
this
.
ACTIVE_DESCENDANT_ID
)
;
}
return
val
;
]
]
>
<
/
setter
>
<
/
property
>
<
method
name
=
"
getIndexOfItem
"
>
<
parameter
name
=
"
item
"
/
>
<
body
>
<
!
[
CDATA
[
return
Array
.
prototype
.
indexOf
.
call
(
this
.
children
item
)
;
]
]
>
<
/
body
>
<
/
method
>
<
method
name
=
"
getItemAtIndex
"
>
<
parameter
name
=
"
index
"
/
>
<
body
>
<
!
[
CDATA
[
return
this
.
children
.
item
(
index
)
;
]
]
>
<
/
body
>
<
/
method
>
<
method
name
=
"
findNextTab
"
>
<
parameter
name
=
"
startTab
"
/
>
<
parameter
name
=
"
opts
"
/
>
<
body
>
<
!
[
CDATA
[
/
*
*
*
Find
an
adjacent
tab
.
*
*
startTab
A
<
tab
>
element
to
start
searching
from
.
*
opts
.
direction
1
to
search
forward
-
1
to
search
backward
.
*
opts
.
wrap
If
true
wrap
around
if
the
search
reaches
*
the
end
(
or
beginning
)
of
the
tab
strip
.
*
opts
.
startWithAdjacent
If
true
(
which
is
the
default
)
start
*
searching
from
the
next
tab
after
*
(
or
before
)
startTab
.
If
false
*
startTab
may
be
returned
if
it
passes
*
the
filter
.
*
opts
.
filter
A
function
to
select
which
tabs
to
return
.
*
*
returns
the
next
<
tab
>
element
or
if
none
exists
null
.
*
/
let
{
direction
=
1
wrap
=
false
startWithAdjacent
=
true
filter
=
tab
=
>
true
}
=
opts
|
|
{
}
;
let
tab
=
startTab
;
if
(
!
startWithAdjacent
&
&
filter
(
tab
)
)
{
return
tab
;
}
let
tabs
=
this
.
allTabs
;
let
i
=
tabs
.
indexOf
(
tab
)
;
if
(
i
<
0
)
{
return
null
;
}
while
(
true
)
{
i
+
=
direction
;
if
(
wrap
)
{
if
(
i
<
0
)
{
i
=
tabs
.
length
-
1
;
}
else
if
(
i
>
=
tabs
.
length
)
{
i
=
0
;
}
}
else
if
(
i
<
0
|
|
i
>
=
tabs
.
length
)
{
return
null
;
}
tab
=
tabs
[
i
]
;
if
(
tab
=
=
startTab
)
{
return
null
;
}
if
(
filter
(
tab
)
)
{
return
tab
;
}
}
]
]
>
<
/
body
>
<
/
method
>
<
method
name
=
"
_selectNewTab
"
>
<
parameter
name
=
"
aNewTab
"
/
>
<
parameter
name
=
"
aFallbackDir
"
/
>
<
parameter
name
=
"
aWrap
"
/
>
<
body
>
<
!
[
CDATA
[
this
.
ariaFocusedItem
=
null
;
aNewTab
=
this
.
findNextTab
(
aNewTab
{
direction
:
aFallbackDir
wrap
:
aWrap
startWithAdjacent
:
false
filter
:
tab
=
>
!
tab
.
hidden
&
&
!
tab
.
disabled
&
&
this
.
_canAdvanceToTab
(
tab
)
}
)
;
var
isTabFocused
=
false
;
try
{
isTabFocused
=
(
document
.
commandDispatcher
.
focusedElement
=
=
this
.
selectedItem
)
;
}
catch
(
e
)
{
}
this
.
selectedItem
=
aNewTab
;
if
(
isTabFocused
)
{
aNewTab
.
focus
(
)
;
}
else
if
(
this
.
getAttribute
(
"
setfocus
"
)
!
=
"
false
"
)
{
let
selectedPanel
=
this
.
tabbox
.
selectedPanel
;
document
.
commandDispatcher
.
advanceFocusIntoSubtree
(
selectedPanel
)
;
/
/
Make
sure
that
the
focus
doesn
'
t
move
outside
the
tabbox
if
(
this
.
tabbox
)
{
try
{
let
el
=
document
.
commandDispatcher
.
focusedElement
;
while
(
el
&
&
el
!
=
this
.
tabbox
.
tabpanels
)
{
if
(
el
=
=
this
.
tabbox
|
|
el
=
=
selectedPanel
)
return
;
el
=
el
.
parentNode
;
}
aNewTab
.
focus
(
)
;
}
catch
(
e
)
{
}
}
}
]
]
>
<
/
body
>
<
/
method
>
<
method
name
=
"
_canAdvanceToTab
"
>
<
parameter
name
=
"
aTab
"
/
>
<
body
>
<
!
[
CDATA
[
return
true
;
]
]
>
<
/
body
>
<
/
method
>
<
method
name
=
"
advanceSelectedTab
"
>
<
parameter
name
=
"
aDir
"
/
>
<
parameter
name
=
"
aWrap
"
/
>
<
body
>
<
!
[
CDATA
[
var
startTab
=
this
.
ariaFocusedItem
|
|
this
.
selectedItem
;
let
newTab
=
this
.
findNextTab
(
startTab
{
direction
:
aDir
wrap
:
aWrap
}
)
;
this
.
_selectNewTab
(
newTab
aDir
aWrap
)
;
]
]
>
<
/
body
>
<
/
method
>
<
method
name
=
"
appendItem
"
>
<
parameter
name
=
"
label
"
/
>
<
parameter
name
=
"
value
"
/
>
<
body
>
<
!
[
CDATA
[
var
tab
=
document
.
createXULElement
(
"
tab
"
)
;
tab
.
setAttribute
(
"
label
"
label
)
;
tab
.
setAttribute
(
"
value
"
value
)
;
this
.
appendChild
(
tab
)
;
return
tab
;
]
]
>
<
/
body
>
<
/
method
>
<
/
implementation
>
<
handlers
>
<
handler
event
=
"
DOMMouseScroll
"
>
<
!
[
CDATA
[
if
(
this
.
_prefService
.
getBoolPref
(
"
toolkit
.
tabbox
.
switchByScrolling
"
)
)
{
if
(
event
.
detail
>
0
)
{
this
.
advanceSelectedTab
(
1
false
)
;
}
else
{
this
.
advanceSelectedTab
(
-
1
false
)
;
}
event
.
stopPropagation
(
)
;
}
]
]
>
<
/
handler
>
<
/
handlers
>
<
/
binding
>
<
/
bindings
>
