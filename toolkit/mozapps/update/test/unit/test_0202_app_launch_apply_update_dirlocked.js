/
*
Any
copyright
is
dedicated
to
the
Public
Domain
.
*
http
:
/
/
creativecommons
.
org
/
publicdomain
/
zero
/
1
.
0
/
*
/
/
*
*
*
Test
applying
an
update
by
applying
an
update
in
the
background
and
*
launching
an
application
*
/
/
*
*
*
This
test
is
identical
to
test_0201_app_launch_apply_update
.
js
except
*
that
it
locks
the
application
directory
when
the
test
is
launched
to
*
check
if
the
alternate
updated
directory
logic
works
correctly
.
*
/
/
*
*
*
The
MAR
file
used
for
this
test
should
not
contain
a
version
2
update
*
manifest
file
(
e
.
g
.
updatev2
.
manifest
)
.
*
/
const
TEST_ID
=
"
0202
"
;
/
/
Backup
the
updater
.
ini
and
use
a
custom
one
to
prevent
the
updater
from
/
/
launching
a
post
update
executable
.
const
FILE_UPDATER_INI_BAK
=
"
updater
.
ini
.
bak
"
;
/
/
Number
of
milliseconds
for
each
do_timeout
call
.
const
CHECK_TIMEOUT_MILLI
=
1000
;
let
gActiveUpdate
;
function
run_test
(
)
{
if
(
APP_BIN_NAME
=
=
"
xulrunner
"
)
{
logTestInfo
(
"
Unable
to
run
this
test
on
xulrunner
"
)
;
return
;
}
if
(
IS_WIN
)
{
var
version
=
AUS_Cc
[
"
mozilla
.
org
/
system
-
info
;
1
"
]
.
getService
(
AUS_Ci
.
nsIPropertyBag2
)
.
getProperty
(
"
version
"
)
;
var
isVistaOrHigher
=
(
parseFloat
(
version
)
>
=
6
.
0
)
;
if
(
!
isVistaOrHigher
)
{
logTestInfo
(
"
Disabled
on
Windows
XP
due
to
bug
909489
"
)
;
return
;
}
}
do_test_pending
(
)
;
do_register_cleanup
(
end_test
)
;
logTestInfo
(
"
setting
up
environment
for
the
update
test
.
.
.
"
)
;
removeUpdateDirsAndFiles
(
)
;
symlinkUpdateFilesIntoBundleDirectory
(
)
;
if
(
IS_WIN
)
{
adjustPathsOnWindows
(
)
;
}
if
(
!
gAppBinPath
)
{
do_throw
(
"
Main
application
binary
not
found
.
.
.
expected
:
"
+
APP_BIN_NAME
+
APP_BIN_SUFFIX
)
;
return
;
}
/
/
Don
'
t
attempt
to
show
a
prompt
when
the
update
is
finished
.
Services
.
prefs
.
setBoolPref
(
PREF_APP_UPDATE_SILENT
true
)
;
let
channel
=
Services
.
prefs
.
getCharPref
(
PREF_APP_UPDATE_CHANNEL
)
;
let
patches
=
getLocalPatchString
(
null
null
null
null
null
"
true
"
STATE_PENDING
)
;
let
updates
=
getLocalUpdateString
(
patches
null
null
null
null
null
null
null
null
null
null
null
null
"
true
"
channel
)
;
writeUpdatesToXMLFile
(
getLocalUpdatesXMLString
(
updates
)
true
)
;
/
/
Read
the
application
.
ini
and
use
its
application
version
let
processDir
=
getAppDir
(
)
;
lockDirectory
(
processDir
)
;
let
file
=
processDir
.
clone
(
)
;
file
.
append
(
"
application
.
ini
"
)
;
let
ini
=
AUS_Cc
[
"
mozilla
.
org
/
xpcom
/
ini
-
parser
-
factory
;
1
"
]
.
getService
(
AUS_Ci
.
nsIINIParserFactory
)
.
createINIParser
(
file
)
;
let
version
=
ini
.
getString
(
"
App
"
"
Version
"
)
;
writeVersionFile
(
version
)
;
writeStatusFile
(
STATE_PENDING
)
;
/
/
Remove
the
old
updated
directory
which
might
be
left
over
from
previous
tests
.
let
oldUpdatedDir
=
processDir
.
clone
(
)
;
oldUpdatedDir
.
append
(
UPDATED_DIR_SUFFIX
.
replace
(
"
/
"
"
"
)
)
;
if
(
oldUpdatedDir
.
exists
(
)
)
{
oldUpdatedDir
.
remove
(
true
)
;
}
/
/
This
is
the
directory
where
the
update
files
will
be
located
let
updateTestDir
=
getUpdateTestDir
(
)
;
try
{
removeDirRecursive
(
updateTestDir
)
;
}
catch
(
e
)
{
logTestInfo
(
"
unable
to
remove
directory
-
path
:
"
+
updateTestDir
.
path
+
"
exception
:
"
+
e
)
;
}
let
updatesPatchDir
=
getUpdatesDir
(
)
;
updatesPatchDir
.
append
(
"
0
"
)
;
let
mar
=
do_get_file
(
"
data
/
simple
.
mar
"
)
;
mar
.
copyTo
(
updatesPatchDir
FILE_UPDATE_ARCHIVE
)
;
reloadUpdateManagerData
(
)
;
gActiveUpdate
=
gUpdateManager
.
activeUpdate
;
do_check_true
(
!
!
gActiveUpdate
)
;
/
/
Backup
the
updater
.
ini
file
if
it
exists
by
moving
it
.
This
prevents
the
/
/
post
update
executable
from
being
launched
if
it
is
specified
.
let
updaterIni
=
processDir
.
clone
(
)
;
updaterIni
.
append
(
FILE_UPDATER_INI
)
;
if
(
updaterIni
.
exists
(
)
)
{
updaterIni
.
moveTo
(
processDir
FILE_UPDATER_INI_BAK
)
;
}
/
/
Backup
the
updater
-
settings
.
ini
file
if
it
exists
by
moving
it
.
let
updateSettingsIni
=
processDir
.
clone
(
)
;
updateSettingsIni
.
append
(
FILE_UPDATE_SETTINGS_INI
)
;
if
(
updateSettingsIni
.
exists
(
)
)
{
updateSettingsIni
.
moveTo
(
processDir
FILE_UPDATE_SETTINGS_INI_BAK
)
;
}
updateSettingsIni
=
processDir
.
clone
(
)
;
updateSettingsIni
.
append
(
FILE_UPDATE_SETTINGS_INI
)
;
writeFile
(
updateSettingsIni
UPDATE_SETTINGS_CONTENTS
)
;
/
/
Initiate
a
background
update
.
logTestInfo
(
"
update
preparation
completed
-
calling
processUpdate
"
)
;
AUS_Cc
[
"
mozilla
.
org
/
updates
/
update
-
processor
;
1
"
]
.
createInstance
(
AUS_Ci
.
nsIUpdateProcessor
)
.
processUpdate
(
gActiveUpdate
)
;
logTestInfo
(
"
processUpdate
completed
-
calling
checkUpdateApplied
"
)
;
checkUpdateApplied
(
)
;
}
function
end_test
(
)
{
logTestInfo
(
"
start
-
test
cleanup
"
)
;
/
/
Remove
the
files
added
by
the
update
.
let
updateTestDir
=
getUpdateTestDir
(
)
;
try
{
logTestInfo
(
"
removing
update
test
directory
"
+
updateTestDir
.
path
)
;
removeDirRecursive
(
updateTestDir
)
;
}
catch
(
e
)
{
logTestInfo
(
"
unable
to
remove
directory
-
path
:
"
+
updateTestDir
.
path
+
"
exception
:
"
+
e
)
;
}
let
processDir
=
getAppDir
(
)
;
/
/
Restore
the
backup
of
the
updater
.
ini
if
it
exists
.
let
updaterIni
=
processDir
.
clone
(
)
;
updaterIni
.
append
(
FILE_UPDATER_INI_BAK
)
;
if
(
updaterIni
.
exists
(
)
)
{
updaterIni
.
moveTo
(
processDir
FILE_UPDATER_INI
)
;
}
/
/
Restore
the
backed
up
updater
-
settings
.
ini
if
it
exists
.
let
updateSettingsIni
=
processDir
.
clone
(
)
;
updateSettingsIni
.
append
(
FILE_UPDATE_SETTINGS_INI_BAK
)
;
if
(
updateSettingsIni
.
exists
(
)
)
{
updateSettingsIni
.
moveTo
(
processDir
FILE_UPDATE_SETTINGS_INI
)
;
}
if
(
IS_UNIX
)
{
/
/
This
will
delete
the
launch
script
if
it
exists
.
getLaunchScript
(
)
;
}
cleanUp
(
)
;
logTestInfo
(
"
finish
-
test
cleanup
"
)
;
}
function
shouldAdjustPathsOnMac
(
)
{
/
/
When
running
xpcshell
tests
locally
xpcshell
and
firefox
-
bin
do
not
live
/
/
in
the
same
directory
.
let
dir
=
getCurrentProcessDir
(
)
;
return
(
IS_MACOSX
&
&
dir
.
leafName
!
=
"
MacOS
"
)
;
}
/
*
*
*
Gets
the
directory
where
the
update
adds
/
removes
the
files
contained
in
the
*
update
.
*
*
return
nsIFile
for
the
directory
where
the
update
adds
/
removes
the
files
*
contained
in
the
update
mar
.
*
/
function
getUpdateTestDir
(
)
{
let
updateTestDir
=
getAppDir
(
)
;
if
(
IS_MACOSX
)
{
updateTestDir
=
updateTestDir
.
parent
.
parent
;
}
updateTestDir
.
append
(
"
update_test
"
)
;
return
updateTestDir
;
}
/
*
*
*
Checks
if
the
update
has
failed
being
applied
in
the
background
.
*
/
function
checkUpdateApplied
(
)
{
/
/
Don
'
t
proceed
until
the
update
has
failed
and
reset
to
pending
.
if
(
gUpdateManager
.
activeUpdate
.
state
!
=
STATE_PENDING
)
{
do_timeout
(
CHECK_TIMEOUT_MILLI
checkUpdateApplied
)
;
return
;
}
logTestInfo
(
"
update
state
equals
"
+
gUpdateManager
.
activeUpdate
.
state
)
;
/
/
Don
'
t
proceed
until
the
update
status
is
pending
.
let
status
=
readStatusFile
(
)
;
do_check_eq
(
status
STATE_PENDING
)
;
unlockDirectory
(
getAppDir
(
)
)
;
removeCallbackCopy
(
)
;
}
