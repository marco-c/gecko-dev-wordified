/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
TargetListener
"
]
;
const
{
Connection
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
Connection
.
jsm
"
)
;
const
{
Session
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
Session
.
jsm
"
)
;
const
{
SocketListener
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
server
/
Socket
.
jsm
"
)
;
/
*
*
*
Represents
a
debuggee
target
(
a
browsing
context
typically
a
tab
)
*
that
clients
can
connect
to
and
debug
.
*
*
Debugger
#
listen
starts
a
WebSocket
listener
*
and
for
each
accepted
connection
a
new
Session
is
created
.
*
There
can
be
multiple
sessions
per
target
.
*
The
session
'
s
lifetime
is
equal
to
the
lifetime
of
the
debugger
connection
.
*
/
class
TargetListener
{
constructor
(
target
)
{
this
.
target
=
target
;
this
.
listener
=
null
;
this
.
sessions
=
new
Map
(
)
;
this
.
nextConnID
=
0
;
this
.
onConnectionAccepted
=
this
.
onConnectionAccepted
.
bind
(
this
)
;
}
get
listening
(
)
{
return
!
!
this
.
listener
&
&
this
.
listener
.
listening
;
}
listen
(
)
{
if
(
this
.
listener
)
{
return
;
}
this
.
listener
=
new
SocketListener
(
)
;
this
.
listener
.
on
(
"
accepted
"
this
.
onConnectionAccepted
)
;
this
.
listener
.
listen
(
"
ws
"
0
/
*
atomically
allocated
port
*
/
)
;
}
close
(
)
{
this
.
listener
.
off
(
"
accepted
"
this
.
onConnectionAccepted
)
;
for
(
const
[
conn
session
]
of
this
.
sessions
)
{
session
.
destructor
(
)
;
conn
.
close
(
)
;
}
this
.
listener
.
close
(
)
;
this
.
listener
=
null
;
this
.
sessions
.
clear
(
)
;
}
/
*
*
*
SocketListener
'
s
accepted
listener
.
Called
whenever
a
new
WebSocket
connection
is
*
established
.
*
*
param
String
eventName
*
param
WebSocketDebuggerTransport
transport
*
param
SocketListener
listener
*
/
onConnectionAccepted
(
eventName
transport
listener
)
{
const
conn
=
new
Connection
(
this
.
nextConnID
+
+
transport
)
;
transport
.
ready
(
)
;
transport
.
on
(
"
close
"
this
.
onConnectionClosed
.
bind
(
this
conn
)
)
;
this
.
sessions
.
set
(
conn
new
Session
(
conn
this
.
target
)
)
;
}
/
*
*
*
WebSocketTransport
'
s
close
listener
.
Called
whenever
a
new
WebSocket
connection
is
*
closed
.
*
*
param
Connection
conn
*
param
String
eventName
*
/
onConnectionClosed
(
conn
eventName
)
{
const
session
=
this
.
sessions
.
get
(
conn
)
;
if
(
!
session
)
{
return
;
}
session
.
destructor
(
)
;
}
get
url
(
)
{
if
(
this
.
listening
)
{
const
{
network
host
port
}
=
this
.
listener
;
return
{
network
}
:
/
/
{
host
}
:
{
port
}
/
;
}
return
null
;
}
toString
(
)
{
return
[
object
TargetListener
{
this
.
url
|
|
"
disconnected
"
}
]
;
}
}
