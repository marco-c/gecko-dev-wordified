/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
Page
"
]
;
const
{
ContentProcessDomain
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
domains
/
ContentProcessDomain
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
UnsupportedError
}
=
ChromeUtils
.
import
(
"
chrome
:
/
/
remote
/
content
/
Error
.
jsm
"
)
;
const
{
LOAD_FLAGS_BYPASS_CACHE
LOAD_FLAGS_BYPASS_PROXY
LOAD_FLAGS_NONE
}
=
Ci
.
nsIWebNavigation
;
class
Page
extends
ContentProcessDomain
{
constructor
(
session
)
{
super
(
session
)
;
this
.
enabled
=
false
;
this
.
lifecycleEnabled
=
false
;
this
.
_onFrameNavigated
=
this
.
_onFrameNavigated
.
bind
(
this
)
;
}
destructor
(
)
{
this
.
setLifecycleEventsEnabled
(
{
enabled
:
false
}
)
;
this
.
disable
(
)
;
super
.
destructor
(
)
;
}
/
/
commands
async
enable
(
)
{
if
(
!
this
.
enabled
)
{
this
.
enabled
=
true
;
this
.
contextObserver
.
on
(
"
frame
-
navigated
"
this
.
_onFrameNavigated
)
;
this
.
chromeEventHandler
.
addEventListener
(
"
DOMContentLoaded
"
this
{
mozSystemGroup
:
true
}
)
;
this
.
chromeEventHandler
.
addEventListener
(
"
pagehide
"
this
{
mozSystemGroup
:
true
}
)
;
this
.
chromeEventHandler
.
addEventListener
(
"
pageshow
"
this
{
mozSystemGroup
:
true
}
)
;
}
}
disable
(
)
{
if
(
this
.
enabled
)
{
this
.
contextObserver
.
off
(
"
frame
-
navigated
"
this
.
_onFrameNavigated
)
;
this
.
chromeEventHandler
.
removeEventListener
(
"
DOMContentLoaded
"
this
{
mozSystemGroup
:
true
}
)
;
this
.
chromeEventHandler
.
removeEventListener
(
"
pagehide
"
this
{
mozSystemGroup
:
true
}
)
;
this
.
chromeEventHandler
.
removeEventListener
(
"
pageshow
"
this
{
mozSystemGroup
:
true
}
)
;
this
.
enabled
=
false
;
}
}
_viewportRect
(
)
{
return
new
DOMRect
(
this
.
content
.
pageXOffset
this
.
content
.
pageYOffset
this
.
content
.
innerWidth
this
.
content
.
innerHeight
)
;
}
async
navigate
(
{
url
referrer
transitionType
frameId
}
=
{
}
)
{
if
(
frameId
&
&
frameId
!
=
this
.
content
.
windowUtils
.
outerWindowID
)
{
throw
new
UnsupportedError
(
"
frameId
not
supported
"
)
;
}
const
opts
=
{
loadFlags
:
transitionToLoadFlag
(
transitionType
)
referrerURI
:
referrer
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
;
this
.
docShell
.
loadURI
(
url
opts
)
;
return
{
frameId
:
this
.
content
.
windowUtils
.
outerWindowID
.
toString
(
)
}
;
}
async
reload
(
{
ignoreCache
}
)
{
let
flags
=
LOAD_FLAGS_NONE
;
if
(
ignoreCache
)
{
flags
|
=
LOAD_FLAGS_BYPASS_CACHE
;
flags
|
=
LOAD_FLAGS_BYPASS_PROXY
;
}
this
.
docShell
.
reload
(
flags
)
;
}
getFrameTree
(
)
{
const
frameId
=
this
.
content
.
windowUtils
.
outerWindowID
.
toString
(
)
;
return
{
frameTree
:
{
frame
:
{
id
:
frameId
url
:
this
.
content
.
location
.
href
loaderId
:
null
securityOrigin
:
null
mimeType
:
null
}
childFrames
:
[
]
}
}
;
}
addScriptToEvaluateOnNewDocument
(
)
{
}
/
*
*
*
Creates
an
isolated
world
for
the
given
frame
.
*
*
Really
it
just
creates
an
execution
context
with
label
"
isolated
"
.
*
*
param
{
Object
}
options
*
param
{
string
}
options
.
frameId
*
param
{
string
=
}
options
.
worldName
*
param
{
boolean
=
}
options
.
grantUniversalAccess
(
not
supported
)
*
This
is
a
powerful
option
use
with
caution
.
*
return
{
number
}
Runtime
.
ExecutionContextId
*
/
createIsolatedWorld
(
options
=
{
}
)
{
const
{
frameId
worldName
}
=
options
;
if
(
frameId
&
&
frameId
!
=
this
.
content
.
windowUtils
.
outerWindowID
)
{
throw
new
UnsupportedError
(
"
frameId
not
supported
"
)
;
}
const
Runtime
=
this
.
session
.
domains
.
get
(
"
Runtime
"
)
;
const
executionContextId
=
Runtime
.
_onContextCreated
(
"
context
-
created
"
{
windowId
:
this
.
content
.
windowUtils
.
currentInnerWindowID
window
:
this
.
content
isDefault
:
false
contextName
:
worldName
contextType
:
"
isolated
"
}
)
;
return
{
executionContextId
}
;
}
/
*
*
*
Controls
whether
page
will
emit
lifecycle
events
.
*
*
param
{
Object
}
options
*
param
{
boolean
}
options
.
enabled
*
If
true
starts
emitting
lifecycle
events
.
*
/
setLifecycleEventsEnabled
(
options
)
{
const
{
enabled
}
=
options
;
this
.
lifecycleEnabled
=
enabled
;
}
url
(
)
{
return
this
.
content
.
location
.
href
;
}
_onFrameNavigated
(
name
{
frameId
window
}
)
{
const
url
=
window
.
location
.
href
;
this
.
emit
(
"
Page
.
frameNavigated
"
{
frame
:
{
id
:
frameId
/
/
frameNavigated
is
only
emitted
for
the
top
level
document
/
/
so
that
it
never
has
a
parent
.
parentId
:
null
url
}
}
)
;
}
emitLifecycleEvent
(
frameId
loaderId
name
timestamp
)
{
if
(
this
.
lifecycleEnabled
)
{
this
.
emit
(
"
Page
.
lifecycleEvent
"
{
frameId
loaderId
name
timestamp
}
)
;
}
}
handleEvent
(
{
type
target
}
)
{
const
isFrame
=
target
.
defaultView
!
=
this
.
content
;
if
(
isFrame
)
{
/
/
Ignore
iframes
for
now
return
;
}
const
timestamp
=
Date
.
now
(
)
;
const
frameId
=
target
.
defaultView
.
windowUtils
.
outerWindowID
.
toString
(
)
;
const
url
=
target
.
location
.
href
;
switch
(
type
)
{
case
"
DOMContentLoaded
"
:
this
.
emit
(
"
Page
.
domContentEventFired
"
{
timestamp
}
)
;
if
(
!
isFrame
)
{
this
.
emitLifecycleEvent
(
frameId
/
*
loaderId
*
/
null
"
DOMContentLoaded
"
timestamp
)
;
}
break
;
case
"
pagehide
"
:
/
/
Maybe
better
to
bound
to
"
unload
"
once
we
can
register
for
this
event
this
.
emit
(
"
Page
.
frameStartedLoading
"
{
frameId
}
)
;
if
(
!
isFrame
)
{
this
.
emitLifecycleEvent
(
frameId
/
*
loaderId
*
/
null
"
init
"
timestamp
)
;
}
break
;
case
"
pageshow
"
:
this
.
emit
(
"
Page
.
loadEventFired
"
{
timestamp
}
)
;
if
(
!
isFrame
)
{
this
.
emitLifecycleEvent
(
frameId
/
*
loaderId
*
/
null
"
load
"
timestamp
)
;
}
/
/
XXX
this
should
most
likely
be
sent
differently
this
.
emit
(
"
Page
.
navigatedWithinDocument
"
{
frameId
url
}
)
;
this
.
emit
(
"
Page
.
frameStoppedLoading
"
{
frameId
}
)
;
break
;
}
}
}
function
transitionToLoadFlag
(
transitionType
)
{
switch
(
transitionType
)
{
case
"
reload
"
:
return
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_IS_REFRESH
;
case
"
link
"
:
default
:
return
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_IS_LINK
;
}
}
