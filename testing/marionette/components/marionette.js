/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
file
*
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
"
use
strict
"
;
const
{
Constructor
:
CC
interfaces
:
Ci
utils
:
Cu
classes
:
Cc
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
MARIONETTE_CONTRACT_ID
=
"
mozilla
.
org
/
marionette
;
1
"
;
const
MARIONETTE_CID
=
Components
.
ID
(
"
{
786a1369
-
dca5
-
4adc
-
8486
-
33d23c88010a
}
"
)
;
const
DEFAULT_PORT
=
2828
;
const
DEFAULT_LOG_LEVEL
=
"
info
"
;
const
LOG_LEVELS
=
new
Map
(
[
[
"
fatal
"
Log
.
Level
.
Fatal
]
[
"
error
"
Log
.
Level
.
Error
]
[
"
warn
"
Log
.
Level
.
Warn
]
[
"
info
"
Log
.
Level
.
Info
]
[
"
config
"
Log
.
Level
.
Config
]
[
"
debug
"
Log
.
Level
.
Debug
]
[
"
trace
"
Log
.
Level
.
Trace
]
]
)
;
/
/
Besides
starting
based
on
existing
prefs
in
a
profile
and
a
command
/
/
line
flag
we
also
support
inheriting
prefs
out
of
an
env
var
and
to
/
/
start
Marionette
that
way
.
/
/
/
/
This
allows
marionette
prefs
to
persist
when
we
do
a
restart
into
/
/
a
different
profile
in
order
to
test
things
like
Firefox
refresh
.
/
/
The
environment
variable
itself
if
present
is
interpreted
as
a
/
/
JSON
structure
with
the
keys
mapping
to
preference
names
in
the
/
/
"
marionette
.
"
branch
and
the
values
to
the
values
of
those
prefs
.
So
/
/
something
like
{
"
enabled
"
:
true
}
would
result
in
the
marionette
.
enabled
/
/
pref
being
set
to
true
thus
triggering
marionette
being
enabled
for
/
/
that
startup
.
const
ENV_PREF_VAR
=
"
MOZ_MARIONETTE_PREF_STATE_ACROSS_RESTARTS
"
;
const
ServerSocket
=
CC
(
"
mozilla
.
org
/
network
/
server
-
socket
;
1
"
"
nsIServerSocket
"
"
initSpecialConnection
"
)
;
/
/
Marionette
preferences
recently
changed
names
.
This
is
an
abstraction
/
/
that
first
looks
for
the
new
name
but
falls
back
to
using
the
old
name
/
/
if
the
new
does
not
exist
.
/
/
/
/
This
shim
can
be
removed
when
Firefox
55
ships
.
const
prefs
=
{
get
enabled
(
)
{
let
fallback
=
Preferences
.
get
(
"
marionette
.
defaultPrefs
.
enabled
"
false
)
;
return
Preferences
.
get
(
"
marionette
.
enabled
"
fallback
)
;
}
get
port
(
)
{
let
fallback
=
Preferences
.
get
(
"
marionette
.
defaultPrefs
.
port
"
DEFAULT_PORT
)
;
return
Preferences
.
get
(
"
marionette
.
port
"
fallback
)
;
}
get
logLevel
(
)
{
let
level
=
DEFAULT_LOG_LEVEL
;
let
fallback
=
Preferences
.
get
(
"
marionette
.
logging
"
level
)
;
let
p
=
Preferences
.
get
(
"
marionette
.
log
.
level
"
fallback
)
;
switch
(
typeof
p
)
{
/
/
Gecko
>
=
46
case
"
string
"
:
let
s
=
p
.
toLowerCase
(
)
;
if
(
LOG_LEVELS
.
has
(
s
)
)
{
level
=
LOG_LEVELS
.
get
(
s
)
;
}
break
;
/
/
Gecko
<
=
45
case
"
boolean
"
:
if
(
p
)
{
level
=
Log
.
Level
.
Trace
;
}
break
;
}
return
level
;
}
get
forceLocal
(
)
{
let
fallback
=
Preferences
.
get
(
"
marionette
.
force
-
local
"
true
)
;
return
Preferences
.
get
(
"
marionette
.
forcelocal
"
fallback
)
;
}
readFromEnvironment
(
key
)
{
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
if
(
env
.
exists
(
key
)
)
{
let
prefs
;
try
{
prefs
=
JSON
.
parse
(
env
.
get
(
key
)
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
"
Invalid
Marionette
preferences
in
environment
;
"
+
"
preferences
will
not
have
been
applied
"
)
;
Cu
.
reportError
(
e
)
;
}
if
(
prefs
)
{
for
(
let
prefName
of
Object
.
keys
(
prefs
)
)
{
Preferences
.
set
(
"
marionette
.
"
+
prefName
prefs
[
prefName
]
)
;
}
}
}
}
}
;
function
MarionetteComponent
(
)
{
this
.
enabled
=
prefs
.
enabled
;
this
.
loaded
=
false
;
this
.
logger
=
this
.
setupLogger
(
prefs
.
logLevel
)
;
this
.
server
=
null
;
this
.
gfxWindow
=
null
;
this
.
finalUIStartup
=
false
;
}
MarionetteComponent
.
prototype
=
{
classDescription
:
"
Marionette
component
"
classID
:
MARIONETTE_CID
contractID
:
MARIONETTE_CONTRACT_ID
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsICommandLineHandler
Ci
.
nsIObserver
]
)
_xpcom_categories
:
[
{
category
:
"
command
-
line
-
handler
"
entry
:
"
b
-
marionette
"
}
{
category
:
"
profile
-
after
-
change
"
service
:
true
}
]
}
;
MarionetteComponent
.
prototype
.
onSocketAccepted
=
function
(
socket
transport
)
{
this
.
logger
.
info
(
"
onSocketAccepted
for
Marionette
dummy
socket
"
)
;
}
;
MarionetteComponent
.
prototype
.
onStopListening
=
function
(
socket
status
)
{
this
.
logger
.
info
(
onStopListening
for
Marionette
dummy
socket
code
{
status
}
)
;
socket
.
close
(
)
;
}
;
/
*
*
Checks
|
cmdLine
|
for
the
-
-
marionette
flag
.
*
/
MarionetteComponent
.
prototype
.
handle
=
function
(
cmdLine
)
{
if
(
cmdLine
.
handleFlag
(
"
marionette
"
false
)
)
{
this
.
enabled
=
true
;
this
.
logger
.
debug
(
"
Marionette
enabled
via
command
-
line
flag
"
)
;
this
.
init
(
)
;
}
}
;
MarionetteComponent
.
prototype
.
observe
=
function
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
profile
-
after
-
change
"
:
/
/
Using
sessionstore
-
windows
-
restored
as
the
xpcom
category
doesn
'
t
/
/
seem
to
work
so
we
wait
for
that
by
adding
an
observer
here
.
Services
.
obs
.
addObserver
(
this
"
sessionstore
-
windows
-
restored
"
false
)
;
prefs
.
readFromEnvironment
(
ENV_PREF_VAR
)
;
if
(
this
.
enabled
)
{
this
.
logger
.
debug
(
"
Marionette
is
enabled
"
)
;
/
/
We
want
to
suppress
the
modal
dialog
that
'
s
shown
/
/
when
starting
up
in
safe
-
mode
to
enable
testing
.
if
(
Services
.
appinfo
.
inSafeMode
)
{
Services
.
obs
.
addObserver
(
this
"
domwindowopened
"
false
)
;
}
}
break
;
case
"
domwindowclosed
"
:
if
(
this
.
gfxWindow
=
=
=
null
|
|
subject
=
=
=
this
.
gfxWindow
)
{
Services
.
obs
.
removeObserver
(
this
topic
)
;
Services
.
obs
.
addObserver
(
this
"
xpcom
-
shutdown
"
false
)
;
this
.
finalUIStartup
=
true
;
this
.
init
(
)
;
}
break
;
case
"
domwindowopened
"
:
Services
.
obs
.
removeObserver
(
this
topic
)
;
this
.
suppressSafeModeDialog
(
subject
)
;
break
;
case
"
sessionstore
-
windows
-
restored
"
:
Services
.
obs
.
removeObserver
(
this
topic
)
;
/
/
When
Firefox
starts
on
Windows
an
additional
GFX
sanity
test
/
/
window
may
appear
off
-
screen
.
Marionette
should
wait
for
it
/
/
to
close
.
let
winEn
=
Services
.
wm
.
getEnumerator
(
null
)
;
while
(
winEn
.
hasMoreElements
(
)
)
{
let
win
=
winEn
.
getNext
(
)
;
if
(
win
.
document
.
documentURI
=
=
"
chrome
:
/
/
gfxsanity
/
content
/
sanityparent
.
html
"
)
{
this
.
gfxWindow
=
win
;
break
;
}
}
if
(
this
.
gfxWindow
)
{
Services
.
obs
.
addObserver
(
this
"
domwindowclosed
"
false
)
;
}
else
{
Services
.
obs
.
addObserver
(
this
"
xpcom
-
shutdown
"
false
)
;
this
.
finalUIStartup
=
true
;
this
.
init
(
)
;
}
break
;
case
"
xpcom
-
shutdown
"
:
Services
.
obs
.
removeObserver
(
this
"
xpcom
-
shutdown
"
)
;
this
.
uninit
(
)
;
break
;
}
}
;
MarionetteComponent
.
prototype
.
setupLogger
=
function
(
level
)
{
let
logger
=
Log
.
repository
.
getLogger
(
"
Marionette
"
)
;
logger
.
level
=
level
;
logger
.
addAppender
(
new
Log
.
DumpAppender
(
)
)
;
return
logger
;
}
;
/
*
*
Wait
for
the
modal
dialogue
to
finish
loading
.
*
/
MarionetteComponent
.
prototype
.
suppressSafeModeDialog
=
function
(
win
)
{
win
.
addEventListener
(
"
load
"
function
(
)
{
if
(
win
.
document
.
getElementById
(
"
safeModeDialog
"
)
)
{
/
/
Accept
the
dialog
to
start
in
safe
-
mode
win
.
setTimeout
(
(
)
=
>
{
win
.
document
.
documentElement
.
getButton
(
"
accept
"
)
.
click
(
)
;
}
)
;
}
}
{
once
:
true
}
)
;
}
;
MarionetteComponent
.
prototype
.
init
=
function
(
)
{
if
(
this
.
loaded
|
|
!
this
.
enabled
|
|
!
this
.
finalUIStartup
)
{
return
;
}
this
.
loaded
=
true
;
if
(
!
prefs
.
forceLocal
)
{
/
/
See
bug
800138
.
Because
the
first
socket
that
opens
with
/
/
force
-
local
=
false
fails
we
open
a
dummy
socket
that
will
fail
.
/
/
keepWhenOffline
=
true
so
that
it
still
work
when
offline
(
local
)
.
/
/
This
allows
the
following
attempt
by
Marionette
to
open
a
socket
/
/
to
succeed
.
let
insaneSacrificialGoat
=
new
ServerSocket
(
666
Ci
.
nsIServerSocket
.
KeepWhenOffline
4
)
;
insaneSacrificialGoat
.
asyncListen
(
this
)
;
}
let
so
;
try
{
Cu
.
import
(
"
chrome
:
/
/
marionette
/
content
/
server
.
js
"
)
;
so
=
new
server
.
TCPListener
(
prefs
.
port
prefs
.
forceLocal
)
;
so
.
start
(
)
;
this
.
logger
.
info
(
Listening
on
port
{
so
.
port
}
)
;
}
catch
(
e
)
{
this
.
logger
.
error
(
Error
on
starting
server
:
{
e
}
)
;
dump
(
e
.
toString
(
)
+
"
\
n
"
+
e
.
stack
+
"
\
n
"
)
;
}
finally
{
if
(
so
)
{
this
.
server
=
so
;
}
}
}
;
MarionetteComponent
.
prototype
.
uninit
=
function
(
)
{
if
(
!
this
.
loaded
)
{
return
;
}
this
.
server
.
stop
(
)
;
this
.
loaded
=
false
;
}
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
[
MarionetteComponent
]
)
;
