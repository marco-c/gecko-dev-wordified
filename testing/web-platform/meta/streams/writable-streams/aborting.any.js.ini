[
aborting
.
any
.
html
]
[
an
abort
(
)
that
happens
during
a
write
(
)
should
trigger
the
underlying
abort
(
)
even
with
a
close
(
)
queued
]
expected
:
FAIL
[
underlying
abort
(
)
should
not
be
called
until
underlying
write
(
)
completes
]
expected
:
FAIL
[
sink
abort
(
)
should
not
be
called
if
stream
was
erroring
due
to
controller
.
error
(
)
before
abort
(
)
was
called
]
expected
:
FAIL
[
Aborting
a
WritableStream
causes
any
outstanding
write
(
)
promises
to
be
rejected
with
the
reason
supplied
]
expected
:
FAIL
[
.
closed
should
not
resolve
before
fulfilled
write
(
)
]
expected
:
FAIL
[
abort
(
)
should
succeed
despite
rejection
from
write
]
expected
:
FAIL
[
WritableStream
if
sink
'
s
abort
throws
the
promise
returned
by
ws
.
abort
(
)
rejects
]
expected
:
FAIL
[
WritableStream
should
NOT
call
underlying
sink
'
s
close
if
no
abort
is
supplied
(
historical
)
]
expected
:
FAIL
[
writer
abort
(
)
during
sink
start
(
)
should
replace
the
writer
.
ready
promise
synchronously
]
expected
:
FAIL
[
WritableStream
if
sink
'
s
abort
throws
for
an
abort
performed
during
a
write
the
promise
returned
by
ws
.
abort
(
)
rejects
]
expected
:
FAIL
[
a
rejecting
sink
.
write
(
)
should
not
prevent
sink
.
abort
(
)
from
being
called
]
expected
:
FAIL
[
if
a
writer
is
created
for
a
stream
with
a
pending
abort
its
ready
should
be
rejected
with
the
abort
error
]
expected
:
FAIL
[
underlying
abort
(
)
should
not
be
called
if
underlying
close
(
)
has
started
]
expected
:
FAIL
[
Aborting
a
WritableStream
passes
through
the
given
reason
]
expected
:
FAIL
[
Aborting
a
WritableStream
should
cause
the
writer
'
s
fulfilled
ready
promise
to
reset
to
a
rejected
one
]
expected
:
FAIL
[
writer
.
ready
should
reject
on
controller
error
without
waiting
for
underlying
write
]
expected
:
FAIL
[
if
underlying
close
(
)
has
started
and
then
rejects
the
abort
(
)
and
close
(
)
promises
should
reject
with
the
underlying
close
rejection
reason
]
expected
:
FAIL
[
if
start
attempts
to
error
the
controller
after
abort
(
)
has
been
called
then
it
should
lose
]
expected
:
FAIL
[
abort
with
an
undefined
argument
should
set
the
stored
error
to
undefined
]
expected
:
FAIL
[
writer
.
abort
(
)
controller
.
error
(
)
while
there
is
an
in
-
flight
close
and
then
finish
the
close
]
expected
:
FAIL
[
.
closed
should
not
resolve
before
rejected
write
(
)
;
write
(
)
error
should
not
overwrite
abort
(
)
error
]
expected
:
FAIL
[
stream
abort
(
)
promise
should
still
resolve
if
sink
start
(
)
rejects
]
expected
:
FAIL
[
controller
.
error
(
)
writer
.
abort
(
)
while
there
is
an
in
-
flight
close
and
then
finish
the
close
]
expected
:
FAIL
[
Aborting
a
WritableStream
prevents
further
writes
after
any
that
are
in
progress
]
expected
:
FAIL
[
writes
should
be
satisfied
in
order
when
aborting
]
expected
:
FAIL
[
abort
with
a
string
argument
should
set
the
stored
error
to
that
argument
]
expected
:
FAIL
[
abort
(
)
should
be
rejected
with
the
rejection
returned
from
close
(
)
]
expected
:
FAIL
[
Aborting
a
WritableStream
immediately
prevents
future
writes
]
expected
:
FAIL
[
Aborting
a
WritableStream
before
it
starts
should
cause
the
writer
'
s
unsettled
ready
promise
to
reject
]
expected
:
FAIL
[
Aborting
a
WritableStream
puts
it
in
an
errored
state
with
the
error
passed
to
abort
(
)
]
expected
:
FAIL
[
Fulfillment
value
of
ws
.
abort
(
)
call
must
be
undefined
even
if
the
underlying
sink
returns
a
non
-
undefined
value
]
expected
:
FAIL
[
sink
abort
(
)
should
not
be
called
if
stream
was
erroring
due
to
bad
strategy
before
abort
(
)
was
called
]
expected
:
FAIL
[
writes
should
be
satisfied
in
order
after
rejected
write
when
aborting
]
expected
:
FAIL
[
releaseLock
(
)
while
aborting
should
reject
the
original
closed
promise
]
expected
:
FAIL
[
when
calling
abort
(
)
twice
on
the
same
stream
both
should
give
the
same
promise
that
fulfills
with
undefined
]
expected
:
FAIL
[
releaseLock
(
)
during
delayed
async
abort
(
)
should
reject
the
writer
.
closed
promise
]
expected
:
FAIL
[
writer
.
abort
(
)
controller
.
error
(
)
while
there
is
an
in
-
flight
write
and
then
finish
the
write
]
expected
:
FAIL
[
close
(
)
should
reject
with
abort
reason
why
abort
(
)
is
first
error
]
expected
:
FAIL
[
WritableStream
if
sink
'
s
abort
throws
the
promise
returned
by
multiple
writer
.
abort
(
)
s
is
the
same
and
rejects
]
expected
:
FAIL
[
returning
a
thenable
from
abort
(
)
should
work
]
expected
:
FAIL
[
when
start
errors
after
stream
abort
(
)
underlying
sink
abort
(
)
should
be
called
anyway
]
expected
:
FAIL
[
sink
abort
(
)
should
not
be
called
until
sink
start
(
)
is
done
]
expected
:
FAIL
[
abort
(
)
on
a
released
writer
rejects
]
expected
:
FAIL
[
Aborting
a
WritableStream
after
it
is
closed
is
a
no
-
op
]
expected
:
FAIL
[
writer
close
(
)
promise
should
resolve
before
abort
(
)
promise
]
expected
:
FAIL
[
promises
returned
from
other
writer
methods
should
be
rejected
when
writer
abort
(
)
happens
during
sink
start
(
)
]
expected
:
FAIL
[
abort
with
no
arguments
should
set
the
stored
error
to
undefined
]
expected
:
FAIL
[
controller
.
error
(
)
writer
.
abort
(
)
while
there
is
an
in
-
flight
write
and
then
finish
the
write
]
expected
:
FAIL
[
calling
abort
(
)
on
an
errored
stream
should
fulfill
with
undefined
]
expected
:
FAIL
[
Closing
a
WritableStream
and
aborting
it
while
it
closes
causes
the
stream
to
ignore
the
abort
attempt
]
expected
:
FAIL
[
WritableStream
if
sink
'
s
abort
throws
the
promise
returned
by
writer
.
abort
(
)
rejects
]
expected
:
FAIL
[
when
calling
abort
(
)
twice
on
the
same
stream
but
sequentially
so
so
there
'
s
no
pending
abort
the
second
time
both
should
fulfill
with
undefined
]
expected
:
FAIL
[
writer
.
abort
(
)
while
there
is
an
in
-
flight
write
and
then
finish
the
write
with
rejection
]
expected
:
FAIL
[
Closing
but
then
immediately
aborting
a
WritableStream
causes
the
stream
to
error
]
expected
:
FAIL
[
aborting
.
any
.
worker
.
html
]
[
an
abort
(
)
that
happens
during
a
write
(
)
should
trigger
the
underlying
abort
(
)
even
with
a
close
(
)
queued
]
expected
:
FAIL
[
underlying
abort
(
)
should
not
be
called
until
underlying
write
(
)
completes
]
expected
:
FAIL
[
sink
abort
(
)
should
not
be
called
if
stream
was
erroring
due
to
controller
.
error
(
)
before
abort
(
)
was
called
]
expected
:
FAIL
[
Aborting
a
WritableStream
causes
any
outstanding
write
(
)
promises
to
be
rejected
with
the
reason
supplied
]
expected
:
FAIL
[
.
closed
should
not
resolve
before
fulfilled
write
(
)
]
expected
:
FAIL
[
abort
(
)
should
succeed
despite
rejection
from
write
]
expected
:
FAIL
[
WritableStream
if
sink
'
s
abort
throws
the
promise
returned
by
ws
.
abort
(
)
rejects
]
expected
:
FAIL
[
WritableStream
should
NOT
call
underlying
sink
'
s
close
if
no
abort
is
supplied
(
historical
)
]
expected
:
FAIL
[
writer
abort
(
)
during
sink
start
(
)
should
replace
the
writer
.
ready
promise
synchronously
]
expected
:
FAIL
[
WritableStream
if
sink
'
s
abort
throws
for
an
abort
performed
during
a
write
the
promise
returned
by
ws
.
abort
(
)
rejects
]
expected
:
FAIL
[
a
rejecting
sink
.
write
(
)
should
not
prevent
sink
.
abort
(
)
from
being
called
]
expected
:
FAIL
[
if
a
writer
is
created
for
a
stream
with
a
pending
abort
its
ready
should
be
rejected
with
the
abort
error
]
expected
:
FAIL
[
underlying
abort
(
)
should
not
be
called
if
underlying
close
(
)
has
started
]
expected
:
FAIL
[
Aborting
a
WritableStream
passes
through
the
given
reason
]
expected
:
FAIL
[
Aborting
a
WritableStream
should
cause
the
writer
'
s
fulfilled
ready
promise
to
reset
to
a
rejected
one
]
expected
:
FAIL
[
writer
.
ready
should
reject
on
controller
error
without
waiting
for
underlying
write
]
expected
:
FAIL
[
if
underlying
close
(
)
has
started
and
then
rejects
the
abort
(
)
and
close
(
)
promises
should
reject
with
the
underlying
close
rejection
reason
]
expected
:
FAIL
[
if
start
attempts
to
error
the
controller
after
abort
(
)
has
been
called
then
it
should
lose
]
expected
:
FAIL
[
abort
with
an
undefined
argument
should
set
the
stored
error
to
undefined
]
expected
:
FAIL
[
writer
.
abort
(
)
controller
.
error
(
)
while
there
is
an
in
-
flight
close
and
then
finish
the
close
]
expected
:
FAIL
[
.
closed
should
not
resolve
before
rejected
write
(
)
;
write
(
)
error
should
not
overwrite
abort
(
)
error
]
expected
:
FAIL
[
stream
abort
(
)
promise
should
still
resolve
if
sink
start
(
)
rejects
]
expected
:
FAIL
[
controller
.
error
(
)
writer
.
abort
(
)
while
there
is
an
in
-
flight
close
and
then
finish
the
close
]
expected
:
FAIL
[
Aborting
a
WritableStream
prevents
further
writes
after
any
that
are
in
progress
]
expected
:
FAIL
[
writes
should
be
satisfied
in
order
when
aborting
]
expected
:
FAIL
[
abort
with
a
string
argument
should
set
the
stored
error
to
that
argument
]
expected
:
FAIL
[
abort
(
)
should
be
rejected
with
the
rejection
returned
from
close
(
)
]
expected
:
FAIL
[
Aborting
a
WritableStream
immediately
prevents
future
writes
]
expected
:
FAIL
[
Aborting
a
WritableStream
before
it
starts
should
cause
the
writer
'
s
unsettled
ready
promise
to
reject
]
expected
:
FAIL
[
Aborting
a
WritableStream
puts
it
in
an
errored
state
with
the
error
passed
to
abort
(
)
]
expected
:
FAIL
[
Fulfillment
value
of
ws
.
abort
(
)
call
must
be
undefined
even
if
the
underlying
sink
returns
a
non
-
undefined
value
]
expected
:
FAIL
[
sink
abort
(
)
should
not
be
called
if
stream
was
erroring
due
to
bad
strategy
before
abort
(
)
was
called
]
expected
:
FAIL
[
writes
should
be
satisfied
in
order
after
rejected
write
when
aborting
]
expected
:
FAIL
[
releaseLock
(
)
while
aborting
should
reject
the
original
closed
promise
]
expected
:
FAIL
[
when
calling
abort
(
)
twice
on
the
same
stream
both
should
give
the
same
promise
that
fulfills
with
undefined
]
expected
:
FAIL
[
releaseLock
(
)
during
delayed
async
abort
(
)
should
reject
the
writer
.
closed
promise
]
expected
:
FAIL
[
writer
.
abort
(
)
controller
.
error
(
)
while
there
is
an
in
-
flight
write
and
then
finish
the
write
]
expected
:
FAIL
[
close
(
)
should
reject
with
abort
reason
why
abort
(
)
is
first
error
]
expected
:
FAIL
[
WritableStream
if
sink
'
s
abort
throws
the
promise
returned
by
multiple
writer
.
abort
(
)
s
is
the
same
and
rejects
]
expected
:
FAIL
[
returning
a
thenable
from
abort
(
)
should
work
]
expected
:
FAIL
[
when
start
errors
after
stream
abort
(
)
underlying
sink
abort
(
)
should
be
called
anyway
]
expected
:
FAIL
[
sink
abort
(
)
should
not
be
called
until
sink
start
(
)
is
done
]
expected
:
FAIL
[
abort
(
)
on
a
released
writer
rejects
]
expected
:
FAIL
[
Aborting
a
WritableStream
after
it
is
closed
is
a
no
-
op
]
expected
:
FAIL
[
writer
close
(
)
promise
should
resolve
before
abort
(
)
promise
]
expected
:
FAIL
[
promises
returned
from
other
writer
methods
should
be
rejected
when
writer
abort
(
)
happens
during
sink
start
(
)
]
expected
:
FAIL
[
abort
with
no
arguments
should
set
the
stored
error
to
undefined
]
expected
:
FAIL
[
controller
.
error
(
)
writer
.
abort
(
)
while
there
is
an
in
-
flight
write
and
then
finish
the
write
]
expected
:
FAIL
[
calling
abort
(
)
on
an
errored
stream
should
fulfill
with
undefined
]
expected
:
FAIL
[
Closing
a
WritableStream
and
aborting
it
while
it
closes
causes
the
stream
to
ignore
the
abort
attempt
]
expected
:
FAIL
[
WritableStream
if
sink
'
s
abort
throws
the
promise
returned
by
writer
.
abort
(
)
rejects
]
expected
:
FAIL
[
when
calling
abort
(
)
twice
on
the
same
stream
but
sequentially
so
so
there
'
s
no
pending
abort
the
second
time
both
should
fulfill
with
undefined
]
expected
:
FAIL
[
writer
.
abort
(
)
while
there
is
an
in
-
flight
write
and
then
finish
the
write
with
rejection
]
expected
:
FAIL
[
Closing
but
then
immediately
aborting
a
WritableStream
causes
the
stream
to
error
]
expected
:
FAIL
[
aborting
.
any
.
serviceworker
.
html
]
[
an
abort
(
)
that
happens
during
a
write
(
)
should
trigger
the
underlying
abort
(
)
even
with
a
close
(
)
queued
]
expected
:
FAIL
[
underlying
abort
(
)
should
not
be
called
until
underlying
write
(
)
completes
]
expected
:
FAIL
[
sink
abort
(
)
should
not
be
called
if
stream
was
erroring
due
to
controller
.
error
(
)
before
abort
(
)
was
called
]
expected
:
FAIL
[
Aborting
a
WritableStream
causes
any
outstanding
write
(
)
promises
to
be
rejected
with
the
reason
supplied
]
expected
:
FAIL
[
.
closed
should
not
resolve
before
fulfilled
write
(
)
]
expected
:
FAIL
[
abort
(
)
should
succeed
despite
rejection
from
write
]
expected
:
FAIL
[
WritableStream
if
sink
'
s
abort
throws
the
promise
returned
by
ws
.
abort
(
)
rejects
]
expected
:
FAIL
[
WritableStream
should
NOT
call
underlying
sink
'
s
close
if
no
abort
is
supplied
(
historical
)
]
expected
:
FAIL
[
writer
abort
(
)
during
sink
start
(
)
should
replace
the
writer
.
ready
promise
synchronously
]
expected
:
FAIL
[
WritableStream
if
sink
'
s
abort
throws
for
an
abort
performed
during
a
write
the
promise
returned
by
ws
.
abort
(
)
rejects
]
expected
:
FAIL
[
a
rejecting
sink
.
write
(
)
should
not
prevent
sink
.
abort
(
)
from
being
called
]
expected
:
FAIL
[
if
a
writer
is
created
for
a
stream
with
a
pending
abort
its
ready
should
be
rejected
with
the
abort
error
]
expected
:
FAIL
[
underlying
abort
(
)
should
not
be
called
if
underlying
close
(
)
has
started
]
expected
:
FAIL
[
Aborting
a
WritableStream
passes
through
the
given
reason
]
expected
:
FAIL
[
Aborting
a
WritableStream
should
cause
the
writer
'
s
fulfilled
ready
promise
to
reset
to
a
rejected
one
]
expected
:
FAIL
[
writer
.
ready
should
reject
on
controller
error
without
waiting
for
underlying
write
]
expected
:
FAIL
[
if
underlying
close
(
)
has
started
and
then
rejects
the
abort
(
)
and
close
(
)
promises
should
reject
with
the
underlying
close
rejection
reason
]
expected
:
FAIL
[
if
start
attempts
to
error
the
controller
after
abort
(
)
has
been
called
then
it
should
lose
]
expected
:
FAIL
[
abort
with
an
undefined
argument
should
set
the
stored
error
to
undefined
]
expected
:
FAIL
[
writer
.
abort
(
)
controller
.
error
(
)
while
there
is
an
in
-
flight
close
and
then
finish
the
close
]
expected
:
FAIL
[
.
closed
should
not
resolve
before
rejected
write
(
)
;
write
(
)
error
should
not
overwrite
abort
(
)
error
]
expected
:
FAIL
[
stream
abort
(
)
promise
should
still
resolve
if
sink
start
(
)
rejects
]
expected
:
FAIL
[
controller
.
error
(
)
writer
.
abort
(
)
while
there
is
an
in
-
flight
close
and
then
finish
the
close
]
expected
:
FAIL
[
Aborting
a
WritableStream
prevents
further
writes
after
any
that
are
in
progress
]
expected
:
FAIL
[
writes
should
be
satisfied
in
order
when
aborting
]
expected
:
FAIL
[
abort
with
a
string
argument
should
set
the
stored
error
to
that
argument
]
expected
:
FAIL
[
abort
(
)
should
be
rejected
with
the
rejection
returned
from
close
(
)
]
expected
:
FAIL
[
Aborting
a
WritableStream
immediately
prevents
future
writes
]
expected
:
FAIL
[
Aborting
a
WritableStream
before
it
starts
should
cause
the
writer
'
s
unsettled
ready
promise
to
reject
]
expected
:
FAIL
[
Aborting
a
WritableStream
puts
it
in
an
errored
state
with
the
error
passed
to
abort
(
)
]
expected
:
FAIL
[
Fulfillment
value
of
ws
.
abort
(
)
call
must
be
undefined
even
if
the
underlying
sink
returns
a
non
-
undefined
value
]
expected
:
FAIL
[
sink
abort
(
)
should
not
be
called
if
stream
was
erroring
due
to
bad
strategy
before
abort
(
)
was
called
]
expected
:
FAIL
[
writes
should
be
satisfied
in
order
after
rejected
write
when
aborting
]
expected
:
FAIL
[
releaseLock
(
)
while
aborting
should
reject
the
original
closed
promise
]
expected
:
FAIL
[
when
calling
abort
(
)
twice
on
the
same
stream
both
should
give
the
same
promise
that
fulfills
with
undefined
]
expected
:
FAIL
[
releaseLock
(
)
during
delayed
async
abort
(
)
should
reject
the
writer
.
closed
promise
]
expected
:
FAIL
[
writer
.
abort
(
)
controller
.
error
(
)
while
there
is
an
in
-
flight
write
and
then
finish
the
write
]
expected
:
FAIL
[
close
(
)
should
reject
with
abort
reason
why
abort
(
)
is
first
error
]
expected
:
FAIL
[
WritableStream
if
sink
'
s
abort
throws
the
promise
returned
by
multiple
writer
.
abort
(
)
s
is
the
same
and
rejects
]
expected
:
FAIL
[
returning
a
thenable
from
abort
(
)
should
work
]
expected
:
FAIL
[
when
start
errors
after
stream
abort
(
)
underlying
sink
abort
(
)
should
be
called
anyway
]
expected
:
FAIL
[
sink
abort
(
)
should
not
be
called
until
sink
start
(
)
is
done
]
expected
:
FAIL
[
abort
(
)
on
a
released
writer
rejects
]
expected
:
FAIL
[
Aborting
a
WritableStream
after
it
is
closed
is
a
no
-
op
]
expected
:
FAIL
[
writer
close
(
)
promise
should
resolve
before
abort
(
)
promise
]
expected
:
FAIL
[
promises
returned
from
other
writer
methods
should
be
rejected
when
writer
abort
(
)
happens
during
sink
start
(
)
]
expected
:
FAIL
[
abort
with
no
arguments
should
set
the
stored
error
to
undefined
]
expected
:
FAIL
[
controller
.
error
(
)
writer
.
abort
(
)
while
there
is
an
in
-
flight
write
and
then
finish
the
write
]
expected
:
FAIL
[
calling
abort
(
)
on
an
errored
stream
should
fulfill
with
undefined
]
expected
:
FAIL
[
Closing
a
WritableStream
and
aborting
it
while
it
closes
causes
the
stream
to
ignore
the
abort
attempt
]
expected
:
FAIL
[
WritableStream
if
sink
'
s
abort
throws
the
promise
returned
by
writer
.
abort
(
)
rejects
]
expected
:
FAIL
[
when
calling
abort
(
)
twice
on
the
same
stream
but
sequentially
so
so
there
'
s
no
pending
abort
the
second
time
both
should
fulfill
with
undefined
]
expected
:
FAIL
[
writer
.
abort
(
)
while
there
is
an
in
-
flight
write
and
then
finish
the
write
with
rejection
]
expected
:
FAIL
[
Closing
but
then
immediately
aborting
a
WritableStream
causes
the
stream
to
error
]
expected
:
FAIL
[
aborting
.
any
.
sharedworker
.
html
]
[
an
abort
(
)
that
happens
during
a
write
(
)
should
trigger
the
underlying
abort
(
)
even
with
a
close
(
)
queued
]
expected
:
FAIL
[
underlying
abort
(
)
should
not
be
called
until
underlying
write
(
)
completes
]
expected
:
FAIL
[
sink
abort
(
)
should
not
be
called
if
stream
was
erroring
due
to
controller
.
error
(
)
before
abort
(
)
was
called
]
expected
:
FAIL
[
Aborting
a
WritableStream
causes
any
outstanding
write
(
)
promises
to
be
rejected
with
the
reason
supplied
]
expected
:
FAIL
[
.
closed
should
not
resolve
before
fulfilled
write
(
)
]
expected
:
FAIL
[
abort
(
)
should
succeed
despite
rejection
from
write
]
expected
:
FAIL
[
WritableStream
if
sink
'
s
abort
throws
the
promise
returned
by
ws
.
abort
(
)
rejects
]
expected
:
FAIL
[
WritableStream
should
NOT
call
underlying
sink
'
s
close
if
no
abort
is
supplied
(
historical
)
]
expected
:
FAIL
[
writer
abort
(
)
during
sink
start
(
)
should
replace
the
writer
.
ready
promise
synchronously
]
expected
:
FAIL
[
WritableStream
if
sink
'
s
abort
throws
for
an
abort
performed
during
a
write
the
promise
returned
by
ws
.
abort
(
)
rejects
]
expected
:
FAIL
[
a
rejecting
sink
.
write
(
)
should
not
prevent
sink
.
abort
(
)
from
being
called
]
expected
:
FAIL
[
if
a
writer
is
created
for
a
stream
with
a
pending
abort
its
ready
should
be
rejected
with
the
abort
error
]
expected
:
FAIL
[
underlying
abort
(
)
should
not
be
called
if
underlying
close
(
)
has
started
]
expected
:
FAIL
[
Aborting
a
WritableStream
passes
through
the
given
reason
]
expected
:
FAIL
[
Aborting
a
WritableStream
should
cause
the
writer
'
s
fulfilled
ready
promise
to
reset
to
a
rejected
one
]
expected
:
FAIL
[
writer
.
ready
should
reject
on
controller
error
without
waiting
for
underlying
write
]
expected
:
FAIL
[
if
underlying
close
(
)
has
started
and
then
rejects
the
abort
(
)
and
close
(
)
promises
should
reject
with
the
underlying
close
rejection
reason
]
expected
:
FAIL
[
if
start
attempts
to
error
the
controller
after
abort
(
)
has
been
called
then
it
should
lose
]
expected
:
FAIL
[
abort
with
an
undefined
argument
should
set
the
stored
error
to
undefined
]
expected
:
FAIL
[
writer
.
abort
(
)
controller
.
error
(
)
while
there
is
an
in
-
flight
close
and
then
finish
the
close
]
expected
:
FAIL
[
.
closed
should
not
resolve
before
rejected
write
(
)
;
write
(
)
error
should
not
overwrite
abort
(
)
error
]
expected
:
FAIL
[
stream
abort
(
)
promise
should
still
resolve
if
sink
start
(
)
rejects
]
expected
:
FAIL
[
controller
.
error
(
)
writer
.
abort
(
)
while
there
is
an
in
-
flight
close
and
then
finish
the
close
]
expected
:
FAIL
[
Aborting
a
WritableStream
prevents
further
writes
after
any
that
are
in
progress
]
expected
:
FAIL
[
writes
should
be
satisfied
in
order
when
aborting
]
expected
:
FAIL
[
abort
with
a
string
argument
should
set
the
stored
error
to
that
argument
]
expected
:
FAIL
[
abort
(
)
should
be
rejected
with
the
rejection
returned
from
close
(
)
]
expected
:
FAIL
[
Aborting
a
WritableStream
immediately
prevents
future
writes
]
expected
:
FAIL
[
Aborting
a
WritableStream
before
it
starts
should
cause
the
writer
'
s
unsettled
ready
promise
to
reject
]
expected
:
FAIL
[
Aborting
a
WritableStream
puts
it
in
an
errored
state
with
the
error
passed
to
abort
(
)
]
expected
:
FAIL
[
Fulfillment
value
of
ws
.
abort
(
)
call
must
be
undefined
even
if
the
underlying
sink
returns
a
non
-
undefined
value
]
expected
:
FAIL
[
sink
abort
(
)
should
not
be
called
if
stream
was
erroring
due
to
bad
strategy
before
abort
(
)
was
called
]
expected
:
FAIL
[
writes
should
be
satisfied
in
order
after
rejected
write
when
aborting
]
expected
:
FAIL
[
releaseLock
(
)
while
aborting
should
reject
the
original
closed
promise
]
expected
:
FAIL
[
when
calling
abort
(
)
twice
on
the
same
stream
both
should
give
the
same
promise
that
fulfills
with
undefined
]
expected
:
FAIL
[
releaseLock
(
)
during
delayed
async
abort
(
)
should
reject
the
writer
.
closed
promise
]
expected
:
FAIL
[
writer
.
abort
(
)
controller
.
error
(
)
while
there
is
an
in
-
flight
write
and
then
finish
the
write
]
expected
:
FAIL
[
close
(
)
should
reject
with
abort
reason
why
abort
(
)
is
first
error
]
expected
:
FAIL
[
WritableStream
if
sink
'
s
abort
throws
the
promise
returned
by
multiple
writer
.
abort
(
)
s
is
the
same
and
rejects
]
expected
:
FAIL
[
returning
a
thenable
from
abort
(
)
should
work
]
expected
:
FAIL
[
when
start
errors
after
stream
abort
(
)
underlying
sink
abort
(
)
should
be
called
anyway
]
expected
:
FAIL
[
sink
abort
(
)
should
not
be
called
until
sink
start
(
)
is
done
]
expected
:
FAIL
[
abort
(
)
on
a
released
writer
rejects
]
expected
:
FAIL
[
Aborting
a
WritableStream
after
it
is
closed
is
a
no
-
op
]
expected
:
FAIL
[
writer
close
(
)
promise
should
resolve
before
abort
(
)
promise
]
expected
:
FAIL
[
promises
returned
from
other
writer
methods
should
be
rejected
when
writer
abort
(
)
happens
during
sink
start
(
)
]
expected
:
FAIL
[
abort
with
no
arguments
should
set
the
stored
error
to
undefined
]
expected
:
FAIL
[
controller
.
error
(
)
writer
.
abort
(
)
while
there
is
an
in
-
flight
write
and
then
finish
the
write
]
expected
:
FAIL
[
calling
abort
(
)
on
an
errored
stream
should
fulfill
with
undefined
]
expected
:
FAIL
[
Closing
a
WritableStream
and
aborting
it
while
it
closes
causes
the
stream
to
ignore
the
abort
attempt
]
expected
:
FAIL
[
WritableStream
if
sink
'
s
abort
throws
the
promise
returned
by
writer
.
abort
(
)
rejects
]
expected
:
FAIL
[
when
calling
abort
(
)
twice
on
the
same
stream
but
sequentially
so
so
there
'
s
no
pending
abort
the
second
time
both
should
fulfill
with
undefined
]
expected
:
FAIL
[
writer
.
abort
(
)
while
there
is
an
in
-
flight
write
and
then
finish
the
write
with
rejection
]
expected
:
FAIL
[
Closing
but
then
immediately
aborting
a
WritableStream
causes
the
stream
to
error
]
expected
:
FAIL
