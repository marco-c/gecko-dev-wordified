<
!
DOCTYPE
html
>
<
meta
charset
=
"
utf
-
8
"
>
<
title
>
Service
Worker
:
Schedule
Job
algorithm
<
/
title
>
<
script
src
=
"
/
resources
/
testharness
.
js
"
>
<
/
script
>
<
script
src
=
"
resources
/
testharness
-
helpers
.
js
"
>
<
/
script
>
<
script
src
=
"
/
resources
/
testharnessreport
.
js
"
>
<
/
script
>
<
script
>
/
/
Tests
for
https
:
/
/
w3c
.
github
.
io
/
ServiceWorker
/
#
schedule
-
job
-
algorithm
/
/
Non
-
equivalent
register
jobs
should
not
be
coalesced
.
const
scope
=
'
resources
/
'
;
const
script1
=
'
resources
/
empty
.
js
'
;
const
script2
=
'
resources
/
empty
.
js
?
change
'
;
async
function
cleanup
(
)
{
const
registration
=
await
navigator
.
serviceWorker
.
getRegistration
(
scope
)
;
if
(
registration
)
await
registration
.
unregister
(
)
;
}
function
absolute_url
(
url
)
{
return
new
URL
(
url
self
.
location
)
.
toString
(
)
;
}
/
/
Test
scriptURL
and
updateViaCache
.
promise_test
(
async
t
=
>
{
await
cleanup
(
)
;
t
.
add_cleanup
(
cleanup
)
;
/
/
Check
defaults
.
const
registration
=
await
navigator
.
serviceWorker
.
register
(
script1
{
scope
}
)
;
assert_equals
(
registration
.
updateViaCache
'
imports
'
)
;
/
/
Schedule
several
register
jobs
in
the
same
scope
.
/
/
None
of
the
changes
should
have
been
coalesced
.
/
/
This
resolves
without
changing
anything
.
const
p1
=
navigator
.
serviceWorker
.
register
(
script1
{
scope
}
)
;
/
/
This
changes
the
script
URL
so
going
with
installing
a
new
worker
without
/
/
byte
-
for
-
byte
update
check
.
const
p2
=
navigator
.
serviceWorker
.
register
(
script2
{
scope
}
)
;
/
/
This
changes
the
updateViaCache
option
but
the
script
URL
is
the
same
.
That
/
/
results
in
updating
the
updateViaCache
flag
but
no
worker
is
going
to
be
/
/
stored
.
const
p3
=
navigator
.
serviceWorker
.
register
(
script2
{
scope
updateViaCache
:
'
none
'
}
)
;
/
/
The
first
call
of
register
(
)
doesn
'
t
change
anything
.
await
p1
;
assert_equals
(
registration
.
installing
null
)
;
/
/
The
scriptURL
must
be
updated
when
p2
resolves
.
At
that
point
a
new
/
/
worker
must
be
in
the
installing
state
because
changing
scriptURL
is
/
/
treated
as
the
same
as
there
'
s
an
update
in
the
script
.
await
p2
;
assert_equals
(
registration
.
installing
.
scriptURL
absolute_url
(
script2
)
)
;
assert_equals
(
registration
.
updateViaCache
'
imports
'
)
;
/
/
The
updateViaCache
must
be
updated
when
p3
resolves
.
await
p3
;
assert_equals
(
registration
.
installing
.
scriptURL
absolute_url
(
script2
)
)
;
assert_equals
(
registration
.
updateViaCache
'
none
'
)
;
}
'
different
scriptURL
and
updateViaCache
'
)
;
/
/
Test
|
type
|
in
another
test
case
because
most
browsers
don
'
t
support
it
.
promise_test
(
async
t
=
>
{
const
script1
=
'
resources
/
empty
.
js
'
;
const
script2
=
'
resources
/
empty
.
js
?
change
'
;
await
cleanup
(
)
;
t
.
add_cleanup
(
cleanup
)
;
/
/
Check
defaults
.
const
registration
=
await
navigator
.
serviceWorker
.
register
(
script1
{
scope
}
)
;
assert_equals
(
registration
.
installing
.
type
'
classic
'
)
;
/
/
Schedule
several
register
jobs
in
the
same
scope
.
/
/
None
of
the
changes
should
have
been
coalesced
.
/
/
This
resolves
without
changing
anything
.
const
p1
=
navigator
.
serviceWorker
.
register
(
script1
{
scope
}
)
;
/
/
This
changes
the
script
URL
so
going
with
installing
a
new
worker
without
/
/
byte
-
for
-
byte
update
check
.
const
p2
=
navigator
.
serviceWorker
.
register
(
script2
{
scope
}
)
;
/
/
This
changes
the
worker
type
and
that
goes
to
the
same
path
with
updating
/
/
the
worker
script
or
the
script
URL
.
const
p3
=
navigator
.
serviceWorker
.
register
(
script2
{
scope
type
:
'
module
'
}
)
;
/
/
The
first
call
of
register
(
)
doesn
'
t
change
anything
.
await
p1
;
assert_equals
(
registration
.
installing
null
)
;
/
/
The
scriptURL
must
be
updated
when
p2
resolves
.
At
this
point
a
new
/
/
worker
must
be
in
the
installing
state
because
changing
scriptURL
is
/
/
treated
as
the
same
as
there
'
s
an
update
in
the
script
.
await
p2
;
assert_equals
(
registration
.
installing
.
scriptURL
absolute_url
(
script2
)
)
;
assert_equals
(
registration
.
installing
.
type
'
classic
'
)
;
/
/
The
script
type
must
be
updated
when
p3
resolves
.
At
this
point
a
new
/
/
worker
must
be
in
the
installing
state
because
changing
script
type
is
also
/
/
treated
as
the
same
as
there
'
s
an
update
in
the
script
.
await
p3
;
assert_equals
(
registration
.
installing
.
scriptURL
absolute_url
(
script2
)
)
;
assert_equals
(
registration
.
installing
.
type
'
module
'
)
;
}
'
different
type
'
)
;
<
/
script
>
