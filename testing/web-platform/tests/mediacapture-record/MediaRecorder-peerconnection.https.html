<
!
doctype
html
>
<
html
>
<
meta
name
=
"
timeout
"
content
=
"
long
"
>
<
head
>
<
title
>
MediaRecorder
peer
connection
<
/
title
>
<
link
rel
=
"
help
"
href
=
"
https
:
/
/
w3c
.
github
.
io
/
mediacapture
-
record
/
MediaRecorder
.
html
#
dom
-
mediarecorder
-
mimeType
"
>
<
script
src
=
"
/
resources
/
testharness
.
js
"
>
<
/
script
>
<
script
src
=
"
/
resources
/
testharnessreport
.
js
"
>
<
/
script
>
<
script
src
=
"
utils
/
peerconnection
.
js
"
>
<
/
script
>
<
/
head
>
<
body
>
<
video
id
=
"
remote
"
autoplay
width
=
"
240
"
/
>
<
script
>
function
runTests
(
{
kind
mimeType
}
)
{
const
formatString
=
{
JSON
.
stringify
(
kind
)
}
with
format
{
mimeType
|
|
"
[
passthrough
]
"
}
.
;
promise_test
(
async
t
=
>
{
const
[
localPc
remotePc
stream
]
=
await
startConnection
(
t
kind
.
audio
kind
.
video
)
;
const
recorder
=
new
MediaRecorder
(
stream
{
mimeType
}
)
;
/
/
Small
timeslice
(
but
not
too
small
to
be
web
compatible
)
.
recorder
.
start
(
200
)
;
await
new
Promise
(
r
=
>
recorder
.
onstart
=
r
)
;
let
combinedSize
=
0
;
/
/
Wait
for
an
arbitrary
amount
of
data
to
appear
before
we
resolve
.
/
/
Keep
it
small
for
android
tests
while
(
combinedSize
<
2000
)
{
const
{
data
}
=
await
new
Promise
(
r
=
>
recorder
.
ondataavailable
=
r
)
;
combinedSize
+
=
data
.
size
;
}
recorder
.
stop
(
)
;
}
"
PeerConnection
MediaRecorder
receives
data
after
onstart
"
+
formatString
)
;
promise_test
(
async
t
=
>
{
const
[
localPc
remotePc
stream
]
=
await
startConnection
(
t
kind
.
audio
kind
.
video
)
;
const
recorder
=
new
MediaRecorder
(
stream
{
mimeType
}
)
;
recorder
.
start
(
)
;
await
new
Promise
(
r
=
>
recorder
.
onstart
=
r
)
;
await
waitForReceivedFrames
(
t
remotePc
kind
.
audio
kind
.
video
10
)
;
for
(
transceiver
of
remotePc
.
getTransceivers
(
)
)
{
transceiver
.
receiver
.
track
.
stop
(
)
;
}
/
/
As
the
tracks
ended
we
'
d
like
to
see
data
from
the
recorder
.
/
/
For
details
:
/
/
https
:
/
/
www
.
w3
.
org
/
TR
/
mediastream
-
recording
/
#
mediarecorder
-
methods
const
stopPromise
=
new
Promise
(
r
=
>
recorder
.
onstop
=
r
)
;
await
new
Promise
(
r
=
>
recorder
.
ondataavailable
=
r
)
;
await
stopPromise
;
}
"
PeerConnection
MediaRecorder
gets
ondata
on
stopping
recorded
"
+
"
tracks
"
+
formatString
)
;
}
[
{
kind
:
{
video
:
true
audio
:
false
}
mimeType
:
"
"
}
{
kind
:
{
video
:
false
audio
:
true
}
mimeType
:
"
"
}
{
kind
:
{
video
:
true
audio
:
true
}
mimeType
:
"
"
}
]
.
forEach
(
runTests
)
;
[
{
kind
:
{
video
:
false
audio
:
true
}
mimeType
:
"
audio
/
webm
;
codecs
=
opus
"
}
{
kind
:
{
video
:
true
audio
:
false
}
mimeType
:
"
video
/
webm
;
codecs
=
vp8
"
}
{
kind
:
{
video
:
true
audio
:
true
}
mimeType
:
"
video
/
webm
;
codecs
=
vp8
opus
"
}
{
kind
:
{
video
:
true
audio
:
false
}
mimeType
:
"
video
/
webm
;
codecs
=
vp9
"
}
{
kind
:
{
video
:
true
audio
:
true
}
mimeType
:
"
video
/
webm
;
codecs
=
vp9
opus
"
}
]
.
forEach
(
(
{
kind
mimeType
}
)
=
>
{
if
(
MediaRecorder
.
isTypeSupported
(
mimeType
)
)
{
return
runTests
(
{
kind
mimeType
}
)
;
}
const
formatString
=
{
JSON
.
stringify
(
kind
)
}
with
format
{
mimeType
}
.
;
promise_test
(
async
t
=
>
{
const
[
stream
]
=
await
startConnection
(
t
kind
.
audio
kind
.
video
)
;
assert_throws_dom
(
'
NotSupportedError
'
(
)
=
>
{
new
MediaRecorder
(
stream
{
mimeType
}
)
;
}
)
;
}
"
MediaRecorder
constructor
throws
when
not
supporting
"
+
formatString
)
;
}
)
;
<
/
script
>
<
/
body
>
<
/
html
>
