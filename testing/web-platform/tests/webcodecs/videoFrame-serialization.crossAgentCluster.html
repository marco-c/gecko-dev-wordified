<
!
DOCTYPE
html
>
<
html
>
<
head
>
<
script
src
=
'
/
resources
/
testharness
.
js
'
>
<
/
script
>
<
script
src
=
'
/
resources
/
testharnessreport
.
js
'
>
<
/
script
>
<
script
src
=
'
/
common
/
get
-
host
-
info
.
sub
.
js
'
>
<
/
script
>
<
script
src
=
'
/
webcodecs
/
utils
.
js
'
>
<
/
script
>
<
script
id
=
'
workerCode
'
type
=
'
javascript
/
worker
'
>
self
.
onmessage
=
(
e
)
=
>
{
let
frame
=
e
.
data
.
frame
;
if
(
e
.
data
.
transfer
)
{
postMessage
(
frame
[
frame
]
)
;
}
else
{
postMessage
(
frame
)
;
}
}
;
<
/
script
>
<
/
head
>
<
body
>
<
script
>
const
HELPER
=
'
/
webcodecs
/
videoFrame
-
serialization
.
crossAgentCluster
.
helper
.
html
'
;
const
SAMEORIGIN_BASE
=
get_host_info
(
)
.
HTTP_ORIGIN
;
const
CROSSORIGIN_BASE
=
get_host_info
(
)
.
HTTP_NOTSAMESITE_ORIGIN
;
const
SAMEORIGIN_HELPER
=
SAMEORIGIN_BASE
+
HELPER
;
const
CROSSORIGIN_HELPER
=
CROSSORIGIN_BASE
+
HELPER
;
promise_test
(
async
(
)
=
>
{
const
target
=
(
await
appendIframe
(
SAMEORIGIN_HELPER
)
)
.
contentWindow
;
let
frame
=
createVideoFrame
(
10
)
;
assert_true
(
await
canSerializeVideoFrame
(
target
frame
)
)
;
}
'
Verify
frames
can
be
passed
within
the
same
agent
clusters
'
)
;
promise_test
(
async
(
)
=
>
{
const
target
=
(
await
appendIframe
(
CROSSORIGIN_HELPER
)
)
.
contentWindow
;
let
frame
=
createVideoFrame
(
20
)
;
assert_false
(
await
canSerializeVideoFrame
(
target
frame
)
)
;
}
'
Verify
frames
cannot
be
passed
accross
the
different
agent
clusters
'
)
;
promise_test
(
async
(
)
=
>
{
const
blob
=
new
Blob
(
[
document
.
querySelector
(
'
#
workerCode
'
)
.
textContent
]
{
type
:
'
text
/
javascript
'
}
)
;
const
worker
=
new
Worker
(
window
.
URL
.
createObjectURL
(
blob
)
)
;
let
frame
=
createVideoFrame
(
30
)
;
worker
.
postMessage
(
{
frame
:
frame
transfer
:
false
}
)
;
const
received
=
await
new
Promise
(
resolve
=
>
worker
.
onmessage
=
e
=
>
{
resolve
(
e
.
data
)
;
}
)
;
assert_equals
(
received
.
toString
(
)
'
[
object
VideoFrame
]
'
)
;
assert_equals
(
received
.
timestamp
30
)
;
}
'
Verify
frames
can
be
passed
back
and
forth
between
main
and
worker
'
)
;
promise_test
(
async
(
)
=
>
{
const
target
=
(
await
appendIframe
(
SAMEORIGIN_HELPER
)
)
.
contentWindow
;
let
frame
=
createVideoFrame
(
10
)
;
assert_true
(
await
canTransferVideoFrame
(
target
frame
)
)
;
assert_true
(
isFrameClosed
(
frame
)
)
;
}
'
Verify
frames
can
be
transferred
within
the
same
agent
clusters
'
)
;
promise_test
(
async
(
)
=
>
{
const
target
=
(
await
appendIframe
(
CROSSORIGIN_HELPER
)
)
.
contentWindow
;
let
frame
=
createVideoFrame
(
20
)
;
assert_false
(
await
canTransferVideoFrame
(
target
frame
)
)
;
}
'
Verify
frames
cannot
be
transferred
accross
the
different
agent
clusters
'
)
;
promise_test
(
async
(
)
=
>
{
const
blob
=
new
Blob
(
[
document
.
querySelector
(
'
#
workerCode
'
)
.
textContent
]
{
type
:
'
text
/
javascript
'
}
)
;
const
worker
=
new
Worker
(
window
.
URL
.
createObjectURL
(
blob
)
)
;
let
frame
=
createVideoFrame
(
30
)
;
worker
.
postMessage
(
{
frame
:
frame
transfer
:
true
}
[
frame
]
)
;
const
received
=
await
new
Promise
(
resolve
=
>
worker
.
onmessage
=
e
=
>
{
resolve
(
e
.
data
)
;
}
)
;
assert_equals
(
received
.
toString
(
)
'
[
object
VideoFrame
]
'
)
;
assert_equals
(
received
.
timestamp
30
)
;
}
'
Verify
frames
can
be
transferred
back
and
forth
between
main
and
worker
'
)
;
function
appendIframe
(
src
)
{
const
frame
=
document
.
createElement
(
'
iframe
'
)
;
document
.
body
.
appendChild
(
frame
)
;
frame
.
src
=
src
;
return
new
Promise
(
resolve
=
>
frame
.
onload
=
(
)
=
>
resolve
(
frame
)
)
;
}
;
function
createVideoFrame
(
ts
)
{
let
data
=
new
Uint8Array
(
[
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
]
)
;
return
new
VideoFrame
(
data
{
timestamp
:
ts
codedWidth
:
2
codedHeight
:
2
format
:
'
RGBA
'
}
)
;
}
function
canSerializeVideoFrame
(
target
vf
transfer
)
{
return
canPostVideoFrame
(
target
vf
false
)
;
}
;
function
canTransferVideoFrame
(
target
vf
transfer
)
{
return
canPostVideoFrame
(
target
vf
true
)
;
}
;
function
canPostVideoFrame
(
target
vf
transfer
)
{
if
(
transfer
)
{
target
.
postMessage
(
vf
'
*
'
[
vf
]
)
;
assert_true
(
isFrameClosed
(
vf
)
)
;
}
else
{
target
.
postMessage
(
vf
'
*
'
)
;
}
/
/
vf
.
timestamp
doesn
'
t
change
after
vf
is
closed
so
it
'
s
fine
to
use
it
.
target
.
postMessage
(
{
'
id
'
:
vf
.
timestamp
}
'
*
'
)
;
return
new
Promise
(
resolve
=
>
window
.
onmessage
=
e
=
>
{
resolve
(
e
.
data
=
=
'
RECEIVED
'
)
;
}
)
;
}
;
<
/
script
>
<
/
body
>
<
/
html
>
