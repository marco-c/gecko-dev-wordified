<
!
DOCTYPE
html
>
<
html
>
<
head
>
<
script
src
=
'
/
resources
/
testharness
.
js
'
>
<
/
script
>
<
script
src
=
'
/
resources
/
testharnessreport
.
js
'
>
<
/
script
>
<
script
src
=
'
/
common
/
get
-
host
-
info
.
sub
.
js
'
>
<
/
script
>
<
script
id
=
'
workerCode
'
type
=
'
javascript
/
worker
'
>
self
.
onmessage
=
(
e
)
=
>
{
let
img
=
e
.
data
.
img
;
if
(
e
.
data
.
transfer
)
{
postMessage
(
img
[
img
]
)
;
}
else
{
postMessage
(
img
)
;
}
}
;
<
/
script
>
<
script
id
=
'
sharedWorkerCode
'
type
=
'
javascript
/
worker
'
>
let
received
=
new
Map
(
)
;
self
.
onconnect
=
function
(
event
)
{
const
port
=
event
.
ports
[
0
]
;
port
.
onmessage
=
function
(
e
)
{
if
(
e
.
data
.
hasOwnProperty
(
'
id
'
)
)
{
port
.
postMessage
(
received
.
get
(
e
.
data
.
id
)
?
'
RECEIVED
'
:
'
NOT_RECEIVED
'
)
;
return
;
}
if
(
e
.
data
.
toString
(
)
=
=
'
[
object
ImageBitmap
]
'
)
{
received
.
set
(
e
.
data
.
width
e
.
data
)
;
}
}
;
}
;
<
/
script
>
<
/
head
>
<
body
>
<
script
>
const
HELPER
=
'
/
html
/
canvas
/
element
/
manual
/
imagebitmap
/
imagebitmap
-
transfer
.
crossAgentCluster
.
helper
.
html
'
;
const
SAMEORIGIN_BASE
=
get_host_info
(
)
.
HTTPS_ORIGIN
;
const
CROSSORIGIN_BASE
=
get_host_info
(
)
.
HTTPS_NOTSAMESITE_ORIGIN
;
const
SAMEORIGIN_HELPER
=
SAMEORIGIN_BASE
+
HELPER
;
const
CROSSORIGIN_HELPER
=
CROSSORIGIN_BASE
+
HELPER
;
promise_test
(
async
(
)
=
>
{
const
target
=
(
await
appendIframe
(
SAMEORIGIN_HELPER
)
)
.
contentWindow
;
let
img
=
createImageBitmap
(
10
10
)
;
assert_true
(
await
canSerializeImageBitmap
(
target
img
)
)
;
}
'
Verify
imagebitmap
can
be
passed
within
the
same
agent
clusters
'
)
;
promise_test
(
async
(
)
=
>
{
const
target
=
(
await
appendIframe
(
CROSSORIGIN_HELPER
)
)
.
contentWindow
;
let
img
=
createImageBitmap
(
20
20
)
;
assert_false
(
await
canSerializeImageBitmap
(
target
img
)
)
;
}
'
Verify
imagebitmap
cannot
be
passed
accross
the
different
agent
clusters
'
)
;
promise_test
(
async
(
)
=
>
{
const
blob
=
new
Blob
(
[
document
.
querySelector
(
'
#
workerCode
'
)
.
textContent
]
{
type
:
'
text
/
javascript
'
}
)
;
const
worker
=
new
Worker
(
window
.
URL
.
createObjectURL
(
blob
)
)
;
let
img
=
createImageBitmap
(
30
30
)
;
worker
.
postMessage
(
{
img
:
img
transfer
:
false
}
)
;
const
received
=
await
new
Promise
(
resolve
=
>
worker
.
onmessage
=
e
=
>
{
resolve
(
e
.
data
)
;
}
)
;
assert_equals
(
received
.
toString
(
)
'
[
object
ImageBitmap
]
'
)
;
assert_equals
(
received
.
width
30
)
;
}
'
Verify
imagebitmap
can
be
passed
back
and
forth
between
main
and
worker
'
)
;
promise_test
(
async
(
)
=
>
{
const
blob
=
new
Blob
(
[
document
.
querySelector
(
'
#
sharedWorkerCode
'
)
.
textContent
]
{
type
:
'
text
/
javascript
'
}
)
;
const
worker
=
new
SharedWorker
(
window
.
URL
.
createObjectURL
(
blob
)
)
;
let
img
=
createImageBitmap
(
40
40
)
;
worker
.
port
.
postMessage
(
img
)
;
worker
.
port
.
postMessage
(
{
'
id
'
:
40
}
)
;
const
received
=
await
new
Promise
(
resolve
=
>
worker
.
port
.
onmessage
=
e
=
>
{
resolve
(
e
.
data
)
;
}
)
;
assert_equals
(
received
'
RECEIVED
'
)
;
}
'
Verify
imagebitmap
can
be
passed
to
sharedworker
'
)
;
promise_test
(
async
(
)
=
>
{
const
target
=
(
await
appendIframe
(
SAMEORIGIN_HELPER
)
)
.
contentWindow
;
let
img
=
createImageBitmap
(
50
50
)
;
assert_true
(
await
canTransferImageBitmap
(
target
img
)
)
;
assert_true
(
isImageBitmapClosed
(
img
)
)
;
}
'
Verify
imagebitmap
can
be
transferred
within
the
same
agent
clusters
'
)
;
promise_test
(
async
(
)
=
>
{
const
target
=
(
await
appendIframe
(
CROSSORIGIN_HELPER
)
)
.
contentWindow
;
let
img
=
createImageBitmap
(
60
60
)
;
assert_false
(
await
canTransferImageBitmap
(
target
img
)
)
;
}
'
Verify
imagebitmap
cannot
be
transferred
accross
the
different
agent
clusters
'
)
;
promise_test
(
async
(
)
=
>
{
const
blob
=
new
Blob
(
[
document
.
querySelector
(
'
#
workerCode
'
)
.
textContent
]
{
type
:
'
text
/
javascript
'
}
)
;
const
worker
=
new
Worker
(
window
.
URL
.
createObjectURL
(
blob
)
)
;
let
img
=
createImageBitmap
(
70
70
)
;
worker
.
postMessage
(
{
img
:
img
transfer
:
true
}
[
img
]
)
;
const
received
=
await
new
Promise
(
resolve
=
>
worker
.
onmessage
=
e
=
>
{
resolve
(
e
.
data
)
;
}
)
;
assert_equals
(
received
.
toString
(
)
'
[
object
ImageBitmap
]
'
)
;
assert_equals
(
received
.
width
70
)
;
}
'
Verify
imagebitmap
can
be
transferred
back
and
forth
between
main
and
worker
'
)
;
promise_test
(
async
(
)
=
>
{
const
blob
=
new
Blob
(
[
document
.
querySelector
(
'
#
sharedWorkerCode
'
)
.
textContent
]
{
type
:
'
text
/
javascript
'
}
)
;
const
worker
=
new
SharedWorker
(
window
.
URL
.
createObjectURL
(
blob
)
)
;
let
img
=
createImageBitmap
(
80
80
)
;
worker
.
port
.
postMessage
(
img
[
img
]
)
;
worker
.
port
.
postMessage
(
{
'
id
'
:
80
}
)
;
const
received
=
await
new
Promise
(
resolve
=
>
worker
.
port
.
onmessage
=
e
=
>
{
resolve
(
e
.
data
)
;
}
)
;
assert_equals
(
received
'
RECEIVED
'
)
;
}
'
Verify
imagebitmap
can
be
transferred
to
a
sharedworker
'
)
;
function
appendIframe
(
src
)
{
const
frame
=
document
.
createElement
(
'
iframe
'
)
;
document
.
body
.
appendChild
(
frame
)
;
frame
.
src
=
src
;
return
new
Promise
(
resolve
=
>
frame
.
onload
=
(
)
=
>
resolve
(
frame
)
)
;
}
;
function
createImageBitmap
(
w
h
)
{
let
canvas
=
new
OffscreenCanvas
(
w
h
)
;
let
ctx
=
canvas
.
getContext
(
'
2d
'
)
;
ctx
.
fillStyle
=
'
rgba
(
50
100
150
255
)
'
;
ctx
.
fillRect
(
0
0
w
h
)
;
return
canvas
.
transferToImageBitmap
(
)
;
}
function
canSerializeImageBitmap
(
target
img
)
{
return
canPostImageBitmap
(
target
img
false
)
;
}
;
function
canTransferImageBitmap
(
target
img
)
{
return
canPostImageBitmap
(
target
img
true
)
;
}
;
function
canPostImageBitmap
(
target
img
transfer
)
{
let
id
=
img
.
width
;
if
(
transfer
)
{
target
.
postMessage
(
img
'
*
'
[
img
]
)
;
assert_true
(
isImageBitmapClosed
(
img
)
)
;
}
else
{
target
.
postMessage
(
img
'
*
'
)
;
}
target
.
postMessage
(
{
'
id
'
:
id
}
'
*
'
)
;
return
new
Promise
(
resolve
=
>
window
.
onmessage
=
e
=
>
{
resolve
(
e
.
data
=
=
'
RECEIVED
'
)
;
}
)
;
}
;
function
isImageBitmapClosed
(
img
)
{
return
img
.
width
=
=
0
&
&
img
.
height
=
=
0
;
}
<
/
script
>
<
/
body
>
<
/
html
>
