<
!
doctype
html
>
<
meta
charset
=
utf
-
8
>
<
meta
name
=
"
timeout
"
content
=
"
long
"
>
<
title
>
RTCDataChannel
.
prototype
.
close
<
/
title
>
<
script
src
=
"
/
resources
/
testharness
.
js
"
>
<
/
script
>
<
script
src
=
"
/
resources
/
testharnessreport
.
js
"
>
<
/
script
>
<
script
src
=
"
RTCPeerConnection
-
helper
.
js
"
>
<
/
script
>
<
script
>
'
use
strict
'
;
promise_test
(
async
t
=
>
{
let
pc1
=
new
RTCPeerConnection
(
)
;
t
.
add_cleanup
(
(
)
=
>
pc1
.
close
(
)
)
;
let
[
channel1
channel2
]
=
await
createDataChannelPair
(
pc1
)
;
let
close_handler
=
new
Promise
(
resolve
=
>
{
channel2
.
onclose
=
event
=
>
{
resolve
(
)
;
}
;
}
)
;
channel2
.
addEventListener
(
'
error
'
t
.
unreached_func
(
)
)
;
channel1
.
close
(
)
;
await
close_handler
;
}
'
Close
datachannel
causes
onclose
to
be
called
'
)
;
promise_test
(
async
t
=
>
{
/
/
This
is
the
same
test
as
above
but
using
addEventListener
/
/
rather
than
the
"
onclose
"
attribute
.
let
pc1
=
new
RTCPeerConnection
(
)
;
t
.
add_cleanup
(
(
)
=
>
pc1
.
close
(
)
)
;
let
[
channel1
channel2
]
=
await
createDataChannelPair
(
pc1
)
;
let
close_handler
=
new
Promise
(
resolve
=
>
{
channel2
.
addEventListener
(
'
close
'
event
=
>
{
resolve
(
)
;
}
)
;
}
)
;
channel2
.
addEventListener
(
'
error
'
t
.
unreached_func
(
)
)
;
channel1
.
close
(
)
;
await
close_handler
;
}
'
Close
datachannel
causes
close
event
to
be
called
'
)
;
promise_test
(
async
t
=
>
{
let
pc1
=
new
RTCPeerConnection
(
)
;
t
.
add_cleanup
(
(
)
=
>
pc1
.
close
(
)
)
;
let
[
channel1
channel2
]
=
await
createDataChannelPair
(
pc1
)
;
let
close_handler
=
new
Promise
(
resolve
=
>
{
channel2
.
addEventListener
(
'
close
'
event
=
>
{
resolve
(
)
;
}
)
;
}
)
;
pc1
.
close
(
)
;
await
close_handler
;
}
'
Close
peerconnection
causes
close
event
to
be
called
'
)
;
<
/
script
>
