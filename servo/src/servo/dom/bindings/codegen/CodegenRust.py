#
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
#
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
file
#
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
#
Common
codegen
classes
.
import
os
import
string
import
operator
from
WebIDL
import
*
from
Configuration
import
NoSuchDescriptorError
AUTOGENERATED_WARNING_COMMENT
=
\
    
"
/
*
THIS
FILE
IS
AUTOGENERATED
-
DO
NOT
EDIT
*
/
\
n
\
n
"
ADDPROPERTY_HOOK_NAME
=
'
_addProperty
'
FINALIZE_HOOK_NAME
=
'
_finalize
'
TRACE_HOOK_NAME
=
'
_trace
'
CONSTRUCT_HOOK_NAME
=
'
_constructor
'
HASINSTANCE_HOOK_NAME
=
'
_hasInstance
'
def
replaceFileIfChanged
(
filename
newContents
)
:
    
"
"
"
    
Read
a
copy
of
the
old
file
so
that
we
don
'
t
touch
it
if
it
hasn
'
t
changed
.
    
Returns
True
if
the
file
was
updated
false
otherwise
.
    
"
"
"
    
oldFileContents
=
"
"
    
try
:
        
oldFile
=
open
(
filename
'
rb
'
)
        
oldFileContents
=
'
'
.
join
(
oldFile
.
readlines
(
)
)
        
oldFile
.
close
(
)
    
except
:
        
pass
    
if
newContents
=
=
oldFileContents
:
        
return
False
    
f
=
open
(
filename
'
wb
'
)
    
f
.
write
(
newContents
)
    
f
.
close
(
)
def
toStringBool
(
arg
)
:
    
return
str
(
not
not
arg
)
.
lower
(
)
def
toBindingNamespace
(
arg
)
:
    
return
re
.
sub
(
"
(
(
_workers
)
?
)
"
"
Binding
\
\
1
"
arg
)
;
def
stripTrailingWhitespace
(
text
)
:
    
tail
=
'
\
n
'
if
text
.
endswith
(
'
\
n
'
)
else
'
'
    
lines
=
text
.
splitlines
(
)
    
for
i
in
range
(
len
(
lines
)
)
:
        
lines
[
i
]
=
lines
[
i
]
.
rstrip
(
)
    
return
'
\
n
'
.
join
(
lines
)
+
tail
def
MakeNativeName
(
name
)
:
    
return
name
[
0
]
.
upper
(
)
+
name
[
1
:
]
builtinNames
=
{
    
IDLType
.
Tags
.
bool
:
'
bool
'
    
IDLType
.
Tags
.
int8
:
'
i8
'
    
IDLType
.
Tags
.
int16
:
'
i16
'
    
IDLType
.
Tags
.
int32
:
'
i32
'
    
IDLType
.
Tags
.
int64
:
'
i64
'
    
IDLType
.
Tags
.
uint8
:
'
u8
'
    
IDLType
.
Tags
.
uint16
:
'
u16
'
    
IDLType
.
Tags
.
uint32
:
'
u32
'
    
IDLType
.
Tags
.
uint64
:
'
u64
'
    
IDLType
.
Tags
.
float
:
'
f32
'
    
IDLType
.
Tags
.
double
:
'
f64
'
}
class
CastableObjectUnwrapper
(
)
:
    
"
"
"
    
A
class
for
unwrapping
an
object
named
by
the
"
source
"
argument
    
based
on
the
passed
-
in
descriptor
and
storing
it
in
a
variable
    
called
by
the
name
in
the
"
target
"
argument
.
    
codeOnFailure
is
the
code
to
run
if
unwrapping
fails
.
    
"
"
"
    
def
__init__
(
self
descriptor
source
target
codeOnFailure
)
:
        
assert
descriptor
.
castable
        
self
.
substitution
=
{
"
type
"
:
descriptor
.
pointerType
+
descriptor
.
nativeType
                              
"
protoID
"
:
0
#
"
prototypes
:
:
id
:
:
"
+
descriptor
.
name
                              
"
source
"
:
source
                              
"
target
"
:
target
                              
"
codeOnFailure
"
:
CGIndenter
(
CGGeneric
(
codeOnFailure
)
4
)
.
define
(
)
}
        
if
descriptor
.
hasXPConnectImpls
:
            
#
We
don
'
t
use
xpc_qsUnwrapThis
because
it
will
always
throw
on
            
#
unwrap
failure
whereas
we
want
to
control
whether
we
throw
or
            
#
not
.
            
self
.
substitution
[
"
codeOnFailure
"
]
=
CGIndenter
(
CGGeneric
(
string
.
Template
(
                
"
{
type
}
*
objPtr
;
\
n
"
                
"
xpc_qsSelfRef
objRef
;
\
n
"
                
"
JS
:
:
Value
val
=
JS
:
:
ObjectValue
(
*
{
source
}
)
;
\
n
"
                
"
nsresult
rv
=
xpc_qsUnwrapArg
<
{
type
}
>
(
cx
val
&
objPtr
&
objRef
.
ptr
&
val
)
;
\
n
"
                
"
if
(
NS_FAILED
(
rv
)
)
{
\
n
"
                
"
{
codeOnFailure
}
\
n
"
                
"
}
\
n
"
                
"
/
/
We
should
be
castable
!
\
n
"
                
"
MOZ_ASSERT
(
!
objRef
.
ptr
)
;
\
n
"
                
"
/
/
We
should
have
an
object
too
!
\
n
"
                
"
MOZ_ASSERT
(
objPtr
)
;
\
n
"
                
"
{
target
}
=
objPtr
;
"
)
.
substitute
(
self
.
substitution
)
)
4
)
.
define
(
)
    
def
__str__
(
self
)
:
        
return
string
.
Template
(
"
"
"
{
target
}
=
unwrap
:
:
<
{
type
}
>
(
{
source
}
)
;
"
"
"
)
.
substitute
(
self
.
substitution
)
#
"
"
"
{
#
nsresult
rv
=
UnwrapObject
<
{
protoID
}
{
type
}
>
(
cx
{
source
}
{
target
}
)
;
#
if
(
NS_FAILED
(
rv
)
)
{
#
{
codeOnFailure
}
#
}
#
}
"
"
"
)
.
substitute
(
self
.
substitution
)
class
FakeCastableDescriptor
(
)
:
    
def
__init__
(
self
descriptor
)
:
        
self
.
castable
=
True
        
self
.
workers
=
descriptor
.
workers
        
self
.
nativeType
=
descriptor
.
nativeType
        
self
.
pointerType
=
descriptor
.
pointerType
        
self
.
name
=
descriptor
.
name
        
self
.
hasXPConnectImpls
=
descriptor
.
hasXPConnectImpls
def
getWrapTemplateForType
(
type
descriptorProvider
result
successCode
                           
isCreator
)
:
    
"
"
"
    
Reflect
a
C
+
+
value
stored
in
"
result
"
of
IDL
type
"
type
"
into
JS
.
The
    
"
successCode
"
is
the
code
to
run
once
we
have
successfully
done
the
    
conversion
.
The
resulting
string
should
be
used
with
string
.
Template
it
    
needs
the
following
keys
when
substituting
:
jsvalPtr
/
jsvalRef
/
obj
.
    
Returns
(
templateString
infallibility
of
conversion
template
)
    
"
"
"
    
haveSuccessCode
=
successCode
is
not
None
    
if
not
haveSuccessCode
:
        
successCode
=
"
return
true
;
"
    
def
setValue
(
value
callWrapValue
=
False
)
:
        
"
"
"
        
Returns
the
code
to
set
the
jsval
to
value
.
If
"
callWrapValue
"
is
true
        
JS_WrapValue
will
be
called
on
the
jsval
.
        
"
"
"
        
if
not
callWrapValue
:
            
tail
=
successCode
        
elif
haveSuccessCode
:
            
tail
=
(
"
if
(
!
JS_WrapValue
(
cx
{
jsvalPtr
}
)
)
{
\
n
"
+
                    
"
return
false
;
\
n
"
+
                    
"
}
\
n
"
+
                    
successCode
)
        
else
:
            
tail
=
"
return
JS_WrapValue
(
cx
{
jsvalPtr
}
)
;
"
        
return
(
"
{
jsvalRef
}
=
%
s
;
\
n
"
+
                
tail
)
%
(
value
)
    
def
wrapAndSetPtr
(
wrapCall
failureCode
=
None
)
:
        
"
"
"
        
Returns
the
code
to
set
the
jsval
by
calling
"
wrapCall
"
.
"
failureCode
"
        
is
the
code
to
run
if
calling
"
wrapCall
"
fails
        
"
"
"
        
if
failureCode
is
None
:
            
if
not
haveSuccessCode
:
                
return
"
return
"
+
wrapCall
+
"
;
"
            
failureCode
=
"
return
false
;
"
        
str
=
(
"
if
(
!
%
s
)
{
\
n
"
+
               
CGIndenter
(
CGGeneric
(
failureCode
)
)
.
define
(
)
+
"
\
n
"
+
               
"
}
\
n
"
+
               
successCode
)
%
(
wrapCall
)
        
return
str
    
if
type
is
None
or
type
.
isVoid
(
)
:
        
return
(
setValue
(
"
JSVAL_VOID
"
)
True
)
    
if
type
.
isArray
(
)
:
        
raise
TypeError
(
"
Can
'
t
handle
array
return
values
yet
"
)
    
if
type
.
isSequence
(
)
:
        
if
type
.
nullable
(
)
:
            
#
Nullable
sequences
are
Nullable
<
nsTArray
<
T
>
>
            
(
recTemplate
recInfall
)
=
getWrapTemplateForType
(
type
.
inner
descriptorProvider
                                                              
"
%
s
.
Value
(
)
"
%
result
successCode
                                                              
isCreator
)
            
return
(
"
"
"
if
(
%
s
.
IsNull
(
)
)
{
%
s
}
%
s
"
"
"
%
(
result
CGIndenter
(
CGGeneric
(
setValue
(
"
JSVAL_NULL
"
)
)
)
.
define
(
)
recTemplate
)
recInfall
)
        
#
Now
do
non
-
nullable
sequences
.
We
use
setting
the
element
        
#
in
the
array
as
our
succcess
code
because
when
we
succeed
in
        
#
wrapping
that
'
s
what
we
should
do
.
        
innerTemplate
=
wrapForType
(
            
type
.
inner
descriptorProvider
            
{
                
'
result
'
:
"
%
s
[
i
]
"
%
result
                
'
successCode
'
:
(
"
if
(
!
JS_DefineElement
(
cx
returnArray
i
tmp
\
n
"
                                
"
NULL
NULL
JSPROP_ENUMERATE
)
)
{
\
n
"
                                
"
return
false
;
\
n
"
                                
"
}
"
)
                
'
jsvalRef
'
:
"
tmp
"
                
'
jsvalPtr
'
:
"
&
tmp
"
                
'
isCreator
'
:
isCreator
                
}
            
)
        
innerTemplate
=
CGIndenter
(
CGGeneric
(
innerTemplate
)
)
.
define
(
)
        
return
(
(
"
"
"
uint32_t
length
=
%
s
.
Length
(
)
;
JSObject
*
returnArray
=
JS_NewArrayObject
(
cx
length
NULL
)
;
if
(
!
returnArray
)
{
  
return
false
;
}
jsval
tmp
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
%
s
}
\
n
"
"
"
%
(
result
innerTemplate
)
)
+
setValue
(
"
JS
:
:
ObjectValue
(
*
returnArray
)
"
)
False
)
    
if
type
.
isGeckoInterface
(
)
:
        
descriptor
=
descriptorProvider
.
getDescriptor
(
type
.
unroll
(
)
.
inner
.
identifier
.
name
)
        
if
type
.
nullable
(
)
:
            
wrappingCode
=
(
"
if
(
!
%
s
)
{
\
n
"
%
(
result
)
+
                            
CGIndenter
(
CGGeneric
(
setValue
(
"
JSVAL_NULL
"
)
)
)
.
define
(
)
+
"
\
n
"
+
                            
"
}
\
n
"
)
        
else
:
            
wrappingCode
=
"
"
        
if
(
not
descriptor
.
interface
.
isExternal
(
)
and
            
not
descriptor
.
interface
.
isCallback
(
)
)
:
            
if
descriptor
.
wrapperCache
:
                
wrapMethod
=
"
WrapNewBindingObject
"
            
else
:
                
if
not
isCreator
:
                    
raise
MethodNotCreatorError
(
descriptor
.
interface
.
identifier
.
name
)
                
wrapMethod
=
"
WrapNewBindingNonWrapperCachedObject
"
            
wrap
=
"
%
s
(
cx
{
obj
}
%
s
{
jsvalPtr
}
)
"
%
(
wrapMethod
result
)
            
#
We
don
'
t
support
prefable
stuff
in
workers
.
            
assert
(
not
descriptor
.
prefable
or
not
descriptor
.
workers
)
            
if
not
descriptor
.
prefable
:
                
#
Non
-
prefable
bindings
can
only
fail
to
wrap
as
a
new
-
binding
object
                
#
if
they
already
threw
an
exception
.
Same
thing
for
                
#
non
-
prefable
bindings
.
                
failed
=
(
"
MOZ_ASSERT
(
JS_IsExceptionPending
(
cx
)
)
;
\
n
"
+
                          
"
return
false
;
"
)
            
else
:
                
if
descriptor
.
notflattened
:
                    
raise
TypeError
(
"
%
s
is
prefable
but
not
flattened
;
"
                                    
"
fallback
won
'
t
work
correctly
"
%
                                    
descriptor
.
interface
.
identifier
.
name
)
                
#
Try
old
-
style
wrapping
for
bindings
which
might
be
preffed
off
.
                
failed
=
wrapAndSetPtr
(
"
HandleNewBindingWrappingFailure
(
cx
{
obj
}
%
s
{
jsvalPtr
}
)
"
%
result
)
            
wrappingCode
+
=
wrapAndSetPtr
(
wrap
failed
)
        
else
:
            
if
descriptor
.
notflattened
:
                
getIID
=
"
&
NS_GET_IID
(
%
s
)
"
%
descriptor
.
nativeType
            
else
:
                
getIID
=
"
"
            
wrap
=
"
WrapObject
(
cx
{
obj
}
%
s
%
s
{
jsvalPtr
}
)
"
%
(
result
getIID
)
            
wrappingCode
+
=
wrapAndSetPtr
(
wrap
)
        
return
(
wrappingCode
False
)
    
if
type
.
isString
(
)
:
        
if
type
.
nullable
(
)
:
            
return
(
wrapAndSetPtr
(
"
xpc
:
:
StringToJsval
(
cx
%
s
{
jsvalPtr
}
)
"
%
result
)
False
)
        
else
:
            
return
(
wrapAndSetPtr
(
"
xpc
:
:
NonVoidStringToJsval
(
cx
%
s
{
jsvalPtr
}
)
"
%
result
)
False
)
    
if
type
.
isEnum
(
)
:
        
if
type
.
nullable
(
)
:
            
raise
TypeError
(
"
We
don
'
t
support
nullable
enumerated
return
types
"
                            
"
yet
"
)
        
return
(
"
"
"
MOZ_ASSERT
(
uint32_t
(
%
(
result
)
s
)
<
ArrayLength
(
%
(
strings
)
s
)
)
;
JSString
*
%
(
resultStr
)
s
=
JS_NewStringCopyN
(
cx
%
(
strings
)
s
[
uint32_t
(
%
(
result
)
s
)
]
.
value
%
(
strings
)
s
[
uint32_t
(
%
(
result
)
s
)
]
.
length
)
;
if
(
!
%
(
resultStr
)
s
)
{
  
return
false
;
}
"
"
"
%
{
"
result
"
:
result
        
"
resultStr
"
:
result
+
"
_str
"
        
"
strings
"
:
type
.
inner
.
identifier
.
name
+
"
Values
:
:
strings
"
}
+
        
setValue
(
"
JS
:
:
StringValue
(
%
s_str
)
"
%
result
)
False
)
    
if
type
.
isCallback
(
)
:
        
assert
not
type
.
isInterface
(
)
        
#
XXXbz
we
'
re
going
to
assume
that
callback
types
are
always
        
#
nullable
and
always
have
[
TreatNonCallableAsNull
]
for
now
.
        
#
See
comments
in
WrapNewBindingObject
explaining
why
we
need
        
#
to
wrap
here
.
        
#
NB
:
setValue
(
.
.
.
True
)
calls
JS_WrapValue
(
)
so
is
fallible
        
return
(
setValue
(
"
JS
:
:
ObjectOrNullValue
(
%
s
)
"
%
result
True
)
False
)
    
if
type
.
tag
(
)
=
=
IDLType
.
Tags
.
any
:
        
#
See
comments
in
WrapNewBindingObject
explaining
why
we
need
        
#
to
wrap
here
.
        
#
NB
:
setValue
(
.
.
.
True
)
calls
JS_WrapValue
(
)
so
is
fallible
        
return
(
setValue
(
result
True
)
False
)
    
if
type
.
isObject
(
)
or
type
.
isSpiderMonkeyInterface
(
)
:
        
#
See
comments
in
WrapNewBindingObject
explaining
why
we
need
        
#
to
wrap
here
.
        
if
type
.
nullable
(
)
:
            
toValue
=
"
JS
:
:
ObjectOrNullValue
(
%
s
)
"
        
else
:
            
toValue
=
"
JS
:
:
ObjectValue
(
*
%
s
)
"
        
#
NB
:
setValue
(
.
.
.
True
)
calls
JS_WrapValue
(
)
so
is
fallible
        
return
(
setValue
(
toValue
%
result
True
)
False
)
    
if
not
type
.
isPrimitive
(
)
:
        
raise
TypeError
(
"
Need
to
learn
to
wrap
%
s
"
%
type
)
    
if
type
.
nullable
(
)
:
        
(
recTemplate
recInfal
)
=
getWrapTemplateForType
(
type
.
inner
descriptorProvider
                                                         
"
%
s
.
Value
(
)
"
%
result
successCode
                                                         
isCreator
)
        
return
(
"
if
(
%
s
.
IsNull
(
)
)
{
\
n
"
%
result
+
                
CGIndenter
(
CGGeneric
(
setValue
(
"
JSVAL_NULL
"
)
)
)
.
define
(
)
+
"
\
n
"
+
                
"
}
\
n
"
+
recTemplate
recInfal
)
    
tag
=
type
.
tag
(
)
    
if
tag
in
[
IDLType
.
Tags
.
int8
IDLType
.
Tags
.
uint8
IDLType
.
Tags
.
int16
               
IDLType
.
Tags
.
uint16
IDLType
.
Tags
.
int32
]
:
        
return
(
setValue
(
"
RUST_INT_TO_JSVAL
(
%
s
as
i32
)
"
%
result
)
True
)
    
elif
tag
in
[
IDLType
.
Tags
.
int64
IDLType
.
Tags
.
uint64
IDLType
.
Tags
.
float
                 
IDLType
.
Tags
.
double
]
:
        
#
XXXbz
will
cast
to
double
do
the
"
even
significand
"
thing
that
webidl
        
#
calls
for
for
64
-
bit
ints
?
Do
we
care
?
        
return
(
setValue
(
"
RUST_JS_NumberValue
(
%
s
as
f64
)
"
%
result
)
True
)
    
elif
tag
=
=
IDLType
.
Tags
.
uint32
:
        
return
(
setValue
(
"
RUST_UINT_TO_JSVAL
(
%
s
)
"
%
result
)
True
)
    
elif
tag
=
=
IDLType
.
Tags
.
bool
:
        
return
(
setValue
(
"
RUST_BOOLEAN_TO_JSVAL
(
%
s
)
"
%
result
)
True
)
    
else
:
        
raise
TypeError
(
"
Need
to
learn
to
wrap
primitive
:
%
s
"
%
type
)
def
wrapForType
(
type
descriptorProvider
templateValues
)
:
    
"
"
"
    
Reflect
a
C
+
+
value
of
IDL
type
"
type
"
into
JS
.
TemplateValues
is
a
dict
    
that
should
contain
:
      
*
'
jsvalRef
'
:
a
C
+
+
reference
to
the
jsval
in
which
to
store
the
result
of
                    
the
conversion
      
*
'
jsvalPtr
'
:
a
C
+
+
pointer
to
the
jsval
in
which
to
store
the
result
of
                    
the
conversion
      
*
'
obj
'
(
optional
)
:
the
name
of
the
variable
that
contains
the
JSObject
to
                          
use
as
a
scope
when
wrapping
if
not
supplied
'
obj
'
                          
will
be
used
as
the
name
      
*
'
result
'
(
optional
)
:
the
name
of
the
variable
in
which
the
C
+
+
value
is
                             
stored
if
not
supplied
'
result
'
will
be
used
as
                             
the
name
      
*
'
successCode
'
(
optional
)
:
the
code
to
run
once
we
have
successfully
done
                                  
the
conversion
if
not
supplied
'
return
true
;
'
                                  
will
be
used
as
the
code
      
*
'
isCreator
'
(
optional
)
:
If
true
we
'
re
wrapping
for
the
return
value
of
                                
a
[
Creator
]
method
.
Assumed
false
if
not
set
.
    
"
"
"
    
wrap
=
getWrapTemplateForType
(
type
descriptorProvider
                                  
templateValues
.
get
(
'
result
'
'
result
'
)
                                  
templateValues
.
get
(
'
successCode
'
None
)
                                  
templateValues
.
get
(
'
isCreator
'
False
)
)
[
0
]
    
defaultValues
=
{
'
obj
'
:
'
obj
'
}
    
return
string
.
Template
(
wrap
)
.
substitute
(
defaultValues
*
*
templateValues
)
def
typeNeedsCx
(
type
retVal
=
False
)
:
    
if
type
is
None
:
        
return
False
    
if
type
.
nullable
(
)
:
        
type
=
type
.
inner
    
if
type
.
isSequence
(
)
or
type
.
isArray
(
)
:
        
type
=
type
.
inner
    
if
type
.
isUnion
(
)
:
        
return
any
(
typeNeedsCx
(
t
)
for
t
in
type
.
unroll
(
)
.
flatMemberTypes
)
    
if
retVal
and
type
.
isSpiderMonkeyInterface
(
)
:
        
return
True
    
return
type
.
isCallback
(
)
or
type
.
isAny
(
)
or
type
.
isObject
(
)
def
memberIsCreator
(
member
)
:
    
return
member
.
getExtendedAttribute
(
"
Creator
"
)
is
not
None
#
Returns
a
tuple
consisting
of
a
CGThing
containing
the
type
of
the
return
#
value
or
None
if
there
is
no
need
for
a
return
value
and
a
boolean
signaling
#
whether
the
return
value
is
passed
in
an
out
parameter
.
def
getRetvalDeclarationForType
(
returnType
descriptorProvider
                                
resultAlreadyAddRefed
)
:
    
if
returnType
is
None
or
returnType
.
isVoid
(
)
:
        
#
Nothing
to
declare
        
return
None
False
    
if
returnType
.
isPrimitive
(
)
and
returnType
.
tag
(
)
in
builtinNames
:
        
result
=
CGGeneric
(
builtinNames
[
returnType
.
tag
(
)
]
)
        
if
returnType
.
nullable
(
)
:
            
result
=
CGWrapper
(
result
pre
=
"
Nullable
<
"
post
=
"
>
"
)
        
return
result
False
    
if
returnType
.
isString
(
)
:
        
return
CGGeneric
(
"
nsString
"
)
True
    
if
returnType
.
isEnum
(
)
:
        
if
returnType
.
nullable
(
)
:
            
raise
TypeError
(
"
We
don
'
t
support
nullable
enum
return
values
"
)
        
return
CGGeneric
(
returnType
.
inner
.
identifier
.
name
)
False
    
if
returnType
.
isGeckoInterface
(
)
:
        
result
=
CGGeneric
(
descriptorProvider
.
getDescriptor
(
            
returnType
.
unroll
(
)
.
inner
.
identifier
.
name
)
.
nativeType
)
        
if
resultAlreadyAddRefed
:
            
result
=
CGWrapper
(
result
pre
=
"
nsRefPtr
<
"
post
=
"
>
"
)
        
else
:
            
result
=
CGWrapper
(
result
post
=
"
*
"
)
        
return
result
False
    
if
returnType
.
isCallback
(
)
:
        
#
XXXbz
we
'
re
going
to
assume
that
callback
types
are
always
        
#
nullable
for
now
.
        
return
CGGeneric
(
"
*
JSObject
"
)
False
    
if
returnType
.
isAny
(
)
:
        
return
CGGeneric
(
"
JSVal
"
)
False
    
if
returnType
.
isObject
(
)
or
returnType
.
isSpiderMonkeyInterface
(
)
:
        
return
CGGeneric
(
"
*
JSObject
"
)
False
    
if
returnType
.
isSequence
(
)
:
        
nullable
=
returnType
.
nullable
(
)
        
if
nullable
:
            
returnType
=
returnType
.
inner
        
#
If
our
result
is
already
addrefed
use
the
right
type
in
the
        
#
sequence
argument
here
.
        
(
result
_
)
=
getRetvalDeclarationForType
(
returnType
.
inner
                                                  
descriptorProvider
                                                  
resultAlreadyAddRefed
)
        
result
=
CGWrapper
(
result
pre
=
"
nsTArray
<
"
post
=
"
>
"
)
        
if
nullable
:
            
result
=
CGWrapper
(
result
pre
=
"
Nullable
<
"
post
=
"
>
"
)
        
return
result
True
    
raise
TypeError
(
"
Don
'
t
know
how
to
declare
return
value
for
%
s
"
%
                    
returnType
)
def
isChromeOnly
(
m
)
:
    
return
m
.
getExtendedAttribute
(
"
ChromeOnly
"
)
class
PropertyDefiner
:
    
"
"
"
    
A
common
superclass
for
defining
things
on
prototype
objects
.
    
Subclasses
should
implement
generateArray
to
generate
the
actual
arrays
of
    
things
we
'
re
defining
.
They
should
also
set
self
.
chrome
to
the
list
of
    
things
exposed
to
chrome
and
self
.
regular
to
the
list
of
things
exposed
to
    
web
pages
.
self
.
chrome
must
be
a
superset
of
self
.
regular
but
also
include
    
all
the
ChromeOnly
stuff
.
    
"
"
"
    
def
__init__
(
self
descriptor
name
)
:
        
self
.
descriptor
=
descriptor
        
self
.
name
=
name
        
#
self
.
prefCacheData
will
store
an
array
of
(
prefname
bool
*
)
        
#
pairs
for
our
bool
var
caches
.
generateArray
will
fill
it
        
#
in
as
needed
.
        
self
.
prefCacheData
=
[
]
    
def
hasChromeOnly
(
self
)
:
        
return
len
(
self
.
chrome
)
>
len
(
self
.
regular
)
    
def
hasNonChromeOnly
(
self
)
:
        
return
len
(
self
.
regular
)
>
0
    
def
variableName
(
self
chrome
)
:
        
if
chrome
and
self
.
hasChromeOnly
(
)
:
            
return
"
sChrome
"
+
self
.
name
        
if
self
.
hasNonChromeOnly
(
)
:
            
return
"
s
"
+
self
.
name
        
return
"
ptr
:
:
null
(
)
"
    
def
usedForXrays
(
self
chrome
)
:
        
#
We
only
need
Xrays
for
methods
attributes
and
constants
.
And
we
only
        
#
need
them
for
the
non
-
chrome
ones
if
we
have
no
chromeonly
things
.
        
#
Otherwise
(
we
have
chromeonly
attributes
)
we
need
Xrays
for
the
chrome
        
#
methods
/
attributes
/
constants
.
Finally
in
workers
there
are
no
Xrays
.
        
return
(
(
self
.
name
is
"
Methods
"
or
self
.
name
is
"
Attributes
"
or
                 
self
.
name
is
"
Constants
"
)
and
                
chrome
=
=
self
.
hasChromeOnly
(
)
and
                
not
self
.
descriptor
.
workers
)
    
def
__str__
(
self
)
:
        
#
We
only
need
to
generate
id
arrays
for
things
that
will
end
        
#
up
used
via
ResolveProperty
or
EnumerateProperties
.
        
str
=
self
.
generateArray
(
self
.
regular
self
.
variableName
(
False
)
                                 
self
.
usedForXrays
(
False
)
)
        
if
self
.
hasChromeOnly
(
)
:
            
str
+
=
self
.
generateArray
(
self
.
chrome
self
.
variableName
(
True
)
                                      
self
.
usedForXrays
(
True
)
)
        
return
str
    
staticmethod
    
def
getControllingPref
(
interfaceMember
)
:
        
prefName
=
interfaceMember
.
getExtendedAttribute
(
"
Pref
"
)
        
if
prefName
is
None
:
            
return
None
        
#
It
'
s
a
list
of
strings
        
assert
(
len
(
prefName
)
is
1
)
        
assert
(
prefName
[
0
]
is
not
None
)
        
return
prefName
[
0
]
    
def
generatePrefableArray
(
self
array
name
specTemplate
specTerminator
                              
specType
getPref
getDataTuple
doIdArrays
)
:
        
"
"
"
        
This
method
generates
our
various
arrays
.
        
array
is
an
array
of
interface
members
as
passed
to
generateArray
        
name
is
the
name
as
passed
to
generateArray
        
specTemplate
is
a
template
for
each
entry
of
the
spec
array
        
specTerminator
is
a
terminator
for
the
spec
array
(
inserted
every
time
          
our
controlling
pref
changes
and
at
the
end
of
the
array
)
        
specType
is
the
actual
typename
of
our
spec
        
getPref
is
a
callback
function
that
takes
an
array
entry
and
returns
          
the
corresponding
pref
value
.
        
getDataTuple
is
a
callback
function
that
takes
an
array
entry
and
          
returns
a
tuple
suitable
for
substitution
into
specTemplate
.
        
"
"
"
        
#
We
want
to
generate
a
single
list
of
specs
but
with
specTerminator
        
#
inserted
at
every
point
where
the
pref
name
controlling
the
member
        
#
changes
.
That
will
make
sure
the
order
of
the
properties
as
exposed
        
#
on
the
interface
and
interface
prototype
objects
does
not
change
when
        
#
pref
control
is
added
to
members
while
still
allowing
us
to
define
all
        
#
the
members
in
the
smallest
number
of
JSAPI
calls
.
        
assert
(
len
(
array
)
is
not
0
)
        
lastPref
=
getPref
(
array
[
0
]
)
#
So
we
won
'
t
put
a
specTerminator
                                     
#
at
the
very
front
of
the
list
.
        
specs
=
[
]
        
prefableSpecs
=
[
]
        
if
doIdArrays
:
            
prefableIds
=
[
]
        
prefableTemplate
=
'
{
true
&
%
s
[
%
d
]
}
'
        
prefCacheTemplate
=
'
&
%
s
[
%
d
]
.
enabled
'
        
def
switchToPref
(
props
pref
)
:
            
#
Remember
the
info
about
where
our
pref
-
controlled
            
#
booleans
live
.
            
if
pref
is
not
None
:
                
props
.
prefCacheData
.
append
(
                    
(
pref
prefCacheTemplate
%
(
name
len
(
prefableSpecs
)
)
)
                    
)
            
#
Set
up
pointers
to
the
new
sets
of
specs
and
ids
            
#
inside
prefableSpecs
and
prefableIds
            
prefableSpecs
.
append
(
prefableTemplate
%
                                 
(
name
+
"
_specs
"
len
(
specs
)
)
)
        
switchToPref
(
self
lastPref
)
        
for
member
in
array
:
            
curPref
=
getPref
(
member
)
            
if
lastPref
!
=
curPref
:
                
#
Terminate
previous
list
                
specs
.
append
(
specTerminator
)
                
#
And
switch
to
our
new
pref
                
switchToPref
(
self
curPref
)
                
lastPref
=
curPref
            
#
And
the
actual
spec
            
specs
.
append
(
specTemplate
%
getDataTuple
(
member
)
)
        
specs
.
append
(
specTerminator
)
        
prefableSpecs
.
append
(
"
{
false
NULL
}
"
)
;
        
arrays
=
(
(
"
const
%
s
:
[
%
s
*
%
i
]
=
[
\
n
"
+
                   
'
\
n
'
.
join
(
specs
)
+
"
\
n
"
+
                   
"
]
;
\
n
\
n
"
)
%
(
name
specType
len
(
specs
)
)
)
                   
#
+
                   
#
"
static
Prefable
<
%
s
>
%
s
[
]
=
[
\
n
"
+
                   
#
'
\
n
'
.
join
(
prefableSpecs
)
+
"
\
n
"
+
                   
#
"
]
;
\
n
\
n
"
)
        
#
if
doIdArrays
:
        
#
arrays
+
=
(
"
const
%
s_ids
:
[
jsid
*
%
i
]
=
[
"
%
(
name
len
(
specs
)
)
)
+
"
"
.
join
(
[
"
JSID_VOID
"
]
*
len
(
specs
)
)
+
"
]
;
\
n
\
n
"
        
return
arrays
class
MethodDefiner
(
PropertyDefiner
)
:
    
"
"
"
    
A
class
for
defining
methods
on
a
prototype
object
.
    
"
"
"
    
def
__init__
(
self
descriptor
name
static
)
:
        
PropertyDefiner
.
__init__
(
self
descriptor
name
)
        
#
FIXME
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
772822
        
#
We
should
be
able
to
check
for
special
operations
without
an
        
#
identifier
.
For
now
we
check
if
the
name
starts
with
__
        
methods
=
[
m
for
m
in
descriptor
.
interface
.
members
if
                   
m
.
isMethod
(
)
and
m
.
isStatic
(
)
=
=
static
and
                   
not
m
.
isIdentifierLess
(
)
]
        
self
.
chrome
=
[
{
"
name
"
:
m
.
identifier
.
name
                        
"
length
"
:
methodLength
(
m
)
                        
"
flags
"
:
"
JSPROP_ENUMERATE
"
                        
"
pref
"
:
PropertyDefiner
.
getControllingPref
(
m
)
}
                       
for
m
in
methods
]
        
self
.
regular
=
[
{
"
name
"
:
m
.
identifier
.
name
                         
"
length
"
:
methodLength
(
m
)
                         
"
flags
"
:
"
JSPROP_ENUMERATE
"
                         
"
pref
"
:
PropertyDefiner
.
getControllingPref
(
m
)
}
                        
for
m
in
methods
if
not
isChromeOnly
(
m
)
]
        
#
FIXME
Check
for
an
existing
iterator
on
the
interface
first
.
        
if
any
(
m
.
isGetter
(
)
and
m
.
isIndexed
(
)
for
m
in
methods
)
:
            
self
.
chrome
.
append
(
{
"
name
"
:
'
iterator
'
                                
"
methodInfo
"
:
False
                                
"
nativeName
"
:
"
JS_ArrayIterator
"
                                
"
length
"
:
0
                                
"
flags
"
:
"
JSPROP_ENUMERATE
"
                                
"
pref
"
:
None
}
)
            
self
.
regular
.
append
(
{
"
name
"
:
'
iterator
'
                                 
"
methodInfo
"
:
False
                                 
"
nativeName
"
:
"
JS_ArrayIterator
"
                                 
"
length
"
:
0
                                 
"
flags
"
:
"
JSPROP_ENUMERATE
"
                                 
"
pref
"
:
None
}
)
        
#
if
not
descriptor
.
interface
.
parent
and
not
static
and
not
descriptor
.
workers
:
        
#
self
.
chrome
.
append
(
{
"
name
"
:
'
QueryInterface
'
        
#
"
methodInfo
"
:
False
        
#
"
length
"
:
1
        
#
"
flags
"
:
"
0
"
        
#
"
pref
"
:
None
}
)
        
if
static
:
            
if
not
descriptor
.
interface
.
hasInterfaceObject
(
)
:
                
#
static
methods
go
on
the
interface
object
                
assert
not
self
.
hasChromeOnly
(
)
and
not
self
.
hasNonChromeOnly
(
)
        
else
:
            
if
not
descriptor
.
interface
.
hasInterfacePrototypeObject
(
)
:
                
#
non
-
static
methods
go
on
the
interface
prototype
object
                
assert
not
self
.
hasChromeOnly
(
)
and
not
self
.
hasNonChromeOnly
(
)
    
def
generateArray
(
self
array
name
doIdArrays
)
:
        
if
len
(
array
)
=
=
0
:
            
return
"
"
        
def
pref
(
m
)
:
            
return
m
[
"
pref
"
]
        
def
specData
(
m
)
:
            
if
m
.
get
(
"
methodInfo
"
True
)
:
                
jitinfo
=
(
"
&
%
s_methodinfo
"
%
m
[
"
name
"
]
)
                
accessor
=
"
genericMethod
"
            
else
:
                
jitinfo
=
"
0
as
*
JSJitInfo
"
                
accessor
=
m
.
get
(
"
nativeName
"
m
[
"
name
"
]
)
            
return
(
m
[
"
name
"
]
accessor
jitinfo
m
[
"
length
"
]
m
[
"
flags
"
]
)
        
def
stringDecl
(
m
)
:
            
return
"
const
%
s_name
:
[
u8
*
%
i
]
=
%
s
;
\
n
"
%
(
m
[
"
name
"
]
len
(
m
[
"
name
"
]
)
+
1
                                                         
str_to_const_array
(
m
[
"
name
"
]
)
)
        
decls
=
'
'
.
join
(
[
stringDecl
(
m
)
for
m
in
array
]
)
        
return
decls
+
self
.
generatePrefableArray
(
            
array
name
            
'
{
name
:
&
%
s_name
as
*
u8
as
*
libc
:
:
c_char
call
:
{
op
:
%
s
info
:
%
s
}
nargs
:
%
s
flags
:
%
s
}
'
            
'
{
name
:
0
as
*
libc
:
:
c_char
call
:
{
op
:
0
as
JSNative
info
:
0
as
*
JSJitInfo
}
nargs
:
0
flags
:
0
}
'
            
'
JSFunctionSpec
'
            
pref
specData
doIdArrays
)
class
AttrDefiner
(
PropertyDefiner
)
:
    
def
__init__
(
self
descriptor
name
)
:
        
PropertyDefiner
.
__init__
(
self
descriptor
name
)
        
self
.
name
=
name
        
self
.
chrome
=
[
m
for
m
in
descriptor
.
interface
.
members
if
m
.
isAttr
(
)
]
        
self
.
regular
=
[
m
for
m
in
self
.
chrome
if
not
isChromeOnly
(
m
)
]
    
def
generateArray
(
self
array
name
doIdArrays
)
:
        
if
len
(
array
)
=
=
0
:
            
return
"
"
        
def
flags
(
attr
)
:
            
return
"
JSPROP_SHARED
|
JSPROP_ENUMERATE
|
JSPROP_NATIVE_ACCESSORS
"
        
def
getter
(
attr
)
:
            
native
=
(
"
genericLenientGetter
"
if
attr
.
hasLenientThis
(
)
                      
else
"
genericGetter
"
)
            
return
(
"
{
op
:
%
(
native
)
s
info
:
&
%
(
name
)
s_getterinfo
as
*
JSJitInfo
}
"
                    
%
{
"
name
"
:
attr
.
identifier
.
name
                       
"
native
"
:
native
}
)
        
def
setter
(
attr
)
:
            
if
attr
.
readonly
:
                
return
"
{
op
:
0
as
*
u8
info
:
0
as
*
JSJitInfo
}
"
            
native
=
(
"
genericLenientSetter
"
if
attr
.
hasLenientThis
(
)
                      
else
"
genericSetter
"
)
            
return
(
"
{
op
:
%
(
native
)
s
info
:
&
%
(
name
)
s_setterinfo
as
*
JSJitInfo
}
"
                    
%
{
"
name
"
:
attr
.
identifier
.
name
                       
"
native
"
:
native
}
)
        
def
specData
(
attr
)
:
            
return
(
attr
.
identifier
.
name
flags
(
attr
)
getter
(
attr
)
                    
setter
(
attr
)
)
        
def
stringDecl
(
attr
)
:
            
name
=
attr
.
identifier
.
name
            
return
"
const
%
s_name
:
[
u8
*
%
i
]
=
%
s
;
\
n
"
%
(
name
len
(
name
)
+
1
                                                         
str_to_const_array
(
name
)
)
        
decls
=
'
'
.
join
(
[
stringDecl
(
m
)
for
m
in
array
]
)
        
return
decls
+
self
.
generatePrefableArray
(
            
array
name
            
'
{
name
:
&
%
s_name
as
*
u8
as
*
libc
:
:
c_char
tinyid
:
0
flags
:
(
(
%
s
)
&
0xFF
)
as
u8
getter
:
%
s
setter
:
%
s
}
'
            
'
{
name
:
0
as
*
libc
:
:
c_char
tinyid
:
0
flags
:
0
getter
:
{
op
:
0
as
*
u8
info
:
0
as
*
JSJitInfo
}
setter
:
{
op
:
0
as
*
u8
info
:
0
as
*
JSJitInfo
}
}
'
            
'
JSPropertySpec
'
            
PropertyDefiner
.
getControllingPref
specData
doIdArrays
)
class
ConstDefiner
(
PropertyDefiner
)
:
    
"
"
"
    
A
class
for
definining
constants
on
the
interface
object
    
"
"
"
    
def
__init__
(
self
descriptor
name
)
:
        
PropertyDefiner
.
__init__
(
self
descriptor
name
)
        
self
.
name
=
name
        
self
.
chrome
=
[
m
for
m
in
descriptor
.
interface
.
members
if
m
.
isConst
(
)
]
        
self
.
regular
=
[
m
for
m
in
self
.
chrome
if
not
isChromeOnly
(
m
)
]
    
def
generateArray
(
self
array
name
doIdArrays
)
:
        
if
len
(
array
)
=
=
0
:
            
return
"
"
        
def
specData
(
const
)
:
            
return
(
const
.
identifier
.
name
                    
convertConstIDLValueToJSVal
(
const
.
value
)
)
        
def
stringDecl
(
const
)
:
            
name
=
const
.
identifier
.
name
            
return
"
const
%
s_name
:
[
u8
*
%
i
]
=
%
s
;
\
n
"
%
(
name
len
(
name
)
+
1
                                                         
str_to_const_array
(
name
)
)
        
decls
=
'
'
.
join
(
[
stringDecl
(
m
)
for
m
in
array
]
)
        
return
decls
+
self
.
generatePrefableArray
(
            
array
name
            
'
{
&
%
s_name
as
*
u8
as
*
libc
:
:
c_char
%
s
}
'
            
'
{
0
JSVAL_VOID
}
'
            
'
ConstantSpec
'
            
PropertyDefiner
.
getControllingPref
specData
doIdArrays
)
class
CGThing
(
)
:
    
"
"
"
    
Abstract
base
class
for
things
that
spit
out
code
.
    
"
"
"
    
def
__init__
(
self
)
:
        
pass
#
Nothing
for
now
    
def
declare
(
self
)
:
        
"
"
"
Produce
code
for
a
header
file
.
"
"
"
        
assert
(
False
)
#
Override
me
!
    
def
define
(
self
)
:
        
"
"
"
Produce
code
for
a
cpp
file
.
"
"
"
        
assert
(
False
)
#
Override
me
!
class
CGNativePropertyHooks
(
CGThing
)
:
    
"
"
"
    
Generate
a
NativePropertyHooks
for
a
given
descriptor
    
"
"
"
    
def
__init__
(
self
descriptor
)
:
        
CGThing
.
__init__
(
self
)
        
self
.
descriptor
=
descriptor
    
def
declare
(
self
)
:
        
if
self
.
descriptor
.
workers
:
            
return
"
"
        
#
return
"
extern
const
NativePropertyHooks
NativeHooks
;
\
n
"
        
return
"
"
    
def
define
(
self
)
:
        
if
self
.
descriptor
.
workers
:
            
return
"
"
        
if
self
.
descriptor
.
concrete
and
self
.
descriptor
.
proxy
:
            
resolveOwnProperty
=
"
ResolveOwnProperty
"
            
enumerateOwnProperties
=
"
EnumerateOwnProperties
"
        
else
:
            
enumerateOwnProperties
=
resolveOwnProperty
=
"
0
as
*
u8
"
        
parent
=
self
.
descriptor
.
interface
.
parent
        
parentHooks
=
(
"
&
"
+
toBindingNamespace
(
parent
.
identifier
.
name
)
+
"
:
:
NativeHooks
"
                       
if
parent
else
'
0
as
*
NativePropertyHooks
'
)
        
return
"
"
"
const
NativeHooks
:
NativePropertyHooks
=
NativePropertyHooks
{
resolve_own_property
:
%
s
resolve_property
:
/
*
ResolveProperty
*
/
0
as
*
u8
enumerate_own_properties
:
%
s
enumerate_properties
:
/
*
EnumerateProperties
*
/
0
as
*
u8
proto_hooks
:
%
s
}
;
"
"
"
%
(
resolveOwnProperty
enumerateOwnProperties
parentHooks
)
#
We
'
ll
want
to
insert
the
indent
at
the
beginnings
of
lines
but
we
#
don
'
t
want
to
indent
empty
lines
.
So
only
indent
lines
that
have
a
#
non
-
newline
character
on
them
.
lineStartDetector
=
re
.
compile
(
"
^
(
?
=
[
^
\
n
#
]
)
"
re
.
MULTILINE
)
class
CGIndenter
(
CGThing
)
:
    
"
"
"
    
A
class
that
takes
another
CGThing
and
generates
code
that
indents
that
    
CGThing
by
some
number
of
spaces
.
The
default
indent
is
two
spaces
.
    
"
"
"
    
def
__init__
(
self
child
indentLevel
=
2
declareOnly
=
False
)
:
        
CGThing
.
__init__
(
self
)
        
self
.
child
=
child
        
self
.
indent
=
"
"
*
indentLevel
        
self
.
declareOnly
=
declareOnly
    
def
declare
(
self
)
:
        
decl
=
self
.
child
.
declare
(
)
        
if
decl
is
not
"
"
:
            
return
re
.
sub
(
lineStartDetector
self
.
indent
decl
)
        
else
:
            
return
"
"
    
def
define
(
self
)
:
        
defn
=
self
.
child
.
define
(
)
        
if
defn
is
not
"
"
and
not
self
.
declareOnly
:
            
return
re
.
sub
(
lineStartDetector
self
.
indent
defn
)
        
else
:
            
return
defn
class
CGWrapper
(
CGThing
)
:
    
"
"
"
    
Generic
CGThing
that
wraps
other
CGThings
with
pre
and
post
text
.
    
"
"
"
    
def
__init__
(
self
child
pre
=
"
"
post
=
"
"
declarePre
=
None
                 
declarePost
=
None
definePre
=
None
definePost
=
None
                 
declareOnly
=
False
defineOnly
=
False
reindent
=
False
)
:
        
CGThing
.
__init__
(
self
)
        
self
.
child
=
child
        
self
.
declarePre
=
declarePre
or
pre
        
self
.
declarePost
=
declarePost
or
post
        
self
.
definePre
=
definePre
or
pre
        
self
.
definePost
=
definePost
or
post
        
self
.
declareOnly
=
declareOnly
        
self
.
defineOnly
=
defineOnly
        
self
.
reindent
=
reindent
    
def
declare
(
self
)
:
        
if
self
.
defineOnly
:
            
return
'
'
        
decl
=
self
.
child
.
declare
(
)
        
if
self
.
reindent
:
            
#
We
don
'
t
use
lineStartDetector
because
we
don
'
t
want
to
            
#
insert
whitespace
at
the
beginning
of
our
_first_
line
.
            
decl
=
stripTrailingWhitespace
(
                
decl
.
replace
(
"
\
n
"
"
\
n
"
+
(
"
"
*
len
(
self
.
declarePre
)
)
)
)
        
return
self
.
declarePre
+
decl
+
self
.
declarePost
    
def
define
(
self
)
:
        
if
self
.
declareOnly
:
            
return
'
'
        
defn
=
self
.
child
.
define
(
)
        
if
self
.
reindent
:
            
#
We
don
'
t
use
lineStartDetector
because
we
don
'
t
want
to
            
#
insert
whitespace
at
the
beginning
of
our
_first_
line
.
            
defn
=
stripTrailingWhitespace
(
                
defn
.
replace
(
"
\
n
"
"
\
n
"
+
(
"
"
*
len
(
self
.
definePre
)
)
)
)
        
return
self
.
definePre
+
defn
+
self
.
definePost
class
CGImports
(
CGWrapper
)
:
    
"
"
"
    
Generates
the
appropriate
import
/
use
statements
.
    
"
"
"
    
def
__init__
(
self
descriptors
dictionaries
declareImports
defineImports
child
)
:
        
"
"
"
        
Builds
a
set
of
imports
to
cover
|
descriptors
|
.
        
Also
includes
the
files
in
|
declareIncludes
|
in
the
header
        
file
and
the
files
in
|
defineIncludes
|
in
the
.
cpp
.
        
"
"
"
        
#
TODO
imports
to
cover
descriptors
etc
.
        
def
_useString
(
imports
)
:
            
return
'
'
.
join
(
[
'
use
%
s
;
\
n
'
%
i
for
i
in
imports
]
)
+
'
\
n
'
        
CGWrapper
.
__init__
(
self
child
                           
definePre
=
_useString
(
sorted
(
defineImports
)
)
)
class
CGNamespace
(
CGWrapper
)
:
    
def
__init__
(
self
namespace
child
declareOnly
=
False
)
:
        
pre
=
"
mod
%
s
{
\
n
"
%
namespace
        
post
=
"
}
/
/
mod
%
s
\
n
"
%
namespace
        
CGWrapper
.
__init__
(
self
child
pre
=
pre
post
=
post
                           
declareOnly
=
declareOnly
)
    
staticmethod
    
def
build
(
namespaces
child
declareOnly
=
False
)
:
        
"
"
"
        
Static
helper
method
to
build
multiple
wrapped
namespaces
.
        
"
"
"
        
if
not
namespaces
:
            
return
CGWrapper
(
child
declareOnly
=
declareOnly
)
        
inner
=
CGNamespace
.
build
(
namespaces
[
1
:
]
child
declareOnly
=
declareOnly
)
        
return
CGNamespace
(
namespaces
[
0
]
inner
declareOnly
=
declareOnly
)
def
DOMClass
(
descriptor
)
:
        
protoList
=
[
'
prototypes
:
:
id
:
:
'
+
proto
for
proto
in
descriptor
.
prototypeChain
]
        
#
Pad
out
the
list
to
the
right
length
with
_ID_Count
so
we
        
#
guarantee
that
all
the
lists
are
the
same
length
.
_ID_Count
        
#
is
never
the
ID
of
any
prototype
so
it
'
s
safe
to
use
as
        
#
padding
.
        
protoList
.
extend
(
[
'
prototypes
:
:
id
:
:
_ID_Count
'
]
*
(
descriptor
.
config
.
maxProtoChainLength
-
len
(
protoList
)
)
)
        
prototypeChainString
=
'
'
.
join
(
protoList
)
        
nativeHooks
=
"
0
as
*
NativePropertyHooks
"
if
descriptor
.
workers
else
"
&
NativeHooks
as
*
NativePropertyHooks
"
        
return
"
"
"
DOMClass
{
  
interface_chain
:
[
%
s
]
  
unused
:
%
s
native_hooks
:
%
s
}
"
"
"
%
(
prototypeChainString
"
false
"
#
toStringBool
(
descriptor
.
nativeIsISupports
)
          
nativeHooks
)
class
CGDOMJSClass
(
CGThing
)
:
    
"
"
"
    
Generate
a
DOMJSClass
for
a
given
descriptor
    
"
"
"
    
def
__init__
(
self
descriptor
)
:
        
CGThing
.
__init__
(
self
)
        
self
.
descriptor
=
descriptor
    
def
declare
(
self
)
:
        
#
return
"
extern
DOMJSClass
Class
;
\
n
"
        
return
"
"
    
def
define
(
self
)
:
        
traceHook
=
TRACE_HOOK_NAME
if
self
.
descriptor
.
customTrace
else
'
0
as
*
u8
'
        
return
"
"
"
const
Class_name
:
[
u8
*
%
i
]
=
%
s
;
const
Class
:
DOMJSClass
=
DOMJSClass
{
  
base
:
JSClass
{
name
:
&
Class_name
as
*
u8
as
*
libc
:
:
c_char
    
flags
:
JSCLASS_IS_DOMJSCLASS
|
(
(
1
&
JSCLASS_RESERVED_SLOTS_MASK
)
<
<
JSCLASS_RESERVED_SLOTS_SHIFT
)
/
/
JSCLASS_HAS_RESERVED_SLOTS
(
1
)
    
addProperty
:
%
s
/
*
addProperty
*
/
    
delProperty
:
crust
:
:
JS_PropertyStub
/
*
delProperty
*
/
    
getProperty
:
crust
:
:
JS_PropertyStub
/
*
getProperty
*
/
    
setProperty
:
crust
:
:
JS_StrictPropertyStub
/
*
setProperty
*
/
    
enumerate
:
crust
:
:
JS_EnumerateStub
    
resolve
:
crust
:
:
JS_ResolveStub
    
convert
:
crust
:
:
JS_ConvertStub
    
finalize
:
%
s
/
*
finalize
*
/
    
checkAccess
:
0
as
*
u8
/
*
checkAccess
*
/
    
call
:
0
as
*
u8
/
*
call
*
/
    
hasInstance
:
0
as
*
u8
/
*
hasInstance
*
/
    
construct
:
0
as
*
u8
/
*
construct
*
/
    
trace
:
%
s
/
*
trace
*
/
    
reserved
:
(
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
/
/
05
                    
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
/
/
10
                    
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
/
/
15
                    
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
/
/
20
                    
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
/
/
25
                    
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
/
/
30
                    
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
/
/
35
                    
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
)
/
/
40
  
}
  
dom_class
:
%
s
}
;
"
"
"
%
(
len
(
self
.
descriptor
.
interface
.
identifier
.
name
)
+
1
       
str_to_const_array
(
self
.
descriptor
.
interface
.
identifier
.
name
)
       
#
ADDPROPERTY_HOOK_NAME
if
self
.
descriptor
.
concrete
and
not
self
.
descriptor
.
workers
and
self
.
descriptor
.
wrapperCache
else
'
crust
:
:
JS_PropertyStub
'
       
'
crust
:
:
JS_PropertyStub
'
       
FINALIZE_HOOK_NAME
traceHook
       
CGIndenter
(
CGGeneric
(
DOMClass
(
self
.
descriptor
)
)
)
.
define
(
)
)
def
str_to_const_array
(
s
)
:
    
return
"
[
"
+
(
"
"
.
join
(
map
(
lambda
x
:
"
'
"
+
x
+
"
'
as
u8
"
list
(
s
)
)
+
[
'
0
as
u8
'
]
)
)
+
"
]
"
class
CGPrototypeJSClass
(
CGThing
)
:
    
def
__init__
(
self
descriptor
)
:
        
CGThing
.
__init__
(
self
)
        
self
.
descriptor
=
descriptor
    
def
declare
(
self
)
:
        
#
We
'
re
purely
for
internal
consumption
        
return
"
"
    
def
define
(
self
)
:
        
return
"
"
"
const
PrototypeClassName__
:
[
u8
*
%
s
]
=
%
s
;
const
PrototypeClass
:
JSClass
=
JSClass
{
  
name
:
&
PrototypeClassName__
as
*
u8
as
*
libc
:
:
c_char
  
flags
:
(
1
&
JSCLASS_RESERVED_SLOTS_MASK
)
<
<
JSCLASS_RESERVED_SLOTS_SHIFT
/
/
JSCLASS_HAS_RESERVED_SLOTS
(
1
)
  
addProperty
:
crust
:
:
JS_PropertyStub
/
*
addProperty
*
/
  
delProperty
:
crust
:
:
JS_PropertyStub
/
*
delProperty
*
/
  
getProperty
:
crust
:
:
JS_PropertyStub
/
*
getProperty
*
/
  
setProperty
:
crust
:
:
JS_StrictPropertyStub
/
*
setProperty
*
/
  
enumerate
:
crust
:
:
JS_EnumerateStub
  
resolve
:
crust
:
:
JS_ResolveStub
  
convert
:
crust
:
:
JS_ConvertStub
  
finalize
:
0
as
*
u8
/
*
finalize
*
/
  
checkAccess
:
0
as
*
u8
/
*
checkAccess
*
/
  
call
:
0
as
*
u8
/
*
call
*
/
  
hasInstance
:
0
as
*
u8
/
*
hasInstance
*
/
  
construct
:
0
as
*
u8
/
*
construct
*
/
  
trace
:
0
as
*
u8
/
*
trace
*
/
  
reserved
:
(
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
/
/
05
                    
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
/
/
10
                    
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
/
/
15
                    
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
/
/
20
                    
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
/
/
25
                    
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
/
/
30
                    
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
/
/
35
                    
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
0
as
*
libc
:
:
c_void
)
/
/
40
}
;
"
"
"
%
(
len
(
self
.
descriptor
.
interface
.
identifier
.
name
+
"
Prototype
"
)
+
1
       
str_to_const_array
(
self
.
descriptor
.
interface
.
identifier
.
name
+
"
Prototype
"
)
)
class
CGInterfaceObjectJSClass
(
CGThing
)
:
    
def
__init__
(
self
descriptor
)
:
        
CGThing
.
__init__
(
self
)
        
self
.
descriptor
=
descriptor
    
def
declare
(
self
)
:
        
#
We
'
re
purely
for
internal
consumption
        
return
"
"
    
def
define
(
self
)
:
        
if
not
self
.
descriptor
.
hasInstanceInterface
:
            
return
"
"
        
ctorname
=
"
0
as
*
u8
"
if
not
self
.
descriptor
.
interface
.
ctor
(
)
else
CONSTRUCT_HOOK_NAME
        
hasinstance
=
HASINSTANCE_HOOK_NAME
        
return
"
"
"
const
InterfaceObjectClass
:
JSClass
=
{
  
%
s
0
  
crust
:
:
JS_PropertyStub
/
*
addProperty
*
/
  
crust
:
:
JS_PropertyStub
/
*
delProperty
*
/
  
crust
:
:
JS_PropertyStub
/
*
getProperty
*
/
  
crust
:
:
JS_StrictPropertyStub
/
*
setProperty
*
/
  
crust
:
:
JS_EnumerateStub
  
crust
:
:
JS_ResolveStub
  
crust
:
:
JS_ConvertStub
  
0
as
*
u8
/
*
finalize
*
/
  
0
as
*
u8
/
*
checkAccess
*
/
  
%
s
/
*
call
*
/
  
%
s
/
*
hasInstance
*
/
  
%
s
/
*
construct
*
/
  
0
as
*
u8
/
*
trace
*
/
  
JSCLASS_NO_INTERNAL_MEMBERS
}
;
"
"
"
%
(
str_to_const_array
(
"
Function
"
ctorname
hasinstance
ctorname
)
)
class
CGList
(
CGThing
)
:
    
"
"
"
    
Generate
code
for
a
list
of
GCThings
.
Just
concatenates
them
together
with
    
an
optional
joiner
string
.
"
\
n
"
is
a
common
joiner
.
    
"
"
"
    
def
__init__
(
self
children
joiner
=
"
"
)
:
        
CGThing
.
__init__
(
self
)
        
self
.
children
=
children
        
self
.
joiner
=
joiner
    
def
append
(
self
child
)
:
        
self
.
children
.
append
(
child
)
    
def
prepend
(
self
child
)
:
        
self
.
children
.
insert
(
0
child
)
    
def
join
(
self
generator
)
:
        
return
self
.
joiner
.
join
(
filter
(
lambda
s
:
len
(
s
)
>
0
(
child
for
child
in
generator
)
)
)
    
def
declare
(
self
)
:
        
return
self
.
join
(
child
.
declare
(
)
for
child
in
self
.
children
if
child
is
not
None
)
    
def
define
(
self
)
:
        
return
self
.
join
(
child
.
define
(
)
for
child
in
self
.
children
if
child
is
not
None
)
class
CGGeneric
(
CGThing
)
:
    
"
"
"
    
A
class
that
spits
out
a
fixed
string
into
the
codegen
.
Can
spit
out
a
    
separate
string
for
the
declaration
too
.
    
"
"
"
    
def
__init__
(
self
define
=
"
"
declare
=
"
"
)
:
        
self
.
declareText
=
declare
        
self
.
defineText
=
define
    
def
declare
(
self
)
:
        
return
self
.
declareText
    
def
define
(
self
)
:
        
return
self
.
defineText
class
Argument
(
)
:
    
"
"
"
    
A
class
for
outputting
the
type
and
name
of
an
argument
    
"
"
"
    
def
__init__
(
self
argType
name
)
:
        
self
.
argType
=
argType
        
self
.
name
=
name
    
def
__str__
(
self
)
:
        
return
self
.
name
+
'
:
'
+
self
.
argType
class
CGAbstractMethod
(
CGThing
)
:
    
"
"
"
    
An
abstract
class
for
generating
code
for
a
method
.
Subclasses
    
should
override
definition_body
to
create
the
actual
code
.
    
descriptor
is
the
descriptor
for
the
interface
the
method
is
associated
with
    
name
is
the
name
of
the
method
as
a
string
    
returnType
is
the
IDLType
of
the
return
value
    
args
is
a
list
of
Argument
objects
    
inline
should
be
True
to
generate
an
inline
method
whose
body
is
    
part
of
the
declaration
.
    
alwaysInline
should
be
True
to
generate
an
inline
method
annotated
with
    
MOZ_ALWAYS_INLINE
.
    
static
should
be
True
to
generate
a
static
method
which
only
has
    
a
definition
.
    
If
templateArgs
is
not
None
it
should
be
a
list
of
strings
containing
    
template
arguments
and
the
function
will
be
templatized
using
those
    
arguments
.
    
"
"
"
    
def
__init__
(
self
descriptor
name
returnType
args
inline
=
False
alwaysInline
=
False
static
=
False
extern
=
False
pub
=
False
templateArgs
=
None
)
:
        
CGThing
.
__init__
(
self
)
        
self
.
descriptor
=
descriptor
        
self
.
name
=
name
        
self
.
returnType
=
returnType
        
self
.
args
=
args
        
self
.
inline
=
inline
        
self
.
alwaysInline
=
alwaysInline
        
self
.
static
=
static
        
self
.
extern
=
extern
        
self
.
templateArgs
=
templateArgs
        
self
.
pub
=
pub
;
    
def
_argstring
(
self
)
:
        
return
'
'
.
join
(
[
str
(
a
)
for
a
in
self
.
args
]
)
    
def
_template
(
self
)
:
        
if
self
.
templateArgs
is
None
:
            
return
'
'
        
return
'
<
%
s
>
\
n
'
%
'
'
.
join
(
self
.
templateArgs
)
    
def
_decorators
(
self
)
:
        
decorators
=
[
]
        
if
self
.
alwaysInline
:
            
decorators
.
append
(
'
#
[
inline
(
always
)
]
'
)
        
elif
self
.
inline
:
            
#
decorators
.
append
(
'
inline
'
)
            
pass
        
if
self
.
extern
:
            
decorators
.
append
(
'
extern
'
)
        
if
self
.
static
:
            
#
decorators
.
append
(
'
static
'
)
            
pass
        
if
self
.
pub
:
            
decorators
.
append
(
'
pub
'
)
        
if
not
decorators
:
            
return
'
'
        
#
maybeNewline
=
"
"
if
self
.
inline
else
"
\
n
"
        
maybeNewline
=
"
"
        
return
'
'
.
join
(
decorators
)
+
maybeNewline
    
def
_returnType
(
self
)
:
        
return
(
"
-
>
%
s
"
%
self
.
returnType
)
if
self
.
returnType
!
=
"
void
"
else
"
"
    
def
declare
(
self
)
:
        
if
self
.
inline
:
            
return
self
.
_define
(
)
        
#
return
"
%
sfn
%
s
%
s
(
%
s
)
%
s
;
\
n
"
%
(
self
.
_decorators
(
)
self
.
name
self
.
_template
(
)
        
#
self
.
_argstring
(
)
self
.
_returnType
(
)
)
        
return
"
"
    
def
_define
(
self
)
:
        
return
self
.
definition_prologue
(
)
+
"
\
n
"
+
self
.
definition_body
(
)
+
self
.
definition_epilogue
(
)
    
def
define
(
self
)
:
        
return
"
"
if
self
.
inline
else
self
.
_define
(
)
    
def
definition_prologue
(
self
)
:
        
return
"
%
sfn
%
s
%
s
(
%
s
)
%
s
{
\
n
unsafe
{
"
%
(
self
.
_decorators
(
)
self
.
name
self
.
_template
(
)
                                                  
self
.
_argstring
(
)
self
.
_returnType
(
)
)
    
def
definition_epilogue
(
self
)
:
        
return
"
\
n
}
\
n
}
\
n
"
    
def
definition_body
(
self
)
:
        
assert
(
False
)
#
Override
me
!
class
CGAbstractExternMethod
(
CGAbstractMethod
)
:
    
"
"
"
    
Abstract
base
class
for
codegen
of
implementation
-
only
(
no
    
declaration
)
static
methods
.
    
"
"
"
    
def
__init__
(
self
descriptor
name
returnType
args
)
:
        
CGAbstractMethod
.
__init__
(
self
descriptor
name
returnType
args
                                  
inline
=
False
extern
=
True
)
    
def
declare
(
self
)
:
        
#
We
only
have
implementation
        
return
"
"
class
PropertyArrays
(
)
:
    
def
__init__
(
self
descriptor
)
:
        
self
.
staticMethods
=
MethodDefiner
(
descriptor
"
StaticMethods
"
True
)
        
self
.
methods
=
MethodDefiner
(
descriptor
"
Methods
"
False
)
        
self
.
attrs
=
AttrDefiner
(
descriptor
"
Attributes
"
)
        
self
.
consts
=
ConstDefiner
(
descriptor
"
Constants
"
)
        
pass
    
staticmethod
    
def
arrayNames
(
)
:
        
return
[
"
staticMethods
"
"
methods
"
"
attrs
"
"
consts
"
]
    
staticmethod
    
def
xrayRelevantArrayNames
(
)
:
        
return
[
"
methods
"
"
attrs
"
"
consts
"
]
    
def
hasChromeOnly
(
self
)
:
        
return
reduce
(
lambda
b
a
:
b
or
getattr
(
self
a
)
.
hasChromeOnly
(
)
                      
self
.
arrayNames
(
)
False
)
    
def
variableNames
(
self
chrome
)
:
        
names
=
{
}
        
for
array
in
self
.
arrayNames
(
)
:
            
names
[
array
]
=
getattr
(
self
array
)
.
variableName
(
chrome
)
        
return
names
    
def
__str__
(
self
)
:
        
define
=
"
"
        
for
array
in
self
.
arrayNames
(
)
:
            
define
+
=
str
(
getattr
(
self
array
)
)
        
return
define
class
CGCreateInterfaceObjectsMethod
(
CGAbstractMethod
)
:
    
"
"
"
    
Generate
the
CreateInterfaceObjects
method
for
an
interface
descriptor
.
    
properties
should
be
a
PropertyArrays
instance
.
    
"
"
"
    
def
__init__
(
self
descriptor
properties
)
:
        
args
=
[
Argument
(
'
*
JSContext
'
'
aCx
'
)
Argument
(
'
*
JSObject
'
'
aGlobal
'
)
                
Argument
(
'
*
JSObject
'
'
aReceiver
'
)
]
        
CGAbstractMethod
.
__init__
(
self
descriptor
'
CreateInterfaceObjects
'
'
*
JSObject
'
args
)
        
self
.
properties
=
properties
    
def
definition_body
(
self
)
:
        
protoChain
=
self
.
descriptor
.
prototypeChain
        
if
len
(
protoChain
)
=
=
1
:
            
getParentProto
=
"
JS_GetObjectPrototype
(
aCx
aGlobal
)
"
        
else
:
            
parentProtoName
=
self
.
descriptor
.
prototypeChain
[
-
2
]
            
getParentProto
=
(
"
%
s
:
:
GetProtoObject
(
aCx
aGlobal
aReceiver
)
"
%
                              
toBindingNamespace
(
parentProtoName
)
)
        
needInterfaceObject
=
self
.
descriptor
.
interface
.
hasInterfaceObject
(
)
        
needInterfacePrototypeObject
=
self
.
descriptor
.
interface
.
hasInterfacePrototypeObject
(
)
        
#
if
we
don
'
t
need
to
create
anything
why
are
we
generating
this
?
        
assert
needInterfaceObject
or
needInterfacePrototypeObject
        
idsToInit
=
[
]
        
#
There
is
no
need
to
init
any
IDs
in
workers
because
worker
bindings
        
#
don
'
t
have
Xrays
.
        
if
False
and
not
self
.
descriptor
.
workers
:
#
XXXjdm
punt
on
the
interned
string
optimization
            
for
var
in
self
.
properties
.
xrayRelevantArrayNames
(
)
:
                
props
=
getattr
(
self
.
properties
var
)
                
#
We
only
have
non
-
chrome
ids
to
init
if
we
have
no
chrome
ids
.
                
if
props
.
hasChromeOnly
(
)
:
                    
idsToInit
.
append
(
props
.
variableName
(
True
)
)
                
elif
props
.
hasNonChromeOnly
(
)
:
                    
idsToInit
.
append
(
props
.
variableName
(
False
)
)
        
if
len
(
idsToInit
)
>
0
:
            
initIds
=
CGList
(
                
[
CGGeneric
(
"
!
InitIds
(
aCx
%
s
%
s_ids
)
"
%
(
varname
varname
)
)
for
                 
varname
in
idsToInit
]
'
|
|
\
n
'
)
            
if
len
(
idsToInit
)
>
1
:
                
initIds
=
CGWrapper
(
initIds
pre
=
"
(
"
post
=
"
)
"
reindent
=
True
)
            
initIds
=
CGList
(
                
[
CGGeneric
(
"
%
s_ids
[
0
]
=
=
JSID_VOID
&
&
"
%
idsToInit
[
0
]
)
initIds
]
                
"
\
n
"
)
            
initIds
=
CGWrapper
(
initIds
pre
=
"
if
"
post
=
"
{
"
reindent
=
True
)
            
initIds
=
CGList
(
                
[
initIds
                 
CGGeneric
(
(
"
%
s_ids
[
0
]
=
JSID_VOID
;
\
n
"
                            
"
return
ptr
:
:
null
(
)
;
"
)
%
idsToInit
[
0
]
)
                 
CGGeneric
(
"
}
"
)
]
                
"
\
n
"
)
        
else
:
            
initIds
=
None
        
prefCacheData
=
[
]
        
for
var
in
self
.
properties
.
arrayNames
(
)
:
            
props
=
getattr
(
self
.
properties
var
)
            
prefCacheData
.
extend
(
props
.
prefCacheData
)
        
if
len
(
prefCacheData
)
is
not
0
:
            
prefCacheData
=
[
                
CGGeneric
(
'
Preferences
:
:
AddBoolVarCache
(
%
s
"
%
s
"
)
;
'
%
(
ptr
pref
)
)
for
                
(
pref
ptr
)
in
prefCacheData
]
            
prefCache
=
CGWrapper
(
CGIndenter
(
CGList
(
prefCacheData
"
\
n
"
)
)
                                  
pre
=
(
"
static
bool
sPrefCachesInited
=
false
;
\
n
"
                                       
"
if
(
!
sPrefCachesInited
)
{
\
n
"
                                       
"
sPrefCachesInited
=
true
;
\
n
"
)
                                  
post
=
"
\
n
}
"
)
        
else
:
            
prefCache
=
None
        
getParentProto
=
(
"
let
parentProto
:
*
JSObject
=
%
s
;
\
n
"
+
                          
"
if
parentProto
.
is_null
(
)
{
\
n
"
+
                          
"
return
ptr
:
:
null
(
)
;
\
n
"
+
                          
"
}
\
n
"
)
%
getParentProto
        
needInterfaceObjectClass
=
(
needInterfaceObject
and
                                    
self
.
descriptor
.
hasInstanceInterface
)
        
needConstructor
=
(
needInterfaceObject
and
                           
not
self
.
descriptor
.
hasInstanceInterface
)
        
if
self
.
descriptor
.
interface
.
ctor
(
)
:
            
constructHook
=
CONSTRUCT_HOOK_NAME
            
constructArgs
=
methodLength
(
self
.
descriptor
.
interface
.
ctor
(
)
)
        
else
:
            
constructHook
=
"
ThrowingConstructor
"
            
constructArgs
=
0
        
if
self
.
descriptor
.
concrete
:
            
if
self
.
descriptor
.
proxy
:
                
domClass
=
"
&
Class
"
            
else
:
                
domClass
=
"
&
Class
.
dom_class
"
        
else
:
            
domClass
=
"
ptr
:
:
null
(
)
"
        
call
=
"
"
"
return
CreateInterfaceObjects2
(
aCx
aGlobal
aReceiver
parentProto
                               
%
s
%
s
%
s
%
d
                               
%
s
                               
%
%
(
methods
)
s
ptr
:
:
to_unsafe_ptr
(
&
%
%
(
attrs
)
s
[
0
]
)
                               
%
%
(
consts
)
s
%
%
(
staticMethods
)
s
                               
%
s
)
;
"
"
"
%
(
            
"
&
PrototypeClass
"
if
needInterfacePrototypeObject
else
"
ptr
:
:
null
(
)
"
            
"
&
InterfaceObjectClass
"
if
needInterfaceObjectClass
else
"
ptr
:
:
null
(
)
"
            
constructHook
if
needConstructor
else
"
ptr
:
:
null
(
)
"
            
constructArgs
            
domClass
            
'
"
'
+
self
.
descriptor
.
interface
.
identifier
.
name
+
'
"
'
if
needInterfaceObject
else
"
ptr
:
:
null
(
)
"
)
        
if
self
.
properties
.
hasChromeOnly
(
)
:
            
if
self
.
descriptor
.
workers
:
                
accessCheck
=
"
mozilla
:
:
dom
:
:
workers
:
:
GetWorkerPrivateFromContext
(
aCx
)
-
>
IsChromeWorker
(
)
"
            
else
:
                
accessCheck
=
"
xpc
:
:
AccessCheck
:
:
isChrome
(
js
:
:
GetObjectCompartment
(
aGlobal
)
)
"
            
chrome
=
CGIfWrapper
(
CGGeneric
(
call
%
self
.
properties
.
variableNames
(
True
)
)
                                 
accessCheck
)
            
chrome
=
CGWrapper
(
chrome
pre
=
"
\
n
\
n
"
)
        
else
:
            
chrome
=
None
        
functionBody
=
CGList
(
            
[
CGGeneric
(
getParentProto
)
initIds
prefCache
chrome
             
CGGeneric
(
call
%
self
.
properties
.
variableNames
(
False
)
)
]
            
"
\
n
\
n
"
)
        
#
return
CGIndenter
(
CGWrapper
(
functionBody
pre
=
"
/
*
"
post
=
"
*
/
return
ptr
:
:
null
(
)
"
)
)
.
define
(
)
        
return
CGIndenter
(
functionBody
)
.
define
(
)
class
CGGetPerInterfaceObject
(
CGAbstractMethod
)
:
    
"
"
"
    
A
method
for
getting
a
per
-
interface
object
(
a
prototype
object
or
interface
    
constructor
object
)
.
    
"
"
"
    
def
__init__
(
self
descriptor
name
idPrefix
=
"
"
)
:
        
args
=
[
Argument
(
'
*
JSContext
'
'
aCx
'
)
Argument
(
'
*
JSObject
'
'
aGlobal
'
)
                
Argument
(
'
*
JSObject
'
'
aReceiver
'
)
]
        
CGAbstractMethod
.
__init__
(
self
descriptor
name
                                  
'
*
JSObject
'
args
inline
=
True
)
        
self
.
id
=
idPrefix
+
"
id
:
:
"
+
self
.
descriptor
.
name
    
def
definition_body
(
self
)
:
        
return
"
"
"
  
/
*
aGlobal
and
aReceiver
are
usually
the
same
but
they
can
be
different
     
too
.
For
example
a
sandbox
often
has
an
xray
wrapper
for
a
window
as
the
     
prototype
of
the
sandbox
'
s
global
.
In
that
case
aReceiver
is
the
xray
     
wrapper
and
aGlobal
is
the
sandbox
'
s
global
.
   
*
/
  
/
*
Make
sure
our
global
is
sane
.
Hopefully
we
can
remove
this
sometime
*
/
  
/
*
if
(
(
*
JS_GetClass
(
aGlobal
)
)
.
flags
&
JSCLASS_DOM_GLOBAL
)
=
=
0
{
    
return
ptr
:
:
null
(
)
;
  
}
*
/
  
/
*
Check
to
see
whether
the
interface
objects
are
already
installed
*
/
  
let
protoOrIfaceArray
:
*
mut
*
JSObject
=
cast
:
:
transmute
(
GetProtoOrIfaceArray
(
aGlobal
)
)
;
  
let
cachedObject
:
*
JSObject
=
*
protoOrIfaceArray
.
offset
(
%
s
as
uint
)
;
  
if
cachedObject
.
is_null
(
)
{
    
let
tmp
:
*
JSObject
=
CreateInterfaceObjects
(
aCx
aGlobal
aReceiver
)
;
    
*
protoOrIfaceArray
.
offset
(
%
s
as
uint
)
=
tmp
;
    
tmp
  
}
else
{
    
cachedObject
  
}
"
"
"
%
(
self
.
id
self
.
id
)
class
CGGetProtoObjectMethod
(
CGGetPerInterfaceObject
)
:
    
"
"
"
    
A
method
for
getting
the
interface
prototype
object
.
    
"
"
"
    
def
__init__
(
self
descriptor
)
:
        
CGGetPerInterfaceObject
.
__init__
(
self
descriptor
"
GetProtoObject
"
                                         
"
prototypes
:
:
"
)
    
def
definition_body
(
self
)
:
        
return
"
"
"
  
/
*
Get
the
interface
prototype
object
for
this
class
.
This
will
create
the
     
object
as
needed
.
*
/
"
"
"
+
CGGetPerInterfaceObject
.
definition_body
(
self
)
class
CGGetConstructorObjectMethod
(
CGGetPerInterfaceObject
)
:
    
"
"
"
    
A
method
for
getting
the
interface
constructor
object
.
    
"
"
"
    
def
__init__
(
self
descriptor
)
:
        
CGGetPerInterfaceObject
.
__init__
(
self
descriptor
"
GetConstructorObject
"
                                         
"
constructors
:
:
"
)
    
def
definition_body
(
self
)
:
        
return
"
"
"
  
/
*
Get
the
interface
object
for
this
class
.
This
will
create
the
object
as
     
needed
.
*
/
"
"
"
+
CGGetPerInterfaceObject
.
definition_body
(
self
)
def
CheckPref
(
descriptor
globalName
varName
retval
wrapperCache
=
None
)
:
    
"
"
"
    
Check
whether
bindings
should
be
enabled
for
this
descriptor
.
If
not
set
    
varName
to
false
and
return
retval
.
    
"
"
"
    
if
not
descriptor
.
prefable
:
        
return
"
"
    
if
wrapperCache
:
       
wrapperCache
=
"
%
s
-
>
ClearIsDOMBinding
(
)
;
\
n
"
%
(
wrapperCache
)
    
else
:
        
wrapperCache
=
"
"
    
failureCode
=
(
"
%
s
=
false
;
\
n
"
+
                   
"
return
%
s
;
"
)
%
(
varName
retval
)
    
return
"
"
"
  
{
    
XPCWrappedNativeScope
*
scope
=
      
XPCWrappedNativeScope
:
:
FindInJSObjectScope
(
aCx
%
s
)
;
    
if
(
!
scope
)
{
%
s
    
}
    
if
(
!
scope
-
>
ExperimentalBindingsEnabled
(
)
)
{
%
s
%
s
    
}
  
}
"
"
"
%
(
globalName
failureCode
wrapperCache
failureCode
)
class
CGDefineDOMInterfaceMethod
(
CGAbstractMethod
)
:
    
"
"
"
    
A
method
for
resolve
hooks
to
try
to
lazily
define
the
interface
object
for
    
a
given
interface
.
    
"
"
"
    
def
__init__
(
self
descriptor
)
:
        
args
=
[
Argument
(
'
*
JSContext
'
'
aCx
'
)
Argument
(
'
*
JSObject
'
'
aReceiver
'
)
                
Argument
(
'
*
mut
bool
'
'
aEnabled
'
)
]
        
CGAbstractMethod
.
__init__
(
self
descriptor
'
DefineDOMInterface
'
'
bool
'
args
pub
=
True
)
    
def
declare
(
self
)
:
        
if
self
.
descriptor
.
workers
:
            
return
'
'
        
#
return
CGAbstractMethod
.
declare
(
self
)
        
return
"
"
    
def
define
(
self
)
:
        
if
self
.
descriptor
.
workers
:
            
return
'
'
        
return
CGAbstractMethod
.
define
(
self
)
    
def
definition_body
(
self
)
:
        
if
self
.
descriptor
.
interface
.
hasInterfacePrototypeObject
(
)
:
            
#
We
depend
on
GetProtoObject
defining
an
interface
constructor
            
#
object
as
needed
.
            
getter
=
"
GetProtoObject
"
        
else
:
            
getter
=
"
GetConstructorObject
"
        
return
(
"
let
global
:
*
JSObject
=
JS_GetGlobalForObject
(
aCx
aReceiver
)
;
\
n
"
+
                
CheckPref
(
self
.
descriptor
"
global
"
"
*
aEnabled
"
"
false
"
)
+
                
"
"
"
  
*
aEnabled
=
true
;
  
return
%
s
(
aCx
global
aReceiver
)
.
is_not_null
(
)
;
"
"
"
%
(
getter
)
)
class
CGCallGenerator
(
CGThing
)
:
    
"
"
"
    
A
class
to
generate
an
actual
call
to
a
C
+
+
object
.
Assumes
that
the
C
+
+
    
object
is
stored
in
a
variable
whose
name
is
given
by
the
|
object
|
argument
.
    
errorReport
should
be
a
CGThing
for
an
error
report
or
None
if
no
    
error
reporting
is
needed
.
    
"
"
"
    
def
__init__
(
self
errorReport
arguments
argsPre
returnType
                 
extendedAttributes
descriptorProvider
nativeMethodName
                 
static
object
=
"
self
"
declareResult
=
True
)
:
        
CGThing
.
__init__
(
self
)
        
assert
errorReport
is
None
or
isinstance
(
errorReport
CGThing
)
        
isFallible
=
errorReport
is
not
None
        
#
resultAlreadyAddRefed
=
isResultAlreadyAddRefed
(
descriptorProvider
        
#
extendedAttributes
)
        
resultAlreadyAddRefed
=
True
        
(
result
resultOutParam
)
=
getRetvalDeclarationForType
(
returnType
                                                               
descriptorProvider
                                                               
resultAlreadyAddRefed
)
        
args
=
CGList
(
[
CGGeneric
(
arg
)
for
arg
in
argsPre
]
"
"
)
        
for
(
a
name
)
in
arguments
:
            
#
This
is
a
workaround
for
a
bug
in
Apple
'
s
clang
.
            
if
a
.
type
.
isObject
(
)
and
not
a
.
type
.
nullable
(
)
and
not
a
.
optional
:
                
name
=
"
(
JSObject
&
)
"
+
name
            
args
.
append
(
CGGeneric
(
name
)
)
        
#
Return
values
that
go
in
outparams
go
here
        
if
resultOutParam
:
            
args
.
append
(
CGGeneric
(
"
result
"
)
)
        
if
isFallible
:
            
args
.
append
(
CGGeneric
(
"
rv
"
)
)
        
needsCx
=
(
typeNeedsCx
(
returnType
True
)
or
                   
any
(
typeNeedsCx
(
a
.
type
)
for
(
a
_
)
in
arguments
)
or
                   
'
implicitJSContext
'
in
extendedAttributes
)
        
if
not
"
cx
"
in
argsPre
and
needsCx
:
            
args
.
prepend
(
CGGeneric
(
"
cx
"
)
)
        
#
Build
up
our
actual
call
        
self
.
cgRoot
=
CGList
(
[
]
"
\
n
"
)
        
call
=
CGGeneric
(
nativeMethodName
)
        
if
static
:
            
call
=
CGWrapper
(
call
pre
=
"
%
s
:
:
"
%
descriptorProvider
.
nativeType
)
        
else
:
            
call
=
CGWrapper
(
call
pre
=
"
(
*
%
s
)
.
"
%
object
)
        
call
=
CGList
(
[
call
CGWrapper
(
args
pre
=
"
(
"
post
=
"
)
;
"
)
]
)
        
if
result
is
not
None
:
            
if
declareResult
:
                
result
=
CGWrapper
(
result
pre
=
"
let
result
:
"
post
=
"
;
"
)
                
self
.
cgRoot
.
prepend
(
result
)
            
if
not
resultOutParam
:
                
call
=
CGWrapper
(
call
pre
=
"
result
=
"
)
        
call
=
CGWrapper
(
call
)
        
self
.
cgRoot
.
append
(
call
)
        
if
isFallible
:
            
self
.
cgRoot
.
prepend
(
CGGeneric
(
"
ErrorResult
rv
;
"
)
)
            
self
.
cgRoot
.
append
(
CGGeneric
(
"
if
(
rv
.
Failed
(
)
)
{
"
)
)
            
self
.
cgRoot
.
append
(
CGIndenter
(
errorReport
)
)
            
self
.
cgRoot
.
append
(
CGGeneric
(
"
}
"
)
)
    
def
define
(
self
)
:
        
return
self
.
cgRoot
.
define
(
)
class
MethodNotCreatorError
(
Exception
)
:
    
def
__init__
(
self
typename
)
:
        
self
.
typename
=
typename
class
CGPerSignatureCall
(
CGThing
)
:
    
"
"
"
    
This
class
handles
the
guts
of
generating
code
for
a
particular
    
call
signature
.
A
call
signature
consists
of
four
things
:
    
1
)
A
return
type
which
can
be
None
to
indicate
that
there
is
no
       
actual
return
value
(
e
.
g
.
this
is
an
attribute
setter
)
or
an
       
IDLType
if
there
'
s
an
IDL
type
involved
(
including
|
void
|
)
.
    
2
)
An
argument
list
which
is
allowed
to
be
empty
.
    
3
)
A
name
of
a
native
method
to
call
.
    
4
)
Whether
or
not
this
method
is
static
.
    
We
also
need
to
know
whether
this
is
a
method
or
a
getter
/
setter
    
to
do
error
reporting
correctly
.
    
The
idlNode
parameter
can
be
either
a
method
or
an
attr
.
We
can
query
    
|
idlNode
.
identifier
|
in
both
cases
so
we
can
be
agnostic
between
the
two
.
    
"
"
"
    
#
XXXbz
For
now
each
entry
in
the
argument
list
is
either
an
    
#
IDLArgument
or
a
FakeArgument
but
longer
-
term
we
may
want
to
    
#
have
ways
of
flagging
things
like
JSContext
*
or
optional_argc
in
    
#
there
.
    
def
__init__
(
self
returnType
argsPre
arguments
nativeMethodName
static
                 
descriptor
idlNode
argConversionStartsAt
=
0
                 
getter
=
False
setter
=
False
)
:
        
CGThing
.
__init__
(
self
)
        
self
.
returnType
=
returnType
        
self
.
descriptor
=
descriptor
        
self
.
idlNode
=
idlNode
        
self
.
extendedAttributes
=
descriptor
.
getExtendedAttributes
(
idlNode
                                                                   
getter
=
getter
                                                                   
setter
=
setter
)
        
self
.
argsPre
=
argsPre
        
self
.
arguments
=
arguments
        
self
.
argCount
=
len
(
arguments
)
        
if
self
.
argCount
>
argConversionStartsAt
:
            
#
Insert
our
argv
in
there
            
cgThings
=
[
CGGeneric
(
self
.
getArgvDecl
(
)
)
]
        
else
:
            
cgThings
=
[
]
        
cgThings
.
extend
(
[
CGArgumentConverter
(
arguments
[
i
]
i
self
.
getArgv
(
)
                                             
self
.
getArgc
(
)
self
.
descriptor
                                             
invalidEnumValueFatal
=
not
setter
)
for
                         
i
in
range
(
argConversionStartsAt
self
.
argCount
)
]
)
        
cgThings
.
append
(
CGCallGenerator
(
                    
self
.
getErrorReport
(
)
if
self
.
isFallible
(
)
else
None
                    
self
.
getArguments
(
)
self
.
argsPre
returnType
                    
self
.
extendedAttributes
descriptor
nativeMethodName
                    
static
)
)
        
self
.
cgRoot
=
CGList
(
cgThings
"
\
n
"
)
    
def
getArgv
(
self
)
:
        
return
"
argv
"
if
self
.
argCount
>
0
else
"
"
    
def
getArgvDecl
(
self
)
:
        
return
"
\
nargv
:
*
JSVal
=
JS_ARGV
(
cx
vp
)
;
\
n
"
    
def
getArgc
(
self
)
:
        
return
"
argc
"
    
def
getArguments
(
self
)
:
        
return
[
(
a
"
arg
"
+
str
(
i
)
)
for
(
i
a
)
in
enumerate
(
self
.
arguments
)
]
    
def
isFallible
(
self
)
:
        
return
not
'
infallible
'
in
self
.
extendedAttributes
    
def
wrap_return_value
(
self
)
:
        
isCreator
=
memberIsCreator
(
self
.
idlNode
)
        
if
isCreator
:
            
#
We
better
be
returning
addrefed
things
!
            
#
assert
(
isResultAlreadyAddRefed
(
self
.
descriptor
            
#
self
.
extendedAttributes
)
or
                   
#
Workers
use
raw
pointers
for
new
-
object
return
                   
#
values
or
something
            
#
self
.
descriptor
.
workers
)
            
pass
        
resultTemplateValues
=
{
'
jsvalRef
'
:
'
*
vp
'
'
jsvalPtr
'
:
'
vp
'
                                 
'
isCreator
'
:
isCreator
}
        
try
:
            
return
wrapForType
(
self
.
returnType
self
.
descriptor
                               
resultTemplateValues
)
        
except
MethodNotCreatorError
err
:
            
assert
not
isCreator
            
raise
TypeError
(
"
%
s
being
returned
from
non
-
creator
method
or
property
%
s
.
%
s
"
%
                            
(
err
.
typename
                             
self
.
descriptor
.
interface
.
identifier
.
name
                             
self
.
idlNode
.
identifier
.
name
)
)
    
def
getErrorReport
(
self
)
:
        
return
CGGeneric
(
'
return
ThrowMethodFailedWithDetails
<
%
s
>
(
cx
rv
"
%
s
"
"
%
s
"
)
;
'
                         
%
(
toStringBool
(
not
self
.
descriptor
.
workers
)
                            
self
.
descriptor
.
interface
.
identifier
.
name
                            
self
.
idlNode
.
identifier
.
name
)
)
    
def
define
(
self
)
:
        
return
(
self
.
cgRoot
.
define
(
)
+
"
\
n
"
+
self
.
wrap_return_value
(
)
)
class
CGGetterCall
(
CGPerSignatureCall
)
:
    
"
"
"
    
A
class
to
generate
a
native
object
getter
call
for
a
particular
IDL
    
getter
.
    
"
"
"
    
def
__init__
(
self
returnType
nativeMethodName
descriptor
attr
)
:
        
CGPerSignatureCall
.
__init__
(
self
returnType
[
]
[
]
                                    
nativeMethodName
False
descriptor
                                    
attr
getter
=
True
)
class
CGAbstractBindingMethod
(
CGAbstractExternMethod
)
:
    
"
"
"
    
Common
class
to
generate
the
JSNatives
for
all
our
methods
getters
and
    
setters
.
This
will
generate
the
function
declaration
and
unwrap
the
    
|
this
|
object
.
Subclasses
are
expected
to
override
the
generate_code
    
function
to
do
the
rest
of
the
work
.
This
function
should
return
a
    
CGThing
which
is
already
properly
indented
.
    
"
"
"
    
def
__init__
(
self
descriptor
name
args
unwrapFailureCode
=
None
)
:
        
CGAbstractExternMethod
.
__init__
(
self
descriptor
name
"
JSBool
"
args
)
        
if
unwrapFailureCode
is
None
:
            
self
.
unwrapFailureCode
=
(
"
return
Throw
<
%
s
>
(
cx
rv
)
;
"
%
                                      
toStringBool
(
not
descriptor
.
workers
)
)
        
else
:
            
self
.
unwrapFailureCode
=
unwrapFailureCode
    
def
definition_body
(
self
)
:
        
#
Our
descriptor
might
claim
that
we
'
re
not
castable
simply
because
        
#
we
'
re
someone
'
s
consequential
interface
.
But
for
this
-
unwrapping
we
        
#
know
that
we
'
re
the
real
deal
.
So
fake
a
descriptor
here
for
        
#
consumption
by
FailureFatalCastableObjectUnwrapper
.
        
unwrapThis
=
CGIndenter
(
CGGeneric
(
            
str
(
CastableObjectUnwrapper
(
                        
FakeCastableDescriptor
(
self
.
descriptor
)
                        
"
obj
"
"
self
"
self
.
unwrapFailureCode
)
)
)
)
        
return
CGList
(
[
self
.
getThis
(
)
unwrapThis
                        
self
.
generate_code
(
)
]
"
\
n
"
)
.
define
(
)
    
def
getThis
(
self
)
:
        
return
CGIndenter
(
            
CGGeneric
(
"
let
obj
:
*
JSObject
=
JS_THIS_OBJECT
(
cx
vp
)
;
\
n
"
                      
"
if
obj
.
is_null
(
)
{
\
n
"
                      
"
return
false
as
JSBool
;
\
n
"
                      
"
}
\
n
"
                      
"
\
n
"
                      
"
let
self
:
%
s
;
"
%
(
self
.
descriptor
.
pointerType
+
self
.
descriptor
.
nativeType
)
)
)
    
def
generate_code
(
self
)
:
        
assert
(
False
)
#
Override
me
class
CGGenericMethod
(
CGAbstractBindingMethod
)
:
    
"
"
"
    
A
class
for
generating
the
C
+
+
code
for
an
IDL
method
.
.
    
"
"
"
    
def
__init__
(
self
descriptor
)
:
        
args
=
[
Argument
(
'
*
JSContext
'
'
cx
'
)
Argument
(
'
uint
'
'
argc
'
)
                
Argument
(
'
*
JSVal
'
'
vp
'
)
]
        
CGAbstractBindingMethod
.
__init__
(
self
descriptor
'
genericMethod
'
args
)
    
def
generate_code
(
self
)
:
        
return
CGIndenter
(
CGGeneric
(
            
"
let
_info
:
*
JSJitInfo
=
RUST_FUNCTION_VALUE_TO_JITINFO
(
JS_CALLEE
(
cx
vp
)
)
;
\
n
"
            
"
let
method
:
JSJitMethodOp
=
(
*
_info
)
.
op
;
\
n
"
            
"
return
method
(
cx
obj
self
argc
vp
)
;
"
)
)
class
CGGenericGetter
(
CGAbstractBindingMethod
)
:
    
"
"
"
    
A
class
for
generating
the
C
+
+
code
for
an
IDL
attribute
getter
.
    
"
"
"
    
def
__init__
(
self
descriptor
lenientThis
=
False
)
:
        
args
=
[
Argument
(
'
*
JSContext
'
'
cx
'
)
Argument
(
'
uint
'
'
argc
'
)
                
Argument
(
'
*
JSVal
'
'
vp
'
)
]
        
if
lenientThis
:
            
name
=
"
genericLenientGetter
"
            
unwrapFailureCode
=
(
                
"
MOZ_ASSERT
(
!
JS_IsExceptionPending
(
cx
)
)
;
\
n
"
                
"
JS_SET_RVAL
(
cx
vp
JS
:
:
UndefinedValue
(
)
)
;
\
n
"
                
"
return
true
;
"
)
        
else
:
            
name
=
"
genericGetter
"
            
unwrapFailureCode
=
None
        
CGAbstractBindingMethod
.
__init__
(
self
descriptor
name
args
                                         
unwrapFailureCode
)
    
def
generate_code
(
self
)
:
        
return
CGIndenter
(
CGGeneric
(
            
"
let
_info
:
*
JSJitInfo
=
RUST_FUNCTION_VALUE_TO_JITINFO
(
JS_CALLEE
(
cx
vp
)
)
;
\
n
"
            
"
let
tmp
:
*
rust_box
<
%
s
>
=
cast
:
:
reinterpret_cast
(
&
self
)
;
\
n
"
            
"
return
CallJitPropertyOp
(
_info
cx
obj
ptr
:
:
addr_of
(
&
(
*
tmp
)
.
payload
)
as
*
libc
:
:
c_void
vp
)
;
"
%
self
.
descriptor
.
nativeType
)
)
class
CGSpecializedGetter
(
CGAbstractExternMethod
)
:
    
"
"
"
    
A
class
for
generating
the
code
for
a
specialized
attribute
getter
    
that
the
JIT
can
call
with
lower
overhead
.
    
"
"
"
    
def
__init__
(
self
descriptor
attr
)
:
        
self
.
attr
=
attr
        
name
=
'
get_
'
+
attr
.
identifier
.
name
        
args
=
[
Argument
(
'
*
JSContext
'
'
cx
'
)
                 
Argument
(
'
*
JSObject
'
'
obj
'
)
                 
Argument
(
'
*
%
s
'
%
descriptor
.
nativeType
'
self
'
)
                 
Argument
(
'
*
mut
JSVal
'
'
vp
'
)
]
        
CGAbstractExternMethod
.
__init__
(
self
descriptor
name
"
bool
"
args
)
    
def
definition_body
(
self
)
:
        
name
=
self
.
attr
.
identifier
.
name
        
nativeName
=
MakeNativeName
(
self
.
descriptor
.
binaryNames
.
get
(
name
name
)
)
        
#
resultOutParam
does
not
depend
on
whether
resultAlreadyAddRefed
is
set
        
(
_
resultOutParam
)
=
getRetvalDeclarationForType
(
self
.
attr
.
type
                                                          
self
.
descriptor
                                                          
False
)
        
infallible
=
(
'
infallible
'
in
                      
self
.
descriptor
.
getExtendedAttributes
(
self
.
attr
                                                            
getter
=
True
)
)
        
if
resultOutParam
or
self
.
attr
.
type
.
nullable
(
)
or
not
infallible
:
            
nativeName
=
"
Get
"
+
nativeName
        
return
CGIndenter
(
CGGetterCall
(
self
.
attr
.
type
nativeName
                                       
self
.
descriptor
self
.
attr
)
)
.
define
(
)
def
infallibleForMember
(
member
type
descriptorProvider
)
:
    
"
"
"
    
Determine
the
fallibility
of
changing
a
C
+
+
value
of
IDL
type
"
type
"
into
    
JS
for
the
given
attribute
.
Apart
from
isCreator
all
the
defaults
are
used
    
since
the
fallbility
does
not
change
based
on
the
boolean
values
    
and
the
template
will
be
discarded
.
    
CURRENT
ASSUMPTIONS
:
        
We
assume
that
successCode
for
wrapping
up
return
values
cannot
contain
        
failure
conditions
.
    
"
"
"
    
return
getWrapTemplateForType
(
type
descriptorProvider
'
result
'
None
\
                                  
memberIsCreator
(
member
)
)
[
1
]
class
CGMemberJITInfo
(
CGThing
)
:
    
"
"
"
    
A
class
for
generating
the
JITInfo
for
a
property
that
points
to
    
our
specialized
getter
and
setter
.
    
"
"
"
    
def
__init__
(
self
descriptor
member
)
:
        
self
.
member
=
member
        
self
.
descriptor
=
descriptor
    
def
declare
(
self
)
:
        
return
"
"
    
def
defineJitInfo
(
self
infoName
opName
infallible
)
:
        
protoID
=
"
prototypes
:
:
id
:
:
%
s
as
u32
"
%
self
.
descriptor
.
name
        
depth
=
self
.
descriptor
.
interface
.
inheritanceDepth
(
)
        
failstr
=
"
true
"
if
infallible
else
"
false
"
        
return
(
"
\
n
"
                
"
const
%
s
:
JSJitInfo
=
JSJitInfo
{
\
n
"
                
"
op
:
%
s
\
n
"
                
"
protoID
:
%
s
\
n
"
                
"
depth
:
%
s
\
n
"
                
"
isInfallible
:
%
s
/
*
False
in
setters
.
*
/
\
n
"
                
"
isConstant
:
false
/
*
Only
relevant
for
getters
.
*
/
\
n
"
                
"
}
;
\
n
"
%
(
infoName
opName
protoID
depth
failstr
)
)
    
def
define
(
self
)
:
        
if
self
.
member
.
isAttr
(
)
:
            
getterinfo
=
(
"
%
s_getterinfo
"
%
self
.
member
.
identifier
.
name
)
            
getter
=
(
"
get_
%
s
"
%
self
.
member
.
identifier
.
name
)
            
getterinfal
=
"
infallible
"
in
self
.
descriptor
.
getExtendedAttributes
(
self
.
member
getter
=
True
)
            
getterinfal
=
getterinfal
and
infallibleForMember
(
self
.
member
self
.
member
.
type
self
.
descriptor
)
            
result
=
self
.
defineJitInfo
(
getterinfo
getter
getterinfal
)
            
if
not
self
.
member
.
readonly
:
                
setterinfo
=
(
"
%
s_setterinfo
"
%
self
.
member
.
identifier
.
name
)
                
setter
=
(
"
set_
%
s
"
%
self
.
member
.
identifier
.
name
)
                
#
Setters
are
always
fallible
since
they
have
to
do
a
typed
unwrap
.
                
result
+
=
self
.
defineJitInfo
(
setterinfo
setter
False
)
            
return
result
        
if
self
.
member
.
isMethod
(
)
:
            
methodinfo
=
(
"
%
s_methodinfo
"
%
self
.
member
.
identifier
.
name
)
            
#
Actually
a
JSJitMethodOp
but
JSJitPropertyOp
by
struct
definition
.
            
method
=
(
"
%
s
"
%
self
.
member
.
identifier
.
name
)
            
#
Methods
are
infallible
if
they
are
infallible
have
no
arguments
            
#
to
unwrap
and
have
a
return
type
that
'
s
infallible
to
wrap
up
for
            
#
return
.
            
methodInfal
=
False
            
sigs
=
self
.
member
.
signatures
(
)
            
if
len
(
sigs
)
=
=
1
:
                
#
Don
'
t
handle
overloading
.
If
there
'
s
more
than
one
signature
                
#
one
of
them
must
take
arguments
.
                
sig
=
sigs
[
0
]
                
if
len
(
sig
[
1
]
)
=
=
0
and
infallibleForMember
(
self
.
member
sig
[
0
]
self
.
descriptor
)
:
                    
#
No
arguments
and
infallible
return
boxing
                    
methodInfal
=
True
            
result
=
self
.
defineJitInfo
(
methodinfo
method
methodInfal
)
            
return
result
        
raise
TypeError
(
"
Illegal
member
type
to
CGPropertyJITInfo
"
)
class
CGAbstractStaticMethod
(
CGAbstractMethod
)
:
    
"
"
"
    
Abstract
base
class
for
codegen
of
implementation
-
only
(
no
    
declaration
)
static
methods
.
    
"
"
"
    
def
__init__
(
self
descriptor
name
returnType
args
)
:
        
CGAbstractMethod
.
__init__
(
self
descriptor
name
returnType
args
                                  
inline
=
False
static
=
True
)
    
def
declare
(
self
)
:
        
#
We
only
have
implementation
        
return
"
"
class
CGAbstractClassHook
(
CGAbstractExternMethod
)
:
    
"
"
"
    
Meant
for
implementing
JSClass
hooks
like
Finalize
or
Trace
.
Does
very
raw
    
'
this
'
unwrapping
as
it
assumes
that
the
unwrapped
type
is
always
known
.
    
"
"
"
    
def
__init__
(
self
descriptor
name
returnType
args
)
:
        
CGAbstractExternMethod
.
__init__
(
self
descriptor
name
returnType
                                        
args
)
    
def
definition_body_prologue
(
self
)
:
        
return
"
"
#
XXXjdm
we
may
want
to
do
a
proper
unwrap
here
        
return
"
"
"
  
let
self
:
*
%
s
=
&
(
unwrap
:
:
<
*
rust_box
<
%
s
>
>
(
obj
)
.
payload
)
;
"
"
"
%
(
self
.
descriptor
.
nativeType
self
.
descriptor
.
nativeType
)
    
def
definition_body
(
self
)
:
        
return
self
.
definition_body_prologue
(
)
+
self
.
generate_code
(
)
    
def
generate_code
(
self
)
:
        
#
Override
me
        
assert
(
False
)
def
finalizeHook
(
descriptor
hookName
context
)
:
    
if
descriptor
.
customFinalize
:
        
return
"
"
"
if
(
self
)
{
  
self
-
>
%
s
(
%
s
)
;
}
"
"
"
%
(
hookName
context
)
    
#
clearWrapper
=
"
ClearWrapper
(
self
self
)
;
\
n
"
if
descriptor
.
wrapperCache
else
"
"
    
if
descriptor
.
workers
:
        
#
release
=
"
self
-
>
Release
(
)
;
"
        
pass
    
else
:
        
assert
descriptor
.
nativeIsISupports
        
release
=
"
"
"
let
val
=
JS_GetReservedSlot
(
obj
0
)
;
let
_
:
%
s
=
cast
:
:
reinterpret_cast
(
&
RUST_JSVAL_TO_PRIVATE
(
val
)
)
;
"
"
"
%
(
descriptor
.
pointerType
+
descriptor
.
nativeType
)
    
#
return
clearWrapper
+
release
    
return
release
class
CGClassConstructHook
(
CGAbstractStaticMethod
)
:
    
"
"
"
    
JS
-
visible
constructor
for
our
objects
    
"
"
"
    
def
__init__
(
self
descriptor
)
:
        
args
=
[
Argument
(
'
*
JSContext
'
'
cx
'
)
Argument
(
'
unsigned
'
'
argc
'
)
Argument
(
'
*
jsval
'
'
vp
'
)
]
        
CGAbstractStaticMethod
.
__init__
(
self
descriptor
CONSTRUCT_HOOK_NAME
                                        
'
JSBool
'
args
)
        
self
.
_ctor
=
self
.
descriptor
.
interface
.
ctor
(
)
    
def
define
(
self
)
:
        
if
not
self
.
_ctor
:
            
return
"
"
        
return
CGAbstractStaticMethod
.
define
(
self
)
    
def
definition_body
(
self
)
:
        
return
self
.
generate_code
(
)
    
def
generate_code
(
self
)
:
        
preamble
=
"
"
"
  
JSObject
*
obj
=
JS_GetGlobalForObject
(
cx
JSVAL_TO_OBJECT
(
JS_CALLEE
(
cx
vp
)
)
)
;
"
"
"
        
if
self
.
descriptor
.
workers
:
            
preArgs
=
[
"
cx
"
"
obj
"
]
        
else
:
            
preamble
+
=
"
"
"
  
nsISupports
*
global
;
  
xpc_qsSelfRef
globalRef
;
  
{
    
nsresult
rv
;
    
JS
:
:
Value
val
=
OBJECT_TO_JSVAL
(
obj
)
;
    
rv
=
xpc_qsUnwrapArg
<
nsISupports
>
(
cx
val
&
global
&
globalRef
.
ptr
&
val
)
;
    
if
(
NS_FAILED
(
rv
)
)
{
      
return
Throw
<
true
>
(
cx
NS_ERROR_XPC_BAD_CONVERT_JS
)
;
    
}
  
}
"
"
"
            
preArgs
=
[
"
global
"
]
        
name
=
self
.
_ctor
.
identifier
.
name
        
nativeName
=
MakeNativeName
(
self
.
descriptor
.
binaryNames
.
get
(
name
name
)
)
        
callGenerator
=
CGMethodCall
(
preArgs
nativeName
True
                                     
self
.
descriptor
self
.
_ctor
)
        
return
preamble
+
callGenerator
.
define
(
)
;
class
CGClassHasInstanceHook
(
CGAbstractStaticMethod
)
:
    
def
__init__
(
self
descriptor
)
:
        
args
=
[
Argument
(
'
*
JSContext
'
'
cx
'
)
Argument
(
'
JSHandleObject
'
'
obj
'
)
                
Argument
(
'
JSMutableHandleValue
'
'
vp
'
)
Argument
(
'
*
JSBool
'
'
bp
'
)
]
        
CGAbstractStaticMethod
.
__init__
(
self
descriptor
HASINSTANCE_HOOK_NAME
                                        
'
JSBool
'
args
)
    
def
define
(
self
)
:
        
if
not
self
.
descriptor
.
hasInstanceInterface
:
            
return
"
"
        
return
CGAbstractStaticMethod
.
define
(
self
)
    
def
definition_body
(
self
)
:
        
return
self
.
generate_code
(
)
    
def
generate_code
(
self
)
:
        
return
"
"
"
if
(
!
vp
.
isObject
(
)
)
{
    
*
bp
=
false
;
    
return
true
;
  
}
  
jsval
protov
;
  
if
(
!
JS_GetProperty
(
cx
obj
"
prototype
"
&
protov
)
)
    
return
false
;
  
if
(
!
protov
.
isObject
(
)
)
{
    
JS_ReportErrorNumber
(
cx
js_GetErrorMessage
NULL
JSMSG_BAD_PROTOTYPE
                         
"
%
s
"
)
;
    
return
false
;
  
}
  
JSObject
*
objProto
=
&
protov
.
toObject
(
)
;
  
JSObject
*
instance
=
&
vp
.
toObject
(
)
;
  
JSObject
*
proto
;
  
if
(
!
JS_GetPrototype
(
cx
instance
&
proto
)
)
    
return
false
;
  
while
(
proto
)
{
    
if
(
proto
=
=
objProto
)
{
      
*
bp
=
true
;
      
return
true
;
    
}
    
if
(
!
JS_GetPrototype
(
cx
proto
&
proto
)
)
      
return
false
;
  
}
  
nsISupports
*
native
=
    
nsContentUtils
:
:
XPConnect
(
)
-
>
GetNativeOfWrapper
(
cx
instance
)
;
  
nsCOMPtr
<
%
s
>
qiResult
=
do_QueryInterface
(
native
)
;
  
*
bp
=
!
!
qiResult
;
  
return
true
;
"
"
"
%
(
self
.
descriptor
.
name
self
.
descriptor
.
hasInstanceInterface
)
class
CGClassFinalizeHook
(
CGAbstractClassHook
)
:
    
"
"
"
    
A
hook
for
finalize
used
to
release
our
native
object
.
    
"
"
"
    
def
__init__
(
self
descriptor
)
:
        
args
=
[
Argument
(
'
*
JSFreeOp
'
'
fop
'
)
Argument
(
'
*
JSObject
'
'
obj
'
)
]
        
CGAbstractClassHook
.
__init__
(
self
descriptor
FINALIZE_HOOK_NAME
                                     
'
void
'
args
)
    
def
generate_code
(
self
)
:
        
return
CGIndenter
(
CGGeneric
(
finalizeHook
(
self
.
descriptor
self
.
name
self
.
args
[
0
]
.
name
)
)
)
.
define
(
)
class
CGDescriptor
(
CGThing
)
:
    
def
__init__
(
self
descriptor
)
:
        
CGThing
.
__init__
(
self
)
        
assert
not
descriptor
.
concrete
or
descriptor
.
interface
.
hasInterfacePrototypeObject
(
)
        
cgThings
=
[
]
        
if
descriptor
.
interface
.
hasInterfacePrototypeObject
(
)
:
            
(
hasMethod
hasGetter
hasLenientGetter
             
hasSetter
hasLenientSetter
)
=
False
False
False
False
False
            
for
m
in
descriptor
.
interface
.
members
:
                
if
m
.
isMethod
(
)
and
not
m
.
isStatic
(
)
and
not
m
.
isIdentifierLess
(
)
:
                    
#
cgThings
.
append
(
CGSpecializedMethod
(
descriptor
m
)
)
                    
#
cgThings
.
append
(
CGMemberJITInfo
(
descriptor
m
)
)
                    
hasMethod
=
True
                
elif
m
.
isAttr
(
)
:
                    
cgThings
.
append
(
CGSpecializedGetter
(
descriptor
m
)
)
                    
if
m
.
hasLenientThis
(
)
:
                        
hasLenientGetter
=
True
                    
else
:
                        
hasGetter
=
True
                    
if
not
m
.
readonly
:
                        
#
cgThings
.
append
(
CGSpecializedSetter
(
descriptor
m
)
)
                        
if
m
.
hasLenientThis
(
)
:
                            
hasLenientSetter
=
True
                        
else
:
                            
hasSetter
=
True
                    
cgThings
.
append
(
CGMemberJITInfo
(
descriptor
m
)
)
            
#
if
hasMethod
:
cgThings
.
append
(
CGGenericMethod
(
descriptor
)
)
            
if
hasGetter
:
cgThings
.
append
(
CGGenericGetter
(
descriptor
)
)
            
#
if
hasLenientGetter
:
cgThings
.
append
(
CGGenericGetter
(
descriptor
            
#
lenientThis
=
True
)
)
            
#
if
hasSetter
:
cgThings
.
append
(
CGGenericSetter
(
descriptor
)
)
            
#
if
hasLenientSetter
:
cgThings
.
append
(
CGGenericSetter
(
descriptor
            
#
lenientThis
=
True
)
)
        
if
descriptor
.
concrete
and
not
descriptor
.
proxy
:
            
if
not
descriptor
.
workers
and
descriptor
.
wrapperCache
:
                
#
cgThings
.
append
(
CGAddPropertyHook
(
descriptor
)
)
                
pass
            
#
Always
have
a
finalize
hook
regardless
of
whether
the
class
wants
a
            
#
custom
hook
.
            
cgThings
.
append
(
CGClassFinalizeHook
(
descriptor
)
)
            
#
Only
generate
a
trace
hook
if
the
class
wants
a
custom
hook
.
            
if
(
descriptor
.
customTrace
)
:
                
#
cgThings
.
append
(
CGClassTraceHook
(
descriptor
)
)
                
pass
        
if
descriptor
.
interface
.
hasInterfaceObject
(
)
:
            
cgThings
.
append
(
CGClassConstructHook
(
descriptor
)
)
            
cgThings
.
append
(
CGClassHasInstanceHook
(
descriptor
)
)
            
cgThings
.
append
(
CGInterfaceObjectJSClass
(
descriptor
)
)
            
pass
        
if
descriptor
.
interface
.
hasInterfacePrototypeObject
(
)
:
            
cgThings
.
append
(
CGPrototypeJSClass
(
descriptor
)
)
            
pass
        
properties
=
PropertyArrays
(
descriptor
)
        
cgThings
.
append
(
CGGeneric
(
define
=
str
(
properties
)
)
)
        
cgThings
.
append
(
CGCreateInterfaceObjectsMethod
(
descriptor
properties
)
)
        
if
descriptor
.
interface
.
hasInterfacePrototypeObject
(
)
:
            
cgThings
.
append
(
CGGetProtoObjectMethod
(
descriptor
)
)
            
pass
        
else
:
            
cgThings
.
append
(
CGGetConstructorObjectMethod
(
descriptor
)
)
            
pass
        
#
Set
up
our
Xray
callbacks
as
needed
.
Note
that
we
don
'
t
need
to
do
        
#
it
in
workers
.
        
if
(
descriptor
.
interface
.
hasInterfacePrototypeObject
(
)
and
            
not
descriptor
.
workers
)
:
            
if
descriptor
.
concrete
and
descriptor
.
proxy
:
                
#
cgThings
.
append
(
CGResolveOwnProperty
(
descriptor
)
)
                
#
cgThings
.
append
(
CGEnumerateOwnProperties
(
descriptor
)
)
                
pass
            
#
cgThings
.
append
(
CGResolveProperty
(
descriptor
properties
)
)
            
#
cgThings
.
append
(
CGEnumerateProperties
(
descriptor
properties
)
)
        
if
descriptor
.
interface
.
hasInterfaceObject
(
)
:
            
cgThings
.
append
(
CGDefineDOMInterfaceMethod
(
descriptor
)
)
            
if
(
not
descriptor
.
interface
.
isExternal
(
)
and
                
#
Workers
stuff
is
never
pref
-
controlled
                
not
descriptor
.
workers
and
                
descriptor
.
interface
.
getExtendedAttribute
(
"
PrefControlled
"
)
is
not
None
)
:
                
#
cgThings
.
append
(
CGPrefEnabled
(
descriptor
)
)
                
pass
        
if
descriptor
.
interface
.
hasInterfacePrototypeObject
(
)
:
            
cgThings
.
append
(
CGNativePropertyHooks
(
descriptor
)
)
            
pass
        
if
descriptor
.
concrete
:
            
if
descriptor
.
proxy
:
                
#
cgThings
.
append
(
CGProxyIsProxy
(
descriptor
)
)
                
#
cgThings
.
append
(
CGProxyUnwrap
(
descriptor
)
)
                
#
cgThings
.
append
(
CGDOMJSProxyHandlerDOMClass
(
descriptor
)
)
                
#
cgThings
.
append
(
CGDOMJSProxyHandler
(
descriptor
)
)
                
#
cgThings
.
append
(
CGIsMethod
(
descriptor
)
)
                
pass
            
else
:
                
cgThings
.
append
(
CGDOMJSClass
(
descriptor
)
)
                
pass
            
if
descriptor
.
wrapperCache
:
                
#
cgThings
.
append
(
CGWrapWithCacheMethod
(
descriptor
)
)
                
#
cgThings
.
append
(
CGWrapMethod
(
descriptor
)
)
                
pass
            
else
:
                
#
cgThings
.
append
(
CGWrapNonWrapperCacheMethod
(
descriptor
)
)
                
pass
        
cgThings
=
CGList
(
(
CGIndenter
(
t
declareOnly
=
True
)
for
t
in
cgThings
)
"
\
n
"
)
        
cgThings
=
CGWrapper
(
cgThings
pre
=
'
\
n
'
post
=
'
\
n
'
)
        
#
self
.
cgRoot
=
CGWrapper
(
CGNamespace
(
toBindingNamespace
(
descriptor
.
name
)
        
#
cgThings
)
        
#
post
=
'
\
n
'
)
        
self
.
cgRoot
=
cgThings
    
def
declare
(
self
)
:
        
return
self
.
cgRoot
.
declare
(
)
    
def
define
(
self
)
:
        
return
self
.
cgRoot
.
define
(
)
class
CGBindingRoot
(
CGThing
)
:
    
"
"
"
    
Root
codegen
class
for
binding
generation
.
Instantiate
the
class
and
call
    
declare
or
define
to
generate
header
or
cpp
code
(
respectively
)
.
    
"
"
"
    
def
__init__
(
self
config
prefix
webIDLFile
)
:
        
descriptors
=
config
.
getDescriptors
(
webIDLFile
=
webIDLFile
                                            
hasInterfaceOrInterfacePrototypeObject
=
True
)
        
dictionaries
=
config
.
getDictionaries
(
webIDLFile
)
        
cgthings
=
[
]
        
#
Do
codegen
for
all
the
descriptors
        
cgthings
.
extend
(
[
CGDescriptor
(
x
)
for
x
in
descriptors
]
)
        
#
And
make
sure
we
have
the
right
number
of
newlines
at
the
end
        
curr
=
CGWrapper
(
CGList
(
cgthings
"
\
n
\
n
"
)
post
=
"
\
n
\
n
"
)
        
#
Wrap
all
of
that
in
our
namespaces
.
        
#
curr
=
CGNamespace
.
build
(
[
'
dom
'
]
        
#
CGWrapper
(
curr
pre
=
"
\
n
"
)
)
        
#
Add
imports
        
curr
=
CGImports
(
descriptors
                         
dictionaries
                         
[
]
                         
[
'
js
:
:
*
'
                          
'
js
:
:
jsapi
:
:
*
'
                          
'
js
:
:
jsapi
:
:
bindgen
:
:
*
'
                          
'
js
:
:
jsfriendapi
:
:
bindgen
:
:
*
'
                          
'
js
:
:
glue
:
:
bindgen
:
:
*
'
                          
'
dom
:
:
bindings
:
:
utils
:
:
*
'
                          
'
dom
:
:
bindings
:
:
clientrect
:
:
*
'
#
XXXjdm
                         
]
                         
curr
)
        
#
Add
the
auto
-
generated
comment
.
        
curr
=
CGWrapper
(
curr
pre
=
AUTOGENERATED_WARNING_COMMENT
)
        
#
Store
the
final
result
.
        
self
.
root
=
curr
    
def
declare
(
self
)
:
        
return
stripTrailingWhitespace
(
self
.
root
.
declare
(
)
)
    
def
define
(
self
)
:
        
return
stripTrailingWhitespace
(
self
.
root
.
define
(
)
)
