use
gfx
:
:
display_list
:
:
DisplayList
;
use
gfx
:
:
compositor
:
:
{
LayerBuffer
LayerBufferSet
}
;
use
azure
:
:
AzFloat
;
use
azure
:
:
azure_hl
:
:
DrawTarget
;
use
cairo
:
:
CAIRO_FORMAT_RGB24
;
use
cairo
:
:
cairo_hl
:
:
ImageSurface
;
use
core
:
:
libc
:
:
c_int
;
use
geom
:
:
matrix2d
:
:
Matrix2D
;
use
geom
:
:
point
:
:
Point2D
;
use
geom
:
:
rect
:
:
Rect
;
use
geom
:
:
size
:
:
Size2D
;
const
TILE_SIZE
:
uint
=
512
;
pub
struct
RenderLayer
{
display_list
:
DisplayList
size
:
Size2D
<
uint
>
}
/
/
/
Given
a
layer
and
a
buffer
either
reuses
the
buffer
(
if
it
'
s
of
the
right
size
and
format
)
/
/
/
or
creates
a
new
buffer
(
if
it
'
s
not
of
the
appropriate
size
and
format
)
and
invokes
the
/
/
/
given
callback
with
the
render
layer
and
the
buffer
.
Returns
the
resulting
layer
buffer
(
which
/
/
/
might
be
the
old
layer
buffer
if
it
had
the
appropriate
size
and
format
)
.
pub
fn
render_layers
(
layer
:
&
RenderLayer
buffer_set
:
LayerBufferSet
f
:
&
fn
(
layer
:
&
RenderLayer
buffer
:
&
LayerBuffer
)
-
>
bool
)
-
>
LayerBufferSet
{
let
mut
buffers
=
match
move
buffer_set
{
LayerBufferSet
{
buffers
:
move
b
}
=
>
move
b
}
;
/
/
FIXME
:
Try
not
to
create
a
new
array
here
.
let
new_buffers
=
dvec
:
:
DVec
(
)
;
/
/
Divide
up
the
layer
into
tiles
.
let
mut
y
=
0
;
while
y
<
layer
.
size
.
height
{
let
mut
x
=
0
;
while
x
<
layer
.
size
.
width
{
/
/
Figure
out
the
dimension
of
this
tile
.
let
right
=
uint
:
:
min
(
x
+
TILE_SIZE
layer
.
size
.
width
)
;
let
bottom
=
uint
:
:
min
(
y
+
TILE_SIZE
layer
.
size
.
height
)
;
let
width
=
right
-
x
;
let
height
=
bottom
-
y
;
/
/
Round
the
width
up
the
nearest
32
pixels
for
DMA
on
the
Mac
.
let
mut
stride
=
width
;
if
stride
%
32
!
=
0
{
stride
=
(
stride
&
!
(
32
-
1
)
)
+
32
;
}
assert
stride
%
32
=
=
0
;
assert
stride
>
=
width
;
let
tile_rect
=
Rect
(
Point2D
(
x
y
)
Size2D
(
width
height
)
)
;
let
buffer
;
/
/
FIXME
:
Try
harder
to
search
for
a
matching
tile
.
/
/
FIXME
:
Don
'
t
use
shift
;
it
'
s
bad
for
perf
.
Maybe
reverse
and
pop
.
if
buffers
.
len
(
)
!
=
0
&
&
buffers
[
0
]
.
rect
=
=
tile_rect
{
debug
!
(
"
reusing
tile
(
%
u
%
u
)
"
x
y
)
;
buffer
=
buffers
.
shift
(
)
;
}
else
{
/
/
Create
a
new
buffer
.
debug
!
(
"
creating
tile
(
%
u
%
u
)
"
x
y
)
;
let
cairo_surface
=
ImageSurface
(
CAIRO_FORMAT_RGB24
stride
as
c_int
height
as
c_int
)
;
let
draw_target
=
DrawTarget
(
&
cairo_surface
)
;
buffer
=
LayerBuffer
{
cairo_surface
:
move
cairo_surface
draw_target
:
move
draw_target
rect
:
tile_rect
stride
:
stride
}
;
}
let
_
=
f
(
layer
&
buffer
)
;
new_buffers
.
push
(
move
buffer
)
;
x
+
=
TILE_SIZE
;
}
y
+
=
TILE_SIZE
;
}
return
LayerBufferSet
{
buffers
:
move
dvec
:
:
unwrap
(
move
new_buffers
)
}
;
}
