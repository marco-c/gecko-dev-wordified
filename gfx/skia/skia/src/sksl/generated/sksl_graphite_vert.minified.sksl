static
constexpr
char
SKSL_MINIFIED_sksl_graphite_vert
[
]
=
"
pure
float
curve_type_using_inf_support
(
float4
a
)
{
return
isinf
(
a
.
z
)
?
2
.
:
float
"
"
(
isinf
(
a
.
w
)
)
;
}
pure
bool
k
(
float
a
)
{
return
a
!
=
0
.
;
}
pure
bool
l
(
float
a
)
{
return
"
"
a
=
=
2
.
;
}
pure
float
m
(
float2
a
float2
b
float2
c
float2
d
float2x2
e
)
{
float2
"
"
f
=
e
*
(
fma
(
-
2
.
.
xx
b
c
)
+
a
)
;
float2
g
=
e
*
(
fma
(
-
2
.
.
xx
c
d
)
+
b
)
;
return
max
(
dot
(
f
f
)
"
"
dot
(
g
g
)
)
;
}
pure
float
n
(
float2
a
float2
b
float2
c
float2
d
float2x2
e
)
{
"
"
float
f
=
m
(
a
b
c
d
e
)
;
return
max
(
ceil
(
sqrt
(
3
.
*
sqrt
(
f
)
)
)
1
.
)
;
}
pure
float
o
"
"
(
float2
a
float2
b
float2
c
float2
d
float2x2
e
)
{
float
f
=
m
(
a
b
c
d
e
)
;
return
"
"
ceil
(
log2
(
max
(
9
.
*
f
1
.
)
)
*
.
25
)
;
}
pure
float
p
(
float2
a
float2
b
float2
c
float
"
"
d
)
{
float2
e
=
(
min
(
min
(
a
b
)
c
)
+
max
(
max
(
a
b
)
c
)
)
*
.
5
;
a
-
=
e
;
b
-
=
e
;
c
-
=
e
;
float
f
=
sqrt
"
"
(
max
(
max
(
dot
(
a
a
)
dot
(
b
b
)
)
dot
(
c
c
)
)
)
;
float2
g
=
fma
(
(
-
2
.
*
d
)
.
xx
b
a
)
+
c
;
float
"
"
h
=
abs
(
fma
(
-
2
.
d
2
.
)
)
;
float
i
=
max
(
0
.
fma
(
f
4
.
-
1
.
)
)
;
float
j
=
length
(
g
)
*
4
.
+
i
*
"
"
h
;
float
k
=
4
.
*
min
(
d
1
.
)
;
return
j
/
k
;
}
pure
float
q
(
float2
a
float2
b
float2
c
"
"
float
d
)
{
float
e
=
p
(
a
b
c
d
)
;
return
max
(
ceil
(
sqrt
(
e
)
)
1
.
)
;
}
pure
float
r
(
"
"
float2
a
float2
b
float2
c
float
d
)
{
float
e
=
p
(
a
b
c
d
)
;
return
ceil
(
log2
(
max
"
"
(
e
1
.
)
)
*
.
5
)
;
}
pure
float2
s
(
float2
c
float2
d
)
{
float2
e
=
c
-
d
;
if
(
e
=
=
0
.
.
xx
)
return
"
"
0
.
.
xx
;
else
{
float
f
=
1
.
/
max
(
abs
(
e
.
x
)
abs
(
e
.
y
)
)
;
return
normalize
(
f
*
e
)
;
}
}
pure
"
"
float
t
(
float2
c
float2
d
)
{
return
clamp
(
dot
(
c
d
)
-
1
.
1
.
)
;
}
pure
float
u
(
"
"
float
a
float
b
)
{
float
c
=
fma
(
a
.
5
.
5
)
;
return
(
c
*
b
)
*
b
>
=
1
.
?
inversesqrt
(
c
)
:
sqrt
"
"
(
c
)
;
}
pure
float
v
(
float
a
)
{
return
.
5
/
acos
(
max
(
1
.
-
.
25
/
a
-
1
.
)
)
;
}
pure
float
w
"
"
(
float
c
float
d
float
e
)
{
return
fma
(
d
-
c
e
c
)
;
}
pure
float2
w
(
float2
c
float2
"
"
d
float
e
)
{
return
fma
(
d
-
c
e
.
xx
c
)
;
}
pure
float4
w
(
float4
c
float4
d
float4
"
"
e
)
{
return
fma
(
d
-
c
e
c
)
;
}
pure
float2
tessellate_filled_curve
(
float2x2
a
float
"
"
b
float
c
float4
d
float4
e
float
f
)
{
float2
g
;
if
(
l
(
f
)
)
g
=
b
!
=
0
.
?
d
.
zw
:
(
c
!
=
0
.
"
"
?
e
.
xy
:
d
.
xy
)
;
else
{
float2
h
=
d
.
xy
;
float2
i
=
d
.
zw
;
float2
j
=
e
.
xy
;
float2
k
=
e
.
zw
;
float
"
"
l
=
-
1
.
;
float
m
;
if
(
k
(
f
)
)
{
l
=
k
.
x
;
m
=
r
(
a
*
h
a
*
i
a
*
j
l
)
;
i
*
=
l
;
k
=
j
;
}
else
m
=
o
(
h
i
"
"
j
k
a
)
;
if
(
b
>
m
)
{
c
=
floor
(
ldexp
(
c
int
(
m
-
b
)
)
)
;
b
=
m
;
}
float
n
=
floor
(
.
5
+
ldexp
(
c
int
"
"
(
5
.
-
b
)
)
)
;
if
(
0
.
<
n
&
&
n
<
32
.
)
{
float
o
=
n
*
.
03125
;
float2
p
=
mix
(
h
i
o
)
;
float2
q
=
mix
(
"
"
i
j
o
)
;
float2
r
=
mix
(
j
k
o
)
;
float2
s
=
mix
(
p
q
o
)
;
float2
t
=
mix
(
q
r
o
)
;
float2
x
"
"
=
mix
(
s
t
o
)
;
float
y
=
mix
(
1
.
l
o
)
;
float
z
=
(
l
+
1
.
)
-
y
;
float
A
=
mix
(
y
z
o
)
;
g
=
l
<
0
.
?
"
"
x
:
s
/
A
;
}
else
g
=
n
=
=
0
.
?
h
:
k
;
}
return
g
;
}
pure
float4
tessellate_stroked_curve
(
float
"
"
a
float
b
float2x2
c
float2
d
float
e
float4
f
float4
g
float2
h
float2
i
"
"
float
j
)
{
float2
k
=
f
.
xy
;
float2
l
=
f
.
zw
;
float2
m
=
g
.
xy
;
float2
n
=
g
.
zw
;
float
o
=
-
1
.
"
"
;
if
(
k
(
j
)
)
{
o
=
n
.
x
;
n
=
m
;
}
float
p
;
if
(
o
<
0
.
)
if
(
k
=
=
l
&
&
m
=
=
n
)
p
=
1
.
;
else
p
=
n
(
k
l
m
n
"
"
c
)
;
else
p
=
q
(
c
*
k
c
*
l
c
*
m
o
)
;
float
q
=
i
.
x
;
float
r
=
i
.
y
;
bool
s
=
i
.
x
=
=
0
.
;
float
t
;
"
"
if
(
s
)
{
t
=
v
(
1
.
)
;
q
=
.
5
;
}
else
t
=
v
(
e
*
i
.
x
)
;
if
(
s
)
{
k
=
c
*
k
;
l
=
c
*
l
;
m
=
c
*
m
;
n
=
c
*
n
;
h
=
c
*
h
;
}
"
"
float2
u
=
s
(
k
=
=
l
?
(
l
=
=
m
?
n
:
m
)
:
l
k
)
;
float2
v
=
s
(
n
n
=
=
m
?
(
m
=
=
l
?
k
:
l
)
:
m
)
;
if
(
u
=
=
0
.
.
"
"
xx
)
{
u
=
float2
(
1
.
0
.
)
;
v
=
float2
(
-
1
.
0
.
)
;
}
float
x
;
if
(
r
>
=
0
.
)
x
=
sign
(
r
)
+
3
.
;
else
{
float2
"
"
y
=
s
(
k
h
)
;
float
z
=
acos
(
t
(
y
u
)
)
;
float
A
=
max
(
ceil
(
z
*
t
)
1
.
)
;
x
=
A
+
2
.
;
x
=
min
(
x
b
"
"
-
2
.
)
;
}
float
y
=
cross_length_2d
(
m
-
k
n
-
l
)
;
float
z
=
abs
(
a
)
-
x
;
if
(
z
<
0
.
)
{
v
=
u
;
if
(
h
!
=
"
"
k
)
u
=
s
(
k
h
)
;
y
=
cross_length_2d
(
u
v
)
;
}
float
A
=
t
(
u
v
)
;
float
B
=
acos
(
A
)
;
if
(
y
<
0
.
"
"
)
B
=
-
B
;
float
C
;
float
D
=
sign
(
a
)
;
if
(
z
<
0
.
)
{
C
=
x
-
2
.
;
p
=
1
.
;
n
=
(
m
=
(
l
=
k
)
)
;
z
+
=
C
+
1
.
;
if
(
z
"
"
<
0
.
)
z
=
0
.
;
else
{
bool
F
=
abs
(
y
)
*
inversesqrt
(
dot
(
u
u
)
*
dot
(
v
v
)
)
<
.
01
;
if
(
!
F
|
|
dot
(
u
"
"
v
)
<
0
.
)
D
=
y
<
0
.
?
min
(
D
0
.
)
:
max
(
D
0
.
)
;
}
}
else
{
float
E
=
(
b
-
x
)
-
1
.
;
C
=
max
(
ceil
(
abs
(
B
)
"
"
*
t
)
1
.
)
;
C
=
min
(
C
E
)
;
p
=
min
(
p
(
E
-
C
)
+
1
.
)
;
}
float
E
=
B
/
C
;
float
F
=
(
p
+
C
)
-
1
.
;
bool
G
=
z
"
"
>
=
F
;
if
(
z
>
F
)
D
=
0
.
;
if
(
abs
(
a
)
=
=
2
.
&
&
r
>
0
.
)
D
*
=
u
(
A
r
)
;
float2
H
;
float2
I
;
if
(
z
!
=
0
.
&
&
"
"
!
G
)
{
float2
J
;
float2
K
;
float2
L
=
l
-
k
;
float2
M
=
n
-
k
;
if
(
o
>
=
0
.
)
{
L
*
=
o
;
K
=
.
5
*
M
-
L
;
J
=
(
"
"
o
-
1
.
)
*
M
;
l
*
=
o
;
}
else
{
float2
N
=
m
-
l
;
K
=
N
-
L
;
J
=
fma
(
-
3
.
.
xx
N
M
)
;
}
float2
N
=
K
*
(
p
*
2
.
)
;
"
"
float2
O
=
L
*
(
p
*
p
)
;
float
P
=
0
.
;
float
Q
=
min
(
p
-
1
.
z
)
;
float
R
=
-
abs
(
E
)
;
float
S
=
(
1
.
"
"
+
z
)
*
abs
(
E
)
;
for
(
float
U
=
32
.
;
U
>
=
1
.
;
U
*
=
.
5
)
{
float
V
=
P
+
U
;
if
(
V
<
=
Q
)
{
float2
W
=
fma
(
V
"
"
.
xx
J
N
)
;
W
=
fma
(
V
.
xx
W
O
)
;
float
X
=
dot
(
normalize
(
W
)
u
)
;
float
Y
=
fma
(
V
R
S
)
;
Y
=
min
"
"
(
Y
3
.
14159274
)
;
if
(
X
>
=
cos
(
Y
)
)
P
=
V
;
}
}
float
U
=
P
/
p
;
float
V
=
z
-
P
;
float
W
=
acos
(
clamp
"
"
(
u
.
x
-
1
.
1
.
)
)
;
W
=
u
.
y
>
=
0
.
?
W
:
-
W
;
float
X
=
fma
(
V
E
W
)
;
H
=
float2
(
cos
(
X
)
sin
(
X
)
)
;
float2
"
"
Y
=
float2
(
-
H
.
y
H
.
x
)
;
float
Z
=
dot
(
Y
J
)
;
float
aa
=
dot
(
Y
K
)
;
float
ac
=
dot
(
Y
L
)
;
float
"
"
ad
=
max
(
aa
*
aa
-
Z
*
ac
0
.
)
;
float
ae
=
sqrt
(
ad
)
;
if
(
aa
>
0
.
)
ae
=
-
ae
;
ae
-
=
aa
;
float
af
=
(
-
"
"
.
5
*
ae
)
*
Z
;
float2
ag
=
abs
(
fma
(
ae
ae
af
)
)
<
abs
(
fma
(
Z
ac
af
)
)
?
float2
(
ae
Z
)
:
float2
"
"
(
ac
ae
)
;
float
ah
=
V
!
=
0
.
&
&
ag
.
y
!
=
0
.
?
saturate
(
ag
.
x
/
ag
.
y
)
:
0
.
;
float
ai
=
max
(
U
ah
)
;
"
"
float2
aj
=
w
(
k
l
ai
)
;
float2
ak
=
w
(
l
m
ai
)
;
float2
al
=
w
(
m
n
ai
)
;
float2
am
=
w
"
"
(
aj
ak
ai
)
;
float2
an
=
w
(
ak
al
ai
)
;
float2
ao
=
w
(
am
an
ai
)
;
float
ap
=
w
(
1
.
o
ai
"
"
)
;
float
aq
=
(
o
+
1
.
)
-
ap
;
float
ar
=
w
(
ap
aq
ai
)
;
if
(
ai
!
=
ah
)
H
=
o
>
=
0
.
?
s
(
ak
*
ap
aj
*
aq
"
"
)
:
s
(
an
am
)
;
I
=
o
>
=
0
.
?
am
/
ar
:
ao
;
}
else
{
H
=
z
=
=
0
.
?
u
:
v
;
I
=
z
=
=
0
.
?
k
:
n
;
}
float2
J
=
float2
"
"
(
H
.
y
-
H
.
x
)
;
I
+
=
J
*
(
q
*
D
)
;
if
(
s
)
return
float4
(
I
+
d
inverse
(
c
)
*
I
)
;
else
return
float4
"
"
(
c
*
I
+
d
I
)
;
}
float4
analytic_rrect_vertex_fn
(
float2
a
float2
b
float
c
float
d
"
"
float4
e
float4
f
float4
g
float4
h
float
i
float3x3
j
out
float4
k
out
float4
"
"
l
out
float4
m
out
float4
n
out
float2
o
out
float2
p
out
float2
q
)
{
float
w
"
"
=
1
.
;
bool
x
=
h
.
z
<
=
0
.
;
bool
y
=
false
;
float4
z
;
float4
A
;
float4
B
=
1
.
.
xxxx
;
bool
C
=
false
"
"
;
if
(
e
.
x
<
-
1
.
)
{
C
=
e
.
y
>
0
.
;
z
=
C
?
g
.
xxzz
:
g
.
xzzx
;
A
=
g
.
yyww
;
if
(
e
.
y
<
0
.
)
{
m
=
-
e
-
2
.
;
n
=
f
;
o
=
float2
"
"
(
0
.
1
.
)
;
}
else
{
m
=
f
;
n
=
m
;
o
=
e
.
zw
;
w
=
o
.
y
<
0
.
?
.
414213568
:
sign
(
o
.
y
)
;
}
}
else
if
(
any
(
greaterThan
"
"
(
e
0
.
.
xxxx
)
)
)
{
z
=
g
.
xzzx
;
A
=
g
.
yyww
;
m
=
e
;
n
=
f
;
o
=
float2
(
0
.
-
1
.
)
;
}
else
{
z
=
f
;
A
=
g
;
B
=
-
e
"
"
;
m
=
0
.
.
xxxx
;
n
=
0
.
.
xxxx
;
o
=
float2
(
0
.
1
.
)
;
y
=
true
;
}
uint
D
=
uint
(
sk_VertexID
)
/
9
;
float2
"
"
E
=
float2
(
m
[
D
]
n
[
D
]
)
;
if
(
D
%
2
!
=
0
)
E
=
E
.
yx
;
float2
F
=
1
.
.
xx
;
if
(
all
(
greaterThan
(
E
0
.
"
"
.
xx
)
)
)
{
w
=
.
414213568
;
F
=
E
.
yx
;
}
float4
G
=
z
-
z
.
wxyz
;
float4
H
=
A
-
A
.
wxyz
;
float4
I
=
1
.
"
"
/
max
(
abs
(
G
)
max
(
abs
(
H
)
1
.
.
xxxx
)
)
;
G
*
=
I
;
H
*
=
I
;
float4
J
=
G
*
G
+
H
*
H
;
float4
K
=
sign
(
J
"
"
)
;
float4
L
=
0
.
.
xxxx
;
float2
M
=
o
.
x
.
xx
;
if
(
any
(
equal
(
K
0
.
.
xxxx
)
)
)
if
(
all
(
equal
(
K
"
"
0
.
.
xxxx
)
)
)
{
G
=
float4
(
0
.
1
.
0
.
-
1
.
)
;
H
=
float4
(
-
1
.
0
.
1
.
0
.
)
;
J
=
1
.
.
xxxx
;
}
else
{
bool
"
"
N
=
(
(
K
.
x
+
K
.
y
)
+
K
.
z
)
+
K
.
w
>
2
.
5
;
float4
O
=
N
?
G
.
yzwx
:
H
.
yzwx
;
float4
P
=
N
?
H
.
yzwx
:
-
G
.
yzwx
"
"
;
G
=
mix
(
O
G
K
)
;
H
=
mix
(
P
H
K
)
;
J
=
mix
(
J
.
yzwx
J
K
)
;
B
=
mix
(
B
.
yzwx
B
K
)
;
if
(
!
N
&
&
w
=
=
0
.
"
"
)
{
M
*
=
float2
(
K
[
D
]
K
.
yzwx
[
D
]
)
;
L
=
(
K
-
1
.
)
*
o
.
x
;
o
.
y
=
1
.
;
w
=
1
.
;
}
}
float4
N
=
inversesqrt
"
"
(
J
)
;
G
*
=
N
;
H
*
=
N
;
float2
O
=
-
float2
(
G
.
yzwx
[
D
]
H
.
yzwx
[
D
]
)
;
float2
P
=
float2
(
G
[
D
]
H
[
"
"
D
]
)
;
float2
Q
;
bool
R
=
false
;
if
(
c
<
0
.
)
if
(
h
.
w
<
0
.
|
|
d
*
h
.
z
!
=
0
.
)
R
=
true
;
else
{
float
S
=
"
"
h
.
w
;
float2
T
=
E
+
(
x
?
-
M
:
M
)
;
if
(
w
=
=
1
.
|
|
any
(
lessThanEqual
(
T
S
.
xx
)
)
)
Q
=
T
-
S
;
else
Q
=
T
"
"
*
a
-
S
*
b
;
}
else
Q
=
(
E
+
M
)
*
(
a
+
w
*
a
.
yx
)
;
if
(
R
)
Q
=
h
.
xy
;
else
{
Q
-
=
E
;
Q
=
(
float2
(
z
[
D
]
A
[
D
]
)
+
"
"
O
*
Q
.
x
)
+
P
*
Q
.
y
;
}
l
=
(
H
*
(
z
-
Q
.
x
)
-
G
*
(
A
-
Q
.
y
)
)
+
L
;
float3x3
S
=
inverse
(
j
)
;
float3
T
=
j
*
float3
"
"
(
Q
1
.
)
;
k
=
float4
(
S
[
0
]
.
xy
-
S
[
0
]
.
z
*
Q
S
[
1
]
.
xy
-
S
[
1
]
.
z
*
Q
)
;
if
(
y
)
{
float4
U
=
-
H
*
(
S
[
0
]
.
"
"
x
-
S
[
0
]
.
z
*
z
)
+
G
*
(
S
[
0
]
.
y
-
S
[
0
]
.
z
*
A
)
;
float4
V
=
-
H
*
(
S
[
1
]
.
x
-
S
[
1
]
.
z
*
z
)
+
G
*
(
S
[
1
]
.
y
-
S
[
1
"
"
]
.
z
*
A
)
;
l
*
=
inversesqrt
(
U
*
U
+
V
*
V
)
;
l
+
=
(
1
.
-
B
)
*
abs
(
T
.
z
)
;
bool
W
=
B
=
=
1
.
.
xxxx
&
&
dot
(
abs
"
"
(
G
*
G
.
yzwx
+
H
*
H
.
yzwx
)
1
.
.
xxxx
)
<
.
00024
;
if
(
W
)
{
float2
X
=
l
.
xy
+
l
.
zw
;
p
.
y
=
1
.
+
min
(
min
"
"
(
X
.
x
X
.
y
)
abs
(
T
.
z
)
)
;
}
else
p
.
y
=
1
.
+
abs
(
T
.
z
)
;
}
if
(
c
>
0
.
&
&
T
.
z
>
0
.
)
{
float2x2
U
=
float2x2
"
"
(
k
)
;
float2
V
=
float2
(
B
[
D
]
B
.
yzwx
[
D
]
)
*
b
;
float2
W
=
(
(
F
.
x
*
V
.
x
)
*
perp
(
-
P
)
)
*
U
;
float2
"
"
X
=
(
(
F
.
y
*
V
.
y
)
*
perp
(
O
)
)
*
U
;
bool
Y
=
all
(
notEqual
(
V
0
.
.
xx
)
)
;
if
(
w
=
=
1
.
&
&
Y
)
{
W
=
normalize
"
"
(
W
)
;
X
=
normalize
(
X
)
;
if
(
dot
(
W
X
)
<
-
.
8
)
{
float
Z
=
sign
(
cross_length_2d
(
W
X
)
)
;
W
=
Z
*
"
"
perp
(
W
)
;
X
=
-
Z
*
perp
(
X
)
;
}
}
T
.
xy
+
=
T
.
z
*
normalize
(
W
+
X
)
;
if
(
y
)
l
-
=
T
.
z
;
else
p
.
y
=
-
T
.
z
;
}
"
"
else
if
(
!
y
)
p
.
y
=
0
.
;
p
.
x
=
float
(
d
!
=
0
.
?
1
.
:
(
x
?
-
1
.
:
0
.
)
)
;
if
(
C
)
k
=
float4
(
float2x2
(
H
.
x
"
"
-
H
.
y
-
G
.
x
G
.
y
)
*
float2x2
(
k
)
)
;
q
=
Q
;
return
float4
(
T
.
xy
T
.
z
*
i
T
.
z
)
;
}
float4
per_edge_aa_quad_vertex_fn
"
"
(
float2
a
float4
b
float4
c
float4
d
float
e
float3x3
f
out
float4
g
out
float2
"
"
h
)
{
float4
k
=
c
-
c
.
wxyz
;
float4
l
=
d
-
d
.
wxyz
;
float4
m
=
1
.
/
max
(
abs
(
k
)
max
(
abs
(
l
)
1
.
"
"
.
xxxx
)
)
;
k
*
=
m
;
l
*
=
m
;
float4
n
=
k
*
k
+
l
*
l
;
float4
o
=
sign
(
n
)
;
if
(
any
(
equal
(
o
0
.
.
xxxx
)
"
"
)
)
if
(
all
(
equal
(
o
0
.
.
xxxx
)
)
)
{
k
=
float4
(
0
.
1
.
0
.
-
1
.
)
;
l
=
float4
(
-
1
.
0
.
1
.
0
.
)
;
n
"
"
=
1
.
.
xxxx
;
}
else
{
bool
p
=
(
(
o
.
x
+
o
.
y
)
+
o
.
z
)
+
o
.
w
>
2
.
5
;
float4
q
=
p
?
k
.
yzwx
:
l
.
yzwx
;
float4
"
"
r
=
p
?
l
.
yzwx
:
-
k
.
yzwx
;
k
=
mix
(
q
k
o
)
;
l
=
mix
(
r
l
o
)
;
n
=
mix
(
n
.
yzwx
n
o
)
;
b
=
mix
(
b
.
yzwx
"
"
b
o
)
;
}
float4
p
=
inversesqrt
(
n
)
;
k
*
=
p
;
l
*
=
p
;
uint
q
=
uint
(
sk_VertexID
)
/
4
;
float2
r
"
"
=
-
float2
(
k
.
yzwx
[
q
]
l
.
yzwx
[
q
]
)
;
float2
s
=
float2
(
k
[
q
]
l
[
q
]
)
;
float2
t
=
float2
(
c
[
"
"
q
]
d
[
q
]
)
;
g
=
l
*
(
c
-
t
.
x
)
-
k
*
(
d
-
t
.
y
)
;
float3x3
u
=
inverse
(
f
)
;
float3
v
=
f
*
float3
(
t
1
.
"
"
)
;
float4
w
=
-
l
*
(
u
[
0
]
.
x
-
u
[
0
]
.
z
*
c
)
+
k
*
(
u
[
0
]
.
y
-
u
[
0
]
.
z
*
d
)
;
float4
x
=
-
l
*
(
u
[
1
]
.
x
-
u
[
1
"
"
]
.
z
*
c
)
+
k
*
(
u
[
1
]
.
y
-
u
[
1
]
.
z
*
d
)
;
g
*
=
inversesqrt
(
w
*
w
+
x
*
x
)
;
g
+
=
(
1
.
5
-
b
)
*
abs
(
v
.
z
)
;
if
(
any
"
"
(
notEqual
(
a
0
.
.
xx
)
)
&
&
v
.
z
>
0
.
)
{
float2x2
y
=
float2x2
(
u
[
0
]
.
xy
-
u
[
0
]
.
z
*
t
u
[
1
]
.
xy
-
u
"
"
[
1
]
.
z
*
t
)
;
float2
z
=
float2
(
b
[
q
]
b
.
yzwx
[
q
]
)
*
a
;
float2
A
=
(
z
.
x
*
perp
(
-
s
)
)
*
y
;
float2
"
"
B
=
(
z
.
y
*
perp
(
r
)
)
*
y
;
bool
C
=
all
(
notEqual
(
z
0
.
.
xx
)
)
;
if
(
C
)
{
A
=
normalize
(
A
)
;
B
=
normalize
"
"
(
B
)
;
if
(
dot
(
A
B
)
<
-
.
8
)
{
float
D
=
sign
(
cross_length_2d
(
A
B
)
)
;
A
=
D
*
perp
(
A
)
;
B
=
-
D
*
perp
"
"
(
B
)
;
}
}
v
.
xy
+
=
v
.
z
*
normalize
(
A
+
B
)
;
g
-
=
v
.
z
;
}
h
=
t
;
return
float4
(
v
.
xy
v
.
z
*
e
v
.
z
)
;
}
float4
"
"
circular_arc_vertex_fn
(
float3
a
float4
b
float3
c
float3
d
float3
e
float3
"
"
f
float4
g
float
h
float3x3
i
out
float4
j
out
float3
k
out
float3
l
out
float3
"
"
m
out
float
n
out
float4
o
out
float2
p
)
{
float2
q
=
b
.
xy
;
float2
r
=
q
;
float
s
=
"
"
min
(
dot
(
a
.
xy
d
.
xy
)
+
d
.
z
0
.
)
;
a
.
xy
-
=
d
.
xy
*
s
;
float
t
=
length
(
a
.
xy
)
;
if
(
a
.
z
>
0
.
)
r
+
=
a
"
"
.
xy
*
b
.
z
;
else
r
+
=
a
.
xy
*
b
.
w
;
float3
u
=
i
*
float3
(
r
1
.
)
;
float3
v
=
i
*
float3
(
q
1
.
)
;
float2
"
"
w
=
u
.
xy
-
v
.
xy
;
if
(
w
!
=
0
.
.
xx
)
{
w
=
normalize
(
w
)
;
u
.
xy
+
=
a
.
z
*
w
;
if
(
a
.
z
>
0
.
)
w
*
=
t
;
else
w
*
=
"
"
t
*
c
.
y
;
}
j
=
float4
(
w
c
.
xy
)
;
if
(
c
.
z
>
0
.
)
{
k
=
e
;
l
=
f
;
m
=
0
.
.
xxx
;
}
else
{
k
=
e
;
l
=
float3
(
0
.
0
.
"
"
1
.
)
;
m
=
f
;
}
if
(
abs
(
c
.
z
)
>
1
.
)
n
=
(
1
.
-
c
.
y
)
*
.
5
;
else
n
=
0
.
;
o
=
g
;
p
=
r
;
return
float4
(
u
.
xy
"
"
h
1
.
)
;
}
float4
text_vertex_fn
(
float2
a
float4x4
b
float4x4
c
float2
d
float2
"
"
e
float2
f
float2
g
float
h
float
i
out
float2
j
out
float2
k
out
float2
l
"
"
)
{
a
*
=
e
;
float2
m
=
h
*
a
+
g
;
float4
n
=
b
*
float4
(
m
0
.
1
.
)
;
l
=
(
c
*
n
)
.
xy
;
k
=
a
+
f
;
j
=
k
*
d
;
return
"
"
float4
(
n
.
xy
i
*
n
.
w
n
.
w
)
;
}
float4
coverage_mask_vertex_fn
(
float2
a
float3x3
b
"
"
float4
c
float4
d
float2
e
float
f
float3x3
g
out
float4
h
out
float2
i
out
"
"
half
j
out
float2
k
)
{
i
=
mix
(
c
.
xy
c
.
zw
a
)
;
float3
l
=
b
*
float3
(
i
+
e
1
.
)
;
float3
m
"
"
=
g
*
l
;
k
=
m
.
xy
/
m
.
z
;
if
(
all
(
lessThanEqual
(
d
.
xy
d
.
zw
)
)
)
{
h
=
d
;
j
=
0
.
;
}
else
{
h
=
d
.
zwxy
;
j
"
"
=
1
.
;
}
return
float4
(
l
.
xy
f
*
l
.
z
l
.
z
)
;
}
float4
cover_bounds_vertex_fn
(
float2
a
"
"
float4
b
float
c
float3x3
d
out
float2
e
)
{
if
(
all
(
lessThanEqual
(
b
.
xy
b
.
zw
)
)
)
"
"
{
a
=
mix
(
b
.
xy
b
.
zw
a
)
;
float3
f
=
d
*
float3
(
a
1
.
)
;
e
=
a
;
return
float4
(
f
.
xy
c
*
f
.
z
f
.
"
"
z
)
;
}
else
{
a
=
mix
(
b
.
zw
b
.
xy
a
)
;
float3
f
=
inverse
(
d
)
*
float3
(
a
1
.
)
;
float
g
=
1
.
/
f
.
z
"
"
;
e
=
f
.
xy
*
g
;
return
float4
(
a
*
g
c
*
g
g
)
;
}
}
"
;
