#
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
#
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
#
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
import
argparse
import
codecs
import
subprocess
import
sys
import
tempfile
import
yaml
def
shell_main
(
)
:
  
parser
=
argparse
.
ArgumentParser
(
)
  
parser
.
add_argument
(
'
-
o
'
'
-
-
output
'
type
=
str
required
=
True
                      
help
=
'
Output
file
'
)
  
parser
.
add_argument
(
'
manifest
'
type
=
str
                      
help
=
'
Manifest
source
file
'
)
  
args
=
parser
.
parse_args
(
)
  
with
open
(
args
.
output
'
w
'
)
as
out_file
:
    
process_manifest
(
out_file
args
.
manifest
)
def
main
(
output_fp
input_filename
)
:
  
process_manifest
(
output_fp
input_filename
)
HEADER
=
"
"
"
/
/
AUTOGENERATED
-
DO
NOT
EDIT
namespace
mozilla
{
namespace
layers
{
struct
ShaderBytes
{
const
void
*
mData
;
size_t
mLength
;
}
;
"
"
"
FOOTER
=
"
"
"
}
/
/
namespace
layers
}
/
/
namespace
mozilla
"
"
"
def
process_manifest
(
output_fp
manifest_filename
)
:
  
with
codecs
.
open
(
manifest_filename
'
r
'
'
UTF
-
8
'
)
as
in_fp
:
    
manifest
=
yaml
.
load
(
in_fp
)
  
shader_folder
_
=
os
.
path
.
split
(
manifest_filename
)
  
output_fp
.
write
(
HEADER
)
  
for
block
in
manifest
:
    
if
'
type
'
not
in
block
:
      
raise
Exception
(
"
Expected
'
type
'
key
with
shader
mode
"
)
    
if
'
file
'
not
in
block
:
      
raise
Exception
(
"
Expected
'
file
'
key
with
shader
file
"
)
    
if
'
shaders
'
not
in
block
:
      
raise
Exception
(
"
Expected
'
shaders
'
key
with
shader
name
list
"
)
    
shader_model
=
block
[
'
type
'
]
    
shader_file
=
os
.
path
.
join
(
shader_folder
block
[
'
file
'
]
)
    
for
shader_name
in
block
[
'
shaders
'
]
:
      
run_fxc
(
        
shader_model
=
shader_model
        
shader_file
=
shader_file
        
shader_name
=
shader_name
        
output_fp
=
output_fp
)
  
output_fp
.
write
(
FOOTER
)
def
run_fxc
(
shader_model
            
shader_file
            
shader_name
            
output_fp
)
:
  
argv
=
[
    
'
fxc
'
    
'
-
nologo
'
    
'
-
T
{
0
}
'
.
format
(
shader_model
)
    
shader_file
    
'
-
E
{
0
}
'
.
format
(
shader_name
)
    
'
-
Vn
{
0
}
'
.
format
(
shader_name
)
  
]
  
if
shader_model
.
startswith
(
'
vs_
'
)
:
    
argv
+
=
[
'
-
DVERTEX_SHADER
'
]
  
elif
shader_model
.
startswith
(
'
ps_
'
)
:
    
argv
+
=
[
'
-
DPIXEL_SHADER
'
]
  
with
ScopedTempFilename
(
)
as
temp_filename
:
    
argv
+
=
[
'
-
Fh
{
0
}
'
.
format
(
temp_filename
)
]
    
sys
.
stdout
.
write
(
'
{
0
}
\
n
'
.
format
(
'
'
.
join
(
argv
)
)
)
    
subprocess
.
check_call
(
argv
)
    
with
open
(
temp_filename
'
r
'
)
as
temp_fp
:
      
output_fp
.
write
(
temp_fp
.
read
(
)
)
  
output_fp
.
write
(
"
ShaderBytes
s
{
0
}
=
{
{
{
0
}
sizeof
(
{
0
}
)
}
}
;
\
n
"
.
format
(
    
shader_name
)
)
#
Allocate
a
temporary
file
name
and
delete
it
when
done
.
We
need
an
extra
#
wrapper
for
this
since
TemporaryNamedFile
holds
the
file
open
.
class
ScopedTempFilename
(
object
)
:
  
def
__init__
(
self
)
:
    
self
.
name
=
None
  
def
__enter__
(
self
)
:
    
with
tempfile
.
NamedTemporaryFile
(
delete
=
False
)
as
tmp
:
      
self
.
name
=
tmp
.
name
      
return
self
.
name
  
def
__exit__
(
self
type
value
traceback
)
:
    
if
not
self
.
name
:
      
return
    
try
:
      
os
.
unlink
(
self
.
name
)
    
except
:
      
pass
if
__name__
=
=
'
__main__
'
:
  
shell_main
(
)
