/
*
*
*
Copyright
2000
Keith
Packard
member
of
The
XFree86
Project
Inc
.
*
Copyright
2000
SuSE
Inc
.
*
2005
Lars
Knoll
&
Zack
Rusin
Trolltech
*
Copyright
2007
Red
Hat
Inc
.
*
*
*
Permission
to
use
copy
modify
distribute
and
sell
this
software
and
its
*
documentation
for
any
purpose
is
hereby
granted
without
fee
provided
that
*
the
above
copyright
notice
appear
in
all
copies
and
that
both
that
*
copyright
notice
and
this
permission
notice
appear
in
supporting
*
documentation
and
that
the
name
of
Keith
Packard
not
be
used
in
*
advertising
or
publicity
pertaining
to
distribution
of
the
software
without
*
specific
written
prior
permission
.
Keith
Packard
makes
no
*
representations
about
the
suitability
of
this
software
for
any
purpose
.
It
*
is
provided
"
as
is
"
without
express
or
implied
warranty
.
*
*
THE
COPYRIGHT
HOLDERS
DISCLAIM
ALL
WARRANTIES
WITH
REGARD
TO
THIS
*
SOFTWARE
INCLUDING
ALL
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
*
FITNESS
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDERS
BE
LIABLE
FOR
ANY
*
SPECIAL
INDIRECT
OR
CONSEQUENTIAL
DAMAGES
OR
ANY
DAMAGES
*
WHATSOEVER
RESULTING
FROM
LOSS
OF
USE
DATA
OR
PROFITS
WHETHER
IN
*
AN
ACTION
OF
CONTRACT
NEGLIGENCE
OR
OTHER
TORTIOUS
ACTION
ARISING
*
OUT
OF
OR
IN
CONNECTION
WITH
THE
USE
OR
PERFORMANCE
OF
THIS
*
SOFTWARE
.
*
/
#
ifdef
HAVE_CONFIG_H
#
include
<
config
.
h
>
#
endif
#
include
<
stdlib
.
h
>
#
include
<
math
.
h
>
#
include
"
pixman
-
private
.
h
"
static
void
radial_gradient_get_scanline_32
(
pixman_image_t
*
image
int
x
int
y
int
width
uint32_t
*
buffer
const
uint32_t
*
mask
uint32_t
mask_bits
)
{
/
*
*
In
the
radial
gradient
problem
we
are
given
two
circles
(
c
r
)
and
*
(
c
r
)
that
define
the
gradient
itself
.
Then
for
any
point
p
we
*
must
compute
the
value
(
s
)
of
t
within
[
0
.
0
1
.
0
]
representing
the
*
circle
(
s
)
that
would
color
the
point
.
*
*
There
are
potentially
two
values
of
t
since
the
point
p
can
be
*
colored
by
both
sides
of
the
circle
(
which
happens
whenever
one
*
circle
is
not
entirely
contained
within
the
other
)
.
*
*
If
we
solve
for
a
value
of
t
that
is
outside
of
[
0
.
0
1
.
0
]
then
we
*
use
the
extend
mode
(
NONE
REPEAT
REFLECT
or
PAD
)
to
map
to
a
*
value
within
[
0
.
0
1
.
0
]
.
*
*
Here
is
an
illustration
of
the
problem
:
*
*
p
*
p
*
*
r
*
p
*
*
*
r
c
*
*
*
c
*
*
Given
(
c
r
)
(
c
r
)
and
p
we
must
find
an
angle
such
that
two
*
points
p
and
p
on
the
two
circles
are
collinear
with
p
.
Then
the
*
desired
value
of
t
is
the
ratio
of
the
length
of
p
p
to
the
length
*
of
p
p
.
*
*
So
we
have
six
unknown
values
:
(
p
x
p
y
)
(
p
x
p
y
)
and
t
.
*
We
can
also
write
six
equations
that
constrain
the
problem
:
*
*
Point
p
is
a
distance
r
from
c
at
an
angle
of
:
*
*
1
.
p
x
=
c
x
+
r
cos
*
2
.
p
y
=
c
y
+
r
sin
*
*
Point
p
is
a
distance
r
from
c
at
an
angle
of
:
*
*
3
.
p
x
=
c
x
+
r2
cos
*
4
.
p
y
=
c
y
+
r2
sin
*
*
Point
p
lies
at
a
fraction
t
along
the
line
segment
p
p
:
*
*
5
.
px
=
t
p
x
+
(
1
-
t
)
p
x
*
6
.
py
=
t
p
y
+
(
1
-
t
)
p
y
*
*
To
solve
first
subtitute
1
-
4
into
5
and
6
:
*
*
px
=
t
(
c
x
+
r
cos
)
+
(
1
-
t
)
(
c
x
+
r
cos
)
*
py
=
t
(
c
y
+
r
sin
)
+
(
1
-
t
)
(
c
y
+
r
sin
)
*
*
Then
solve
each
for
cos
and
sin
expressed
as
a
function
of
t
:
*
*
cos
=
(
-
(
c
x
-
c
x
)
t
+
(
px
-
c
x
)
)
/
(
(
r
-
r
)
t
+
r
)
*
sin
=
(
-
(
c
y
-
c
y
)
t
+
(
py
-
c
y
)
)
/
(
(
r
-
r
)
t
+
r
)
*
*
To
simplify
this
a
bit
we
define
new
variables
for
several
of
the
*
common
terms
as
shown
below
:
*
*
p
*
p
*
*
r
*
p
*
pdy
*
c
*
r
*
cdy
*
*
c
pdx
cdx
*
*
cdx
=
(
c
x
-
c
x
)
*
cdy
=
(
c
y
-
c
y
)
*
dr
=
r
-
r
*
pdx
=
px
-
c
x
*
pdy
=
py
-
c
y
*
*
Note
that
cdx
cdy
and
dr
do
not
depend
on
point
p
at
all
so
can
*
be
pre
-
computed
for
the
entire
gradient
.
The
simplifed
equations
*
are
now
:
*
*
cos
=
(
-
cdx
t
+
pdx
)
/
(
dr
t
+
r
)
*
sin
=
(
-
cdy
t
+
pdy
)
/
(
dr
t
+
r
)
*
*
Finally
to
get
a
single
function
of
t
and
eliminate
the
last
*
unknown
we
use
the
identity
sin
+
cos
=
1
.
First
square
*
each
equation
(
we
knew
a
quadratic
was
coming
since
it
must
be
*
possible
to
obtain
two
solutions
in
some
cases
)
:
*
*
cos
=
(
cdx
t
-
2
cdx
pdx
t
+
pdx
)
/
(
dr
t
+
2
r
dr
t
+
r
)
*
sin
=
(
cdy
t
-
2
cdy
pdy
t
+
pdy
)
/
(
dr
t
+
2
r
dr
t
+
r
)
*
*
Then
add
both
together
set
the
result
equal
to
1
and
express
as
a
*
standard
quadratic
equation
in
t
of
the
form
At
+
Bt
+
C
=
0
*
*
(
cdx
+
cdy
-
dr
)
t
-
2
(
cdx
pdx
+
cdy
pdy
+
r
dr
)
t
+
(
pdx
+
pdy
-
r
)
=
0
*
*
In
other
words
:
*
*
A
=
cdx
+
cdy
-
dr
*
B
=
-
2
(
pdx
cdx
+
pdy
cdy
+
r
dr
)
*
C
=
pdx
+
pdy
-
r
*
*
And
again
notice
that
A
does
not
depend
on
p
so
can
be
*
precomputed
.
From
here
we
just
use
the
quadratic
formula
to
solve
*
for
t
:
*
*
t
=
(
-
2
B
(
B
-
4
A
C
)
)
/
2
A
*
/
gradient_t
*
gradient
=
(
gradient_t
*
)
image
;
source_image_t
*
source
=
(
source_image_t
*
)
image
;
radial_gradient_t
*
radial
=
(
radial_gradient_t
*
)
image
;
uint32_t
*
end
=
buffer
+
width
;
pixman_gradient_walker_t
walker
;
pixman_bool_t
affine
=
TRUE
;
double
cx
=
1
.
;
double
cy
=
0
.
;
double
cz
=
0
.
;
double
rx
=
x
+
0
.
5
;
double
ry
=
y
+
0
.
5
;
double
rz
=
1
.
;
_pixman_gradient_walker_init
(
&
walker
gradient
source
-
>
common
.
repeat
)
;
if
(
source
-
>
common
.
transform
)
{
pixman_vector_t
v
;
/
*
reference
point
is
the
center
of
the
pixel
*
/
v
.
vector
[
0
]
=
pixman_int_to_fixed
(
x
)
+
pixman_fixed_1
/
2
;
v
.
vector
[
1
]
=
pixman_int_to_fixed
(
y
)
+
pixman_fixed_1
/
2
;
v
.
vector
[
2
]
=
pixman_fixed_1
;
if
(
!
pixman_transform_point_3d
(
source
-
>
common
.
transform
&
v
)
)
return
;
cx
=
source
-
>
common
.
transform
-
>
matrix
[
0
]
[
0
]
/
65536
.
;
cy
=
source
-
>
common
.
transform
-
>
matrix
[
1
]
[
0
]
/
65536
.
;
cz
=
source
-
>
common
.
transform
-
>
matrix
[
2
]
[
0
]
/
65536
.
;
rx
=
v
.
vector
[
0
]
/
65536
.
;
ry
=
v
.
vector
[
1
]
/
65536
.
;
rz
=
v
.
vector
[
2
]
/
65536
.
;
affine
=
source
-
>
common
.
transform
-
>
matrix
[
2
]
[
0
]
=
=
0
&
&
v
.
vector
[
2
]
=
=
pixman_fixed_1
;
}
if
(
affine
)
{
/
*
When
computing
t
over
a
scanline
we
notice
that
some
expressions
*
are
constant
so
we
can
compute
them
just
once
.
Given
:
*
*
t
=
(
-
2
B
(
B
-
4
A
C
)
)
/
2
A
*
*
where
*
*
A
=
cdx
+
cdy
-
dr
[
precomputed
as
radial
-
>
A
]
*
B
=
-
2
(
pdx
cdx
+
pdy
cdy
+
r
dr
)
*
C
=
pdx
+
pdy
-
r
*
*
Since
we
have
an
affine
transformation
we
know
that
(
pdx
pdy
)
*
increase
linearly
with
each
pixel
*
*
pdx
=
pdx
+
n
cx
*
pdy
=
pdy
+
n
cy
*
*
we
can
then
express
B
in
terms
of
an
linear
increment
along
*
the
scanline
:
*
*
B
=
B
+
n
cB
with
*
B
=
-
2
(
pdx
cdx
+
pdy
cdy
+
r
dr
)
and
*
cB
=
-
2
(
cx
cdx
+
cy
cdy
)
*
*
Thus
we
can
replace
the
full
evaluation
of
B
per
-
pixel
(
4
multiplies
*
2
additions
)
with
a
single
addition
.
*
/
double
r1
=
radial
-
>
c1
.
radius
/
65536
.
;
double
r1sq
=
r1
*
r1
;
double
pdx
=
rx
-
radial
-
>
c1
.
x
/
65536
.
;
double
pdy
=
ry
-
radial
-
>
c1
.
y
/
65536
.
;
double
A
=
radial
-
>
A
;
double
invA
=
-
65536
.
/
(
2
.
*
A
)
;
double
A4
=
-
4
.
*
A
;
double
B
=
-
2
.
*
(
pdx
*
radial
-
>
cdx
+
pdy
*
radial
-
>
cdy
+
r1
*
radial
-
>
dr
)
;
double
cB
=
-
2
.
*
(
cx
*
radial
-
>
cdx
+
cy
*
radial
-
>
cdy
)
;
pixman_bool_t
invert
=
A
*
radial
-
>
dr
<
0
;
while
(
buffer
<
end
)
{
if
(
!
mask
|
|
*
mask
+
+
&
mask_bits
)
{
pixman_fixed_48_16_t
t
;
double
det
=
B
*
B
+
A4
*
(
pdx
*
pdx
+
pdy
*
pdy
-
r1sq
)
;
if
(
det
<
=
0
.
)
t
=
(
pixman_fixed_48_16_t
)
(
B
*
invA
)
;
else
if
(
invert
)
t
=
(
pixman_fixed_48_16_t
)
(
(
B
+
sqrt
(
det
)
)
*
invA
)
;
else
t
=
(
pixman_fixed_48_16_t
)
(
(
B
-
sqrt
(
det
)
)
*
invA
)
;
*
buffer
=
_pixman_gradient_walker_pixel
(
&
walker
t
)
;
}
+
+
buffer
;
pdx
+
=
cx
;
pdy
+
=
cy
;
B
+
=
cB
;
}
}
else
{
/
*
projective
*
/
while
(
buffer
<
end
)
{
if
(
!
mask
|
|
*
mask
+
+
&
mask_bits
)
{
double
pdx
pdy
;
double
B
C
;
double
det
;
double
c1x
=
radial
-
>
c1
.
x
/
65536
.
0
;
double
c1y
=
radial
-
>
c1
.
y
/
65536
.
0
;
double
r1
=
radial
-
>
c1
.
radius
/
65536
.
0
;
pixman_fixed_48_16_t
t
;
double
x
y
;
if
(
rz
!
=
0
)
{
x
=
rx
/
rz
;
y
=
ry
/
rz
;
}
else
{
x
=
y
=
0
.
;
}
pdx
=
x
-
c1x
;
pdy
=
y
-
c1y
;
B
=
-
2
*
(
pdx
*
radial
-
>
cdx
+
pdy
*
radial
-
>
cdy
+
r1
*
radial
-
>
dr
)
;
C
=
(
pdx
*
pdx
+
pdy
*
pdy
-
r1
*
r1
)
;
det
=
(
B
*
B
)
-
(
4
*
radial
-
>
A
*
C
)
;
if
(
det
<
0
.
0
)
det
=
0
.
0
;
if
(
radial
-
>
A
*
radial
-
>
dr
<
0
)
t
=
(
pixman_fixed_48_16_t
)
(
(
-
B
-
sqrt
(
det
)
)
/
(
2
.
0
*
radial
-
>
A
)
*
65536
)
;
else
t
=
(
pixman_fixed_48_16_t
)
(
(
-
B
+
sqrt
(
det
)
)
/
(
2
.
0
*
radial
-
>
A
)
*
65536
)
;
*
buffer
=
_pixman_gradient_walker_pixel
(
&
walker
t
)
;
}
+
+
buffer
;
rx
+
=
cx
;
ry
+
=
cy
;
rz
+
=
cz
;
}
}
}
static
void
radial_gradient_property_changed
(
pixman_image_t
*
image
)
{
image
-
>
common
.
get_scanline_32
=
radial_gradient_get_scanline_32
;
image
-
>
common
.
get_scanline_64
=
_pixman_image_get_scanline_generic_64
;
}
PIXMAN_EXPORT
pixman_image_t
*
pixman_image_create_radial_gradient
(
pixman_point_fixed_t
*
inner
pixman_point_fixed_t
*
outer
pixman_fixed_t
inner_radius
pixman_fixed_t
outer_radius
const
pixman_gradient_stop_t
*
stops
int
n_stops
)
{
pixman_image_t
*
image
;
radial_gradient_t
*
radial
;
return_val_if_fail
(
n_stops
>
=
2
NULL
)
;
image
=
_pixman_image_allocate
(
)
;
if
(
!
image
)
return
NULL
;
radial
=
&
image
-
>
radial
;
if
(
!
_pixman_init_gradient
(
&
radial
-
>
common
stops
n_stops
)
)
{
free
(
image
)
;
return
NULL
;
}
image
-
>
type
=
RADIAL
;
radial
-
>
c1
.
x
=
inner
-
>
x
;
radial
-
>
c1
.
y
=
inner
-
>
y
;
radial
-
>
c1
.
radius
=
inner_radius
;
radial
-
>
c2
.
x
=
outer
-
>
x
;
radial
-
>
c2
.
y
=
outer
-
>
y
;
radial
-
>
c2
.
radius
=
outer_radius
;
radial
-
>
cdx
=
pixman_fixed_to_double
(
radial
-
>
c2
.
x
-
radial
-
>
c1
.
x
)
;
radial
-
>
cdy
=
pixman_fixed_to_double
(
radial
-
>
c2
.
y
-
radial
-
>
c1
.
y
)
;
radial
-
>
dr
=
pixman_fixed_to_double
(
radial
-
>
c2
.
radius
-
radial
-
>
c1
.
radius
)
;
radial
-
>
A
=
(
radial
-
>
cdx
*
radial
-
>
cdx
+
radial
-
>
cdy
*
radial
-
>
cdy
-
radial
-
>
dr
*
radial
-
>
dr
)
;
image
-
>
common
.
property_changed
=
radial_gradient_property_changed
;
return
image
;
}
