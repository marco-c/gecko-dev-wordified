/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
"
use
strict
"
;
/
/
CensusTreeNode
is
an
intermediate
representation
of
a
census
report
that
/
/
exists
between
after
a
report
is
generated
by
taking
a
census
and
before
the
/
/
report
is
rendered
in
the
DOM
.
It
must
be
dead
simple
to
render
with
no
/
/
further
data
processing
or
massaging
needed
before
rendering
DOM
nodes
.
Our
/
/
goal
is
to
do
the
census
report
to
CensusTreeNode
transformation
in
the
/
/
HeapAnalysesWorker
and
ensure
that
the
*
*
only
*
*
work
that
the
main
thread
/
/
has
to
do
is
strictly
DOM
rendering
work
.
const
{
Visitor
walk
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
devtools
/
shared
/
heapsnapshot
/
CensusUtils
.
js
"
)
;
/
*
*
*
Return
true
if
the
given
object
is
a
SavedFrame
stack
object
false
otherwise
.
*
*
param
{
any
}
obj
*
returns
{
Boolean
}
*
/
function
isSavedFrame
(
obj
)
{
return
Object
.
prototype
.
toString
.
call
(
obj
)
=
=
=
"
[
object
SavedFrame
]
"
;
}
/
*
*
*
A
FrameCache
maps
from
SavedFrames
to
CensusTreeNodes
.
It
is
used
when
*
aggregating
multiple
SavedFrame
allocation
stack
keys
into
a
tree
of
many
*
CensusTreeNodes
.
Each
stack
may
share
older
frames
and
we
want
to
preserve
*
this
sharing
when
converting
to
CensusTreeNode
so
before
creating
a
new
*
CensusTreeNode
we
look
for
an
existing
one
in
one
of
our
FrameCaches
.
*
/
function
FrameCache
(
)
{
}
FrameCache
.
prototype
=
null
;
/
*
*
*
The
value
of
a
single
entry
stored
in
a
FrameCache
.
It
is
a
pair
of
the
*
CensusTreeNode
for
this
frame
and
the
subsequent
FrameCache
for
this
node
'
s
*
children
.
*
*
param
{
SavedFrame
}
frame
*
The
frame
being
cached
.
*
/
function
FrameCacheValue
(
frame
)
{
/
/
The
CensusTreeNode
for
this
frame
.
this
.
node
=
new
CensusTreeNode
(
frame
)
;
/
/
The
FrameCache
for
this
frame
'
s
children
.
this
.
children
=
undefined
;
}
FrameCacheValue
.
prototype
=
null
;
/
*
*
*
Create
a
unique
string
for
the
given
SavedFrame
(
ignoring
the
frame
'
s
parent
*
chain
)
that
can
be
used
as
a
hash
to
key
this
frame
within
a
FrameCache
.
*
*
param
{
SavedFrame
}
frame
*
The
SavedFrame
object
we
would
like
to
lookup
in
or
insert
into
a
*
FrameCache
.
*
*
returns
{
String
}
*
The
unique
string
that
can
be
used
as
a
key
in
a
FrameCache
.
*
/
FrameCache
.
hash
=
function
(
frame
)
{
return
{
frame
.
functionDisplayName
}
{
frame
.
source
}
{
frame
.
line
}
{
frame
.
column
}
{
frame
.
asyncCause
}
;
}
;
/
*
*
*
Associate
frame
with
value
in
the
given
cache
.
*
*
param
{
FrameCache
}
cache
*
param
{
SavedFrame
}
frame
*
param
{
FrameCacheValue
}
value
*
/
FrameCache
.
insert
=
function
(
cache
frame
value
)
{
cache
[
FrameCache
.
hash
(
frame
)
]
=
value
;
}
;
/
*
*
*
Lookup
frame
in
cache
and
return
its
value
if
it
exists
.
*
*
param
{
FrameCache
}
cache
*
param
{
SavedFrame
}
frame
*
*
returns
{
undefined
|
FrameCacheValue
}
*
/
FrameCache
.
lookup
=
function
(
cache
frame
)
{
return
cache
[
FrameCache
.
hash
(
frame
)
]
;
}
;
/
*
*
*
Add
child
to
parent
'
s
set
of
children
.
*
*
param
{
CensusTreeNode
}
parent
*
param
{
CensusTreeNode
}
child
*
/
function
addChild
(
parent
child
)
{
if
(
!
parent
.
children
)
{
parent
.
children
=
[
]
;
}
parent
.
children
.
push
(
child
)
;
}
/
*
*
*
Get
an
array
of
each
frame
in
the
provided
stack
.
*
*
param
{
SavedFrame
}
stack
*
returns
{
Array
<
SavedFrame
>
}
*
/
function
getArrayOfFrames
(
stack
)
{
const
frames
=
[
]
;
let
frame
=
stack
;
while
(
frame
)
{
frames
.
push
(
frame
)
;
frame
=
frame
.
parent
;
}
frames
.
reverse
(
)
;
return
frames
;
}
/
*
*
*
Given
an
edge
to
a
sub
-
report
whose
structure
is
described
by
*
breakdown
create
a
CensusTreeNode
tree
.
*
*
param
{
Object
}
breakdown
*
The
breakdown
specifying
the
structure
of
the
given
report
.
*
*
param
{
Object
}
report
*
The
census
report
.
*
*
param
{
null
|
String
|
SavedFrame
}
edge
*
The
edge
leading
to
this
report
from
the
parent
report
.
*
*
param
{
FrameCache
}
frameCache
*
The
cache
of
CensusTreeNodes
we
have
already
made
for
the
siblings
of
*
the
node
being
created
.
The
existing
nodes
are
reused
when
possible
.
*
*
param
{
Object
}
outParams
*
The
return
values
are
attached
to
this
object
after
this
function
*
returns
.
Because
we
create
a
CensusTreeNode
for
each
frame
in
a
*
SavedFrame
stack
edge
there
may
multiple
nodes
per
sub
-
report
.
*
*
-
top
:
The
deepest
node
in
the
CensusTreeNode
subtree
created
.
*
*
-
bottom
:
The
shallowest
node
in
the
CensusTreeNode
subtree
created
.
*
This
is
null
if
the
shallowest
node
in
the
subtree
was
*
found
in
the
frameCache
and
reused
.
*
*
Note
that
top
and
bottom
are
not
necessarily
different
.
In
the
case
*
where
there
is
a
1
:
1
correspondence
between
an
edge
in
the
report
and
*
a
CensusTreeNode
top
and
bottom
refer
to
the
same
node
.
*
/
function
makeCensusTreeNodeSubTree
(
breakdown
report
edge
frameCache
outParams
)
{
if
(
!
isSavedFrame
(
edge
)
)
{
const
node
=
new
CensusTreeNode
(
edge
)
;
outParams
.
top
=
outParams
.
bottom
=
node
;
return
;
}
/
/
Loop
through
each
frame
in
the
stack
and
get
or
create
a
CensusTreeNode
for
/
/
the
frame
.
const
frames
=
getArrayOfFrames
(
edge
)
;
let
cache
=
frameCache
;
let
prevNode
;
for
(
let
i
=
0
length
=
frames
.
length
;
i
<
length
;
i
+
+
)
{
const
frame
=
frames
[
i
]
;
/
/
Get
or
create
the
FrameCacheValue
for
this
frame
.
If
we
already
have
a
/
/
FrameCacheValue
(
and
hence
a
CensusTreeNode
)
for
this
frame
we
don
'
t
/
/
need
to
add
the
node
to
the
previous
node
'
s
children
as
we
have
already
/
/
done
that
.
If
we
don
'
t
have
a
FrameCacheValue
and
CensusTreeNode
for
/
/
this
frame
then
create
one
and
make
sure
to
hook
it
up
as
a
child
of
/
/
the
previous
node
.
let
isNewNode
=
false
;
let
val
=
FrameCache
.
lookup
(
cache
frame
)
;
if
(
!
val
)
{
isNewNode
=
true
;
val
=
new
FrameCacheValue
(
frame
)
;
FrameCache
.
insert
(
cache
frame
val
)
;
if
(
prevNode
)
{
addChild
(
prevNode
val
.
node
)
;
}
}
if
(
i
=
=
=
0
)
{
outParams
.
bottom
=
isNewNode
?
val
.
node
:
null
;
}
if
(
i
=
=
=
length
-
1
)
{
outParams
.
top
=
val
.
node
;
}
prevNode
=
val
.
node
;
if
(
i
!
=
=
length
-
1
&
&
!
val
.
children
)
{
/
/
This
is
not
the
last
frame
and
therefore
this
node
will
have
/
/
children
which
we
must
cache
.
val
.
children
=
new
FrameCache
(
)
;
}
cache
=
val
.
children
;
}
}
/
*
*
*
A
Visitor
that
walks
a
census
report
and
creates
the
corresponding
*
CensusTreeNode
tree
.
*
/
function
CensusTreeNodeVisitor
(
)
{
/
/
The
root
of
the
resulting
CensusTreeNode
tree
.
this
.
_root
=
null
;
/
/
The
stack
of
CensusTreeNodes
that
we
are
in
the
process
of
building
while
/
/
walking
the
census
report
.
this
.
_nodeStack
=
[
]
;
/
/
To
avoid
unnecessary
allocations
we
reuse
the
same
out
parameter
object
/
/
passed
to
makeCensusTreeNodeSubTree
every
time
we
call
it
.
this
.
_outParams
=
{
top
:
null
bottom
:
null
}
;
/
/
The
stack
of
FrameCache
s
that
we
use
to
aggregate
many
SavedFrame
stacks
/
/
into
a
single
CensusTreeNode
tree
.
this
.
_frameCacheStack
=
[
new
FrameCache
(
)
]
;
}
CensusTreeNodeVisitor
.
prototype
=
Object
.
create
(
Visitor
)
;
/
*
*
*
Create
the
CensusTreeNode
subtree
for
this
sub
-
report
and
link
it
to
the
*
parent
CensusTreeNode
.
*
*
overrides
Visitor
.
prototype
.
enter
*
/
CensusTreeNodeVisitor
.
prototype
.
enter
=
function
(
breakdown
report
edge
)
{
const
cache
=
this
.
_frameCacheStack
[
this
.
_frameCacheStack
.
length
-
1
]
;
makeCensusTreeNodeSubTree
(
breakdown
report
edge
cache
this
.
_outParams
)
;
const
{
top
bottom
}
=
this
.
_outParams
;
if
(
!
this
.
_root
)
{
this
.
_root
=
bottom
;
}
else
{
if
(
bottom
)
{
addChild
(
this
.
_nodeStack
[
this
.
_nodeStack
.
length
-
1
]
bottom
)
;
}
}
this
.
_frameCacheStack
.
push
(
new
FrameCache
)
;
this
.
_nodeStack
.
push
(
top
)
;
}
;
function
values
(
cache
)
{
return
Object
.
keys
(
cache
)
.
map
(
k
=
>
cache
[
k
]
)
;
}
/
*
*
*
We
have
finished
adding
children
to
the
CensusTreeNode
subtree
for
the
*
current
sub
-
report
.
Make
sure
that
the
children
are
sorted
for
every
node
in
*
the
subtree
.
*
*
overrides
Visitor
.
prototype
.
exit
*
/
CensusTreeNodeVisitor
.
prototype
.
exit
=
function
(
breakdown
report
edge
)
{
const
top
=
this
.
_nodeStack
.
pop
(
)
;
if
(
top
.
children
)
{
top
.
children
.
sort
(
compareByBytes
)
;
}
const
cache
=
this
.
_frameCacheStack
.
pop
(
)
;
const
toSort
=
values
(
cache
)
;
while
(
toSort
.
length
)
{
const
{
node
children
}
=
toSort
.
pop
(
)
;
if
(
!
node
.
children
)
{
continue
;
}
if
(
node
!
=
=
top
)
{
node
.
children
.
sort
(
compareByBytes
)
;
}
if
(
!
children
)
{
continue
;
}
const
newlyNeedSorting
=
values
(
children
)
;
for
(
let
i
=
0
length
=
newlyNeedSorting
.
length
;
i
<
length
;
i
+
+
)
{
toSort
.
push
(
newlyNeedSorting
[
i
]
)
;
}
}
}
;
/
*
*
*
overrides
Visitor
.
prototype
.
count
*
/
CensusTreeNodeVisitor
.
prototype
.
count
=
function
(
breakdown
report
edge
)
{
const
node
=
this
.
_nodeStack
[
this
.
_nodeStack
.
length
-
1
]
;
node
.
count
=
report
.
count
;
node
.
bytes
=
report
.
bytes
;
}
;
/
*
*
*
Get
the
root
of
the
resulting
CensusTreeNode
tree
.
*
*
returns
{
CensusTreeNode
}
*
/
CensusTreeNodeVisitor
.
prototype
.
root
=
function
(
)
{
if
(
!
this
.
_root
)
{
throw
new
Error
(
"
Attempt
to
get
the
root
before
walking
the
census
report
!
"
)
;
}
if
(
this
.
_nodeStack
.
length
)
{
throw
new
Error
(
"
Attempt
to
get
the
root
while
walking
the
census
report
!
"
)
;
}
return
this
.
_root
;
}
;
/
*
*
*
Create
a
single
uninitialized
CensusTreeNode
.
*
*
param
{
null
|
String
|
SavedFrame
}
name
*
/
function
CensusTreeNode
(
name
)
{
this
.
name
=
name
;
this
.
bytes
=
undefined
;
this
.
count
=
undefined
;
this
.
children
=
undefined
;
}
CensusTreeNode
.
prototype
=
null
;
/
*
*
*
Compare
the
given
nodes
by
their
bytes
properties
.
*
*
param
{
CensusTreeNode
}
node1
*
param
{
CensusTreeNode
}
node2
*
*
returns
{
Number
}
*
A
number
suitable
for
using
with
Array
.
prototype
.
sort
.
*
/
function
compareByBytes
(
node1
node2
)
{
return
(
node2
.
bytes
|
|
0
)
-
(
node1
.
bytes
|
|
0
)
;
}
/
*
*
*
Takes
a
report
from
a
census
(
dbg
.
memory
.
takeCensus
(
)
)
and
the
breakdown
*
used
to
generate
the
census
and
returns
a
structure
used
to
render
*
a
tree
to
display
the
data
.
*
*
Returns
a
recursive
"
CensusTreeNode
"
object
looking
like
:
*
*
CensusTreeNode
=
{
*
/
/
children
if
it
exists
is
sorted
by
bytes
if
they
are
leaf
nodes
.
*
children
:
?
[
<
CensusTreeNode
.
.
.
>
]
*
name
:
<
?
String
>
*
count
:
<
?
Number
>
*
bytes
:
<
?
Number
>
*
}
*
*
param
{
Object
}
breakdown
*
The
breakdown
used
to
generate
the
census
report
.
*
*
param
{
Object
}
report
*
The
census
report
generated
with
the
specified
breakdown
.
*
*
returns
{
CensusTreeNode
}
*
/
exports
.
censusReportToCensusTreeNode
=
function
(
breakdown
report
)
{
const
visitor
=
new
CensusTreeNodeVisitor
(
)
;
walk
(
breakdown
report
visitor
)
;
return
visitor
.
root
(
)
;
}
;
