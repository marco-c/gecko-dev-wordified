/
*
-
*
-
indent
-
tabs
-
mode
:
nil
;
js
-
indent
-
level
:
2
-
*
-
*
/
/
*
vim
:
set
ft
=
javascript
ts
=
2
et
sw
=
2
tw
=
80
:
*
/
/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
"
use
strict
"
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
loader
.
lazyRequireGetter
(
this
"
Reflect
"
"
resource
:
/
/
gre
/
modules
/
reflect
.
jsm
"
true
)
;
/
*
*
*
A
JS
parser
using
the
reflection
API
.
*
/
const
Parser
=
function
Parser
(
)
{
this
.
_cache
=
new
Map
(
)
;
this
.
errors
=
[
]
;
this
.
logExceptions
=
true
;
}
;
Parser
.
prototype
=
{
/
*
*
*
Gets
a
collection
of
parser
methods
for
a
specified
source
.
*
*
param
string
source
*
The
source
text
content
.
*
param
string
url
[
optional
]
*
The
source
url
.
The
AST
nodes
will
be
cached
so
you
can
use
this
*
identifier
to
avoid
parsing
the
whole
source
again
.
*
/
get
(
source
url
=
"
"
)
{
/
/
Try
to
use
the
cached
AST
nodes
to
avoid
useless
parsing
operations
.
if
(
this
.
_cache
.
has
(
url
)
)
{
return
this
.
_cache
.
get
(
url
)
;
}
/
/
The
source
may
not
necessarily
be
JS
in
which
case
we
need
to
extract
/
/
all
the
scripts
.
Fastest
/
easiest
way
is
with
a
regular
expression
.
/
/
Don
'
t
worry
the
rules
of
using
a
<
script
>
tag
are
really
strict
/
/
this
will
work
.
const
regexp
=
/
<
script
[
^
>
]
*
?
(
?
:
>
(
[
^
]
*
?
)
<
\
/
script
\
s
*
>
|
\
/
>
)
/
gim
;
const
syntaxTrees
=
[
]
;
const
scriptMatches
=
[
]
;
let
scriptMatch
;
if
(
source
.
match
(
/
^
\
s
*
<
/
)
)
{
/
/
First
non
whitespace
character
is
&
lt
so
most
definitely
HTML
.
while
(
(
scriptMatch
=
regexp
.
exec
(
source
)
)
)
{
/
/
Contents
are
captured
at
index
1
or
nothing
:
Self
-
closing
scripts
/
/
won
'
t
capture
code
content
scriptMatches
.
push
(
scriptMatch
[
1
]
|
|
"
"
)
;
}
}
/
/
If
there
are
no
script
matches
send
the
whole
source
directly
to
the
/
/
reflection
API
to
generate
the
AST
nodes
.
if
(
!
scriptMatches
.
length
)
{
/
/
Reflect
.
parse
throws
when
encounters
a
syntax
error
.
try
{
const
nodes
=
Reflect
.
parse
(
source
)
;
const
length
=
source
.
length
;
syntaxTrees
.
push
(
new
SyntaxTree
(
nodes
url
length
)
)
;
}
catch
(
e
)
{
this
.
errors
.
push
(
e
)
;
if
(
this
.
logExceptions
)
{
DevToolsUtils
.
reportException
(
url
e
)
;
}
}
}
else
{
/
/
Generate
the
AST
nodes
for
each
script
.
for
(
const
script
of
scriptMatches
)
{
/
/
Reflect
.
parse
throws
when
encounters
a
syntax
error
.
try
{
const
nodes
=
Reflect
.
parse
(
script
)
;
const
offset
=
source
.
indexOf
(
script
)
;
const
length
=
script
.
length
;
syntaxTrees
.
push
(
new
SyntaxTree
(
nodes
url
length
offset
)
)
;
}
catch
(
e
)
{
this
.
errors
.
push
(
e
)
;
if
(
this
.
logExceptions
)
{
DevToolsUtils
.
reportException
(
url
e
)
;
}
}
}
}
const
pool
=
new
SyntaxTreesPool
(
syntaxTrees
url
)
;
/
/
Cache
the
syntax
trees
pool
by
the
specified
url
.
This
is
entirely
/
/
optional
but
it
'
s
strongly
encouraged
to
cache
ASTs
because
/
/
generating
them
can
be
costly
with
big
/
complex
sources
.
if
(
url
)
{
this
.
_cache
.
set
(
url
pool
)
;
}
return
pool
;
}
_cache
:
null
errors
:
null
}
;
exports
.
Parser
=
Parser
;
/
*
*
*
A
pool
handling
a
collection
of
AST
nodes
generated
by
the
reflection
API
.
*
*
param
object
syntaxTrees
*
A
collection
of
AST
nodes
generated
for
a
source
.
*
param
string
url
[
optional
]
*
The
source
url
.
*
/
function
SyntaxTreesPool
(
syntaxTrees
url
=
"
<
unknown
>
"
)
{
this
.
_trees
=
syntaxTrees
;
this
.
_url
=
url
;
this
.
_cache
=
new
Map
(
)
;
}
SyntaxTreesPool
.
prototype
=
{
/
*
*
*
return
SyntaxTree
*
The
last
tree
in
this
.
_trees
*
/
getLastSyntaxTree
(
)
{
return
this
.
_trees
[
this
.
_trees
.
length
-
1
]
;
}
_trees
:
null
_cache
:
null
}
;
/
*
*
*
A
collection
of
AST
nodes
generated
by
the
reflection
API
.
*
*
param
object
nodes
*
The
AST
nodes
.
*
param
string
url
*
The
source
url
.
*
param
number
length
*
The
total
number
of
chars
of
the
parsed
script
in
the
parent
source
.
*
param
number
offset
[
optional
]
*
The
char
offset
of
the
parsed
script
in
the
parent
source
.
*
/
function
SyntaxTree
(
nodes
url
length
offset
=
0
)
{
this
.
AST
=
nodes
;
this
.
url
=
url
;
this
.
length
=
length
;
this
.
offset
=
offset
;
}
