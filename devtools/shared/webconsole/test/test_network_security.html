<
!
DOCTYPE
HTML
>
<
html
lang
=
"
en
"
>
<
head
>
<
meta
charset
=
"
utf8
"
>
<
title
>
Test
for
the
network
actor
(
HPKP
detection
)
<
/
title
>
<
script
type
=
"
text
/
javascript
"
src
=
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
SimpleTest
.
js
"
>
<
/
script
>
<
script
type
=
"
text
/
javascript
"
src
=
"
common
.
js
"
>
<
/
script
>
<
!
-
-
Any
copyright
is
dedicated
to
the
Public
Domain
.
-
http
:
/
/
creativecommons
.
org
/
publicdomain
/
zero
/
1
.
0
/
-
-
>
<
/
head
>
<
body
>
<
p
>
Test
for
the
network
actor
(
HPKP
detection
)
<
/
p
>
<
iframe
src
=
"
https
:
/
/
example
.
com
/
chrome
/
devtools
/
shared
/
webconsole
/
test
/
network_requests_iframe
.
html
"
>
<
/
iframe
>
<
script
class
=
"
testbody
"
type
=
"
text
/
javascript
"
>
Cu
.
import
(
"
resource
:
/
/
testing
-
common
/
BrowserTestUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
SimpleTest
.
waitForExplicitFinish
(
)
;
let
gCurrentTestCase
=
-
1
;
const
HPKP_PREF
=
"
security
.
cert_pinning
.
process_headers_from_non_builtin_roots
"
;
/
/
Static
pins
tested
by
unit
/
test_security
-
info
-
static
-
hpkp
.
js
.
const
TEST_CASES
=
[
{
desc
:
"
no
HSTS
or
HPKP
"
url
:
"
https
:
/
/
example
.
com
"
usesHSTS
:
false
usesPinning
:
false
}
{
desc
:
"
HSTS
from
this
response
no
Public
Key
Pinning
"
url
:
"
https
:
/
/
example
.
com
/
"
+
"
browser
/
browser
/
base
/
content
/
test
/
general
/
browser_star_hsts
.
sjs
"
usesHSTS
:
true
usesPinning
:
false
}
{
desc
:
"
stored
HSTS
from
previous
response
no
Public
Key
Pinning
"
url
:
"
https
:
/
/
example
.
com
/
"
usesHSTS
:
true
usesPinning
:
false
}
{
desc
:
"
no
Public
Key
Pinning
or
HSTS
"
url
:
"
https
:
/
/
include
-
subdomains
.
pinning
-
dynamic
.
example
.
com
/
"
usesHSTS
:
false
usesPinning
:
false
}
{
desc
:
"
dynamic
Public
Key
Pinning
with
this
request
no
HSTS
"
url
:
"
https
:
/
/
include
-
subdomains
.
pinning
-
dynamic
.
example
.
com
/
"
+
"
browser
/
browser
/
base
/
content
/
test
/
general
/
pinning_headers
.
sjs
"
usesHSTS
:
false
usesPinning
:
true
}
{
desc
:
"
dynamic
Public
Key
Pinning
with
previous
request
no
HSTS
"
url
:
"
https
:
/
/
include
-
subdomains
.
pinning
-
dynamic
.
example
.
com
/
"
usesHSTS
:
false
usesPinning
:
true
}
]
;
const
TEST_MODES
=
[
"
public
"
"
private
"
]
;
let
ALL_TESTS
=
[
]
;
function
startTest
(
)
{
/
/
Need
to
enable
this
pref
or
pinning
headers
are
rejected
due
test
/
/
certificate
.
Services
.
prefs
.
setBoolPref
(
HPKP_PREF
true
)
;
SimpleTest
.
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
setBoolPref
(
HPKP_PREF
false
)
;
/
/
Reset
pinning
state
.
let
gSSService
=
Cc
[
"
mozilla
.
org
/
ssservice
;
1
"
]
.
getService
(
Ci
.
nsISiteSecurityService
)
;
let
gIOService
=
Cc
[
"
mozilla
.
org
/
network
/
io
-
service
;
1
"
]
.
getService
(
Ci
.
nsIIOService
)
;
for
(
let
{
url
}
of
TEST_CASES
)
{
let
uri
=
gIOService
.
newURI
(
url
)
;
gSSService
.
removeState
(
Ci
.
nsISiteSecurityService
.
HEADER_HSTS
uri
0
)
;
gSSService
.
removeState
(
Ci
.
nsISiteSecurityService
.
HEADER_HSTS
uri
Ci
.
nsISocketProvider
.
NO_PERMANENT_STORAGE
{
privateBrowsingId
:
1
}
)
;
gSSService
.
removeState
(
Ci
.
nsISiteSecurityService
.
HEADER_HPKP
uri
0
)
;
gSSService
.
removeState
(
Ci
.
nsISiteSecurityService
.
HEADER_HPKP
uri
Ci
.
nsISocketProvider
.
NO_PERMANENT_STORAGE
{
privateBrowsingId
:
1
}
)
;
}
}
)
;
info
(
"
Test
detection
of
HTTP
Strict
Transport
Security
"
+
"
and
Public
Key
Pinning
.
"
)
;
for
(
let
mode
of
TEST_MODES
)
{
for
(
let
testCase
of
TEST_CASES
)
{
let
test
=
{
mode
}
;
for
(
let
attr
in
testCase
)
{
test
[
attr
]
=
testCase
[
attr
]
;
}
ALL_TESTS
.
push
(
test
)
;
}
}
removeEventListener
(
"
load
"
startTest
)
;
attachConsoleToTab
(
[
"
NetworkActivity
"
]
onAttach
)
;
}
function
onAttach
(
state
response
)
{
let
callback
=
onNetworkEventUpdate
.
bind
(
null
state
)
;
state
.
dbgClient
.
addListener
(
"
networkEventUpdate
"
callback
)
;
runNextCase
(
state
)
;
}
function
runNextCase
(
state
)
{
gCurrentTestCase
+
+
;
if
(
gCurrentTestCase
=
=
=
ALL_TESTS
.
length
)
{
info
(
"
Tests
ran
.
Cleaning
up
.
"
)
;
closeDebugger
(
state
SimpleTest
.
finish
)
;
return
;
}
let
{
desc
url
mode
}
=
ALL_TESTS
[
gCurrentTestCase
]
;
info
(
"
Testing
site
with
"
+
desc
)
;
if
(
mode
=
=
"
private
"
)
{
info
(
"
Cleaning
up
the
previous
window
.
"
)
;
closeDebugger
(
state
runInPrivateWindow
)
;
}
else
{
let
iframe
=
document
.
querySelector
(
"
iframe
"
)
.
contentWindow
;
iframe
.
wrappedJSObject
.
makeXhrCallback
(
"
GET
"
url
)
;
}
}
function
onNetworkEventUpdate
(
state
type
packet
)
{
function
onSecurityInfo
(
received
)
{
let
data
=
ALL_TESTS
[
gCurrentTestCase
]
;
is
(
received
.
securityInfo
.
hsts
data
.
usesHSTS
"
Strict
Transport
Security
detected
correctly
.
"
)
;
is
(
received
.
securityInfo
.
hpkp
data
.
usesPinning
"
Public
Key
Pinning
detected
correctly
.
"
)
;
runNextCase
(
state
)
;
}
if
(
packet
.
updateType
=
=
=
"
securityInfo
"
)
{
state
.
client
.
getSecurityInfo
(
packet
.
from
onSecurityInfo
)
;
}
}
function
whenDelayedStartupFinished
(
aWindow
aCallback
)
{
SpecialPowers
.
Services
.
obs
.
addObserver
(
function
observer
(
aSubject
aTopic
)
{
if
(
aWindow
=
=
aSubject
)
{
SpecialPowers
.
Services
.
obs
.
removeObserver
(
observer
aTopic
)
;
SimpleTest
.
executeSoon
(
aCallback
)
;
}
}
"
browser
-
delayed
-
startup
-
finished
"
false
)
;
}
let
mainWindow
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShellTreeItem
)
.
rootTreeItem
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
function
runInPrivateWindow
(
)
{
let
win
=
mainWindow
.
OpenBrowserWindow
(
{
private
:
true
}
)
;
Task
.
spawn
(
function
*
(
)
{
yield
new
Promise
(
resolve
=
>
whenDelayedStartupFinished
(
win
resolve
)
)
;
let
browser
=
win
.
gBrowser
.
selectedBrowser
;
let
url
=
ALL_TESTS
[
gCurrentTestCase
]
.
url
;
win
.
gBrowser
.
selectedTab
=
win
.
gBrowser
.
getTabForBrowser
(
browser
)
;
yield
new
Promise
(
function
(
resolve
)
{
attachConsoleToTab
(
[
"
NetworkActivity
"
]
function
(
state
)
{
let
callback
=
onNetworkEventUpdate
.
bind
(
null
state
)
;
state
.
dbgClient
.
addListener
(
"
networkEventUpdate
"
callback
)
;
resolve
(
)
;
}
)
;
}
)
;
yield
BrowserTestUtils
.
loadURI
(
browser
url
)
;
}
)
;
}
addEventListener
(
"
load
"
startTest
)
;
<
/
script
>
<
/
body
>
<
/
html
>
