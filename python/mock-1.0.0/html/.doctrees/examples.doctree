cdocutils
.
nodes
document
q
)
q
}
q
(
U
nametypesq
}
q
(
X
mocking
a
generator
methodq
NX
mock
subclasses
and
their
attributesq
NX
coping
with
mutable
argumentsq
NX
mocking
chained
callsq
NX
mocking
openq
NX
*
less
verbose
configuration
of
mock
objectsq
NX
yield
statementq
X
copy
.
deepcopyq
X
pyhamcrestq
U
1
X
further
examplesq
NX
twisted
adaptorq
X
!
checking
multiple
calls
with
mockq
NX
#
matching
any
argument
in
assertionsq
NX
+
hamcrest
.
library
.
integration
.
match_equalityq
X
unittest2q
X
this
blog
entryq
X
%
multiple
calls
with
different
effectsq
NX
datetime
.
date
.
today
(
)
q
X
advanced
usesq
X
mocking
unbound
methodsq
NX
__iter__q
U
2
X
more
complex
argument
matchingq
NX
further
-
examplesq
X
mocking
propertiesq
NX8
tracking
order
of
calls
and
less
verbose
call
assertionsq
NX
(
generator
tricks
for
systems
programmersq
X
partial
mockingq
NX
#
mocking
a
dictionary
with
magicmockq
!
NX
&
raising
exceptions
on
attribute
accessq
"
NX
applying
the
same
patch
to
every
test
methodq
#
NX
mocks
without
some
attributesq
NX
nesting
patchesq
%
NX
one
userq
&
X
mocking
imports
with
patch
.
dictq
'
NuU
substitution_defsq
(
}
q
)
U
parse_messagesq
*
]
q
+
U
current_sourceq
NU
decorationq
-
NU
autofootnote_startq
.
K
U
nameidsq
/
}
q0
(
h
U
mocking
-
a
-
generator
-
methodq1h
U
mock
-
subclasses
-
and
-
their
-
attributesq2h
U
coping
-
with
-
mutable
-
argumentsq3h
U
mocking
-
chained
-
callsq4h
U
mocking
-
openq5h
U
*
less
-
verbose
-
configuration
-
of
-
mock
-
objectsq6h
U
yield
-
statementq7h
U
copy
-
deepcopyq8h
U
pyhamcrestq9U
1U
id3q
:
h
U
id1q
;
h
U
twisted
-
adaptorq
<
h
U
!
checking
-
multiple
-
calls
-
with
-
mockq
=
h
U
#
matching
-
any
-
argument
-
in
-
assertionsq
>
h
U
+
hamcrest
-
library
-
integration
-
match
-
equalityq
?
h
U
unittest2q
h
U
this
-
blog
-
entryqAh
U
%
multiple
-
calls
-
with
-
different
-
effectsqBh
U
datetime
-
date
-
todayqCh
U
advanced
-
usesqDh
U
mocking
-
unbound
-
methodsqEh
U
iterqFU
2U
id5qGh
U
more
-
complex
-
argument
-
matchingqHh
U
further
-
examplesqIh
U
mocking
-
propertiesqJh
U8tracking
-
order
-
of
-
calls
-
and
-
less
-
verbose
-
call
-
assertionsqKh
U
(
generator
-
tricks
-
for
-
systems
-
programmersqLh
U
partial
-
mockingqMh
!
U
#
mocking
-
a
-
dictionary
-
with
-
magicmockqNh
"
U
&
raising
-
exceptions
-
on
-
attribute
-
accessqOh
#
U
applying
-
the
-
same
-
patch
-
to
-
every
-
test
-
methodqPh
U
mocks
-
without
-
some
-
attributesqQh
%
U
nesting
-
patchesqRh
&
U
one
-
userqSh
'
U
mocking
-
imports
-
with
-
patch
-
dictqTuU
childrenqU
]
qV
(
cdocutils
.
nodes
target
qW
)
qX
}
qY
(
U
rawsourceqZX
.
.
_further
-
examples
:
q
[
U
parentq
\
h
U
sourceq
]
cdocutils
.
nodes
reprunicode
q
^
X
/
compile
/
mock
/
docs
/
examples
.
txtq_
q
}
qabU
tagnameqbU
targetqcU
attributesqd
}
qe
(
U
idsqf
]
qgU
backrefsqh
]
qiU
dupnamesqj
]
qkU
classesql
]
qmU
namesqn
]
qoU
refidqphIuU
lineqqK
U
documentqrh
hU
]
qsubcdocutils
.
nodes
section
qt
)
qu
}
qv
(
hZU
h
\
h
h
]
h
U
expect_referenced_by_nameqw
}
qxh
hXshbU
sectionqyhd
}
qz
(
hj
]
q
{
hl
]
q
|
hh
]
q
}
hf
]
q
~
(
hIh
;
ehn
]
q
(
h
h
euhqK
hrh
U
expect_referenced_by_idq
}
q
hIhXshU
]
q
(
cdocutils
.
nodes
title
q
)
q
}
q
(
hZX
Further
Examplesq
h
\
huh
]
h
hbU
titleq
hd
}
q
(
hj
]
q
hl
]
q
hh
]
q
hf
]
q
hn
]
q
uhqK
hrh
hU
]
q
cdocutils
.
nodes
Text
q
X
Further
Examplesq
q
}
q
(
hZh
h
\
h
ubaubcdocutils
.
nodes
comment
q
)
q
}
q
(
hZX
from
datetime
import
date
BackendProvider
=
Mock
(
)
sys
.
modules
[
'
mymodule
'
]
=
mymodule
=
Mock
(
name
=
'
mymodule
'
)
def
grob
(
val
)
:
"
First
frob
and
then
clear
val
"
mymodule
.
frob
(
val
)
val
.
clear
(
)
mymodule
.
frob
=
lambda
val
:
val
mymodule
.
grob
=
grob
mymodule
.
date
=
date
class
TestCase
(
unittest2
.
TestCase
)
:
def
run
(
self
)
:
result
=
unittest2
.
TestResult
(
)
out
=
unittest2
.
TestCase
.
run
(
self
result
)
assert
result
.
wasSuccessful
(
)
from
mock
import
inPy3kq
h
\
huh
]
h
hbU
commentq
hd
}
q
(
U
testnodetypeq
X
testsetupq
U
xml
:
spaceq
U
preserveq
hf
]
q
hh
]
q
hj
]
q
hl
]
q
hn
]
q
U
groupsq
]
q
U
defaultq
aU
optionsq
}
q
uhqK
hrh
hU
]
q
h
X
from
datetime
import
date
BackendProvider
=
Mock
(
)
sys
.
modules
[
'
mymodule
'
]
=
mymodule
=
Mock
(
name
=
'
mymodule
'
)
def
grob
(
val
)
:
"
First
frob
and
then
clear
val
"
mymodule
.
frob
(
val
)
val
.
clear
(
)
mymodule
.
frob
=
lambda
val
:
val
mymodule
.
grob
=
grob
mymodule
.
date
=
date
class
TestCase
(
unittest2
.
TestCase
)
:
def
run
(
self
)
:
result
=
unittest2
.
TestResult
(
)
out
=
unittest2
.
TestCase
.
run
(
self
result
)
assert
result
.
wasSuccessful
(
)
from
mock
import
inPy3kq
q
}
q
(
hZU
h
\
h
ubaubcdocutils
.
nodes
paragraph
q
)
q
}
q
(
hZXX
For
comprehensive
examples
see
the
unit
tests
included
in
the
full
source
distribution
.
q
h
\
huh
]
h
hbU
paragraphq
hd
}
q
(
hj
]
q
hl
]
q
hh
]
q
hf
]
q
hn
]
q
uhqK
#
hrh
hU
]
q
h
XX
For
comprehensive
examples
see
the
unit
tests
included
in
the
full
source
distribution
.
q
q
}
q
(
hZh
h
\
h
ubaubh
)
q
}
q
(
hZX
Here
are
some
more
examples
for
some
slightly
more
advanced
scenarios
than
in
the
:
ref
:
getting
started
<
getting
-
started
>
guide
.
q
h
\
huh
]
h
hbh
hd
}
q
(
hj
]
q
hl
]
q
hh
]
q
hf
]
q
hn
]
q
uhqK
&
hrh
hU
]
q
(
h
XR
Here
are
some
more
examples
for
some
slightly
more
advanced
scenarios
than
in
the
q
q
}
q
(
hZXR
Here
are
some
more
examples
for
some
slightly
more
advanced
scenarios
than
in
the
q
h
\
h
ubcsphinx
.
addnodes
pending_xref
q
)
q
}
q
(
hZX
(
:
ref
:
getting
started
<
getting
-
started
>
q
h
\
h
h
]
h
hbU
pending_xrefq
hd
}
q
(
U
reftypeq
X
refq
U
refwarnq
U
reftargetq
X
getting
-
startedq
U
refdomainq
X
stdq
hf
]
q
hh
]
q
U
refexplicitq
hj
]
q
hl
]
q
hn
]
q
U
refdocq
U
examplesq
uhqK
&
hU
]
q
cdocutils
.
nodes
emphasis
q
)
q
}
q
(
hZh
hd
}
q
(
hj
]
q
hl
]
q
(
U
xrefq
h
X
std
-
refq
ehh
]
q
hf
]
q
hn
]
q
uh
\
h
hU
]
q
h
X
getting
startedq
q
}
q
(
hZU
h
\
h
ubahbU
emphasisq
ubaubh
X
guide
.
q
q
}
q
(
hZX
guide
.
q
h
\
h
ubeubht
)
q
}
q
(
hZU
h
\
huh
]
h
hbhyhd
}
q
(
hj
]
q
hl
]
q
hh
]
q
hf
]
q
h4ahn
]
q
h
auhqK
+
hrh
hU
]
q
(
h
)
q
}
q
(
hZX
Mocking
chained
callsq
h
\
h
h
]
h
hbh
hd
}
q
(
hj
]
q
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqK
+
hrh
hU
]
r
h
X
Mocking
chained
callsr
r
}
r
(
hZh
h
\
h
ubaubh
)
r
}
r
(
hZX
Mocking
chained
calls
is
actually
straightforward
with
mock
once
you
understand
the
:
attr
:
~
Mock
.
return_value
attribute
.
When
a
mock
is
called
for
the
first
time
or
you
fetch
its
return_value
before
it
has
been
called
a
new
Mock
is
created
.
r
h
\
h
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqK
-
hrh
hU
]
r
(
h
XT
Mocking
chained
calls
is
actually
straightforward
with
mock
once
you
understand
the
r
r
}
r
(
hZXT
Mocking
chained
calls
is
actually
straightforward
with
mock
once
you
understand
the
r
h
\
j
ubh
)
r
}
r
(
hZX
:
attr
:
~
Mock
.
return_value
r
h
\
j
h
]
h
hbh
hd
}
r
(
U
reftyper
X
attrr
h
h
X
Mock
.
return_valuer
U
refdomainr
X
pyr
hf
]
r
hh
]
r
U
refexplicitr
!
hj
]
r
"
hl
]
r
#
hn
]
r
h
h
U
py
:
classr
%
NU
py
:
moduler
&
X
mockr
'
uhqK
-
hU
]
r
(
cdocutils
.
nodes
literal
r
)
)
r
*
}
r
+
(
hZj
hd
}
r
(
hj
]
r
-
hl
]
r
.
(
h
j
X
py
-
attrr
/
ehh
]
r0
hf
]
r1
hn
]
r2
uh
\
j
hU
]
r3
h
X
return_valuer4
r5
}
r6
(
hZU
h
\
j
*
ubahbU
literalr7
ubaubh
XG
attribute
.
When
a
mock
is
called
for
the
first
time
or
you
fetch
its
r8
r9
}
r
:
(
hZXG
attribute
.
When
a
mock
is
called
for
the
first
time
or
you
fetch
its
r
;
h
\
j
ubcdocutils
.
nodes
title_reference
r
<
)
r
=
}
r
>
(
hZX
return_value
r
?
hd
}
r
(
hj
]
rA
hl
]
rB
hh
]
rC
hf
]
rD
hn
]
rE
uh
\
j
hU
]
rF
h
X
return_valuerG
rH
}
rI
(
hZU
h
\
j
=
ubahbU
title_referencerJ
ubh
X
"
before
it
has
been
called
a
new
rK
rL
}
rM
(
hZX
"
before
it
has
been
called
a
new
rN
h
\
j
ubj
<
)
rO
}
rP
(
hZX
Mock
rQ
hd
}
rR
(
hj
]
rS
hl
]
rT
hh
]
rU
hf
]
rV
hn
]
rW
uh
\
j
hU
]
rX
h
X
MockrY
rZ
}
r
[
(
hZU
h
\
jO
ubahbjJ
ubh
X
is
created
.
r
\
r
]
}
r
^
(
hZX
is
created
.
r_
h
\
j
ubeubh
)
r
}
ra
(
hZX
This
means
that
you
can
see
how
the
object
returned
from
a
call
to
a
mocked
object
has
been
used
by
interrogating
the
return_value
mock
:
rb
h
\
h
h
]
h
hbh
hd
}
rc
(
hj
]
rd
hl
]
re
hh
]
rf
hf
]
rg
hn
]
rh
uhqK2hrh
hU
]
ri
(
h
Xv
This
means
that
you
can
see
how
the
object
returned
from
a
call
to
a
mocked
object
has
been
used
by
interrogating
the
rj
rk
}
rl
(
hZXv
This
means
that
you
can
see
how
the
object
returned
from
a
call
to
a
mocked
object
has
been
used
by
interrogating
the
rm
h
\
j
ubj
<
)
rn
}
ro
(
hZX
return_value
rp
hd
}
rq
(
hj
]
rr
hl
]
rs
hh
]
rt
hf
]
ru
hn
]
rv
uh
\
j
hU
]
rw
h
X
return_valuerx
ry
}
rz
(
hZU
h
\
jn
ubahbjJ
ubh
X
mock
:
r
{
r
|
}
r
}
(
hZX
mock
:
r
~
h
\
j
ubeubcdocutils
.
nodes
literal_block
r
)
r
}
r
(
hZX
>
>
>
mock
=
Mock
(
)
>
>
>
mock
(
)
.
foo
(
a
=
2
b
=
3
)
<
Mock
name
=
'
mock
(
)
.
foo
(
)
'
id
=
'
.
.
.
'
>
>
>
>
mock
.
return_value
.
foo
.
assert_called_with
(
a
=
2
b
=
3
)
r
h
\
h
h
]
h
hbU
literal_blockr
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqK5hrh
hU
]
r
h
X
>
>
>
mock
=
Mock
(
)
>
>
>
mock
(
)
.
foo
(
a
=
2
b
=
3
)
<
Mock
name
=
'
mock
(
)
.
foo
(
)
'
id
=
'
.
.
.
'
>
>
>
>
mock
.
return_value
.
foo
.
assert_called_with
(
a
=
2
b
=
3
)
r
r
}
r
(
hZU
h
\
j
ubaubh
)
r
}
r
(
hZX
From
here
it
is
a
simple
step
to
configure
and
then
make
assertions
about
chained
calls
.
Of
course
another
alternative
is
writing
your
code
in
a
more
testable
way
in
the
first
place
.
.
.
r
h
\
h
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqK
<
hrh
hU
]
r
h
X
From
here
it
is
a
simple
step
to
configure
and
then
make
assertions
about
chained
calls
.
Of
course
another
alternative
is
writing
your
code
in
a
more
testable
way
in
the
first
place
.
.
.
r
r
}
r
(
hZj
h
\
j
ubaubh
)
r
}
r
(
hZX
So
suppose
we
have
some
code
that
looks
a
little
bit
like
this
:
r
h
\
h
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqK
hrh
hU
]
r
h
X
So
suppose
we
have
some
code
that
looks
a
little
bit
like
this
:
r
r
}
r
(
hZj
h
\
j
ubaubj
)
r
}
r
(
hZX
>
>
>
class
Something
(
object
)
:
.
.
.
def
__init__
(
self
)
:
.
.
.
self
.
backend
=
BackendProvider
(
)
.
.
.
def
method
(
self
)
:
.
.
.
response
=
self
.
backend
.
get_endpoint
(
'
foobar
'
)
.
create_call
(
'
spam
'
'
eggs
'
)
.
start_call
(
)
.
.
.
#
more
coder
h
\
h
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqKBhrh
hU
]
r
h
X
>
>
>
class
Something
(
object
)
:
.
.
.
def
__init__
(
self
)
:
.
.
.
self
.
backend
=
BackendProvider
(
)
.
.
.
def
method
(
self
)
:
.
.
.
response
=
self
.
backend
.
get_endpoint
(
'
foobar
'
)
.
create_call
(
'
spam
'
'
eggs
'
)
.
start_call
(
)
.
.
.
#
more
coder
r
}
r
(
hZU
h
\
j
ubaubh
)
r
}
r
(
hZX
Assuming
that
BackendProvider
is
already
well
tested
how
do
we
test
method
(
)
?
Specifically
we
want
to
test
that
the
code
section
#
more
code
uses
the
response
object
in
the
correct
way
.
r
h
\
h
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqKKhrh
hU
]
r
(
h
X
Assuming
that
r
r
}
r
(
hZX
Assuming
that
r
h
\
j
ubj
<
)
r
}
r
(
hZX
BackendProvider
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
BackendProviderr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
(
is
already
well
tested
how
do
we
test
r
r
}
r
(
hZX
(
is
already
well
tested
how
do
we
test
r
h
\
j
ubj
<
)
r
}
r
(
hZX
method
(
)
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
method
(
)
r
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X6
?
Specifically
we
want
to
test
that
the
code
section
r
r
}
r
(
hZX6
?
Specifically
we
want
to
test
that
the
code
section
r
h
\
j
ubj
<
)
r
}
r
(
hZX
#
more
code
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
#
more
coder
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
-
uses
the
response
object
in
the
correct
way
.
r
r
}
r
(
hZX
-
uses
the
response
object
in
the
correct
way
.
r
h
\
j
ubeubh
)
r
}
r
(
hZX
As
this
chain
of
calls
is
made
from
an
instance
attribute
we
can
monkey
patch
the
backend
attribute
on
a
Something
instance
.
In
this
particular
case
we
are
only
interested
in
the
return
value
from
the
final
call
to
start_call
so
we
don
'
t
have
much
configuration
to
do
.
Let
'
s
assume
the
object
it
returns
is
'
file
-
like
'
so
we
'
ll
ensure
that
our
response
object
uses
the
builtin
file
as
its
spec
.
r
h
\
h
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqKOhrh
hU
]
r
(
h
XR
As
this
chain
of
calls
is
made
from
an
instance
attribute
we
can
monkey
patch
the
r
r
}
r
(
hZXR
As
this
chain
of
calls
is
made
from
an
instance
attribute
we
can
monkey
patch
the
r
h
\
j
ubj
<
)
r
}
r
(
hZX
backend
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
backendr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
attribute
on
a
r
r
}
r
(
hZX
attribute
on
a
r
h
\
j
ubj
<
)
r
}
r
(
hZX
Something
r
!
hd
}
r
"
(
hj
]
r
#
hl
]
r
hh
]
r
%
hf
]
r
&
hn
]
r
'
uh
\
j
hU
]
r
(
h
X
Somethingr
)
r
*
}
r
+
(
hZU
h
\
j
ubahbjJ
ubh
Xe
instance
.
In
this
particular
case
we
are
only
interested
in
the
return
value
from
the
final
call
to
r
r
-
}
r
.
(
hZXe
instance
.
In
this
particular
case
we
are
only
interested
in
the
return
value
from
the
final
call
to
r
/
h
\
j
ubj
<
)
r0
}
r1
(
hZX
start_call
r2
hd
}
r3
(
hj
]
r4
hl
]
r5
hh
]
r6
hf
]
r7
hn
]
r8
uh
\
j
hU
]
r9
h
X
start_callr
:
r
;
}
r
<
(
hZU
h
\
j0
ubahbjJ
ubh
X
so
we
don
'
t
have
much
configuration
to
do
.
Let
'
s
assume
the
object
it
returns
is
'
file
-
like
'
so
we
'
ll
ensure
that
our
response
object
uses
the
builtin
r
=
r
>
}
r
?
(
hZX
so
we
don
'
t
have
much
configuration
to
do
.
Let
'
s
assume
the
object
it
returns
is
'
file
-
like
'
so
we
'
ll
ensure
that
our
response
object
uses
the
builtin
r
h
\
j
ubj
<
)
rA
}
rB
(
hZX
file
rC
hd
}
rD
(
hj
]
rE
hl
]
rF
hh
]
rG
hf
]
rH
hn
]
rI
uh
\
j
hU
]
rJ
h
X
filerK
rL
}
rM
(
hZU
h
\
jA
ubahbjJ
ubh
X
as
its
rN
rO
}
rP
(
hZX
as
its
rQ
h
\
j
ubj
<
)
rR
}
rS
(
hZX
spec
rT
hd
}
rU
(
hj
]
rV
hl
]
rW
hh
]
rX
hf
]
rY
hn
]
rZ
uh
\
j
hU
]
r
[
h
X
specr
\
r
]
}
r
^
(
hZU
h
\
jR
ubahbjJ
ubh
X
.
r_
}
r
(
hZX
.
h
\
j
ubeubh
)
ra
}
rb
(
hZX
To
do
this
we
create
a
mock
instance
as
our
mock
backend
and
create
a
mock
response
object
for
it
.
To
set
the
response
as
the
return
value
for
that
final
start_call
we
could
do
this
:
rc
h
\
h
h
]
h
hbh
hd
}
rd
(
hj
]
re
hl
]
rf
hh
]
rg
hf
]
rh
hn
]
ri
uhqKVhrh
hU
]
rj
(
h
X
To
do
this
we
create
a
mock
instance
as
our
mock
backend
and
create
a
mock
response
object
for
it
.
To
set
the
response
as
the
return
value
for
that
final
rk
rl
}
rm
(
hZX
To
do
this
we
create
a
mock
instance
as
our
mock
backend
and
create
a
mock
response
object
for
it
.
To
set
the
response
as
the
return
value
for
that
final
rn
h
\
ja
ubj
<
)
ro
}
rp
(
hZX
start_call
rq
hd
}
rr
(
hj
]
rs
hl
]
rt
hh
]
ru
hf
]
rv
hn
]
rw
uh
\
ja
hU
]
rx
h
X
start_callry
rz
}
r
{
(
hZU
h
\
jo
ubahbjJ
ubh
X
we
could
do
this
:
r
|
r
}
}
r
~
(
hZX
we
could
do
this
:
r
h
\
ja
ubeubcdocutils
.
nodes
block_quote
r
)
r
}
r
(
hZU
h
\
h
h
]
h
hbU
block_quoter
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqNhrh
hU
]
r
h
)
r
}
r
(
hZXj
mock_backend
.
get_endpoint
.
return_value
.
create_call
.
return_value
.
start_call
.
return_value
=
mock_response
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqKZhU
]
r
(
j
<
)
r
}
r
(
hZXi
mock_backend
.
get_endpoint
.
return_value
.
create_call
.
return_value
.
start_call
.
return_value
=
mock_response
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
Xg
mock_backend
.
get_endpoint
.
return_value
.
create_call
.
return_value
.
start_call
.
return_value
=
mock_responser
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
.
r
}
r
(
hZX
.
h
\
j
ubeubaubh
)
r
}
r
(
hZX
}
We
can
do
that
in
a
slightly
nicer
way
using
the
:
meth
:
~
Mock
.
configure_mock
method
to
directly
set
the
return
value
for
us
:
r
h
\
h
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqK
\
hrh
hU
]
r
(
h
X1
We
can
do
that
in
a
slightly
nicer
way
using
the
r
r
}
r
(
hZX1
We
can
do
that
in
a
slightly
nicer
way
using
the
r
h
\
j
ubh
)
r
}
r
(
hZX
:
meth
:
~
Mock
.
configure_mock
r
h
\
j
h
]
h
hbh
hd
}
r
(
U
reftyper
X
methr
h
h
X
Mock
.
configure_mockr
U
refdomainr
X
pyr
hf
]
r
hh
]
r
U
refexplicitr
hj
]
r
hl
]
r
hn
]
r
h
h
j
%
Nj
&
j
'
uhqK
\
hU
]
r
j
)
)
r
}
r
(
hZj
hd
}
r
(
hj
]
r
hl
]
r
(
h
j
X
py
-
methr
ehh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
configure_mock
(
)
r
r
}
r
(
hZU
h
\
j
ubahbj7
ubaubh
X0
method
to
directly
set
the
return
value
for
us
:
r
r
}
r
(
hZX0
method
to
directly
set
the
return
value
for
us
:
r
h
\
j
ubeubj
)
r
}
r
(
hZX
>
>
>
something
=
Something
(
)
>
>
>
mock_response
=
Mock
(
spec
=
file
)
>
>
>
mock_backend
=
Mock
(
)
>
>
>
config
=
{
'
get_endpoint
.
return_value
.
create_call
.
return_value
.
start_call
.
return_value
'
:
mock_response
}
>
>
>
mock_backend
.
configure_mock
(
*
*
config
)
r
h
\
h
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqK_hrh
hU
]
r
h
X
>
>
>
something
=
Something
(
)
>
>
>
mock_response
=
Mock
(
spec
=
file
)
>
>
>
mock_backend
=
Mock
(
)
>
>
>
config
=
{
'
get_endpoint
.
return_value
.
create_call
.
return_value
.
start_call
.
return_value
'
:
mock_response
}
>
>
>
mock_backend
.
configure_mock
(
*
*
config
)
r
r
}
r
(
hZU
h
\
j
ubaubh
)
r
}
r
(
hZXR
With
these
we
monkey
patch
the
"
mock
backend
"
in
place
and
can
make
the
real
call
:
r
h
\
h
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqKghrh
hU
]
r
h
XR
With
these
we
monkey
patch
the
"
mock
backend
"
in
place
and
can
make
the
real
call
:
r
r
}
r
(
hZj
h
\
j
ubaubj
)
r
}
r
(
hZX
;
>
>
>
something
.
backend
=
mock_backend
>
>
>
something
.
method
(
)
r
h
\
h
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqKjhrh
hU
]
r
h
X
;
>
>
>
something
.
backend
=
mock_backend
>
>
>
something
.
method
(
)
r
r
}
r
(
hZU
h
\
j
ubaubh
)
r
}
r
(
hZX
Using
:
attr
:
~
Mock
.
mock_calls
we
can
check
the
chained
call
with
a
single
assert
.
A
chained
call
is
several
calls
in
one
line
of
code
so
there
will
be
several
entries
in
mock_calls
.
We
can
use
:
meth
:
call
.
call_list
to
create
this
list
of
calls
for
us
:
r
h
\
h
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqKohrh
hU
]
r
(
h
X
Using
r
r
}
r
(
hZX
Using
r
h
\
j
ubh
)
r
}
r
(
hZX
:
attr
:
~
Mock
.
mock_calls
r
h
\
j
h
]
h
hbh
hd
}
r
(
U
reftyper
X
attrr
h
h
X
Mock
.
mock_callsr
U
refdomainr
X
pyr
hf
]
r
hh
]
r
U
refexplicitr
hj
]
r
hl
]
r
hn
]
r
h
h
j
%
Nj
&
j
'
uhqKohU
]
r
!
j
)
)
r
"
}
r
#
(
hZj
hd
}
r
(
hj
]
r
%
hl
]
r
&
(
h
j
X
py
-
attrr
'
ehh
]
r
(
hf
]
r
)
hn
]
r
*
uh
\
j
hU
]
r
+
h
X
mock_callsr
r
-
}
r
.
(
hZU
h
\
j
"
ubahbj7
ubaubh
X
we
can
check
the
chained
call
with
a
single
assert
.
A
chained
call
is
several
calls
in
one
line
of
code
so
there
will
be
several
entries
in
r
/
r0
}
r1
(
hZX
we
can
check
the
chained
call
with
a
single
assert
.
A
chained
call
is
several
calls
in
one
line
of
code
so
there
will
be
several
entries
in
r2
h
\
j
ubj
<
)
r3
}
r4
(
hZX
mock_calls
r5
hd
}
r6
(
hj
]
r7
hl
]
r8
hh
]
r9
hf
]
r
:
hn
]
r
;
uh
\
j
hU
]
r
<
h
X
mock_callsr
=
r
>
}
r
?
(
hZU
h
\
j3
ubahbjJ
ubh
X
.
We
can
use
r
rA
}
rB
(
hZX
.
We
can
use
rC
h
\
j
ubh
)
rD
}
rE
(
hZX
:
meth
:
call
.
call_list
rF
h
\
j
h
]
h
hbh
hd
}
rG
(
U
reftyperH
X
methrI
h
h
X
call
.
call_listrJ
U
refdomainrK
X
pyrL
hf
]
rM
hh
]
rN
U
refexplicitrO
hj
]
rP
hl
]
rQ
hn
]
rR
h
h
j
%
Nj
&
j
'
uhqKohU
]
rS
j
)
)
rT
}
rU
(
hZjF
hd
}
rV
(
hj
]
rW
hl
]
rX
(
h
jL
X
py
-
methrY
ehh
]
rZ
hf
]
r
[
hn
]
r
\
uh
\
jD
hU
]
r
]
h
X
call
.
call_list
(
)
r
^
r_
}
r
(
hZU
h
\
jT
ubahbj7
ubaubh
X
%
to
create
this
list
of
calls
for
us
:
ra
rb
}
rc
(
hZX
%
to
create
this
list
of
calls
for
us
:
rd
h
\
j
ubeubj
)
re
}
rf
(
hZX
>
>
>
chained
=
call
.
get_endpoint
(
'
foobar
'
)
.
create_call
(
'
spam
'
'
eggs
'
)
.
start_call
(
)
>
>
>
call_list
=
chained
.
call_list
(
)
>
>
>
assert
mock_backend
.
mock_calls
=
=
call_listrg
h
\
h
h
]
h
hbj
hd
}
rh
(
U
testnodetyperi
X
doctestrj
h
h
hf
]
rk
hh
]
rl
hj
]
rm
hl
]
rn
hn
]
ro
U
groupsrp
]
rq
h
ah
}
rr
uhqKthrh
hU
]
rs
h
X
>
>
>
chained
=
call
.
get_endpoint
(
'
foobar
'
)
.
create_call
(
'
spam
'
'
eggs
'
)
.
start_call
(
)
>
>
>
call_list
=
chained
.
call_list
(
)
>
>
>
assert
mock_backend
.
mock_calls
=
=
call_listrt
ru
}
rv
(
hZU
h
\
je
ubaubeubht
)
rw
}
rx
(
hZU
h
\
huh
]
h
hbhyhd
}
ry
(
hj
]
rz
hl
]
r
{
hh
]
r
|
hf
]
r
}
hMahn
]
r
~
h
auhqK
|
hrh
hU
]
r
(
h
)
r
}
r
(
hZX
Partial
mockingr
h
\
jw
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqK
|
hrh
hU
]
r
h
X
Partial
mockingr
r
}
r
(
hZj
h
\
j
ubaubh
)
r
}
r
(
hZXh
In
some
tests
I
wanted
to
mock
out
a
call
to
datetime
.
date
.
today
(
)
<
http
:
/
/
docs
.
python
.
org
/
library
/
datetime
.
html
#
datetime
.
date
.
today
>
_
to
return
a
known
date
but
I
didn
'
t
want
to
prevent
the
code
under
test
from
creating
new
date
objects
.
Unfortunately
datetime
.
date
is
written
in
C
and
so
I
couldn
'
t
just
monkey
-
patch
out
the
static
date
.
today
method
.
r
h
\
jw
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqK
~
hrh
hU
]
r
(
h
X
-
In
some
tests
I
wanted
to
mock
out
a
call
to
r
r
}
r
(
hZX
-
In
some
tests
I
wanted
to
mock
out
a
call
to
r
h
\
j
ubcdocutils
.
nodes
reference
r
)
r
}
r
(
hZX
[
datetime
.
date
.
today
(
)
<
http
:
/
/
docs
.
python
.
org
/
library
/
datetime
.
html
#
datetime
.
date
.
today
>
_r
hd
}
r
(
U
namer
X
datetime
.
date
.
today
(
)
r
U
refurir
X
http
:
/
/
docs
.
python
.
org
/
library
/
datetime
.
html
#
datetime
.
date
.
todayr
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
datetime
.
date
.
today
(
)
r
r
}
r
(
hZU
h
\
j
ubahbU
referencer
ubhW
)
r
}
r
(
hZXC
<
http
:
/
/
docs
.
python
.
org
/
library
/
datetime
.
html
#
datetime
.
date
.
today
>
r
U
referencedr
K
h
\
j
hbhchd
}
r
(
U
refurir
j
hf
]
r
hCahh
]
r
hj
]
r
hl
]
r
hn
]
r
h
auhU
]
r
ubh
Xx
to
return
a
known
date
but
I
didn
'
t
want
to
prevent
the
code
under
test
from
creating
new
date
objects
.
Unfortunately
r
r
}
r
(
hZXx
to
return
a
known
date
but
I
didn
'
t
want
to
prevent
the
code
under
test
from
creating
new
date
objects
.
Unfortunately
r
h
\
j
ubj
<
)
r
}
r
(
hZX
datetime
.
date
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
datetime
.
dater
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
XE
is
written
in
C
and
so
I
couldn
'
t
just
monkey
-
patch
out
the
static
r
r
}
r
(
hZXE
is
written
in
C
and
so
I
couldn
'
t
just
monkey
-
patch
out
the
static
r
h
\
j
ubj
<
)
r
}
r
(
hZX
date
.
today
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
date
.
todayr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
method
.
r
r
}
r
(
hZX
method
.
r
h
\
j
ubeubh
)
r
}
r
(
hZX
I
found
a
simple
way
of
doing
this
that
involved
effectively
wrapping
the
date
class
with
a
mock
but
passing
through
calls
to
the
constructor
to
the
real
class
(
and
returning
real
instances
)
.
r
h
\
jw
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqK
hrh
hU
]
r
h
X
I
found
a
simple
way
of
doing
this
that
involved
effectively
wrapping
the
date
class
with
a
mock
but
passing
through
calls
to
the
constructor
to
the
real
class
(
and
returning
real
instances
)
.
r
r
}
r
(
hZj
h
\
j
ubaubh
)
r
}
r
(
hZX
=
The
:
func
:
patch
decorator
<
patch
>
is
used
here
to
mock
out
the
date
class
in
the
module
under
test
.
The
:
attr
:
side_effect
attribute
on
the
mock
date
class
is
then
set
to
a
lambda
function
that
returns
a
real
date
.
When
the
mock
date
class
is
called
a
real
date
will
be
constructed
and
returned
by
side_effect
.
r
h
\
jw
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqK
hrh
hU
]
r
(
h
X
The
r
r
}
r
(
hZX
The
r
h
\
j
ubh
)
r
}
r
(
hZX
:
func
:
patch
decorator
<
patch
>
r
h
\
j
h
]
h
hbh
hd
}
r
(
U
reftyper
X
funcr
h
h
X
patchr
U
refdomainr
X
pyr
hf
]
r
hh
]
r
U
refexplicitr
hj
]
r
hl
]
r
hn
]
r
h
h
j
%
Nj
&
j
'
uhqK
hU
]
r
j
)
)
r
}
r
(
hZj
hd
}
r
(
hj
]
r
hl
]
r
(
h
j
X
py
-
funcr
ehh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
patch
decoratorr
r
}
r
(
hZU
h
\
j
ubahbj7
ubaubh
X
is
used
here
to
mock
out
the
r
r
}
r
(
hZX
is
used
here
to
mock
out
the
r
h
\
j
ubj
<
)
r
}
r
(
hZX
date
r
hd
}
r
(
hj
]
r
hl
]
r
!
hh
]
r
"
hf
]
r
#
hn
]
r
uh
\
j
hU
]
r
%
h
X
dater
&
r
'
}
r
(
(
hZU
h
\
j
ubahbjJ
ubh
X
%
class
in
the
module
under
test
.
The
r
)
r
*
}
r
+
(
hZX
%
class
in
the
module
under
test
.
The
r
h
\
j
ubh
)
r
-
}
r
.
(
hZX
:
attr
:
side_effect
r
/
h
\
j
h
]
h
hbh
hd
}
r0
(
U
reftyper1
X
attrr2
h
h
X
side_effectr3
U
refdomainr4
X
pyr5
hf
]
r6
hh
]
r7
U
refexplicitr8
hj
]
r9
hl
]
r
:
hn
]
r
;
h
h
j
%
Nj
&
j
'
uhqK
hU
]
r
<
j
)
)
r
=
}
r
>
(
hZj
/
hd
}
r
?
(
hj
]
r
hl
]
rA
(
h
j5
X
py
-
attrrB
ehh
]
rC
hf
]
rD
hn
]
rE
uh
\
j
-
hU
]
rF
h
X
side_effectrG
rH
}
rI
(
hZU
h
\
j
=
ubahbj7
ubaubh
X
attribute
on
the
mock
date
class
is
then
set
to
a
lambda
function
that
returns
a
real
date
.
When
the
mock
date
class
is
called
a
real
date
will
be
constructed
and
returned
by
rJ
rK
}
rL
(
hZX
attribute
on
the
mock
date
class
is
then
set
to
a
lambda
function
that
returns
a
real
date
.
When
the
mock
date
class
is
called
a
real
date
will
be
constructed
and
returned
by
rM
h
\
j
ubj
<
)
rN
}
rO
(
hZX
side_effect
rP
hd
}
rQ
(
hj
]
rR
hl
]
rS
hh
]
rT
hf
]
rU
hn
]
rV
uh
\
j
hU
]
rW
h
X
side_effectrX
rY
}
rZ
(
hZU
h
\
jN
ubahbjJ
ubh
X
.
r
[
}
r
\
(
hZX
.
h
\
j
ubeubj
)
r
]
}
r
^
(
hZXI
>
>
>
from
datetime
import
date
>
>
>
with
patch
(
'
mymodule
.
date
'
)
as
mock_date
:
.
.
.
mock_date
.
today
.
return_value
=
date
(
2010
10
8
)
.
.
.
mock_date
.
side_effect
=
lambda
*
args
*
*
kw
:
date
(
*
args
*
*
kw
)
.
.
.
.
.
.
assert
mymodule
.
date
.
today
(
)
=
=
date
(
2010
10
8
)
.
.
.
assert
mymodule
.
date
(
2009
6
8
)
=
=
date
(
2009
6
8
)
.
.
.
r_
h
\
jw
h
]
h
hbj
hd
}
r
(
U
testnodetypera
X
doctestrb
h
h
hf
]
rc
hh
]
rd
hj
]
re
hl
]
rf
hn
]
rg
U
groupsrh
]
ri
h
ah
}
rj
uhqK
hrh
hU
]
rk
h
XI
>
>
>
from
datetime
import
date
>
>
>
with
patch
(
'
mymodule
.
date
'
)
as
mock_date
:
.
.
.
mock_date
.
today
.
return_value
=
date
(
2010
10
8
)
.
.
.
mock_date
.
side_effect
=
lambda
*
args
*
*
kw
:
date
(
*
args
*
*
kw
)
.
.
.
.
.
.
assert
mymodule
.
date
.
today
(
)
=
=
date
(
2010
10
8
)
.
.
.
assert
mymodule
.
date
(
2009
6
8
)
=
=
date
(
2009
6
8
)
.
.
.
rl
rm
}
rn
(
hZU
h
\
j
]
ubaubh
)
ro
}
rp
(
hZX
Note
that
we
don
'
t
patch
datetime
.
date
globally
we
patch
date
in
the
module
that
*
uses
*
it
.
See
:
ref
:
where
to
patch
<
where
-
to
-
patch
>
.
rq
h
\
jw
h
]
h
hbh
hd
}
rr
(
hj
]
rs
hl
]
rt
hh
]
ru
hf
]
rv
hn
]
rw
uhqK
hrh
hU
]
rx
(
h
X
Note
that
we
don
'
t
patch
ry
rz
}
r
{
(
hZX
Note
that
we
don
'
t
patch
r
|
h
\
jo
ubj
<
)
r
}
}
r
~
(
hZX
datetime
.
date
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
jo
hU
]
r
h
X
datetime
.
dater
r
}
r
(
hZU
h
\
j
}
ubahbjJ
ubh
X
globally
we
patch
r
r
}
r
(
hZX
globally
we
patch
r
h
\
jo
ubj
<
)
r
}
r
(
hZX
date
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
jo
hU
]
r
h
X
dater
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
in
the
module
that
r
r
}
r
(
hZX
in
the
module
that
r
h
\
jo
ubh
)
r
}
r
(
hZX
*
uses
*
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
jo
hU
]
r
h
X
usesr
r
}
r
(
hZU
h
\
j
ubahbh
ubh
X
it
.
See
r
r
}
r
(
hZX
it
.
See
r
h
\
jo
ubh
)
r
}
r
(
hZX
&
:
ref
:
where
to
patch
<
where
-
to
-
patch
>
r
h
\
jo
h
]
h
hbh
hd
}
r
(
U
reftyper
X
refr
h
h
X
where
-
to
-
patchr
U
refdomainr
X
stdr
hf
]
r
hh
]
r
U
refexplicitr
hj
]
r
hl
]
r
hn
]
r
h
h
uhqK
hU
]
r
h
)
r
}
r
(
hZj
hd
}
r
(
hj
]
r
hl
]
r
(
h
j
X
std
-
refr
ehh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
where
to
patchr
r
}
r
(
hZU
h
\
j
ubahbh
ubaubh
X
.
r
}
r
(
hZX
.
h
\
jo
ubeubh
)
r
}
r
(
hZX
'
When
date
.
today
(
)
is
called
a
known
date
is
returned
but
calls
to
the
date
(
.
.
.
)
constructor
still
return
normal
dates
.
Without
this
you
can
find
yourself
having
to
calculate
an
expected
result
using
exactly
the
same
algorithm
as
the
code
under
test
which
is
a
classic
testing
anti
-
pattern
.
r
h
\
jw
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqK
hrh
hU
]
r
(
h
X
When
r
r
}
r
(
hZX
When
r
h
\
j
ubj
<
)
r
}
r
(
hZX
date
.
today
(
)
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
date
.
today
(
)
r
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X6
is
called
a
known
date
is
returned
but
calls
to
the
r
r
}
r
(
hZX6
is
called
a
known
date
is
returned
but
calls
to
the
r
h
\
j
ubj
<
)
r
}
r
(
hZX
date
(
.
.
.
)
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
date
(
.
.
.
)
r
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
constructor
still
return
normal
dates
.
Without
this
you
can
find
yourself
having
to
calculate
an
expected
result
using
exactly
the
same
algorithm
as
the
code
under
test
which
is
a
classic
testing
anti
-
pattern
.
r
r
}
r
(
hZX
constructor
still
return
normal
dates
.
Without
this
you
can
find
yourself
having
to
calculate
an
expected
result
using
exactly
the
same
algorithm
as
the
code
under
test
which
is
a
classic
testing
anti
-
pattern
.
r
h
\
j
ubeubh
)
r
}
r
(
hZX
Calls
to
the
date
constructor
are
recorded
in
the
mock_date
attributes
(
call_count
and
friends
)
which
may
also
be
useful
for
your
tests
.
r
h
\
jw
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqK
hrh
hU
]
r
(
h
X2
Calls
to
the
date
constructor
are
recorded
in
the
r
r
}
r
(
hZX2
Calls
to
the
date
constructor
are
recorded
in
the
r
h
\
j
ubj
<
)
r
}
r
(
hZX
mock_date
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
mock_dater
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
attributes
(
r
r
}
r
(
hZX
attributes
(
r
h
\
j
ubj
<
)
r
}
r
(
hZX
call_count
r
hd
}
r
!
(
hj
]
r
"
hl
]
r
#
hh
]
r
hf
]
r
%
hn
]
r
&
uh
\
j
hU
]
r
'
h
X
call_countr
(
r
)
}
r
*
(
hZU
h
\
j
ubahbjJ
ubh
X6
and
friends
)
which
may
also
be
useful
for
your
tests
.
r
+
r
}
r
-
(
hZX6
and
friends
)
which
may
also
be
useful
for
your
tests
.
r
.
h
\
j
ubeubh
)
r
/
}
r0
(
hZX
An
alternative
way
of
dealing
with
mocking
dates
or
other
builtin
classes
is
discussed
in
this
blog
entry
<
http
:
/
/
williamjohnbert
.
com
/
2011
/
07
/
how
-
to
-
unit
-
testing
-
in
-
django
-
with
-
mocking
-
and
-
patching
/
>
_
.
r1
h
\
jw
h
]
h
hbh
hd
}
r2
(
hj
]
r3
hl
]
r4
hh
]
r5
hf
]
r6
hn
]
r7
uhqK
hrh
hU
]
r8
(
h
X
\
An
alternative
way
of
dealing
with
mocking
dates
or
other
builtin
classes
is
discussed
in
r9
r
:
}
r
;
(
hZX
\
An
alternative
way
of
dealing
with
mocking
dates
or
other
builtin
classes
is
discussed
in
r
<
h
\
j
/
ubj
)
r
=
}
r
>
(
hZXp
this
blog
entry
<
http
:
/
/
williamjohnbert
.
com
/
2011
/
07
/
how
-
to
-
unit
-
testing
-
in
-
django
-
with
-
mocking
-
and
-
patching
/
>
_r
?
hd
}
r
(
U
namerA
X
this
blog
entryrB
j
X
[
http
:
/
/
williamjohnbert
.
com
/
2011
/
07
/
how
-
to
-
unit
-
testing
-
in
-
django
-
with
-
mocking
-
and
-
patching
/
rC
hf
]
rD
hh
]
rE
hj
]
rF
hl
]
rG
hn
]
rH
uh
\
j
/
hU
]
rI
h
X
this
blog
entryrJ
rK
}
rL
(
hZU
h
\
j
=
ubahbj
ubhW
)
rM
}
rN
(
hZX
^
<
http
:
/
/
williamjohnbert
.
com
/
2011
/
07
/
how
-
to
-
unit
-
testing
-
in
-
django
-
with
-
mocking
-
and
-
patching
/
>
rO
j
K
h
\
j
/
hbhchd
}
rP
(
U
refurirQ
jC
hf
]
rR
hAahh
]
rS
hj
]
rT
hl
]
rU
hn
]
rV
h
auhU
]
rW
ubh
X
.
rX
}
rY
(
hZX
.
h
\
j
/
ubeubeubht
)
rZ
}
r
[
(
hZU
h
\
huh
]
h
hbhyhd
}
r
\
(
hj
]
r
]
hl
]
r
^
hh
]
r_
hf
]
r
h1ahn
]
ra
h
auhqK
hrh
hU
]
rb
(
h
)
rc
}
rd
(
hZX
Mocking
a
Generator
Methodre
h
\
jZ
h
]
h
hbh
hd
}
rf
(
hj
]
rg
hl
]
rh
hh
]
ri
hf
]
rj
hn
]
rk
uhqK
hrh
hU
]
rl
h
X
Mocking
a
Generator
Methodrm
rn
}
ro
(
hZje
h
\
jc
ubaubh
)
rp
}
rq
(
hZX
A
Python
generator
is
a
function
or
method
that
uses
the
yield
statement
<
http
:
/
/
docs
.
python
.
org
/
reference
/
simple_stmts
.
html
#
the
-
yield
-
statement
>
_
to
return
a
series
of
values
when
iterated
over
[
#
]
_
.
rr
h
\
jZ
h
]
h
hbh
hd
}
rs
(
hj
]
rt
hl
]
ru
hh
]
rv
hf
]
rw
hn
]
rx
uhqK
hrh
hU
]
ry
(
h
X9
A
Python
generator
is
a
function
or
method
that
uses
the
rz
r
{
}
r
|
(
hZX9
A
Python
generator
is
a
function
or
method
that
uses
the
r
}
h
\
jp
ubj
)
r
~
}
r
(
hZX
[
yield
statement
<
http
:
/
/
docs
.
python
.
org
/
reference
/
simple_stmts
.
html
#
the
-
yield
-
statement
>
_r
hd
}
r
(
U
namer
X
yield
statementr
j
XF
http
:
/
/
docs
.
python
.
org
/
reference
/
simple_stmts
.
html
#
the
-
yield
-
statementr
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
uh
\
jp
hU
]
r
h
X
yield
statementr
r
}
r
(
hZU
h
\
j
~
ubahbj
ubhW
)
r
}
r
(
hZXI
<
http
:
/
/
docs
.
python
.
org
/
reference
/
simple_stmts
.
html
#
the
-
yield
-
statement
>
r
j
K
h
\
jp
hbhchd
}
r
(
U
refurir
j
hf
]
r
h7ahh
]
r
hj
]
r
hl
]
r
hn
]
r
h
auhU
]
r
ubh
X1
to
return
a
series
of
values
when
iterated
over
r
r
}
r
(
hZX1
to
return
a
series
of
values
when
iterated
over
r
h
\
jp
ubcdocutils
.
nodes
footnote_reference
r
)
r
}
r
(
hZX
[
#
]
_r
U
resolvedr
K
h
\
jp
hbU
footnote_referencer
hd
}
r
(
U
autor
K
hf
]
r
U
id2r
ahh
]
r
hj
]
r
hl
]
r
hn
]
r
hph
:
uhU
]
r
h
X
1
r
}
r
(
hZU
h
\
j
ubaubh
X
.
r
}
r
(
hZX
.
h
\
jp
ubeubh
)
r
}
r
(
hZX
A
generator
method
/
function
is
called
to
return
the
generator
object
.
It
is
the
generator
object
that
is
then
iterated
over
.
The
protocol
method
for
iteration
is
__iter__
<
http
:
/
/
docs
.
python
.
org
/
library
/
stdtypes
.
html
#
container
.
__iter__
>
_
so
we
can
mock
this
using
a
MagicMock
.
r
h
\
jZ
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqK
hrh
hU
]
r
(
h
X
A
generator
method
/
function
is
called
to
return
the
generator
object
.
It
is
the
generator
object
that
is
then
iterated
over
.
The
protocol
method
for
iteration
is
r
r
}
r
(
hZX
A
generator
method
/
function
is
called
to
return
the
generator
object
.
It
is
the
generator
object
that
is
then
iterated
over
.
The
protocol
method
for
iteration
is
r
h
\
j
ubj
)
r
}
r
(
hZXM
__iter__
<
http
:
/
/
docs
.
python
.
org
/
library
/
stdtypes
.
html
#
container
.
__iter__
>
_r
hd
}
r
(
U
namer
X
__iter__r
j
X
?
http
:
/
/
docs
.
python
.
org
/
library
/
stdtypes
.
html
#
container
.
__iter__r
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
__iter__r
r
}
r
(
hZU
h
\
j
ubahbj
ubhW
)
r
}
r
(
hZXB
<
http
:
/
/
docs
.
python
.
org
/
library
/
stdtypes
.
html
#
container
.
__iter__
>
r
j
K
h
\
j
hbhchd
}
r
(
U
refurir
j
hf
]
r
hFahh
]
r
hj
]
r
hl
]
r
hn
]
r
h
auhU
]
r
ubh
X
so
we
can
mock
this
using
a
r
r
}
r
(
hZX
so
we
can
mock
this
using
a
r
h
\
j
ubj
<
)
r
}
r
(
hZX
MagicMock
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
MagicMockr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
.
r
}
r
(
hZX
.
h
\
j
ubeubh
)
r
}
r
(
hZXI
Here
'
s
an
example
class
with
an
"
iter
"
method
implemented
as
a
generator
:
r
h
\
jZ
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqK
hrh
hU
]
r
h
XI
Here
'
s
an
example
class
with
an
"
iter
"
method
implemented
as
a
generator
:
r
r
}
r
(
hZj
h
\
j
ubaubj
)
r
}
r
(
hZX
>
>
>
class
Foo
(
object
)
:
.
.
.
def
iter
(
self
)
:
.
.
.
for
i
in
[
1
2
3
]
:
.
.
.
yield
i
.
.
.
>
>
>
foo
=
Foo
(
)
>
>
>
list
(
foo
.
iter
(
)
)
[
1
2
3
]
r
h
\
jZ
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqK
hrh
hU
]
r
h
X
>
>
>
class
Foo
(
object
)
:
.
.
.
def
iter
(
self
)
:
.
.
.
for
i
in
[
1
2
3
]
:
.
.
.
yield
i
.
.
.
>
>
>
foo
=
Foo
(
)
>
>
>
list
(
foo
.
iter
(
)
)
[
1
2
3
]
r
r
}
r
(
hZU
h
\
j
ubaubh
)
r
}
r
(
hZXB
How
would
we
mock
this
class
and
in
particular
its
"
iter
"
method
?
r
h
\
jZ
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqK
hrh
hU
]
r
h
XB
How
would
we
mock
this
class
and
in
particular
its
"
iter
"
method
?
r
r
}
r
(
hZj
h
\
j
ubaubh
)
r
}
r
(
hZX
To
configure
the
values
returned
from
the
iteration
(
implicit
in
the
call
to
list
)
we
need
to
configure
the
object
returned
by
the
call
to
foo
.
iter
(
)
.
r
h
\
jZ
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqK
hrh
hU
]
r
!
(
h
XM
To
configure
the
values
returned
from
the
iteration
(
implicit
in
the
call
to
r
"
r
#
}
r
(
hZXM
To
configure
the
values
returned
from
the
iteration
(
implicit
in
the
call
to
r
%
h
\
j
ubj
<
)
r
&
}
r
'
(
hZX
list
r
(
hd
}
r
)
(
hj
]
r
*
hl
]
r
+
hh
]
r
hf
]
r
-
hn
]
r
.
uh
\
j
hU
]
r
/
h
X
listr0
r1
}
r2
(
hZU
h
\
j
&
ubahbjJ
ubh
X
;
)
we
need
to
configure
the
object
returned
by
the
call
to
r3
r4
}
r5
(
hZX
;
)
we
need
to
configure
the
object
returned
by
the
call
to
r6
h
\
j
ubj
<
)
r7
}
r8
(
hZX
foo
.
iter
(
)
r9
hd
}
r
:
(
hj
]
r
;
hl
]
r
<
hh
]
r
=
hf
]
r
>
hn
]
r
?
uh
\
j
hU
]
r
h
X
foo
.
iter
(
)
rA
rB
}
rC
(
hZU
h
\
j7
ubahbjJ
ubh
X
.
rD
}
rE
(
hZX
.
h
\
j
ubeubj
)
rF
}
rG
(
hZXo
>
>
>
mock_foo
=
MagicMock
(
)
>
>
>
mock_foo
.
iter
.
return_value
=
iter
(
[
1
2
3
]
)
>
>
>
list
(
mock_foo
.
iter
(
)
)
[
1
2
3
]
rH
h
\
jZ
h
]
h
hbj
hd
}
rI
(
U
testnodetyperJ
X
doctestrK
h
h
hf
]
rL
hh
]
rM
hj
]
rN
hl
]
rO
hn
]
rP
U
groupsrQ
]
rR
h
ah
}
rS
uhqK
hrh
hU
]
rT
h
Xo
>
>
>
mock_foo
=
MagicMock
(
)
>
>
>
mock_foo
.
iter
.
return_value
=
iter
(
[
1
2
3
]
)
>
>
>
list
(
mock_foo
.
iter
(
)
)
[
1
2
3
]
rU
rV
}
rW
(
hZU
h
\
jF
ubaubcdocutils
.
nodes
footnote
rX
)
rY
}
rZ
(
hZX
<
There
are
also
generator
expressions
and
more
advanced
uses
<
http
:
/
/
www
.
dabeaz
.
com
/
coroutines
/
index
.
html
>
_
of
generators
but
we
aren
'
t
concerned
about
them
here
.
A
very
good
introduction
to
generators
and
how
powerful
they
are
is
:
Generator
Tricks
for
Systems
Programmers
<
http
:
/
/
www
.
dabeaz
.
com
/
generators
/
>
_
.
r
[
h
\
jZ
h
]
h
hbU
footnoter
\
hd
}
r
]
(
j
K
hf
]
r
^
h
:
ahh
]
r_
j
ahj
]
r
hl
]
ra
hn
]
rb
U
1auhqK
hrh
hU
]
rc
(
cdocutils
.
nodes
label
rd
)
re
}
rf
(
hZU
h
\
jY
h
]
NhbU
labelrg
hd
}
rh
(
hj
]
ri
hl
]
rj
hh
]
rk
hf
]
rl
hn
]
rm
uhqNhrh
hU
]
rn
h
X
1
ro
}
rp
(
hZU
h
\
je
ubaubh
)
rq
}
rr
(
hZX
:
There
are
also
generator
expressions
and
more
advanced
uses
<
http
:
/
/
www
.
dabeaz
.
com
/
coroutines
/
index
.
html
>
_
of
generators
but
we
aren
'
t
concerned
about
them
here
.
A
very
good
introduction
to
generators
and
how
powerful
they
are
is
:
Generator
Tricks
for
Systems
Programmers
<
http
:
/
/
www
.
dabeaz
.
com
/
generators
/
>
_
.
rs
h
\
jY
h
]
h
hbh
hd
}
rt
(
hj
]
ru
hl
]
rv
hh
]
rw
hf
]
rx
hn
]
ry
uhqK
hU
]
rz
(
h
X
.
There
are
also
generator
expressions
and
more
r
{
r
|
}
r
}
(
hZX
.
There
are
also
generator
expressions
and
more
r
~
h
\
jq
ubj
)
r
}
r
(
hZX
>
advanced
uses
<
http
:
/
/
www
.
dabeaz
.
com
/
coroutines
/
index
.
html
>
_r
hd
}
r
(
U
namer
X
advanced
usesr
j
X
+
http
:
/
/
www
.
dabeaz
.
com
/
coroutines
/
index
.
htmlr
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
uh
\
jq
hU
]
r
h
X
advanced
usesr
r
}
r
(
hZU
h
\
j
ubahbj
ubhW
)
r
}
r
(
hZX
.
<
http
:
/
/
www
.
dabeaz
.
com
/
coroutines
/
index
.
html
>
r
j
K
h
\
jq
hbhchd
}
r
(
U
refurir
j
hf
]
r
hDahh
]
r
hj
]
r
hl
]
r
hn
]
r
h
auhU
]
r
ubh
X
~
of
generators
but
we
aren
'
t
concerned
about
them
here
.
A
very
good
introduction
to
generators
and
how
powerful
they
are
is
:
r
r
}
r
(
hZX
~
of
generators
but
we
aren
'
t
concerned
about
them
here
.
A
very
good
introduction
to
generators
and
how
powerful
they
are
is
:
r
h
\
jq
ubj
)
r
}
r
(
hZXO
Generator
Tricks
for
Systems
Programmers
<
http
:
/
/
www
.
dabeaz
.
com
/
generators
/
>
_r
hd
}
r
(
U
namer
X
(
Generator
Tricks
for
Systems
Programmersr
j
X
!
http
:
/
/
www
.
dabeaz
.
com
/
generators
/
r
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
uh
\
jq
hU
]
r
h
X
(
Generator
Tricks
for
Systems
Programmersr
r
}
r
(
hZU
h
\
j
ubahbj
ubhW
)
r
}
r
(
hZX
<
http
:
/
/
www
.
dabeaz
.
com
/
generators
/
>
r
j
K
h
\
jq
hbhchd
}
r
(
U
refurir
j
hf
]
r
hLahh
]
r
hj
]
r
hl
]
r
hn
]
r
h
auhU
]
r
ubh
X
.
r
}
r
(
hZX
.
h
\
jq
ubeubeubeubht
)
r
}
r
(
hZU
h
\
huh
]
h
hbhyhd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hPahn
]
r
h
#
auhqK
hrh
hU
]
r
(
h
)
r
}
r
(
hZX
Applying
the
same
patch
to
every
test
methodr
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqK
hrh
hU
]
r
h
X
Applying
the
same
patch
to
every
test
methodr
r
}
r
(
hZj
h
\
j
ubaubh
)
r
}
r
(
hZX
If
you
want
several
patches
in
place
for
multiple
test
methods
the
obvious
way
is
to
apply
the
patch
decorators
to
every
method
.
This
can
feel
like
unnecessary
repetition
.
For
Python
2
.
6
or
more
recent
you
can
use
patch
(
in
all
its
various
forms
)
as
a
class
decorator
.
This
applies
the
patches
to
all
test
methods
on
the
class
.
A
test
method
is
identified
by
methods
whose
names
start
with
test
:
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqK
hrh
hU
]
r
(
h
X
If
you
want
several
patches
in
place
for
multiple
test
methods
the
obvious
way
is
to
apply
the
patch
decorators
to
every
method
.
This
can
feel
like
unnecessary
repetition
.
For
Python
2
.
6
or
more
recent
you
can
use
r
r
}
r
(
hZX
If
you
want
several
patches
in
place
for
multiple
test
methods
the
obvious
way
is
to
apply
the
patch
decorators
to
every
method
.
This
can
feel
like
unnecessary
repetition
.
For
Python
2
.
6
or
more
recent
you
can
use
r
h
\
j
ubj
<
)
r
}
r
(
hZX
patch
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
patchr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
(
in
all
its
various
forms
)
as
a
class
decorator
.
This
applies
the
patches
to
all
test
methods
on
the
class
.
A
test
method
is
identified
by
methods
whose
names
start
with
r
r
}
r
(
hZX
(
in
all
its
various
forms
)
as
a
class
decorator
.
This
applies
the
patches
to
all
test
methods
on
the
class
.
A
test
method
is
identified
by
methods
whose
names
start
with
r
h
\
j
ubj
<
)
r
}
r
(
hZX
test
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
testr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
:
r
}
r
(
hZX
:
h
\
j
ubeubj
)
r
}
r
(
hZX
>
>
>
patch
(
'
mymodule
.
SomeClass
'
)
.
.
.
class
MyTest
(
TestCase
)
:
.
.
.
.
.
.
def
test_one
(
self
MockSomeClass
)
:
.
.
.
self
.
assertTrue
(
mymodule
.
SomeClass
is
MockSomeClass
)
.
.
.
.
.
.
def
test_two
(
self
MockSomeClass
)
:
.
.
.
self
.
assertTrue
(
mymodule
.
SomeClass
is
MockSomeClass
)
.
.
.
.
.
.
def
not_a_test
(
self
)
:
.
.
.
return
'
something
'
.
.
.
>
>
>
MyTest
(
'
test_one
'
)
.
test_one
(
)
>
>
>
MyTest
(
'
test_two
'
)
.
test_two
(
)
>
>
>
MyTest
(
'
test_two
'
)
.
not_a_test
(
)
'
something
'
r
h
\
j
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqK
hrh
hU
]
r
h
X
>
>
>
patch
(
'
mymodule
.
SomeClass
'
)
.
.
.
class
MyTest
(
TestCase
)
:
.
.
.
.
.
.
def
test_one
(
self
MockSomeClass
)
:
.
.
.
self
.
assertTrue
(
mymodule
.
SomeClass
is
MockSomeClass
)
.
.
.
.
.
.
def
test_two
(
self
MockSomeClass
)
:
.
.
.
self
.
assertTrue
(
mymodule
.
SomeClass
is
MockSomeClass
)
.
.
.
.
.
.
def
not_a_test
(
self
)
:
.
.
.
return
'
something
'
.
.
.
>
>
>
MyTest
(
'
test_one
'
)
.
test_one
(
)
>
>
>
MyTest
(
'
test_two
'
)
.
test_two
(
)
>
>
>
MyTest
(
'
test_two
'
)
.
not_a_test
(
)
'
something
'
r
r
}
r
(
hZU
h
\
j
ubaubh
)
r
}
r
(
hZX
An
alternative
way
of
managing
patches
is
to
use
the
:
ref
:
start
-
and
-
stop
.
These
allow
you
to
move
the
patching
into
your
setUp
and
tearDown
methods
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqK
hrh
hU
]
r
(
h
X5
An
alternative
way
of
managing
patches
is
to
use
the
r
r
}
r
(
hZX5
An
alternative
way
of
managing
patches
is
to
use
the
r
h
\
j
ubh
)
r
}
r
(
hZX
:
ref
:
start
-
and
-
stop
r
!
h
\
j
h
]
h
hbh
hd
}
r
"
(
U
reftyper
#
X
refr
h
h
X
start
-
and
-
stopr
%
U
refdomainr
&
X
stdr
'
hf
]
r
(
hh
]
r
)
U
refexplicitr
*
hj
]
r
+
hl
]
r
hn
]
r
-
h
h
uhqK
hU
]
r
.
h
)
r
/
}
r0
(
hZj
!
hd
}
r1
(
hj
]
r2
hl
]
r3
(
h
j
'
X
std
-
refr4
ehh
]
r5
hf
]
r6
hn
]
r7
uh
\
j
hU
]
r8
h
X
start
-
and
-
stopr9
r
:
}
r
;
(
hZU
h
\
j
/
ubahbh
ubaubh
X1
.
These
allow
you
to
move
the
patching
into
your
r
<
r
=
}
r
>
(
hZX1
.
These
allow
you
to
move
the
patching
into
your
r
?
h
\
j
ubj
<
)
r
}
rA
(
hZX
setUp
rB
hd
}
rC
(
hj
]
rD
hl
]
rE
hh
]
rF
hf
]
rG
hn
]
rH
uh
\
j
hU
]
rI
h
X
setUprJ
rK
}
rL
(
hZU
h
\
j
ubahbjJ
ubh
X
and
rM
rN
}
rO
(
hZX
and
rP
h
\
j
ubj
<
)
rQ
}
rR
(
hZX
tearDown
rS
hd
}
rT
(
hj
]
rU
hl
]
rV
hh
]
rW
hf
]
rX
hn
]
rY
uh
\
j
hU
]
rZ
h
X
tearDownr
[
r
\
}
r
]
(
hZU
h
\
jQ
ubahbjJ
ubh
X
methods
.
r
^
r_
}
r
(
hZX
methods
.
ra
h
\
j
ubeubj
)
rb
}
rc
(
hZXR
>
>
>
class
MyTest
(
TestCase
)
:
.
.
.
def
setUp
(
self
)
:
.
.
.
self
.
patcher
=
patch
(
'
mymodule
.
foo
'
)
.
.
.
self
.
mock_foo
=
self
.
patcher
.
start
(
)
.
.
.
.
.
.
def
test_foo
(
self
)
:
.
.
.
self
.
assertTrue
(
mymodule
.
foo
is
self
.
mock_foo
)
.
.
.
.
.
.
def
tearDown
(
self
)
:
.
.
.
self
.
patcher
.
stop
(
)
.
.
.
>
>
>
MyTest
(
'
test_foo
'
)
.
run
(
)
rd
h
\
j
h
]
h
hbj
hd
}
re
(
U
testnodetyperf
X
doctestrg
h
h
hf
]
rh
hh
]
ri
hj
]
rj
hl
]
rk
hn
]
rl
U
groupsrm
]
rn
h
ah
}
ro
uhqK
hrh
hU
]
rp
h
XR
>
>
>
class
MyTest
(
TestCase
)
:
.
.
.
def
setUp
(
self
)
:
.
.
.
self
.
patcher
=
patch
(
'
mymodule
.
foo
'
)
.
.
.
self
.
mock_foo
=
self
.
patcher
.
start
(
)
.
.
.
.
.
.
def
test_foo
(
self
)
:
.
.
.
self
.
assertTrue
(
mymodule
.
foo
is
self
.
mock_foo
)
.
.
.
.
.
.
def
tearDown
(
self
)
:
.
.
.
self
.
patcher
.
stop
(
)
.
.
.
>
>
>
MyTest
(
'
test_foo
'
)
.
run
(
)
rq
rr
}
rs
(
hZU
h
\
jb
ubaubh
)
rt
}
ru
(
hZX
+
If
you
use
this
technique
you
must
ensure
that
the
patching
is
"
undone
"
by
calling
stop
.
This
can
be
fiddlier
than
you
might
think
because
if
an
exception
is
raised
in
the
setUp
then
tearDown
is
not
called
.
unittest2
<
http
:
/
/
pypi
.
python
.
org
/
pypi
/
unittest2
>
_
cleanup
functions
make
this
simpler
:
rv
h
\
j
h
]
h
hbh
hd
}
rw
(
hj
]
rx
hl
]
ry
hh
]
rz
hf
]
r
{
hn
]
r
|
uhqM
hrh
hU
]
r
}
(
h
XS
If
you
use
this
technique
you
must
ensure
that
the
patching
is
"
undone
"
by
calling
r
~
r
}
r
(
hZXS
If
you
use
this
technique
you
must
ensure
that
the
patching
is
"
undone
"
by
calling
r
h
\
jt
ubj
<
)
r
}
r
(
hZX
stop
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
jt
hU
]
r
h
X
stopr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
Xy
.
This
can
be
fiddlier
than
you
might
think
because
if
an
exception
is
raised
in
the
setUp
then
tearDown
is
not
called
.
r
r
}
r
(
hZXy
.
This
can
be
fiddlier
than
you
might
think
because
if
an
exception
is
raised
in
the
setUp
then
tearDown
is
not
called
.
r
h
\
jt
ubj
)
r
}
r
(
hZX4
unittest2
<
http
:
/
/
pypi
.
python
.
org
/
pypi
/
unittest2
>
_r
hd
}
r
(
U
namer
X
unittest2r
j
X
%
http
:
/
/
pypi
.
python
.
org
/
pypi
/
unittest2r
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
uh
\
jt
hU
]
r
h
X
unittest2r
r
}
r
(
hZU
h
\
j
ubahbj
ubhW
)
r
}
r
(
hZX
(
<
http
:
/
/
pypi
.
python
.
org
/
pypi
/
unittest2
>
r
j
K
h
\
jt
hbhchd
}
r
(
U
refurir
j
hf
]
r
h
ahh
]
r
hj
]
r
hl
]
r
hn
]
r
h
auhU
]
r
ubh
X
%
cleanup
functions
make
this
simpler
:
r
r
}
r
(
hZX
%
cleanup
functions
make
this
simpler
:
r
h
\
jt
ubeubj
)
r
}
r
(
hZX2
>
>
>
class
MyTest
(
TestCase
)
:
.
.
.
def
setUp
(
self
)
:
.
.
.
patcher
=
patch
(
'
mymodule
.
foo
'
)
.
.
.
self
.
addCleanup
(
patcher
.
stop
)
.
.
.
self
.
mock_foo
=
patcher
.
start
(
)
.
.
.
.
.
.
def
test_foo
(
self
)
:
.
.
.
self
.
assertTrue
(
mymodule
.
foo
is
self
.
mock_foo
)
.
.
.
>
>
>
MyTest
(
'
test_foo
'
)
.
run
(
)
r
h
\
j
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqM
hrh
hU
]
r
h
X2
>
>
>
class
MyTest
(
TestCase
)
:
.
.
.
def
setUp
(
self
)
:
.
.
.
patcher
=
patch
(
'
mymodule
.
foo
'
)
.
.
.
self
.
addCleanup
(
patcher
.
stop
)
.
.
.
self
.
mock_foo
=
patcher
.
start
(
)
.
.
.
.
.
.
def
test_foo
(
self
)
:
.
.
.
self
.
assertTrue
(
mymodule
.
foo
is
self
.
mock_foo
)
.
.
.
>
>
>
MyTest
(
'
test_foo
'
)
.
run
(
)
r
r
}
r
(
hZU
h
\
j
ubaubeubht
)
r
}
r
(
hZU
h
\
huh
]
h
hbhyhd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hEahn
]
r
h
auhqM
hrh
hU
]
r
(
h
)
r
}
r
(
hZX
Mocking
Unbound
Methodsr
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
h
X
Mocking
Unbound
Methodsr
r
}
r
(
hZj
h
\
j
ubaubh
)
r
}
r
(
hZX
Whilst
writing
tests
today
I
needed
to
patch
an
*
unbound
method
*
(
patching
the
method
on
the
class
rather
than
on
the
instance
)
.
I
needed
self
to
be
passed
in
as
the
first
argument
because
I
want
to
make
asserts
about
which
objects
were
calling
this
particular
method
.
The
issue
is
that
you
can
'
t
patch
with
a
mock
for
this
because
if
you
replace
an
unbound
method
with
a
mock
it
doesn
'
t
become
a
bound
method
when
fetched
from
the
instance
and
so
it
doesn
'
t
get
self
passed
in
.
The
workaround
is
to
patch
the
unbound
method
with
a
real
function
instead
.
The
:
func
:
patch
decorator
makes
it
so
simple
to
patch
out
methods
with
a
mock
that
having
to
create
a
real
function
becomes
a
nuisance
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
(
h
X0
Whilst
writing
tests
today
I
needed
to
patch
an
r
r
}
r
(
hZX0
Whilst
writing
tests
today
I
needed
to
patch
an
r
h
\
j
ubh
)
r
}
r
(
hZX
*
unbound
method
*
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
unbound
methodr
r
}
r
(
hZU
h
\
j
ubahbh
ubh
X
(
patching
the
method
on
the
class
rather
than
on
the
instance
)
.
I
needed
self
to
be
passed
in
as
the
first
argument
because
I
want
to
make
asserts
about
which
objects
were
calling
this
particular
method
.
The
issue
is
that
you
can
'
t
patch
with
a
mock
for
this
because
if
you
replace
an
unbound
method
with
a
mock
it
doesn
'
t
become
a
bound
method
when
fetched
from
the
instance
and
so
it
doesn
'
t
get
self
passed
in
.
The
workaround
is
to
patch
the
unbound
method
with
a
real
function
instead
.
The
r
r
}
r
(
hZX
(
patching
the
method
on
the
class
rather
than
on
the
instance
)
.
I
needed
self
to
be
passed
in
as
the
first
argument
because
I
want
to
make
asserts
about
which
objects
were
calling
this
particular
method
.
The
issue
is
that
you
can
'
t
patch
with
a
mock
for
this
because
if
you
replace
an
unbound
method
with
a
mock
it
doesn
'
t
become
a
bound
method
when
fetched
from
the
instance
and
so
it
doesn
'
t
get
self
passed
in
.
The
workaround
is
to
patch
the
unbound
method
with
a
real
function
instead
.
The
r
h
\
j
ubh
)
r
}
r
(
hZX
:
func
:
patch
r
h
\
j
h
]
h
hbh
hd
}
r
(
U
reftyper
X
funcr
h
h
X
patchr
U
refdomainr
X
pyr
hf
]
r
hh
]
r
U
refexplicitr
hj
]
r
hl
]
r
hn
]
r
h
h
j
%
Nj
&
j
'
uhqM
hU
]
r
j
)
)
r
}
r
(
hZj
hd
}
r
(
hj
]
r
hl
]
r
(
h
j
X
py
-
funcr
ehh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
patch
(
)
r
r
}
r
(
hZU
h
\
j
ubahbj7
ubaubh
Xx
decorator
makes
it
so
simple
to
patch
out
methods
with
a
mock
that
having
to
create
a
real
function
becomes
a
nuisance
.
r
r
}
r
(
hZXx
decorator
makes
it
so
simple
to
patch
out
methods
with
a
mock
that
having
to
create
a
real
function
becomes
a
nuisance
.
r
h
\
j
ubeubh
)
r
}
r
(
hZX
If
you
pass
autospec
=
True
to
patch
then
it
does
the
patching
with
a
*
real
*
function
object
.
This
function
object
has
the
same
signature
as
the
one
it
is
replacing
but
delegates
to
a
mock
under
the
hood
.
You
still
get
your
mock
auto
-
created
in
exactly
the
same
way
as
before
.
What
it
means
though
is
that
if
you
use
it
to
patch
out
an
unbound
method
on
a
class
the
mocked
function
will
be
turned
into
a
bound
method
if
it
is
fetched
from
an
instance
.
It
will
have
self
passed
in
as
the
first
argument
which
is
exactly
what
I
wanted
:
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
!
hn
]
r
"
uhqM
(
hrh
hU
]
r
#
(
h
X
If
you
pass
r
r
%
}
r
&
(
hZX
If
you
pass
r
'
h
\
j
ubj
<
)
r
(
}
r
)
(
hZX
autospec
=
True
r
*
hd
}
r
+
(
hj
]
r
hl
]
r
-
hh
]
r
.
hf
]
r
/
hn
]
r0
uh
\
j
hU
]
r1
h
X
autospec
=
Truer2
r3
}
r4
(
hZU
h
\
j
(
ubahbjJ
ubh
X
+
to
patch
then
it
does
the
patching
with
a
r5
r6
}
r7
(
hZX
+
to
patch
then
it
does
the
patching
with
a
r8
h
\
j
ubh
)
r9
}
r
:
(
hZX
*
real
*
r
;
hd
}
r
<
(
hj
]
r
=
hl
]
r
>
hh
]
r
?
hf
]
r
hn
]
rA
uh
\
j
hU
]
rB
h
X
realrC
rD
}
rE
(
hZU
h
\
j9
ubahbh
ubh
X
function
object
.
This
function
object
has
the
same
signature
as
the
one
it
is
replacing
but
delegates
to
a
mock
under
the
hood
.
You
still
get
your
mock
auto
-
created
in
exactly
the
same
way
as
before
.
What
it
means
though
is
that
if
you
use
it
to
patch
out
an
unbound
method
on
a
class
the
mocked
function
will
be
turned
into
a
bound
method
if
it
is
fetched
from
an
instance
.
It
will
have
rF
rG
}
rH
(
hZX
function
object
.
This
function
object
has
the
same
signature
as
the
one
it
is
replacing
but
delegates
to
a
mock
under
the
hood
.
You
still
get
your
mock
auto
-
created
in
exactly
the
same
way
as
before
.
What
it
means
though
is
that
if
you
use
it
to
patch
out
an
unbound
method
on
a
class
the
mocked
function
will
be
turned
into
a
bound
method
if
it
is
fetched
from
an
instance
.
It
will
have
rI
h
\
j
ubj
<
)
rJ
}
rK
(
hZX
self
rL
hd
}
rM
(
hj
]
rN
hl
]
rO
hh
]
rP
hf
]
rQ
hn
]
rR
uh
\
j
hU
]
rS
h
X
selfrT
rU
}
rV
(
hZU
h
\
jJ
ubahbjJ
ubh
XA
passed
in
as
the
first
argument
which
is
exactly
what
I
wanted
:
rW
rX
}
rY
(
hZXA
passed
in
as
the
first
argument
which
is
exactly
what
I
wanted
:
rZ
h
\
j
ubeubj
)
r
[
}
r
\
(
hZX
>
>
>
class
Foo
(
object
)
:
.
.
.
def
foo
(
self
)
:
.
.
.
pass
.
.
.
>
>
>
with
patch
.
object
(
Foo
'
foo
'
autospec
=
True
)
as
mock_foo
:
.
.
.
mock_foo
.
return_value
=
'
foo
'
.
.
.
foo
=
Foo
(
)
.
.
.
foo
.
foo
(
)
.
.
.
'
foo
'
>
>
>
mock_foo
.
assert_called_once_with
(
foo
)
r
]
h
\
j
h
]
h
hbj
hd
}
r
^
(
U
testnodetyper_
X
doctestr
h
h
hf
]
ra
hh
]
rb
hj
]
rc
hl
]
rd
hn
]
re
U
groupsrf
]
rg
h
ah
}
rh
uhqM1
hrh
hU
]
ri
h
X
>
>
>
class
Foo
(
object
)
:
.
.
.
def
foo
(
self
)
:
.
.
.
pass
.
.
.
>
>
>
with
patch
.
object
(
Foo
'
foo
'
autospec
=
True
)
as
mock_foo
:
.
.
.
mock_foo
.
return_value
=
'
foo
'
.
.
.
foo
=
Foo
(
)
.
.
.
foo
.
foo
(
)
.
.
.
'
foo
'
>
>
>
mock_foo
.
assert_called_once_with
(
foo
)
rj
rk
}
rl
(
hZU
h
\
j
[
ubaubh
)
rm
}
rn
(
hZX
If
we
don
'
t
use
autospec
=
True
then
the
unbound
method
is
patched
out
with
a
Mock
instance
instead
and
isn
'
t
called
with
self
.
ro
h
\
j
h
]
h
hbh
hd
}
rp
(
hj
]
rq
hl
]
rr
hh
]
rs
hf
]
rt
hn
]
ru
uhqM
?
hrh
hU
]
rv
(
h
X
If
we
don
'
t
use
rw
rx
}
ry
(
hZX
If
we
don
'
t
use
rz
h
\
jm
ubj
<
)
r
{
}
r
|
(
hZX
autospec
=
True
r
}
hd
}
r
~
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
jm
hU
]
r
h
X
autospec
=
Truer
r
}
r
(
hZU
h
\
j
{
ubahbjJ
ubh
X
\
then
the
unbound
method
is
patched
out
with
a
Mock
instance
instead
and
isn
'
t
called
with
r
r
}
r
(
hZX
\
then
the
unbound
method
is
patched
out
with
a
Mock
instance
instead
and
isn
'
t
called
with
r
h
\
jm
ubj
<
)
r
}
r
(
hZX
self
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
jm
hU
]
r
h
X
selfr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
.
r
}
r
(
hZX
.
h
\
jm
ubeubeubht
)
r
}
r
(
hZU
h
\
huh
]
h
hbhyhd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
h
=
ahn
]
r
h
auhqMD
hrh
hU
]
r
(
h
)
r
}
r
(
hZX
!
Checking
multiple
calls
with
mockr
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqMD
hrh
hU
]
r
h
X
!
Checking
multiple
calls
with
mockr
r
}
r
(
hZj
h
\
j
ubaubh
)
r
}
r
(
hZXO
mock
has
a
nice
API
for
making
assertions
about
how
your
mock
objects
are
used
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqMF
hrh
hU
]
r
h
XO
mock
has
a
nice
API
for
making
assertions
about
how
your
mock
objects
are
used
.
r
r
}
r
(
hZj
h
\
j
ubaubj
)
r
}
r
(
hZX
>
>
>
mock
=
Mock
(
)
>
>
>
mock
.
foo_bar
.
return_value
=
None
>
>
>
mock
.
foo_bar
(
'
baz
'
spam
=
'
eggs
'
)
>
>
>
mock
.
foo_bar
.
assert_called_with
(
'
baz
'
spam
=
'
eggs
'
)
r
h
\
j
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqMH
hrh
hU
]
r
h
X
>
>
>
mock
=
Mock
(
)
>
>
>
mock
.
foo_bar
.
return_value
=
None
>
>
>
mock
.
foo_bar
(
'
baz
'
spam
=
'
eggs
'
)
>
>
>
mock
.
foo_bar
.
assert_called_with
(
'
baz
'
spam
=
'
eggs
'
)
r
r
}
r
(
hZU
h
\
j
ubaubh
)
r
}
r
(
hZX
If
your
mock
is
only
being
called
once
you
can
use
the
:
meth
:
assert_called_once_with
method
that
also
asserts
that
the
:
attr
:
call_count
is
one
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqMO
hrh
hU
]
r
(
h
X7
If
your
mock
is
only
being
called
once
you
can
use
the
r
r
}
r
(
hZX7
If
your
mock
is
only
being
called
once
you
can
use
the
r
h
\
j
ubh
)
r
}
r
(
hZX
:
meth
:
assert_called_once_with
r
h
\
j
h
]
h
hbh
hd
}
r
(
U
reftyper
X
methr
h
h
X
assert_called_once_withr
U
refdomainr
X
pyr
hf
]
r
hh
]
r
U
refexplicitr
hj
]
r
hl
]
r
hn
]
r
h
h
j
%
Nj
&
j
'
uhqMO
hU
]
r
j
)
)
r
}
r
(
hZj
hd
}
r
(
hj
]
r
hl
]
r
(
h
j
X
py
-
methr
ehh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
assert_called_once_with
(
)
r
r
}
r
(
hZU
h
\
j
ubahbj7
ubaubh
X
#
method
that
also
asserts
that
the
r
r
}
r
(
hZX
#
method
that
also
asserts
that
the
r
h
\
j
ubh
)
r
}
r
(
hZX
:
attr
:
call_count
r
h
\
j
h
]
h
hbh
hd
}
r
(
U
reftyper
X
attrr
h
h
X
call_countr
U
refdomainr
X
pyr
hf
]
r
hh
]
r
U
refexplicitr
hj
]
r
hl
]
r
hn
]
r
h
h
j
%
Nj
&
j
'
uhqMO
hU
]
r
j
)
)
r
}
r
(
hZj
hd
}
r
(
hj
]
r
hl
]
r
(
h
j
X
py
-
attrr
ehh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
call_countr
r
}
r
(
hZU
h
\
j
ubahbj7
ubaubh
X
is
one
.
r
r
}
r
(
hZX
is
one
.
r
h
\
j
ubeubj
)
r
}
r
!
(
hZX
>
>
>
mock
.
foo_bar
.
assert_called_once_with
(
'
baz
'
spam
=
'
eggs
'
)
>
>
>
mock
.
foo_bar
(
)
>
>
>
mock
.
foo_bar
.
assert_called_once_with
(
'
baz
'
spam
=
'
eggs
'
)
Traceback
(
most
recent
call
last
)
:
.
.
.
AssertionError
:
Expected
to
be
called
once
.
Called
2
times
.
r
"
h
\
j
h
]
h
hbj
hd
}
r
#
(
U
testnodetyper
X
doctestr
%
h
h
hf
]
r
&
hh
]
r
'
hj
]
r
(
hl
]
r
)
hn
]
r
*
U
groupsr
+
]
r
h
ah
}
r
-
uhqMS
hrh
hU
]
r
.
h
X
>
>
>
mock
.
foo_bar
.
assert_called_once_with
(
'
baz
'
spam
=
'
eggs
'
)
>
>
>
mock
.
foo_bar
(
)
>
>
>
mock
.
foo_bar
.
assert_called_once_with
(
'
baz
'
spam
=
'
eggs
'
)
Traceback
(
most
recent
call
last
)
:
.
.
.
AssertionError
:
Expected
to
be
called
once
.
Called
2
times
.
r
/
r0
}
r1
(
hZU
h
\
j
ubaubh
)
r2
}
r3
(
hZX
Both
assert_called_with
and
assert_called_once_with
make
assertions
about
the
*
most
recent
*
call
.
If
your
mock
is
going
to
be
called
several
times
and
you
want
to
make
assertions
about
*
all
*
those
calls
you
can
use
:
attr
:
~
Mock
.
call_args_list
:
r4
h
\
j
h
]
h
hbh
hd
}
r5
(
hj
]
r6
hl
]
r7
hh
]
r8
hf
]
r9
hn
]
r
:
uhqM
\
hrh
hU
]
r
;
(
h
X
Both
r
<
r
=
}
r
>
(
hZX
Both
r
?
h
\
j2
ubj
<
)
r
}
rA
(
hZX
assert_called_with
rB
hd
}
rC
(
hj
]
rD
hl
]
rE
hh
]
rF
hf
]
rG
hn
]
rH
uh
\
j2
hU
]
rI
h
X
assert_called_withrJ
rK
}
rL
(
hZU
h
\
j
ubahbjJ
ubh
X
and
rM
rN
}
rO
(
hZX
and
rP
h
\
j2
ubj
<
)
rQ
}
rR
(
hZX
assert_called_once_with
rS
hd
}
rT
(
hj
]
rU
hl
]
rV
hh
]
rW
hf
]
rX
hn
]
rY
uh
\
j2
hU
]
rZ
h
X
assert_called_once_withr
[
r
\
}
r
]
(
hZU
h
\
jQ
ubahbjJ
ubh
X
make
assertions
about
the
r
^
r_
}
r
(
hZX
make
assertions
about
the
ra
h
\
j2
ubh
)
rb
}
rc
(
hZX
*
most
recent
*
rd
hd
}
re
(
hj
]
rf
hl
]
rg
hh
]
rh
hf
]
ri
hn
]
rj
uh
\
j2
hU
]
rk
h
X
most
recentrl
rm
}
rn
(
hZU
h
\
jb
ubahbh
ubh
X_
call
.
If
your
mock
is
going
to
be
called
several
times
and
you
want
to
make
assertions
about
ro
rp
}
rq
(
hZX_
call
.
If
your
mock
is
going
to
be
called
several
times
and
you
want
to
make
assertions
about
rr
h
\
j2
ubh
)
rs
}
rt
(
hZX
*
all
*
ru
hd
}
rv
(
hj
]
rw
hl
]
rx
hh
]
ry
hf
]
rz
hn
]
r
{
uh
\
j2
hU
]
r
|
h
X
allr
}
r
~
}
r
(
hZU
h
\
js
ubahbh
ubh
X
those
calls
you
can
use
r
r
}
r
(
hZX
those
calls
you
can
use
r
h
\
j2
ubh
)
r
}
r
(
hZX
:
attr
:
~
Mock
.
call_args_list
r
h
\
j2
h
]
h
hbh
hd
}
r
(
U
reftyper
X
attrr
h
h
X
Mock
.
call_args_listr
U
refdomainr
X
pyr
hf
]
r
hh
]
r
U
refexplicitr
hj
]
r
hl
]
r
hn
]
r
h
h
j
%
Nj
&
j
'
uhqM
\
hU
]
r
j
)
)
r
}
r
(
hZj
hd
}
r
(
hj
]
r
hl
]
r
(
h
j
X
py
-
attrr
ehh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
call_args_listr
r
}
r
(
hZU
h
\
j
ubahbj7
ubaubh
X
:
r
}
r
(
hZX
:
h
\
j2
ubeubj
)
r
}
r
(
hZX
>
>
>
mock
=
Mock
(
return_value
=
None
)
>
>
>
mock
(
1
2
3
)
>
>
>
mock
(
4
5
6
)
>
>
>
mock
(
)
>
>
>
mock
.
call_args_list
[
call
(
1
2
3
)
call
(
4
5
6
)
call
(
)
]
r
h
\
j
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqMa
hrh
hU
]
r
h
X
>
>
>
mock
=
Mock
(
return_value
=
None
)
>
>
>
mock
(
1
2
3
)
>
>
>
mock
(
4
5
6
)
>
>
>
mock
(
)
>
>
>
mock
.
call_args_list
[
call
(
1
2
3
)
call
(
4
5
6
)
call
(
)
]
r
r
}
r
(
hZU
h
\
j
ubaubh
)
r
}
r
(
hZX
The
:
data
:
call
helper
makes
it
easy
to
make
assertions
about
these
calls
.
You
can
build
up
a
list
of
expected
calls
and
compare
it
to
call_args_list
.
This
looks
remarkably
similar
to
the
repr
of
the
call_args_list
:
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqMj
hrh
hU
]
r
(
h
X
The
r
r
}
r
(
hZX
The
r
h
\
j
ubh
)
r
}
r
(
hZX
:
data
:
call
r
h
\
j
h
]
h
hbh
hd
}
r
(
U
reftyper
X
datar
h
h
X
callr
U
refdomainr
X
pyr
hf
]
r
hh
]
r
U
refexplicitr
hj
]
r
hl
]
r
hn
]
r
h
h
j
%
Nj
&
j
'
uhqMj
hU
]
r
j
)
)
r
}
r
(
hZj
hd
}
r
(
hj
]
r
hl
]
r
(
h
j
X
py
-
datar
ehh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
callr
r
}
r
(
hZU
h
\
j
ubahbj7
ubaubh
Xx
helper
makes
it
easy
to
make
assertions
about
these
calls
.
You
can
build
up
a
list
of
expected
calls
and
compare
it
to
r
r
}
r
(
hZXx
helper
makes
it
easy
to
make
assertions
about
these
calls
.
You
can
build
up
a
list
of
expected
calls
and
compare
it
to
r
h
\
j
ubj
<
)
r
}
r
(
hZX
call_args_list
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
call_args_listr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X3
.
This
looks
remarkably
similar
to
the
repr
of
the
r
r
}
r
(
hZX3
.
This
looks
remarkably
similar
to
the
repr
of
the
r
h
\
j
ubj
<
)
r
}
r
(
hZX
call_args_list
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
call_args_listr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
:
r
}
r
(
hZX
:
h
\
j
ubeubj
)
r
}
r
(
hZX
^
>
>
>
expected
=
[
call
(
1
2
3
)
call
(
4
5
6
)
call
(
)
]
>
>
>
mock
.
call_args_list
=
=
expected
Truer
h
\
j
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqMn
hrh
hU
]
r
h
X
^
>
>
>
expected
=
[
call
(
1
2
3
)
call
(
4
5
6
)
call
(
)
]
>
>
>
mock
.
call_args_list
=
=
expected
Truer
r
}
r
(
hZU
h
\
j
ubaubeubht
)
r
}
r
(
hZU
h
\
huh
]
h
hbhyhd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
h3ahn
]
r
h
auhqMv
hrh
hU
]
r
(
h
)
r
}
r
(
hZX
Coping
with
mutable
argumentsr
!
h
\
j
h
]
h
hbh
hd
}
r
"
(
hj
]
r
#
hl
]
r
hh
]
r
%
hf
]
r
&
hn
]
r
'
uhqMv
hrh
hU
]
r
(
h
X
Coping
with
mutable
argumentsr
)
r
*
}
r
+
(
hZj
!
h
\
j
ubaubh
)
r
}
r
-
(
hZX6
Another
situation
is
rare
but
can
bite
you
is
when
your
mock
is
called
with
mutable
arguments
.
call_args
and
call_args_list
store
*
references
*
to
the
arguments
.
If
the
arguments
are
mutated
by
the
code
under
test
then
you
can
no
longer
make
assertions
about
what
the
values
were
when
the
mock
was
called
.
r
.
h
\
j
h
]
h
hbh
hd
}
r
/
(
hj
]
r0
hl
]
r1
hh
]
r2
hf
]
r3
hn
]
r4
uhqMx
hrh
hU
]
r5
(
h
Xa
Another
situation
is
rare
but
can
bite
you
is
when
your
mock
is
called
with
mutable
arguments
.
r6
r7
}
r8
(
hZXa
Another
situation
is
rare
but
can
bite
you
is
when
your
mock
is
called
with
mutable
arguments
.
r9
h
\
j
ubj
<
)
r
:
}
r
;
(
hZX
call_args
r
<
hd
}
r
=
(
hj
]
r
>
hl
]
r
?
hh
]
r
hf
]
rA
hn
]
rB
uh
\
j
hU
]
rC
h
X
call_argsrD
rE
}
rF
(
hZU
h
\
j
:
ubahbjJ
ubh
X
and
rG
rH
}
rI
(
hZX
and
rJ
h
\
j
ubj
<
)
rK
}
rL
(
hZX
call_args_list
rM
hd
}
rN
(
hj
]
rO
hl
]
rP
hh
]
rQ
hf
]
rR
hn
]
rS
uh
\
j
hU
]
rT
h
X
call_args_listrU
rV
}
rW
(
hZU
h
\
jK
ubahbjJ
ubh
X
store
rX
rY
}
rZ
(
hZX
store
r
[
h
\
j
ubh
)
r
\
}
r
]
(
hZX
*
references
*
r
^
hd
}
r_
(
hj
]
r
hl
]
ra
hh
]
rb
hf
]
rc
hn
]
rd
uh
\
j
hU
]
re
h
X
referencesrf
rg
}
rh
(
hZU
h
\
j
\
ubahbh
ubh
X
to
the
arguments
.
If
the
arguments
are
mutated
by
the
code
under
test
then
you
can
no
longer
make
assertions
about
what
the
values
were
when
the
mock
was
called
.
ri
rj
}
rk
(
hZX
to
the
arguments
.
If
the
arguments
are
mutated
by
the
code
under
test
then
you
can
no
longer
make
assertions
about
what
the
values
were
when
the
mock
was
called
.
rl
h
\
j
ubeubh
)
rm
}
rn
(
hZXh
Here
'
s
some
example
code
that
shows
the
problem
.
Imagine
the
following
functions
defined
in
'
mymodule
'
:
:
ro
h
\
j
h
]
h
hbh
hd
}
rp
(
hj
]
rq
hl
]
rr
hh
]
rs
hf
]
rt
hn
]
ru
uhqM
}
hrh
hU
]
rv
h
Xg
Here
'
s
some
example
code
that
shows
the
problem
.
Imagine
the
following
functions
defined
in
'
mymodule
'
:
rw
rx
}
ry
(
hZXg
Here
'
s
some
example
code
that
shows
the
problem
.
Imagine
the
following
functions
defined
in
'
mymodule
'
:
rz
h
\
jm
ubaubj
)
r
{
}
r
|
(
hZXi
def
frob
(
val
)
:
pass
def
grob
(
val
)
:
"
First
frob
and
then
clear
val
"
frob
(
val
)
val
.
clear
(
)
r
}
h
\
j
h
]
h
hbj
hd
}
r
~
(
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
uhqM
hrh
hU
]
r
h
Xi
def
frob
(
val
)
:
pass
def
grob
(
val
)
:
"
First
frob
and
then
clear
val
"
frob
(
val
)
val
.
clear
(
)
r
r
}
r
(
hZU
h
\
j
{
ubaubh
)
r
}
r
(
hZXY
When
we
try
to
test
that
grob
calls
frob
with
the
correct
argument
look
what
happens
:
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
(
h
X
When
we
try
to
test
that
r
r
}
r
(
hZX
When
we
try
to
test
that
r
h
\
j
ubj
<
)
r
}
r
(
hZX
grob
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
grobr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
calls
r
r
}
r
(
hZX
calls
r
h
\
j
ubj
<
)
r
}
r
(
hZX
frob
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
frobr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
-
with
the
correct
argument
look
what
happens
:
r
r
}
r
(
hZX
-
with
the
correct
argument
look
what
happens
:
r
h
\
j
ubeubj
)
r
}
r
(
hZX
>
>
>
with
patch
(
'
mymodule
.
frob
'
)
as
mock_frob
:
.
.
.
val
=
set
(
[
6
]
)
.
.
.
mymodule
.
grob
(
val
)
.
.
.
>
>
>
val
set
(
[
]
)
>
>
>
mock_frob
.
assert_called_with
(
set
(
[
6
]
)
)
Traceback
(
most
recent
call
last
)
:
.
.
.
AssertionError
:
Expected
:
(
(
set
(
[
6
]
)
)
{
}
)
Called
with
:
(
(
set
(
[
]
)
)
{
}
)
r
h
\
j
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqM
hrh
hU
]
r
h
X
>
>
>
with
patch
(
'
mymodule
.
frob
'
)
as
mock_frob
:
.
.
.
val
=
set
(
[
6
]
)
.
.
.
mymodule
.
grob
(
val
)
.
.
.
>
>
>
val
set
(
[
]
)
>
>
>
mock_frob
.
assert_called_with
(
set
(
[
6
]
)
)
Traceback
(
most
recent
call
last
)
:
.
.
.
AssertionError
:
Expected
:
(
(
set
(
[
6
]
)
)
{
}
)
Called
with
:
(
(
set
(
[
]
)
)
{
}
)
r
r
}
r
(
hZU
h
\
j
ubaubh
)
r
}
r
(
hZX
One
possibility
would
be
for
mock
to
copy
the
arguments
you
pass
in
.
This
could
then
cause
problems
if
you
do
assertions
that
rely
on
object
identity
for
equality
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
h
X
One
possibility
would
be
for
mock
to
copy
the
arguments
you
pass
in
.
This
could
then
cause
problems
if
you
do
assertions
that
rely
on
object
identity
for
equality
.
r
r
}
r
(
hZj
h
\
j
ubaubh
)
r
}
r
(
hZX
Here
'
s
one
solution
that
uses
the
:
attr
:
side_effect
functionality
.
If
you
provide
a
side_effect
function
for
a
mock
then
side_effect
will
be
called
with
the
same
args
as
the
mock
.
This
gives
us
an
opportunity
to
copy
the
arguments
and
store
them
for
later
assertions
.
In
this
example
I
'
m
using
*
another
*
mock
to
store
the
arguments
so
that
I
can
use
the
mock
methods
for
doing
the
assertion
.
Again
a
helper
function
sets
this
up
for
me
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
(
h
X
"
Here
'
s
one
solution
that
uses
the
r
r
}
r
(
hZX
"
Here
'
s
one
solution
that
uses
the
r
h
\
j
ubh
)
r
}
r
(
hZX
:
attr
:
side_effect
r
h
\
j
h
]
h
hbh
hd
}
r
(
U
reftyper
X
attrr
h
h
X
side_effectr
U
refdomainr
X
pyr
hf
]
r
hh
]
r
U
refexplicitr
hj
]
r
hl
]
r
hn
]
r
h
h
j
%
Nj
&
j
'
uhqM
hU
]
r
j
)
)
r
}
r
(
hZj
hd
}
r
(
hj
]
r
hl
]
r
(
h
j
X
py
-
attrr
ehh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
side_effectr
r
}
r
(
hZU
h
\
j
ubahbj7
ubaubh
X
!
functionality
.
If
you
provide
a
r
r
}
r
(
hZX
!
functionality
.
If
you
provide
a
r
h
\
j
ubj
<
)
r
}
r
(
hZX
side_effect
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
side_effectr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
function
for
a
mock
then
r
r
}
r
(
hZX
function
for
a
mock
then
r
h
\
j
ubj
<
)
r
}
r
(
hZX
side_effect
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
side_effectr
!
r
"
}
r
#
(
hZU
h
\
j
ubahbjJ
ubh
X
will
be
called
with
the
same
args
as
the
mock
.
This
gives
us
an
opportunity
to
copy
the
arguments
and
store
them
for
later
assertions
.
In
this
example
I
'
m
using
r
r
%
}
r
&
(
hZX
will
be
called
with
the
same
args
as
the
mock
.
This
gives
us
an
opportunity
to
copy
the
arguments
and
store
them
for
later
assertions
.
In
this
example
I
'
m
using
r
'
h
\
j
ubh
)
r
(
}
r
)
(
hZX
*
another
*
r
*
hd
}
r
+
(
hj
]
r
hl
]
r
-
hh
]
r
.
hf
]
r
/
hn
]
r0
uh
\
j
hU
]
r1
h
X
anotherr2
r3
}
r4
(
hZU
h
\
j
(
ubahbh
ubh
X
mock
to
store
the
arguments
so
that
I
can
use
the
mock
methods
for
doing
the
assertion
.
Again
a
helper
function
sets
this
up
for
me
.
r5
r6
}
r7
(
hZX
mock
to
store
the
arguments
so
that
I
can
use
the
mock
methods
for
doing
the
assertion
.
Again
a
helper
function
sets
this
up
for
me
.
r8
h
\
j
ubeubj
)
r9
}
r
:
(
hZXV
>
>
>
from
copy
import
deepcopy
>
>
>
from
mock
import
Mock
patch
DEFAULT
>
>
>
def
copy_call_args
(
mock
)
:
.
.
.
new_mock
=
Mock
(
)
.
.
.
def
side_effect
(
*
args
*
*
kwargs
)
:
.
.
.
args
=
deepcopy
(
args
)
.
.
.
kwargs
=
deepcopy
(
kwargs
)
.
.
.
new_mock
(
*
args
*
*
kwargs
)
.
.
.
return
DEFAULT
.
.
.
mock
.
side_effect
=
side_effect
.
.
.
return
new_mock
.
.
.
>
>
>
with
patch
(
'
mymodule
.
frob
'
)
as
mock_frob
:
.
.
.
new_mock
=
copy_call_args
(
mock_frob
)
.
.
.
val
=
set
(
[
6
]
)
.
.
.
mymodule
.
grob
(
val
)
.
.
.
>
>
>
new_mock
.
assert_called_with
(
set
(
[
6
]
)
)
>
>
>
new_mock
.
call_args
call
(
set
(
[
6
]
)
)
r
;
h
\
j
h
]
h
hbj
hd
}
r
<
(
U
testnodetyper
=
X
doctestr
>
h
h
hf
]
r
?
hh
]
r
hj
]
rA
hl
]
rB
hn
]
rC
U
groupsrD
]
rE
h
ah
}
rF
uhqM
hrh
hU
]
rG
h
XV
>
>
>
from
copy
import
deepcopy
>
>
>
from
mock
import
Mock
patch
DEFAULT
>
>
>
def
copy_call_args
(
mock
)
:
.
.
.
new_mock
=
Mock
(
)
.
.
.
def
side_effect
(
*
args
*
*
kwargs
)
:
.
.
.
args
=
deepcopy
(
args
)
.
.
.
kwargs
=
deepcopy
(
kwargs
)
.
.
.
new_mock
(
*
args
*
*
kwargs
)
.
.
.
return
DEFAULT
.
.
.
mock
.
side_effect
=
side_effect
.
.
.
return
new_mock
.
.
.
>
>
>
with
patch
(
'
mymodule
.
frob
'
)
as
mock_frob
:
.
.
.
new_mock
=
copy_call_args
(
mock_frob
)
.
.
.
val
=
set
(
[
6
]
)
.
.
.
mymodule
.
grob
(
val
)
.
.
.
>
>
>
new_mock
.
assert_called_with
(
set
(
[
6
]
)
)
>
>
>
new_mock
.
call_args
call
(
set
(
[
6
]
)
)
rH
rI
}
rJ
(
hZU
h
\
j9
ubaubh
)
rK
}
rL
(
hZX
copy_call_args
is
called
with
the
mock
that
will
be
called
.
It
returns
a
new
mock
that
we
do
the
assertion
on
.
The
side_effect
function
makes
a
copy
of
the
args
and
calls
our
new_mock
with
the
copy
.
rM
h
\
j
h
]
h
hbh
hd
}
rN
(
hj
]
rO
hl
]
rP
hh
]
rQ
hf
]
rR
hn
]
rS
uhqM
hrh
hU
]
rT
(
j
<
)
rU
}
rV
(
hZX
copy_call_args
rW
hd
}
rX
(
hj
]
rY
hl
]
rZ
hh
]
r
[
hf
]
r
\
hn
]
r
]
uh
\
jK
hU
]
r
^
h
X
copy_call_argsr_
r
}
ra
(
hZU
h
\
jU
ubahbjJ
ubh
Xe
is
called
with
the
mock
that
will
be
called
.
It
returns
a
new
mock
that
we
do
the
assertion
on
.
The
rb
rc
}
rd
(
hZXe
is
called
with
the
mock
that
will
be
called
.
It
returns
a
new
mock
that
we
do
the
assertion
on
.
The
re
h
\
jK
ubj
<
)
rf
}
rg
(
hZX
side_effect
rh
hd
}
ri
(
hj
]
rj
hl
]
rk
hh
]
rl
hf
]
rm
hn
]
rn
uh
\
jK
hU
]
ro
h
X
side_effectrp
rq
}
rr
(
hZU
h
\
jf
ubahbjJ
ubh
X1
function
makes
a
copy
of
the
args
and
calls
our
rs
rt
}
ru
(
hZX1
function
makes
a
copy
of
the
args
and
calls
our
rv
h
\
jK
ubj
<
)
rw
}
rx
(
hZX
new_mock
ry
hd
}
rz
(
hj
]
r
{
hl
]
r
|
hh
]
r
}
hf
]
r
~
hn
]
r
uh
\
jK
hU
]
r
h
X
new_mockr
r
}
r
(
hZU
h
\
jw
ubahbjJ
ubh
X
with
the
copy
.
r
r
}
r
(
hZX
with
the
copy
.
r
h
\
jK
ubeubcdocutils
.
nodes
note
r
)
r
}
r
(
hZX
If
your
mock
is
only
going
to
be
used
once
there
is
an
easier
way
of
checking
arguments
at
the
point
they
are
called
.
You
can
simply
do
the
checking
inside
a
side_effect
function
.
.
.
doctest
:
:
>
>
>
def
side_effect
(
arg
)
:
.
.
.
assert
arg
=
=
set
(
[
6
]
)
.
.
.
>
>
>
mock
=
Mock
(
side_effect
=
side_effect
)
>
>
>
mock
(
set
(
[
6
]
)
)
>
>
>
mock
(
set
(
)
)
Traceback
(
most
recent
call
last
)
:
.
.
.
AssertionErrorr
h
\
j
h
]
NhbU
noter
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqNhrh
hU
]
r
(
h
)
r
}
r
(
hZX
If
your
mock
is
only
going
to
be
used
once
there
is
an
easier
way
of
checking
arguments
at
the
point
they
are
called
.
You
can
simply
do
the
checking
inside
a
side_effect
function
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hU
]
r
(
h
X
If
your
mock
is
only
going
to
be
used
once
there
is
an
easier
way
of
checking
arguments
at
the
point
they
are
called
.
You
can
simply
do
the
checking
inside
a
r
r
}
r
(
hZX
If
your
mock
is
only
going
to
be
used
once
there
is
an
easier
way
of
checking
arguments
at
the
point
they
are
called
.
You
can
simply
do
the
checking
inside
a
r
h
\
j
ubj
<
)
r
}
r
(
hZX
side_effect
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
side_effectr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
function
.
r
r
}
r
(
hZX
function
.
r
h
\
j
ubeubj
)
r
}
r
(
hZX
>
>
>
def
side_effect
(
arg
)
:
.
.
.
assert
arg
=
=
set
(
[
6
]
)
.
.
.
>
>
>
mock
=
Mock
(
side_effect
=
side_effect
)
>
>
>
mock
(
set
(
[
6
]
)
)
>
>
>
mock
(
set
(
)
)
Traceback
(
most
recent
call
last
)
:
.
.
.
AssertionErrorr
h
\
j
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqM
hU
]
r
h
X
>
>
>
def
side_effect
(
arg
)
:
.
.
.
assert
arg
=
=
set
(
[
6
]
)
.
.
.
>
>
>
mock
=
Mock
(
side_effect
=
side_effect
)
>
>
>
mock
(
set
(
[
6
]
)
)
>
>
>
mock
(
set
(
)
)
Traceback
(
most
recent
call
last
)
:
.
.
.
AssertionErrorr
r
}
r
(
hZU
h
\
j
ubaubeubh
)
r
}
r
(
hZX
An
alternative
approach
is
to
create
a
subclass
of
Mock
or
MagicMock
that
copies
(
using
copy
.
deepcopy
<
http
:
/
/
docs
.
python
.
org
/
library
/
copy
.
html
#
copy
.
deepcopy
>
_
)
the
arguments
.
Here
'
s
an
example
implementation
:
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
(
h
X3
An
alternative
approach
is
to
create
a
subclass
of
r
r
}
r
(
hZX3
An
alternative
approach
is
to
create
a
subclass
of
r
h
\
j
ubj
<
)
r
}
r
(
hZX
Mock
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
Mockr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
or
r
r
}
r
(
hZX
or
r
h
\
j
ubj
<
)
r
}
r
(
hZX
MagicMock
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
MagicMockr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
that
copies
(
using
r
r
}
r
(
hZX
that
copies
(
using
r
h
\
j
ubj
)
r
}
r
(
hZXI
copy
.
deepcopy
<
http
:
/
/
docs
.
python
.
org
/
library
/
copy
.
html
#
copy
.
deepcopy
>
_r
hd
}
r
(
U
namer
X
copy
.
deepcopyr
j
X6
http
:
/
/
docs
.
python
.
org
/
library
/
copy
.
html
#
copy
.
deepcopyr
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
copy
.
deepcopyr
r
}
r
(
hZU
h
\
j
ubahbj
ubhW
)
r
}
r
(
hZX9
<
http
:
/
/
docs
.
python
.
org
/
library
/
copy
.
html
#
copy
.
deepcopy
>
r
j
K
h
\
j
hbhchd
}
r
(
U
refurir
j
hf
]
r
h8ahh
]
r
hj
]
r
hl
]
r
hn
]
r
h
auhU
]
r
ubh
X2
)
the
arguments
.
Here
'
s
an
example
implementation
:
r
r
}
r
(
hZX2
)
the
arguments
.
Here
'
s
an
example
implementation
:
r
h
\
j
ubeubj
)
r
}
r
(
hZX2
>
>
>
from
copy
import
deepcopy
>
>
>
class
CopyingMock
(
MagicMock
)
:
.
.
.
def
__call__
(
self
*
args
*
*
kwargs
)
:
.
.
.
args
=
deepcopy
(
args
)
.
.
.
kwargs
=
deepcopy
(
kwargs
)
.
.
.
return
super
(
CopyingMock
self
)
.
__call__
(
*
args
*
*
kwargs
)
.
.
.
>
>
>
c
=
CopyingMock
(
return_value
=
None
)
>
>
>
arg
=
set
(
)
>
>
>
c
(
arg
)
>
>
>
arg
.
add
(
1
)
>
>
>
c
.
assert_called_with
(
set
(
)
)
>
>
>
c
.
assert_called_with
(
arg
)
Traceback
(
most
recent
call
last
)
:
.
.
.
AssertionError
:
Expected
call
:
mock
(
set
(
[
1
]
)
)
Actual
call
:
mock
(
set
(
[
]
)
)
>
>
>
c
.
foo
<
CopyingMock
name
=
'
mock
.
foo
'
id
=
'
.
.
.
'
>
r
h
\
j
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
!
uhqM
hrh
hU
]
r
"
h
X2
>
>
>
from
copy
import
deepcopy
>
>
>
class
CopyingMock
(
MagicMock
)
:
.
.
.
def
__call__
(
self
*
args
*
*
kwargs
)
:
.
.
.
args
=
deepcopy
(
args
)
.
.
.
kwargs
=
deepcopy
(
kwargs
)
.
.
.
return
super
(
CopyingMock
self
)
.
__call__
(
*
args
*
*
kwargs
)
.
.
.
>
>
>
c
=
CopyingMock
(
return_value
=
None
)
>
>
>
arg
=
set
(
)
>
>
>
c
(
arg
)
>
>
>
arg
.
add
(
1
)
>
>
>
c
.
assert_called_with
(
set
(
)
)
>
>
>
c
.
assert_called_with
(
arg
)
Traceback
(
most
recent
call
last
)
:
.
.
.
AssertionError
:
Expected
call
:
mock
(
set
(
[
1
]
)
)
Actual
call
:
mock
(
set
(
[
]
)
)
>
>
>
c
.
foo
<
CopyingMock
name
=
'
mock
.
foo
'
id
=
'
.
.
.
'
>
r
#
r
}
r
%
(
hZU
h
\
j
ubaubh
)
r
&
}
r
'
(
hZX
When
you
subclass
Mock
or
MagicMock
all
dynamically
created
attributes
and
the
return_value
will
use
your
subclass
automatically
.
That
means
all
children
of
a
CopyingMock
will
also
have
the
type
CopyingMock
.
r
(
h
\
j
h
]
h
hbh
hd
}
r
)
(
hj
]
r
*
hl
]
r
+
hh
]
r
hf
]
r
-
hn
]
r
.
uhqM
hrh
hU
]
r
/
(
h
X
When
you
subclass
r0
r1
}
r2
(
hZX
When
you
subclass
r3
h
\
j
&
ubj
<
)
r4
}
r5
(
hZX
Mock
r6
hd
}
r7
(
hj
]
r8
hl
]
r9
hh
]
r
:
hf
]
r
;
hn
]
r
<
uh
\
j
&
hU
]
r
=
h
X
Mockr
>
r
?
}
r
(
hZU
h
\
j4
ubahbjJ
ubh
X
or
rA
rB
}
rC
(
hZX
or
rD
h
\
j
&
ubj
<
)
rE
}
rF
(
hZX
MagicMock
rG
hd
}
rH
(
hj
]
rI
hl
]
rJ
hh
]
rK
hf
]
rL
hn
]
rM
uh
\
j
&
hU
]
rN
h
X
MagicMockrO
rP
}
rQ
(
hZU
h
\
jE
ubahbjJ
ubh
X
-
all
dynamically
created
attributes
and
the
rR
rS
}
rT
(
hZX
-
all
dynamically
created
attributes
and
the
rU
h
\
j
&
ubj
<
)
rV
}
rW
(
hZX
return_value
rX
hd
}
rY
(
hj
]
rZ
hl
]
r
[
hh
]
r
\
hf
]
r
]
hn
]
r
^
uh
\
j
&
hU
]
r_
h
X
return_valuer
ra
}
rb
(
hZU
h
\
jV
ubahbjJ
ubh
XD
will
use
your
subclass
automatically
.
That
means
all
children
of
a
rc
rd
}
re
(
hZXD
will
use
your
subclass
automatically
.
That
means
all
children
of
a
rf
h
\
j
&
ubj
<
)
rg
}
rh
(
hZX
CopyingMock
ri
hd
}
rj
(
hj
]
rk
hl
]
rl
hh
]
rm
hf
]
rn
hn
]
ro
uh
\
j
&
hU
]
rp
h
X
CopyingMockrq
rr
}
rs
(
hZU
h
\
jg
ubahbjJ
ubh
X
will
also
have
the
type
rt
ru
}
rv
(
hZX
will
also
have
the
type
rw
h
\
j
&
ubj
<
)
rx
}
ry
(
hZX
CopyingMock
rz
hd
}
r
{
(
hj
]
r
|
hl
]
r
}
hh
]
r
~
hf
]
r
hn
]
r
uh
\
j
&
hU
]
r
h
X
CopyingMockr
r
}
r
(
hZU
h
\
jx
ubahbjJ
ubh
X
.
r
}
r
(
hZX
.
h
\
j
&
ubeubeubht
)
r
}
r
(
hZU
h
\
huh
]
h
hbhyhd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hOahn
]
r
h
"
auhqM
hrh
hU
]
r
(
h
)
r
}
r
(
hZX
&
Raising
exceptions
on
attribute
accessr
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
h
X
&
Raising
exceptions
on
attribute
accessr
r
}
r
(
hZj
h
\
j
ubaubh
)
r
}
r
(
hZX
You
can
use
:
class
:
PropertyMock
to
mimic
the
behaviour
of
properties
.
This
includes
raising
exceptions
when
an
attribute
is
accessed
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
(
h
X
You
can
use
r
r
}
r
(
hZX
You
can
use
r
h
\
j
ubh
)
r
}
r
(
hZX
:
class
:
PropertyMock
r
h
\
j
h
]
h
hbh
hd
}
r
(
U
reftyper
X
classr
h
h
X
PropertyMockr
U
refdomainr
X
pyr
hf
]
r
hh
]
r
U
refexplicitr
hj
]
r
hl
]
r
hn
]
r
h
h
j
%
Nj
&
j
'
uhqM
hU
]
r
j
)
)
r
}
r
(
hZj
hd
}
r
(
hj
]
r
hl
]
r
(
h
j
X
py
-
classr
ehh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
PropertyMockr
r
}
r
(
hZU
h
\
j
ubahbj7
ubaubh
Xf
to
mimic
the
behaviour
of
properties
.
This
includes
raising
exceptions
when
an
attribute
is
accessed
.
r
r
}
r
(
hZXf
to
mimic
the
behaviour
of
properties
.
This
includes
raising
exceptions
when
an
attribute
is
accessed
.
r
h
\
j
ubeubh
)
r
}
r
(
hZXN
Here
'
s
an
example
raising
a
ValueError
when
the
'
foo
'
attribute
is
accessed
:
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
(
h
X
Here
'
s
an
example
raising
a
r
r
}
r
(
hZX
Here
'
s
an
example
raising
a
r
h
\
j
ubj
<
)
r
}
r
(
hZX
ValueError
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
ValueErrorr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
&
when
the
'
foo
'
attribute
is
accessed
:
r
r
}
r
(
hZX
&
when
the
'
foo
'
attribute
is
accessed
:
r
h
\
j
ubeubj
)
r
}
r
(
hZX
>
>
>
m
=
MagicMock
(
)
>
>
>
p
=
PropertyMock
(
side_effect
=
ValueError
)
>
>
>
type
(
m
)
.
foo
=
p
>
>
>
m
.
foo
Traceback
(
most
recent
call
last
)
:
.
.
.
.
ValueErrorr
h
\
j
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqM
hrh
hU
]
r
h
X
>
>
>
m
=
MagicMock
(
)
>
>
>
p
=
PropertyMock
(
side_effect
=
ValueError
)
>
>
>
type
(
m
)
.
foo
=
p
>
>
>
m
.
foo
Traceback
(
most
recent
call
last
)
:
.
.
.
.
ValueErrorr
r
}
r
(
hZU
h
\
j
ubaubh
)
r
}
r
(
hZX
Because
every
mock
object
has
its
own
type
a
new
subclass
of
whichever
mock
class
you
'
re
using
all
mock
objects
are
isolated
from
each
other
.
You
can
safely
attach
properties
(
or
other
descriptors
or
whatever
you
want
in
fact
)
to
type
(
mock
)
without
affecting
other
mock
objects
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
(
h
X
Because
every
mock
object
has
its
own
type
a
new
subclass
of
whichever
mock
class
you
'
re
using
all
mock
objects
are
isolated
from
each
other
.
You
can
safely
attach
properties
(
or
other
descriptors
or
whatever
you
want
in
fact
)
to
r
r
}
r
(
hZX
Because
every
mock
object
has
its
own
type
a
new
subclass
of
whichever
mock
class
you
'
re
using
all
mock
objects
are
isolated
from
each
other
.
You
can
safely
attach
properties
(
or
other
descriptors
or
whatever
you
want
in
fact
)
to
r
h
\
j
ubj
<
)
r
}
r
(
hZX
type
(
mock
)
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
type
(
mock
)
r
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
&
without
affecting
other
mock
objects
.
r
r
}
r
(
hZX
&
without
affecting
other
mock
objects
.
r
h
\
j
ubeubeubht
)
r
}
r
(
hZU
h
\
huh
]
h
hbhyhd
}
r
(
hj
]
r
hl
]
r
hh
]
r
!
hf
]
r
"
hBahn
]
r
#
h
auhqM
hrh
hU
]
r
(
h
)
r
%
}
r
&
(
hZX
%
Multiple
calls
with
different
effectsr
'
h
\
j
h
]
h
hbh
hd
}
r
(
(
hj
]
r
)
hl
]
r
*
hh
]
r
+
hf
]
r
hn
]
r
-
uhqM
hrh
hU
]
r
.
h
X
%
Multiple
calls
with
different
effectsr
/
r0
}
r1
(
hZj
'
h
\
j
%
ubaubj
)
r2
}
r3
(
hZX
In
mock
1
.
0
the
handling
of
iterable
side_effect
was
changed
.
Any
exceptions
in
the
iterable
will
be
raised
instead
of
returned
.
r4
h
\
j
h
]
h
hbj
hd
}
r5
(
hj
]
r6
hl
]
r7
hh
]
r8
hf
]
r9
hn
]
r
:
uhqNhrh
hU
]
r
;
h
)
r
<
}
r
=
(
hZX
In
mock
1
.
0
the
handling
of
iterable
side_effect
was
changed
.
Any
exceptions
in
the
iterable
will
be
raised
instead
of
returned
.
r
>
h
\
j2
h
]
h
hbh
hd
}
r
?
(
hj
]
r
hl
]
rA
hh
]
rB
hf
]
rC
hn
]
rD
uhqM
hU
]
rE
(
h
X
%
In
mock
1
.
0
the
handling
of
iterable
rF
rG
}
rH
(
hZX
%
In
mock
1
.
0
the
handling
of
iterable
rI
h
\
j
<
ubj
<
)
rJ
}
rK
(
hZX
side_effect
rL
hd
}
rM
(
hj
]
rN
hl
]
rO
hh
]
rP
hf
]
rQ
hn
]
rR
uh
\
j
<
hU
]
rS
h
X
side_effectrT
rU
}
rV
(
hZU
h
\
jJ
ubahbjJ
ubh
XP
was
changed
.
Any
exceptions
in
the
iterable
will
be
raised
instead
of
returned
.
rW
rX
}
rY
(
hZXP
was
changed
.
Any
exceptions
in
the
iterable
will
be
raised
instead
of
returned
.
rZ
h
\
j
<
ubeubaubh
)
r
[
}
r
\
(
hZX
Handling
code
that
needs
to
behave
differently
on
subsequent
calls
during
the
test
can
be
tricky
.
For
example
you
may
have
a
function
that
needs
to
raise
an
exception
the
first
time
it
is
called
but
returns
a
response
on
the
second
call
(
testing
retry
behaviour
)
.
r
]
h
\
j
h
]
h
hbh
hd
}
r
^
(
hj
]
r_
hl
]
r
hh
]
ra
hf
]
rb
hn
]
rc
uhqM
hrh
hU
]
rd
h
X
Handling
code
that
needs
to
behave
differently
on
subsequent
calls
during
the
test
can
be
tricky
.
For
example
you
may
have
a
function
that
needs
to
raise
an
exception
the
first
time
it
is
called
but
returns
a
response
on
the
second
call
(
testing
retry
behaviour
)
.
re
rf
}
rg
(
hZj
]
h
\
j
[
ubaubh
)
rh
}
ri
(
hZX
One
approach
is
to
use
a
:
attr
:
side_effect
function
that
replaces
itself
.
The
first
time
it
is
called
the
side_effect
sets
a
new
side_effect
that
will
be
used
for
the
second
call
.
It
then
raises
an
exception
:
rj
h
\
j
h
]
h
hbh
hd
}
rk
(
hj
]
rl
hl
]
rm
hh
]
rn
hf
]
ro
hn
]
rp
uhqM
hrh
hU
]
rq
(
h
X
One
approach
is
to
use
a
rr
rs
}
rt
(
hZX
One
approach
is
to
use
a
ru
h
\
jh
ubh
)
rv
}
rw
(
hZX
:
attr
:
side_effect
rx
h
\
jh
h
]
h
hbh
hd
}
ry
(
U
reftyperz
X
attrr
{
h
h
X
side_effectr
|
U
refdomainr
}
X
pyr
~
hf
]
r
hh
]
r
U
refexplicitr
hj
]
r
hl
]
r
hn
]
r
h
h
j
%
Nj
&
j
'
uhqM
hU
]
r
j
)
)
r
}
r
(
hZjx
hd
}
r
(
hj
]
r
hl
]
r
(
h
j
~
X
py
-
attrr
ehh
]
r
hf
]
r
hn
]
r
uh
\
jv
hU
]
r
h
X
side_effectr
r
}
r
(
hZU
h
\
j
ubahbj7
ubaubh
X
function
that
replaces
itself
.
The
first
time
it
is
called
the
r
r
}
r
(
hZX
function
that
replaces
itself
.
The
first
time
it
is
called
the
r
h
\
jh
ubj
<
)
r
}
r
(
hZX
side_effect
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
jh
hU
]
r
h
X
side_effectr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
sets
a
new
r
r
}
r
(
hZX
sets
a
new
r
h
\
jh
ubj
<
)
r
}
r
(
hZX
side_effect
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
jh
hU
]
r
h
X
side_effectr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
XD
that
will
be
used
for
the
second
call
.
It
then
raises
an
exception
:
r
r
}
r
(
hZXD
that
will
be
used
for
the
second
call
.
It
then
raises
an
exception
:
r
h
\
jh
ubeubj
)
r
}
r
(
hZXT
>
>
>
def
side_effect
(
*
args
)
:
.
.
.
def
second_call
(
*
args
)
:
.
.
.
return
'
response
'
.
.
.
mock
.
side_effect
=
second_call
.
.
.
raise
Exception
(
'
boom
'
)
.
.
.
>
>
>
mock
=
Mock
(
side_effect
=
side_effect
)
>
>
>
mock
(
'
first
'
)
Traceback
(
most
recent
call
last
)
:
.
.
.
Exception
:
boom
>
>
>
mock
(
'
second
'
)
'
response
'
>
>
>
mock
.
assert_called_with
(
'
second
'
)
r
h
\
j
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqM
hrh
hU
]
r
h
XT
>
>
>
def
side_effect
(
*
args
)
:
.
.
.
def
second_call
(
*
args
)
:
.
.
.
return
'
response
'
.
.
.
mock
.
side_effect
=
second_call
.
.
.
raise
Exception
(
'
boom
'
)
.
.
.
>
>
>
mock
=
Mock
(
side_effect
=
side_effect
)
>
>
>
mock
(
'
first
'
)
Traceback
(
most
recent
call
last
)
:
.
.
.
Exception
:
boom
>
>
>
mock
(
'
second
'
)
'
response
'
>
>
>
mock
.
assert_called_with
(
'
second
'
)
r
r
}
r
(
hZU
h
\
j
ubaubh
)
r
}
r
(
hZX
Another
perfectly
valid
way
would
be
to
pop
return
values
from
a
list
.
If
the
return
value
is
an
exception
raise
it
instead
of
returning
it
:
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
h
X
Another
perfectly
valid
way
would
be
to
pop
return
values
from
a
list
.
If
the
return
value
is
an
exception
raise
it
instead
of
returning
it
:
r
r
}
r
(
hZj
h
\
j
ubaubj
)
r
}
r
(
hZXv
>
>
>
returns
=
[
Exception
(
'
boom
'
)
'
response
'
]
>
>
>
def
side_effect
(
*
args
)
:
.
.
.
result
=
returns
.
pop
(
0
)
.
.
.
if
isinstance
(
result
Exception
)
:
.
.
.
raise
result
.
.
.
return
result
.
.
.
>
>
>
mock
=
Mock
(
side_effect
=
side_effect
)
>
>
>
mock
(
'
first
'
)
Traceback
(
most
recent
call
last
)
:
.
.
.
Exception
:
boom
>
>
>
mock
(
'
second
'
)
'
response
'
>
>
>
mock
.
assert_called_with
(
'
second
'
)
r
h
\
j
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqM
/
hrh
hU
]
r
h
Xv
>
>
>
returns
=
[
Exception
(
'
boom
'
)
'
response
'
]
>
>
>
def
side_effect
(
*
args
)
:
.
.
.
result
=
returns
.
pop
(
0
)
.
.
.
if
isinstance
(
result
Exception
)
:
.
.
.
raise
result
.
.
.
return
result
.
.
.
>
>
>
mock
=
Mock
(
side_effect
=
side_effect
)
>
>
>
mock
(
'
first
'
)
Traceback
(
most
recent
call
last
)
:
.
.
.
Exception
:
boom
>
>
>
mock
(
'
second
'
)
'
response
'
>
>
>
mock
.
assert_called_with
(
'
second
'
)
r
r
}
r
(
hZU
h
\
j
ubaubh
)
r
}
r
(
hZX
Which
approach
you
prefer
is
a
matter
of
taste
.
The
first
approach
is
actually
a
line
shorter
but
maybe
the
second
approach
is
more
readable
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqMA
hrh
hU
]
r
h
X
Which
approach
you
prefer
is
a
matter
of
taste
.
The
first
approach
is
actually
a
line
shorter
but
maybe
the
second
approach
is
more
readable
.
r
r
}
r
(
hZj
h
\
j
ubaubeubht
)
r
}
r
(
hZU
h
\
huh
]
h
hbhyhd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hRahn
]
r
h
%
auhqMF
hrh
hU
]
r
(
h
)
r
}
r
(
hZX
Nesting
Patchesr
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqMF
hrh
hU
]
r
h
X
Nesting
Patchesr
r
}
r
(
hZj
h
\
j
ubaubh
)
r
}
r
(
hZX
Using
patch
as
a
context
manager
is
nice
but
if
you
do
multiple
patches
you
can
end
up
with
nested
with
statements
indenting
further
and
further
to
the
right
:
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqMH
hrh
hU
]
r
h
X
Using
patch
as
a
context
manager
is
nice
but
if
you
do
multiple
patches
you
can
end
up
with
nested
with
statements
indenting
further
and
further
to
the
right
:
r
r
}
r
(
hZj
h
\
j
ubaubj
)
r
}
r
(
hZX
>
>
>
class
MyTest
(
TestCase
)
:
.
.
.
.
.
.
def
test_foo
(
self
)
:
.
.
.
with
patch
(
'
mymodule
.
Foo
'
)
as
mock_foo
:
.
.
.
with
patch
(
'
mymodule
.
Bar
'
)
as
mock_bar
:
.
.
.
with
patch
(
'
mymodule
.
Spam
'
)
as
mock_spam
:
.
.
.
assert
mymodule
.
Foo
is
mock_foo
.
.
.
assert
mymodule
.
Bar
is
mock_bar
.
.
.
assert
mymodule
.
Spam
is
mock_spam
.
.
.
>
>
>
original
=
mymodule
.
Foo
>
>
>
MyTest
(
'
test_foo
'
)
.
test_foo
(
)
>
>
>
assert
mymodule
.
Foo
is
originalr
h
\
j
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
!
hj
]
r
"
hl
]
r
#
hn
]
r
U
groupsr
%
]
r
&
h
ah
}
r
'
uhqML
hrh
hU
]
r
(
h
X
>
>
>
class
MyTest
(
TestCase
)
:
.
.
.
.
.
.
def
test_foo
(
self
)
:
.
.
.
with
patch
(
'
mymodule
.
Foo
'
)
as
mock_foo
:
.
.
.
with
patch
(
'
mymodule
.
Bar
'
)
as
mock_bar
:
.
.
.
with
patch
(
'
mymodule
.
Spam
'
)
as
mock_spam
:
.
.
.
assert
mymodule
.
Foo
is
mock_foo
.
.
.
assert
mymodule
.
Bar
is
mock_bar
.
.
.
assert
mymodule
.
Spam
is
mock_spam
.
.
.
>
>
>
original
=
mymodule
.
Foo
>
>
>
MyTest
(
'
test_foo
'
)
.
test_foo
(
)
>
>
>
assert
mymodule
.
Foo
is
originalr
)
r
*
}
r
+
(
hZU
h
\
j
ubaubh
)
r
}
r
-
(
hZX
With
unittest2_
cleanup
functions
and
the
:
ref
:
start
-
and
-
stop
we
can
achieve
the
same
effect
without
the
nested
indentation
.
A
simple
helper
method
create_patch
puts
the
patch
in
place
and
returns
the
created
mock
for
us
:
r
.
h
\
j
h
]
h
hbh
hd
}
r
/
(
hj
]
r0
hl
]
r1
hh
]
r2
hf
]
r3
hn
]
r4
uhqM
\
hrh
hU
]
r5
(
h
X
With
r6
r7
}
r8
(
hZX
With
r9
h
\
j
ubj
)
r
:
}
r
;
(
hZX
unittest2_r
<
j
K
h
\
j
hbj
hd
}
r
=
(
U
namer
>
X
unittest2r
?
j
j
hf
]
r
hh
]
rA
hj
]
rB
hl
]
rC
hn
]
rD
uhU
]
rE
h
X
unittest2rF
rG
}
rH
(
hZU
h
\
j
:
ubaubh
X
rI
}
rJ
(
hZX
h
\
j
ubj
<
)
rK
}
rL
(
hZX
cleanup
rM
hd
}
rN
(
hj
]
rO
hl
]
rP
hh
]
rQ
hf
]
rR
hn
]
rS
uh
\
j
hU
]
rT
h
X
cleanuprU
rV
}
rW
(
hZU
h
\
jK
ubahbjJ
ubh
X
functions
and
the
rX
rY
}
rZ
(
hZX
functions
and
the
r
[
h
\
j
ubh
)
r
\
}
r
]
(
hZX
:
ref
:
start
-
and
-
stop
r
^
h
\
j
h
]
h
hbh
hd
}
r_
(
U
reftyper
X
refra
h
h
X
start
-
and
-
stoprb
U
refdomainrc
X
stdrd
hf
]
re
hh
]
rf
U
refexplicitrg
hj
]
rh
hl
]
ri
hn
]
rj
h
h
uhqM
\
hU
]
rk
h
)
rl
}
rm
(
hZj
^
hd
}
rn
(
hj
]
ro
hl
]
rp
(
h
jd
X
std
-
refrq
ehh
]
rr
hf
]
rs
hn
]
rt
uh
\
j
\
hU
]
ru
h
X
start
-
and
-
stoprv
rw
}
rx
(
hZU
h
\
jl
ubahbh
ubaubh
XX
we
can
achieve
the
same
effect
without
the
nested
indentation
.
A
simple
helper
method
ry
rz
}
r
{
(
hZXX
we
can
achieve
the
same
effect
without
the
nested
indentation
.
A
simple
helper
method
r
|
h
\
j
ubj
<
)
r
}
}
r
~
(
hZX
create_patch
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
create_patchr
r
}
r
(
hZU
h
\
j
}
ubahbjJ
ubh
X
>
puts
the
patch
in
place
and
returns
the
created
mock
for
us
:
r
r
}
r
(
hZX
>
puts
the
patch
in
place
and
returns
the
created
mock
for
us
:
r
h
\
j
ubeubj
)
r
}
r
(
hZX
>
>
>
class
MyTest
(
TestCase
)
:
.
.
.
.
.
.
def
create_patch
(
self
name
)
:
.
.
.
patcher
=
patch
(
name
)
.
.
.
thing
=
patcher
.
start
(
)
.
.
.
self
.
addCleanup
(
patcher
.
stop
)
.
.
.
return
thing
.
.
.
.
.
.
def
test_foo
(
self
)
:
.
.
.
mock_foo
=
self
.
create_patch
(
'
mymodule
.
Foo
'
)
.
.
.
mock_bar
=
self
.
create_patch
(
'
mymodule
.
Bar
'
)
.
.
.
mock_spam
=
self
.
create_patch
(
'
mymodule
.
Spam
'
)
.
.
.
.
.
.
assert
mymodule
.
Foo
is
mock_foo
.
.
.
assert
mymodule
.
Bar
is
mock_bar
.
.
.
assert
mymodule
.
Spam
is
mock_spam
.
.
.
>
>
>
original
=
mymodule
.
Foo
>
>
>
MyTest
(
'
test_foo
'
)
.
run
(
)
>
>
>
assert
mymodule
.
Foo
is
originalr
h
\
j
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqMa
hrh
hU
]
r
h
X
>
>
>
class
MyTest
(
TestCase
)
:
.
.
.
.
.
.
def
create_patch
(
self
name
)
:
.
.
.
patcher
=
patch
(
name
)
.
.
.
thing
=
patcher
.
start
(
)
.
.
.
self
.
addCleanup
(
patcher
.
stop
)
.
.
.
return
thing
.
.
.
.
.
.
def
test_foo
(
self
)
:
.
.
.
mock_foo
=
self
.
create_patch
(
'
mymodule
.
Foo
'
)
.
.
.
mock_bar
=
self
.
create_patch
(
'
mymodule
.
Bar
'
)
.
.
.
mock_spam
=
self
.
create_patch
(
'
mymodule
.
Spam
'
)
.
.
.
.
.
.
assert
mymodule
.
Foo
is
mock_foo
.
.
.
assert
mymodule
.
Bar
is
mock_bar
.
.
.
assert
mymodule
.
Spam
is
mock_spam
.
.
.
>
>
>
original
=
mymodule
.
Foo
>
>
>
MyTest
(
'
test_foo
'
)
.
run
(
)
>
>
>
assert
mymodule
.
Foo
is
originalr
r
}
r
(
hZU
h
\
j
ubaubeubht
)
r
}
r
(
hZU
h
\
huh
]
h
hbhyhd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hNahn
]
r
h
!
auhqMz
hrh
hU
]
r
(
h
)
r
}
r
(
hZX
#
Mocking
a
dictionary
with
MagicMockr
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqMz
hrh
hU
]
r
h
X
#
Mocking
a
dictionary
with
MagicMockr
r
}
r
(
hZj
h
\
j
ubaubh
)
r
}
r
(
hZX
You
may
want
to
mock
a
dictionary
or
other
container
object
recording
all
access
to
it
whilst
having
it
still
behave
like
a
dictionary
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
|
hrh
hU
]
r
h
X
You
may
want
to
mock
a
dictionary
or
other
container
object
recording
all
access
to
it
whilst
having
it
still
behave
like
a
dictionary
.
r
r
}
r
(
hZj
h
\
j
ubaubh
)
r
}
r
(
hZX
We
can
do
this
with
:
class
:
MagicMock
which
will
behave
like
a
dictionary
and
using
:
data
:
~
Mock
.
side_effect
to
delegate
dictionary
access
to
a
real
underlying
dictionary
that
is
under
our
control
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
(
h
X
We
can
do
this
with
r
r
}
r
(
hZX
We
can
do
this
with
r
h
\
j
ubh
)
r
}
r
(
hZX
:
class
:
MagicMock
r
h
\
j
h
]
h
hbh
hd
}
r
(
U
reftyper
X
classr
h
h
X
MagicMockr
U
refdomainr
X
pyr
hf
]
r
hh
]
r
U
refexplicitr
hj
]
r
hl
]
r
hn
]
r
h
h
j
%
Nj
&
j
'
uhqM
hU
]
r
j
)
)
r
}
r
(
hZj
hd
}
r
(
hj
]
r
hl
]
r
(
h
j
X
py
-
classr
ehh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
MagicMockr
r
}
r
(
hZU
h
\
j
ubahbj7
ubaubh
X1
which
will
behave
like
a
dictionary
and
using
r
r
}
r
(
hZX1
which
will
behave
like
a
dictionary
and
using
r
h
\
j
ubh
)
r
}
r
(
hZX
:
data
:
~
Mock
.
side_effect
r
h
\
j
h
]
h
hbh
hd
}
r
(
U
reftyper
X
datar
h
h
X
Mock
.
side_effectr
U
refdomainr
X
pyr
hf
]
r
hh
]
r
U
refexplicitr
hj
]
r
hl
]
r
hn
]
r
h
h
j
%
Nj
&
j
'
uhqM
hU
]
r
j
)
)
r
}
r
(
hZj
hd
}
r
(
hj
]
r
hl
]
r
(
h
j
X
py
-
datar
ehh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
side_effectr
r
}
r
(
hZU
h
\
j
ubahbj7
ubaubh
XY
to
delegate
dictionary
access
to
a
real
underlying
dictionary
that
is
under
our
control
.
r
r
}
r
(
hZXY
to
delegate
dictionary
access
to
a
real
underlying
dictionary
that
is
under
our
control
.
r
h
\
j
ubeubh
)
r
}
r
(
hZX
When
the
__getitem__
and
__setitem__
methods
of
our
MagicMock
are
called
(
normal
dictionary
access
)
then
side_effect
is
called
with
the
key
(
and
in
the
case
of
__setitem__
the
value
too
)
.
We
can
also
control
what
is
returned
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
(
h
X
When
the
r
r
}
r
(
hZX
When
the
r
h
\
j
ubj
<
)
r
!
}
r
"
(
hZX
__getitem__
r
#
hd
}
r
(
hj
]
r
%
hl
]
r
&
hh
]
r
'
hf
]
r
(
hn
]
r
)
uh
\
j
hU
]
r
*
h
X
__getitem__r
+
r
}
r
-
(
hZU
h
\
j
!
ubahbjJ
ubh
X
and
r
.
r
/
}
r0
(
hZX
and
r1
h
\
j
ubj
<
)
r2
}
r3
(
hZX
__setitem__
r4
hd
}
r5
(
hj
]
r6
hl
]
r7
hh
]
r8
hf
]
r9
hn
]
r
:
uh
\
j
hU
]
r
;
h
X
__setitem__r
<
r
=
}
r
>
(
hZU
h
\
j2
ubahbjJ
ubh
X
methods
of
our
r
?
r
}
rA
(
hZX
methods
of
our
rB
h
\
j
ubj
<
)
rC
}
rD
(
hZX
MagicMock
rE
hd
}
rF
(
hj
]
rG
hl
]
rH
hh
]
rI
hf
]
rJ
hn
]
rK
uh
\
j
hU
]
rL
h
X
MagicMockrM
rN
}
rO
(
hZU
h
\
jC
ubahbjJ
ubh
X
are
called
(
normal
dictionary
access
)
then
rP
rQ
}
rR
(
hZX
are
called
(
normal
dictionary
access
)
then
rS
h
\
j
ubj
<
)
rT
}
rU
(
hZX
side_effect
rV
hd
}
rW
(
hj
]
rX
hl
]
rY
hh
]
rZ
hf
]
r
[
hn
]
r
\
uh
\
j
hU
]
r
]
h
X
side_effectr
^
r_
}
r
(
hZU
h
\
jT
ubahbjJ
ubh
X
is
called
with
the
key
(
and
in
the
case
of
ra
rb
}
rc
(
hZX
is
called
with
the
key
(
and
in
the
case
of
rd
h
\
j
ubj
<
)
re
}
rf
(
hZX
__setitem__
rg
hd
}
rh
(
hj
]
ri
hl
]
rj
hh
]
rk
hf
]
rl
hn
]
rm
uh
\
j
hU
]
rn
h
X
__setitem__ro
rp
}
rq
(
hZU
h
\
je
ubahbjJ
ubh
X6
the
value
too
)
.
We
can
also
control
what
is
returned
.
rr
rs
}
rt
(
hZX6
the
value
too
)
.
We
can
also
control
what
is
returned
.
ru
h
\
j
ubeubh
)
rv
}
rw
(
hZX
After
the
MagicMock
has
been
used
we
can
use
attributes
like
:
data
:
~
Mock
.
call_args_list
to
assert
about
how
the
dictionary
was
used
:
rx
h
\
j
h
]
h
hbh
hd
}
ry
(
hj
]
rz
hl
]
r
{
hh
]
r
|
hf
]
r
}
hn
]
r
~
uhqM
hrh
hU
]
r
(
h
X
After
the
r
r
}
r
(
hZX
After
the
r
h
\
jv
ubj
<
)
r
}
r
(
hZX
MagicMock
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
jv
hU
]
r
h
X
MagicMockr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
*
has
been
used
we
can
use
attributes
like
r
r
}
r
(
hZX
*
has
been
used
we
can
use
attributes
like
r
h
\
jv
ubh
)
r
}
r
(
hZX
:
data
:
~
Mock
.
call_args_list
r
h
\
jv
h
]
h
hbh
hd
}
r
(
U
reftyper
X
datar
h
h
X
Mock
.
call_args_listr
U
refdomainr
X
pyr
hf
]
r
hh
]
r
U
refexplicitr
hj
]
r
hl
]
r
hn
]
r
h
h
j
%
Nj
&
j
'
uhqM
hU
]
r
j
)
)
r
}
r
(
hZj
hd
}
r
(
hj
]
r
hl
]
r
(
h
j
X
py
-
datar
ehh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
call_args_listr
r
}
r
(
hZU
h
\
j
ubahbj7
ubaubh
X
-
to
assert
about
how
the
dictionary
was
used
:
r
r
}
r
(
hZX
-
to
assert
about
how
the
dictionary
was
used
:
r
h
\
jv
ubeubj
)
r
}
r
(
hZX
>
>
>
my_dict
=
{
'
a
'
:
1
'
b
'
:
2
'
c
'
:
3
}
>
>
>
def
getitem
(
name
)
:
.
.
.
return
my_dict
[
name
]
.
.
.
>
>
>
def
setitem
(
name
val
)
:
.
.
.
my_dict
[
name
]
=
val
.
.
.
>
>
>
mock
=
MagicMock
(
)
>
>
>
mock
.
__getitem__
.
side_effect
=
getitem
>
>
>
mock
.
__setitem__
.
side_effect
=
setitemr
h
\
j
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqM
hrh
hU
]
r
h
X
>
>
>
my_dict
=
{
'
a
'
:
1
'
b
'
:
2
'
c
'
:
3
}
>
>
>
def
getitem
(
name
)
:
.
.
.
return
my_dict
[
name
]
.
.
.
>
>
>
def
setitem
(
name
val
)
:
.
.
.
my_dict
[
name
]
=
val
.
.
.
>
>
>
mock
=
MagicMock
(
)
>
>
>
mock
.
__getitem__
.
side_effect
=
getitem
>
>
>
mock
.
__setitem__
.
side_effect
=
setitemr
r
}
r
(
hZU
h
\
j
ubaubj
)
r
}
r
(
hZXF
An
alternative
to
using
MagicMock
is
to
use
Mock
and
*
only
*
provide
the
magic
methods
you
specifically
want
:
.
.
doctest
:
:
>
>
>
mock
=
Mock
(
)
>
>
>
mock
.
__setitem__
=
Mock
(
side_effect
=
getitem
)
>
>
>
mock
.
__getitem__
=
Mock
(
side_effect
=
setitem
)
A
*
third
*
option
is
to
use
MagicMock
but
passing
in
dict
as
the
spec
(
or
spec_set
)
argument
so
that
the
MagicMock
created
only
has
dictionary
magic
methods
available
:
.
.
doctest
:
:
>
>
>
mock
=
MagicMock
(
spec_set
=
dict
)
>
>
>
mock
.
__getitem__
.
side_effect
=
getitem
>
>
>
mock
.
__setitem__
.
side_effect
=
setitemr
h
\
j
h
]
Nhbj
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqNhrh
hU
]
r
(
h
)
r
}
r
(
hZXp
An
alternative
to
using
MagicMock
is
to
use
Mock
and
*
only
*
provide
the
magic
methods
you
specifically
want
:
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hU
]
r
(
h
X
An
alternative
to
using
r
r
}
r
(
hZX
An
alternative
to
using
r
h
\
j
ubj
<
)
r
}
r
(
hZX
MagicMock
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
MagicMockr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
is
to
use
r
r
}
r
(
hZX
is
to
use
r
h
\
j
ubj
<
)
r
}
r
(
hZX
Mock
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
Mockr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
and
r
r
}
r
(
hZX
and
r
h
\
j
ubh
)
r
}
r
(
hZX
*
only
*
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
onlyr
r
}
r
(
hZU
h
\
j
ubahbh
ubh
X1
provide
the
magic
methods
you
specifically
want
:
r
r
}
r
(
hZX1
provide
the
magic
methods
you
specifically
want
:
r
h
\
j
ubeubj
)
r
}
r
(
hZXs
>
>
>
mock
=
Mock
(
)
>
>
>
mock
.
__setitem__
=
Mock
(
side_effect
=
getitem
)
>
>
>
mock
.
__getitem__
=
Mock
(
side_effect
=
setitem
)
r
h
\
j
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqM
hU
]
r
!
h
Xs
>
>
>
mock
=
Mock
(
)
>
>
>
mock
.
__setitem__
=
Mock
(
side_effect
=
getitem
)
>
>
>
mock
.
__getitem__
=
Mock
(
side_effect
=
setitem
)
r
"
r
#
}
r
(
hZU
h
\
j
ubaubh
)
r
%
}
r
&
(
hZX
A
*
third
*
option
is
to
use
MagicMock
but
passing
in
dict
as
the
spec
(
or
spec_set
)
argument
so
that
the
MagicMock
created
only
has
dictionary
magic
methods
available
:
r
'
h
\
j
h
]
h
hbh
hd
}
r
(
(
hj
]
r
)
hl
]
r
*
hh
]
r
+
hf
]
r
hn
]
r
-
uhqM
hU
]
r
.
(
h
X
A
r
/
r0
}
r1
(
hZX
A
r2
h
\
j
%
ubh
)
r3
}
r4
(
hZX
*
third
*
r5
hd
}
r6
(
hj
]
r7
hl
]
r8
hh
]
r9
hf
]
r
:
hn
]
r
;
uh
\
j
%
hU
]
r
<
h
X
thirdr
=
r
>
}
r
?
(
hZU
h
\
j3
ubahbh
ubh
X
option
is
to
use
r
rA
}
rB
(
hZX
option
is
to
use
rC
h
\
j
%
ubj
<
)
rD
}
rE
(
hZX
MagicMock
rF
hd
}
rG
(
hj
]
rH
hl
]
rI
hh
]
rJ
hf
]
rK
hn
]
rL
uh
\
j
%
hU
]
rM
h
X
MagicMockrN
rO
}
rP
(
hZU
h
\
jD
ubahbjJ
ubh
X
but
passing
in
rQ
rR
}
rS
(
hZX
but
passing
in
rT
h
\
j
%
ubj
<
)
rU
}
rV
(
hZX
dict
rW
hd
}
rX
(
hj
]
rY
hl
]
rZ
hh
]
r
[
hf
]
r
\
hn
]
r
]
uh
\
j
%
hU
]
r
^
h
X
dictr_
r
}
ra
(
hZU
h
\
jU
ubahbjJ
ubh
X
as
the
rb
rc
}
rd
(
hZX
as
the
re
h
\
j
%
ubj
<
)
rf
}
rg
(
hZX
spec
rh
hd
}
ri
(
hj
]
rj
hl
]
rk
hh
]
rl
hf
]
rm
hn
]
rn
uh
\
j
%
hU
]
ro
h
X
specrp
rq
}
rr
(
hZU
h
\
jf
ubahbjJ
ubh
X
(
or
rs
rt
}
ru
(
hZX
(
or
rv
h
\
j
%
ubj
<
)
rw
}
rx
(
hZX
spec_set
ry
hd
}
rz
(
hj
]
r
{
hl
]
r
|
hh
]
r
}
hf
]
r
~
hn
]
r
uh
\
j
%
hU
]
r
h
X
spec_setr
r
}
r
(
hZU
h
\
jw
ubahbjJ
ubh
X
)
argument
so
that
the
r
r
}
r
(
hZX
)
argument
so
that
the
r
h
\
j
%
ubj
<
)
r
}
r
(
hZX
MagicMock
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
%
hU
]
r
h
X
MagicMockr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X5
created
only
has
dictionary
magic
methods
available
:
r
r
}
r
(
hZX5
created
only
has
dictionary
magic
methods
available
:
r
h
\
j
%
ubeubj
)
r
}
r
(
hZXy
>
>
>
mock
=
MagicMock
(
spec_set
=
dict
)
>
>
>
mock
.
__getitem__
.
side_effect
=
getitem
>
>
>
mock
.
__setitem__
.
side_effect
=
setitemr
h
\
j
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqM
hU
]
r
h
Xy
>
>
>
mock
=
MagicMock
(
spec_set
=
dict
)
>
>
>
mock
.
__getitem__
.
side_effect
=
getitem
>
>
>
mock
.
__setitem__
.
side_effect
=
setitemr
r
}
r
(
hZU
h
\
j
ubaubeubh
)
r
}
r
(
hZX
With
these
side
effect
functions
in
place
the
mock
will
behave
like
a
normal
dictionary
but
recording
the
access
.
It
even
raises
a
KeyError
if
you
try
to
access
a
key
that
doesn
'
t
exist
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
(
h
X
/
With
these
side
effect
functions
in
place
the
r
r
}
r
(
hZX
/
With
these
side
effect
functions
in
place
the
r
h
\
j
ubj
<
)
r
}
r
(
hZX
mock
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
mockr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
XQ
will
behave
like
a
normal
dictionary
but
recording
the
access
.
It
even
raises
a
r
r
}
r
(
hZXQ
will
behave
like
a
normal
dictionary
but
recording
the
access
.
It
even
raises
a
r
h
\
j
ubj
<
)
r
}
r
(
hZX
KeyError
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
KeyErrorr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
/
if
you
try
to
access
a
key
that
doesn
'
t
exist
.
r
r
}
r
(
hZX
/
if
you
try
to
access
a
key
that
doesn
'
t
exist
.
r
h
\
j
ubeubj
)
r
}
r
(
hZX
>
>
>
mock
[
'
a
'
]
1
>
>
>
mock
[
'
c
'
]
3
>
>
>
mock
[
'
d
'
]
Traceback
(
most
recent
call
last
)
:
.
.
.
KeyError
:
'
d
'
>
>
>
mock
[
'
b
'
]
=
'
fish
'
>
>
>
mock
[
'
d
'
]
=
'
eggs
'
>
>
>
mock
[
'
b
'
]
'
fish
'
>
>
>
mock
[
'
d
'
]
'
eggs
'
r
h
\
j
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqM
hrh
hU
]
r
h
X
>
>
>
mock
[
'
a
'
]
1
>
>
>
mock
[
'
c
'
]
3
>
>
>
mock
[
'
d
'
]
Traceback
(
most
recent
call
last
)
:
.
.
.
KeyError
:
'
d
'
>
>
>
mock
[
'
b
'
]
=
'
fish
'
>
>
>
mock
[
'
d
'
]
=
'
eggs
'
>
>
>
mock
[
'
b
'
]
'
fish
'
>
>
>
mock
[
'
d
'
]
'
eggs
'
r
r
}
r
(
hZU
h
\
j
ubaubh
)
r
}
r
(
hZXm
After
it
has
been
used
you
can
make
assertions
about
the
access
using
the
normal
mock
methods
and
attributes
:
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
h
Xm
After
it
has
been
used
you
can
make
assertions
about
the
access
using
the
normal
mock
methods
and
attributes
:
r
r
}
r
(
hZj
h
\
j
ubaubj
)
r
}
r
(
hZX
>
>
>
mock
.
__getitem__
.
call_args_list
[
call
(
'
a
'
)
call
(
'
c
'
)
call
(
'
d
'
)
call
(
'
b
'
)
call
(
'
d
'
)
]
>
>
>
mock
.
__setitem__
.
call_args_list
[
call
(
'
b
'
'
fish
'
)
call
(
'
d
'
'
eggs
'
)
]
>
>
>
my_dict
{
'
a
'
:
1
'
c
'
:
3
'
b
'
:
'
fish
'
'
d
'
:
'
eggs
'
}
r
h
\
j
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqM
hrh
hU
]
r
h
X
>
>
>
mock
.
__getitem__
.
call_args_list
[
call
(
'
a
'
)
call
(
'
c
'
)
call
(
'
d
'
)
call
(
'
b
'
)
call
(
'
d
'
)
]
>
>
>
mock
.
__setitem__
.
call_args_list
[
call
(
'
b
'
'
fish
'
)
call
(
'
d
'
'
eggs
'
)
]
>
>
>
my_dict
{
'
a
'
:
1
'
c
'
:
3
'
b
'
:
'
fish
'
'
d
'
:
'
eggs
'
}
r
r
}
r
(
hZU
h
\
j
ubaubeubht
)
r
}
r
(
hZU
h
\
huh
]
h
hbhyhd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
h2ahn
]
r
h
auhqM
hrh
hU
]
r
(
h
)
r
}
r
(
hZX
Mock
subclasses
and
their
attributesr
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
h
X
Mock
subclasses
and
their
attributesr
r
}
r
!
(
hZj
h
\
j
ubaubh
)
r
"
}
r
#
(
hZX
There
are
various
reasons
why
you
might
want
to
subclass
Mock
.
One
reason
might
be
to
add
helper
methods
.
Here
'
s
a
silly
example
:
r
h
\
j
h
]
h
hbh
hd
}
r
%
(
hj
]
r
&
hl
]
r
'
hh
]
r
(
hf
]
r
)
hn
]
r
*
uhqM
hrh
hU
]
r
+
(
h
X9
There
are
various
reasons
why
you
might
want
to
subclass
r
r
-
}
r
.
(
hZX9
There
are
various
reasons
why
you
might
want
to
subclass
r
/
h
\
j
"
ubj
<
)
r0
}
r1
(
hZX
Mock
r2
hd
}
r3
(
hj
]
r4
hl
]
r5
hh
]
r6
hf
]
r7
hn
]
r8
uh
\
j
"
hU
]
r9
h
X
Mockr
:
r
;
}
r
<
(
hZU
h
\
j0
ubahbjJ
ubh
XD
.
One
reason
might
be
to
add
helper
methods
.
Here
'
s
a
silly
example
:
r
=
r
>
}
r
?
(
hZXD
.
One
reason
might
be
to
add
helper
methods
.
Here
'
s
a
silly
example
:
r
h
\
j
"
ubeubj
)
rA
}
rB
(
hZX
>
>
>
class
MyMock
(
MagicMock
)
:
.
.
.
def
has_been_called
(
self
)
:
.
.
.
return
self
.
called
.
.
.
>
>
>
mymock
=
MyMock
(
return_value
=
None
)
>
>
>
mymock
<
MyMock
id
=
'
.
.
.
'
>
>
>
>
mymock
.
has_been_called
(
)
False
>
>
>
mymock
(
)
>
>
>
mymock
.
has_been_called
(
)
TruerC
h
\
j
h
]
h
hbj
hd
}
rD
(
U
testnodetyperE
X
doctestrF
h
h
hf
]
rG
hh
]
rH
hj
]
rI
hl
]
rJ
hn
]
rK
U
groupsrL
]
rM
h
ah
}
rN
uhqM
hrh
hU
]
rO
h
X
>
>
>
class
MyMock
(
MagicMock
)
:
.
.
.
def
has_been_called
(
self
)
:
.
.
.
return
self
.
called
.
.
.
>
>
>
mymock
=
MyMock
(
return_value
=
None
)
>
>
>
mymock
<
MyMock
id
=
'
.
.
.
'
>
>
>
>
mymock
.
has_been_called
(
)
False
>
>
>
mymock
(
)
>
>
>
mymock
.
has_been_called
(
)
TruerP
rQ
}
rR
(
hZU
h
\
jA
ubaubh
)
rS
}
rT
(
hZX
The
standard
behaviour
for
Mock
instances
is
that
attributes
and
the
return
value
mocks
are
of
the
same
type
as
the
mock
they
are
accessed
on
.
This
ensures
that
Mock
attributes
are
Mocks
and
MagicMock
attributes
are
MagicMocks
[
#
]
_
.
So
if
you
'
re
subclassing
to
add
helper
methods
then
they
'
ll
also
be
available
on
the
attributes
and
return
value
mock
of
instances
of
your
subclass
.
rU
h
\
j
h
]
h
hbh
hd
}
rV
(
hj
]
rW
hl
]
rX
hh
]
rY
hf
]
rZ
hn
]
r
[
uhqM
hrh
hU
]
r
\
(
h
X
The
standard
behaviour
for
r
]
r
^
}
r_
(
hZX
The
standard
behaviour
for
r
h
\
jS
ubj
<
)
ra
}
rb
(
hZX
Mock
rc
hd
}
rd
(
hj
]
re
hl
]
rf
hh
]
rg
hf
]
rh
hn
]
ri
uh
\
jS
hU
]
rj
h
X
Mockrk
rl
}
rm
(
hZU
h
\
ja
ubahbjJ
ubh
X
instances
is
that
attributes
and
the
return
value
mocks
are
of
the
same
type
as
the
mock
they
are
accessed
on
.
This
ensures
that
rn
ro
}
rp
(
hZX
instances
is
that
attributes
and
the
return
value
mocks
are
of
the
same
type
as
the
mock
they
are
accessed
on
.
This
ensures
that
rq
h
\
jS
ubj
<
)
rr
}
rs
(
hZX
Mock
rt
hd
}
ru
(
hj
]
rv
hl
]
rw
hh
]
rx
hf
]
ry
hn
]
rz
uh
\
jS
hU
]
r
{
h
X
Mockr
|
r
}
}
r
~
(
hZU
h
\
jr
ubahbjJ
ubh
X
attributes
are
r
r
}
r
(
hZX
attributes
are
r
h
\
jS
ubj
<
)
r
}
r
(
hZX
Mocks
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
jS
hU
]
r
h
X
Mocksr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
and
r
r
}
r
(
hZX
and
r
h
\
jS
ubj
<
)
r
}
r
(
hZX
MagicMock
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
jS
hU
]
r
h
X
MagicMockr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
attributes
are
r
r
}
r
(
hZX
attributes
are
r
h
\
jS
ubj
<
)
r
}
r
(
hZX
MagicMocks
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
jS
hU
]
r
h
X
MagicMocksr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
r
}
r
(
hZX
h
\
jS
ubj
)
r
}
r
(
hZX
[
#
]
_r
j
K
h
\
jS
hbj
hd
}
r
(
j
K
hf
]
r
U
id4r
ahh
]
r
hj
]
r
hl
]
r
hn
]
r
hphGuhU
]
r
h
X
2
r
}
r
(
hZU
h
\
j
ubaubh
X
.
So
if
you
'
re
subclassing
to
add
helper
methods
then
they
'
ll
also
be
available
on
the
attributes
and
return
value
mock
of
instances
of
your
subclass
.
r
r
}
r
(
hZX
.
So
if
you
'
re
subclassing
to
add
helper
methods
then
they
'
ll
also
be
available
on
the
attributes
and
return
value
mock
of
instances
of
your
subclass
.
r
h
\
jS
ubeubj
)
r
}
r
(
hZX
>
>
>
mymock
.
foo
<
MyMock
name
=
'
mock
.
foo
'
id
=
'
.
.
.
'
>
>
>
>
mymock
.
foo
.
has_been_called
(
)
False
>
>
>
mymock
.
foo
(
)
<
MyMock
name
=
'
mock
.
foo
(
)
'
id
=
'
.
.
.
'
>
>
>
>
mymock
.
foo
.
has_been_called
(
)
Truer
h
\
j
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqM
hrh
hU
]
r
h
X
>
>
>
mymock
.
foo
<
MyMock
name
=
'
mock
.
foo
'
id
=
'
.
.
.
'
>
>
>
>
mymock
.
foo
.
has_been_called
(
)
False
>
>
>
mymock
.
foo
(
)
<
MyMock
name
=
'
mock
.
foo
(
)
'
id
=
'
.
.
.
'
>
>
>
>
mymock
.
foo
.
has_been_called
(
)
Truer
r
}
r
(
hZU
h
\
j
ubaubh
)
r
}
r
(
hZX0
Sometimes
this
is
inconvenient
.
For
example
one
user
<
https
:
/
/
code
.
google
.
com
/
p
/
mock
/
issues
/
detail
?
id
=
105
>
_
is
subclassing
mock
to
created
a
Twisted
adaptor
<
http
:
/
/
twistedmatrix
.
com
/
documents
/
11
.
0
.
0
/
api
/
twisted
.
python
.
components
.
html
>
_
.
Having
this
applied
to
attributes
too
actually
causes
errors
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
(
h
X
-
Sometimes
this
is
inconvenient
.
For
example
r
r
}
r
(
hZX
-
Sometimes
this
is
inconvenient
.
For
example
r
h
\
j
ubj
)
r
}
r
(
hZXA
one
user
<
https
:
/
/
code
.
google
.
com
/
p
/
mock
/
issues
/
detail
?
id
=
105
>
_r
hd
}
r
(
U
namer
X
one
userr
j
X3
https
:
/
/
code
.
google
.
com
/
p
/
mock
/
issues
/
detail
?
id
=
105r
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
one
userr
r
}
r
(
hZU
h
\
j
ubahbj
ubhW
)
r
}
r
(
hZX6
<
https
:
/
/
code
.
google
.
com
/
p
/
mock
/
issues
/
detail
?
id
=
105
>
r
j
K
h
\
j
hbhchd
}
r
(
U
refurir
j
hf
]
r
hSahh
]
r
hj
]
r
hl
]
r
hn
]
r
h
&
auhU
]
r
ubh
X
"
is
subclassing
mock
to
created
a
r
r
}
r
(
hZX
"
is
subclassing
mock
to
created
a
r
h
\
j
ubj
)
r
}
r
(
hZXa
Twisted
adaptor
<
http
:
/
/
twistedmatrix
.
com
/
documents
/
11
.
0
.
0
/
api
/
twisted
.
python
.
components
.
html
>
_r
hd
}
r
(
U
namer
X
Twisted
adaptorr
j
XL
http
:
/
/
twistedmatrix
.
com
/
documents
/
11
.
0
.
0
/
api
/
twisted
.
python
.
components
.
htmlr
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
Twisted
adaptorr
r
}
r
(
hZU
h
\
j
ubahbj
ubhW
)
r
}
r
(
hZXO
<
http
:
/
/
twistedmatrix
.
com
/
documents
/
11
.
0
.
0
/
api
/
twisted
.
python
.
components
.
html
>
r
j
K
h
\
j
hbhchd
}
r
(
U
refurir
j
hf
]
r
h
<
ahh
]
r
hj
]
r
hl
]
r
hn
]
r
h
auhU
]
r
ubh
X
?
.
Having
this
applied
to
attributes
too
actually
causes
errors
.
r
r
}
r
!
(
hZX
?
.
Having
this
applied
to
attributes
too
actually
causes
errors
.
r
"
h
\
j
ubeubh
)
r
#
}
r
(
hZXM
Mock
(
in
all
its
flavours
)
uses
a
method
called
_get_child_mock
to
create
these
"
sub
-
mocks
"
for
attributes
and
return
values
.
You
can
prevent
your
subclass
being
used
for
attributes
by
overriding
this
method
.
The
signature
is
that
it
takes
arbitrary
keyword
arguments
(
*
*
kwargs
)
which
are
then
passed
onto
the
mock
constructor
:
r
%
h
\
j
h
]
h
hbh
hd
}
r
&
(
hj
]
r
'
hl
]
r
(
hh
]
r
)
hf
]
r
*
hn
]
r
+
uhqM
hrh
hU
]
r
(
j
<
)
r
-
}
r
.
(
hZX
Mock
r
/
hd
}
r0
(
hj
]
r1
hl
]
r2
hh
]
r3
hf
]
r4
hn
]
r5
uh
\
j
#
hU
]
r6
h
X
Mockr7
r8
}
r9
(
hZU
h
\
j
-
ubahbjJ
ubh
X
(
in
all
its
flavours
)
uses
a
method
called
r
:
r
;
}
r
<
(
hZX
(
in
all
its
flavours
)
uses
a
method
called
r
=
h
\
j
#
ubj
<
)
r
>
}
r
?
(
hZX
_get_child_mock
r
hd
}
rA
(
hj
]
rB
hl
]
rC
hh
]
rD
hf
]
rE
hn
]
rF
uh
\
j
#
hU
]
rG
h
X
_get_child_mockrH
rI
}
rJ
(
hZU
h
\
j
>
ubahbjJ
ubh
X
to
create
these
"
sub
-
mocks
"
for
attributes
and
return
values
.
You
can
prevent
your
subclass
being
used
for
attributes
by
overriding
this
method
.
The
signature
is
that
it
takes
arbitrary
keyword
arguments
(
rK
rL
}
rM
(
hZX
to
create
these
"
sub
-
mocks
"
for
attributes
and
return
values
.
You
can
prevent
your
subclass
being
used
for
attributes
by
overriding
this
method
.
The
signature
is
that
it
takes
arbitrary
keyword
arguments
(
rN
h
\
j
#
ubj
<
)
rO
}
rP
(
hZX
*
*
kwargs
rQ
hd
}
rR
(
hj
]
rS
hl
]
rT
hh
]
rU
hf
]
rV
hn
]
rW
uh
\
j
#
hU
]
rX
h
X
*
*
kwargsrY
rZ
}
r
[
(
hZU
h
\
jO
ubahbjJ
ubh
X2
)
which
are
then
passed
onto
the
mock
constructor
:
r
\
r
]
}
r
^
(
hZX2
)
which
are
then
passed
onto
the
mock
constructor
:
r_
h
\
j
#
ubeubj
)
r
}
ra
(
hZXH
>
>
>
class
Subclass
(
MagicMock
)
:
.
.
.
def
_get_child_mock
(
self
*
*
kwargs
)
:
.
.
.
return
MagicMock
(
*
*
kwargs
)
.
.
.
>
>
>
mymock
=
Subclass
(
)
>
>
>
mymock
.
foo
<
MagicMock
name
=
'
mock
.
foo
'
id
=
'
.
.
.
'
>
>
>
>
assert
isinstance
(
mymock
Subclass
)
>
>
>
assert
not
isinstance
(
mymock
.
foo
Subclass
)
>
>
>
assert
not
isinstance
(
mymock
(
)
Subclass
)
rb
h
\
j
h
]
h
hbj
hd
}
rc
(
U
testnodetyperd
X
doctestre
h
h
hf
]
rf
hh
]
rg
hj
]
rh
hl
]
ri
hn
]
rj
U
groupsrk
]
rl
h
ah
}
rm
uhqM
hrh
hU
]
rn
h
XH
>
>
>
class
Subclass
(
MagicMock
)
:
.
.
.
def
_get_child_mock
(
self
*
*
kwargs
)
:
.
.
.
return
MagicMock
(
*
*
kwargs
)
.
.
.
>
>
>
mymock
=
Subclass
(
)
>
>
>
mymock
.
foo
<
MagicMock
name
=
'
mock
.
foo
'
id
=
'
.
.
.
'
>
>
>
>
assert
isinstance
(
mymock
Subclass
)
>
>
>
assert
not
isinstance
(
mymock
.
foo
Subclass
)
>
>
>
assert
not
isinstance
(
mymock
(
)
Subclass
)
ro
rp
}
rq
(
hZU
h
\
j
ubaubjX
)
rr
}
rs
(
hZX
An
exception
to
this
rule
are
the
non
-
callable
mocks
.
Attributes
use
the
callable
variant
because
otherwise
non
-
callable
mocks
couldn
'
t
have
callable
methods
.
rt
h
\
j
h
]
h
hbj
\
hd
}
ru
(
j
K
hf
]
rv
hGahh
]
rw
j
ahj
]
rx
hl
]
ry
hn
]
rz
U
2auhqM
hrh
hU
]
r
{
(
jd
)
r
|
}
r
}
(
hZU
h
\
jr
h
]
Nhbjg
hd
}
r
~
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqNhrh
hU
]
r
h
X
2
r
}
r
(
hZU
h
\
j
|
ubaubh
)
r
}
r
(
hZX
An
exception
to
this
rule
are
the
non
-
callable
mocks
.
Attributes
use
the
callable
variant
because
otherwise
non
-
callable
mocks
couldn
'
t
have
callable
methods
.
r
h
\
jr
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hU
]
r
h
X
An
exception
to
this
rule
are
the
non
-
callable
mocks
.
Attributes
use
the
callable
variant
because
otherwise
non
-
callable
mocks
couldn
'
t
have
callable
methods
.
r
r
}
r
(
hZj
h
\
j
ubaubeubeubht
)
r
}
r
(
hZU
h
\
huh
]
h
hbhyhd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hTahn
]
r
h
'
auhqM
hrh
hU
]
r
(
h
)
r
}
r
(
hZX
Mocking
imports
with
patch
.
dictr
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
h
X
Mocking
imports
with
patch
.
dictr
r
}
r
(
hZj
h
\
j
ubaubh
)
r
}
r
(
hZX
One
situation
where
mocking
can
be
hard
is
where
you
have
a
local
import
inside
a
function
.
These
are
harder
to
mock
because
they
aren
'
t
using
an
object
from
the
module
namespace
that
we
can
patch
out
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
h
X
One
situation
where
mocking
can
be
hard
is
where
you
have
a
local
import
inside
a
function
.
These
are
harder
to
mock
because
they
aren
'
t
using
an
object
from
the
module
namespace
that
we
can
patch
out
.
r
r
}
r
(
hZj
h
\
j
ubaubh
)
r
}
r
(
hZX
Generally
local
imports
are
to
be
avoided
.
They
are
sometimes
done
to
prevent
circular
dependencies
for
which
there
is
*
usually
*
a
much
better
way
to
solve
the
problem
(
refactor
the
code
)
or
to
prevent
"
up
front
costs
"
by
delaying
the
import
.
This
can
also
be
solved
in
better
ways
than
an
unconditional
local
import
(
store
the
module
as
a
class
or
module
attribute
and
only
do
the
import
on
first
use
)
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
(
h
Xx
Generally
local
imports
are
to
be
avoided
.
They
are
sometimes
done
to
prevent
circular
dependencies
for
which
there
is
r
r
}
r
(
hZXx
Generally
local
imports
are
to
be
avoided
.
They
are
sometimes
done
to
prevent
circular
dependencies
for
which
there
is
r
h
\
j
ubh
)
r
}
r
(
hZX
*
usually
*
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
usuallyr
r
}
r
(
hZU
h
\
j
ubahbh
ubh
X
a
much
better
way
to
solve
the
problem
(
refactor
the
code
)
or
to
prevent
"
up
front
costs
"
by
delaying
the
import
.
This
can
also
be
solved
in
better
ways
than
an
unconditional
local
import
(
store
the
module
as
a
class
or
module
attribute
and
only
do
the
import
on
first
use
)
.
r
r
}
r
(
hZX
a
much
better
way
to
solve
the
problem
(
refactor
the
code
)
or
to
prevent
"
up
front
costs
"
by
delaying
the
import
.
This
can
also
be
solved
in
better
ways
than
an
unconditional
local
import
(
store
the
module
as
a
class
or
module
attribute
and
only
do
the
import
on
first
use
)
.
r
h
\
j
ubeubh
)
r
}
r
(
hZX
That
aside
there
is
a
way
to
use
mock
to
affect
the
results
of
an
import
.
Importing
fetches
an
*
object
*
from
the
sys
.
modules
dictionary
.
Note
that
it
fetches
an
*
object
*
which
need
not
be
a
module
.
Importing
a
module
for
the
first
time
results
in
a
module
object
being
put
in
sys
.
modules
so
usually
when
you
import
something
you
get
a
module
back
.
This
need
not
be
the
case
however
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
!
hrh
hU
]
r
(
h
X
!
That
aside
there
is
a
way
to
use
r
r
}
r
(
hZX
!
That
aside
there
is
a
way
to
use
r
h
\
j
ubj
<
)
r
}
r
(
hZX
mock
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
mockr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
:
to
affect
the
results
of
an
import
.
Importing
fetches
an
r
r
}
r
(
hZX
:
to
affect
the
results
of
an
import
.
Importing
fetches
an
r
h
\
j
ubh
)
r
}
r
(
hZX
*
object
*
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
objectr
r
}
r
(
hZU
h
\
j
ubahbh
ubh
X
from
the
r
r
}
r
(
hZX
from
the
r
h
\
j
ubj
<
)
r
}
r
(
hZX
sys
.
modules
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
sys
.
modulesr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
%
dictionary
.
Note
that
it
fetches
an
r
r
}
r
(
hZX
%
dictionary
.
Note
that
it
fetches
an
r
h
\
j
ubh
)
r
}
r
(
hZX
*
object
*
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
objectr
!
r
"
}
r
#
(
hZU
h
\
j
ubahbh
ubh
Xl
which
need
not
be
a
module
.
Importing
a
module
for
the
first
time
results
in
a
module
object
being
put
in
r
r
%
}
r
&
(
hZXl
which
need
not
be
a
module
.
Importing
a
module
for
the
first
time
results
in
a
module
object
being
put
in
r
'
h
\
j
ubj
<
)
r
(
}
r
)
(
hZX
sys
.
modules
r
*
hd
}
r
+
(
hj
]
r
hl
]
r
-
hh
]
r
.
hf
]
r
/
hn
]
r0
uh
\
j
hU
]
r1
h
X
sys
.
modulesr2
r3
}
r4
(
hZU
h
\
j
(
ubahbjJ
ubh
X
so
usually
when
you
import
something
you
get
a
module
back
.
This
need
not
be
the
case
however
.
r5
r6
}
r7
(
hZX
so
usually
when
you
import
something
you
get
a
module
back
.
This
need
not
be
the
case
however
.
r8
h
\
j
ubeubh
)
r9
}
r
:
(
hZXV
This
means
you
can
use
:
func
:
patch
.
dict
to
*
temporarily
*
put
a
mock
in
place
in
sys
.
modules
.
Any
imports
whilst
this
patch
is
active
will
fetch
the
mock
.
When
the
patch
is
complete
(
the
decorated
function
exits
the
with
statement
body
is
complete
or
patcher
.
stop
(
)
is
called
)
then
whatever
was
there
previously
will
be
restored
safely
.
r
;
h
\
j
h
]
h
hbh
hd
}
r
<
(
hj
]
r
=
hl
]
r
>
hh
]
r
?
hf
]
r
hn
]
rA
uhqM
(
hrh
hU
]
rB
(
h
X
This
means
you
can
use
rC
rD
}
rE
(
hZX
This
means
you
can
use
rF
h
\
j9
ubh
)
rG
}
rH
(
hZX
:
func
:
patch
.
dict
rI
h
\
j9
h
]
h
hbh
hd
}
rJ
(
U
reftyperK
X
funcrL
h
h
X
patch
.
dictrM
U
refdomainrN
X
pyrO
hf
]
rP
hh
]
rQ
U
refexplicitrR
hj
]
rS
hl
]
rT
hn
]
rU
h
h
j
%
Nj
&
j
'
uhqM
(
hU
]
rV
j
)
)
rW
}
rX
(
hZjI
hd
}
rY
(
hj
]
rZ
hl
]
r
[
(
h
jO
X
py
-
funcr
\
ehh
]
r
]
hf
]
r
^
hn
]
r_
uh
\
jG
hU
]
r
h
X
patch
.
dict
(
)
ra
rb
}
rc
(
hZU
h
\
jW
ubahbj7
ubaubh
X
to
rd
re
}
rf
(
hZX
to
rg
h
\
j9
ubh
)
rh
}
ri
(
hZX
*
temporarily
*
rj
hd
}
rk
(
hj
]
rl
hl
]
rm
hh
]
rn
hf
]
ro
hn
]
rp
uh
\
j9
hU
]
rq
h
X
temporarilyrr
rs
}
rt
(
hZU
h
\
jh
ubahbh
ubh
X
put
a
mock
in
place
in
ru
rv
}
rw
(
hZX
put
a
mock
in
place
in
rx
h
\
j9
ubj
<
)
ry
}
rz
(
hZX
sys
.
modules
r
{
hd
}
r
|
(
hj
]
r
}
hl
]
r
~
hh
]
r
hf
]
r
hn
]
r
uh
\
j9
hU
]
r
h
X
sys
.
modulesr
r
}
r
(
hZU
h
\
jy
ubahbjJ
ubh
X
.
Any
imports
whilst
this
patch
is
active
will
fetch
the
mock
.
When
the
patch
is
complete
(
the
decorated
function
exits
the
with
statement
body
is
complete
or
r
r
}
r
(
hZX
.
Any
imports
whilst
this
patch
is
active
will
fetch
the
mock
.
When
the
patch
is
complete
(
the
decorated
function
exits
the
with
statement
body
is
complete
or
r
h
\
j9
ubj
<
)
r
}
r
(
hZX
patcher
.
stop
(
)
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j9
hU
]
r
h
X
patcher
.
stop
(
)
r
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
XG
is
called
)
then
whatever
was
there
previously
will
be
restored
safely
.
r
r
}
r
(
hZXG
is
called
)
then
whatever
was
there
previously
will
be
restored
safely
.
r
h
\
j9
ubeubh
)
r
}
r
(
hZX5
Here
'
s
an
example
that
mocks
out
the
'
fooble
'
module
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
.
hrh
hU
]
r
h
X5
Here
'
s
an
example
that
mocks
out
the
'
fooble
'
module
.
r
r
}
r
(
hZj
h
\
j
ubaubj
)
r
}
r
(
hZX
>
>
>
mock
=
Mock
(
)
>
>
>
with
patch
.
dict
(
'
sys
.
modules
'
{
'
fooble
'
:
mock
}
)
:
.
.
.
import
fooble
.
.
.
fooble
.
blob
(
)
.
.
.
<
Mock
name
=
'
mock
.
blob
(
)
'
id
=
'
.
.
.
'
>
>
>
>
assert
'
fooble
'
not
in
sys
.
modules
>
>
>
mock
.
blob
.
assert_called_once_with
(
)
r
h
\
j
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqM0
hrh
hU
]
r
h
X
>
>
>
mock
=
Mock
(
)
>
>
>
with
patch
.
dict
(
'
sys
.
modules
'
{
'
fooble
'
:
mock
}
)
:
.
.
.
import
fooble
.
.
.
fooble
.
blob
(
)
.
.
.
<
Mock
name
=
'
mock
.
blob
(
)
'
id
=
'
.
.
.
'
>
>
>
>
assert
'
fooble
'
not
in
sys
.
modules
>
>
>
mock
.
blob
.
assert_called_once_with
(
)
r
r
}
r
(
hZU
h
\
j
ubaubh
)
r
}
r
(
hZXd
As
you
can
see
the
import
fooble
succeeds
but
on
exit
there
is
no
'
fooble
'
left
in
sys
.
modules
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
;
hrh
hU
]
r
(
h
X
As
you
can
see
the
r
r
}
r
(
hZX
As
you
can
see
the
r
h
\
j
ubj
<
)
r
}
r
(
hZX
import
fooble
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
import
foobler
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X4
succeeds
but
on
exit
there
is
no
'
fooble
'
left
in
r
r
}
r
(
hZX4
succeeds
but
on
exit
there
is
no
'
fooble
'
left
in
r
h
\
j
ubj
<
)
r
}
r
(
hZX
sys
.
modules
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
sys
.
modulesr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
.
r
}
r
(
hZX
.
h
\
j
ubeubh
)
r
}
r
(
hZX7
This
also
works
for
the
from
module
import
name
form
:
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
>
hrh
hU
]
r
(
h
X
This
also
works
for
the
r
r
}
r
(
hZX
This
also
works
for
the
r
h
\
j
ubj
<
)
r
}
r
(
hZX
from
module
import
name
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
from
module
import
namer
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
form
:
r
r
}
r
(
hZX
form
:
r
h
\
j
ubeubj
)
r
}
r
(
hZX
>
>
>
mock
=
Mock
(
)
>
>
>
with
patch
.
dict
(
'
sys
.
modules
'
{
'
fooble
'
:
mock
}
)
:
.
.
.
from
fooble
import
blob
.
.
.
blob
.
blip
(
)
.
.
.
<
Mock
name
=
'
mock
.
blob
.
blip
(
)
'
id
=
'
.
.
.
'
>
>
>
>
mock
.
blob
.
blip
.
assert_called_once_with
(
)
r
h
\
j
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqM
hrh
hU
]
r
h
X
>
>
>
mock
=
Mock
(
)
>
>
>
with
patch
.
dict
(
'
sys
.
modules
'
{
'
fooble
'
:
mock
}
)
:
.
.
.
from
fooble
import
blob
.
.
.
blob
.
blip
(
)
.
.
.
<
Mock
name
=
'
mock
.
blob
.
blip
(
)
'
id
=
'
.
.
.
'
>
>
>
>
mock
.
blob
.
blip
.
assert_called_once_with
(
)
r
r
}
r
(
hZU
h
\
j
ubaubh
)
r
}
r
(
hZX
:
With
slightly
more
work
you
can
also
mock
package
imports
:
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
!
uhqMJ
hrh
hU
]
r
"
h
X
:
With
slightly
more
work
you
can
also
mock
package
imports
:
r
#
r
}
r
%
(
hZj
h
\
j
ubaubj
)
r
&
}
r
'
(
hZX
>
>
>
mock
=
Mock
(
)
>
>
>
modules
=
{
'
package
'
:
mock
'
package
.
module
'
:
mock
.
module
}
>
>
>
with
patch
.
dict
(
'
sys
.
modules
'
modules
)
:
.
.
.
from
package
.
module
import
fooble
.
.
.
fooble
(
)
.
.
.
<
Mock
name
=
'
mock
.
module
.
fooble
(
)
'
id
=
'
.
.
.
'
>
>
>
>
mock
.
module
.
fooble
.
assert_called_once_with
(
)
r
(
h
\
j
h
]
h
hbj
hd
}
r
)
(
U
testnodetyper
*
X
doctestr
+
h
h
hf
]
r
hh
]
r
-
hj
]
r
.
hl
]
r
/
hn
]
r0
U
groupsr1
]
r2
h
ah
}
r3
uhqML
hrh
hU
]
r4
h
X
>
>
>
mock
=
Mock
(
)
>
>
>
modules
=
{
'
package
'
:
mock
'
package
.
module
'
:
mock
.
module
}
>
>
>
with
patch
.
dict
(
'
sys
.
modules
'
modules
)
:
.
.
.
from
package
.
module
import
fooble
.
.
.
fooble
(
)
.
.
.
<
Mock
name
=
'
mock
.
module
.
fooble
(
)
'
id
=
'
.
.
.
'
>
>
>
>
mock
.
module
.
fooble
.
assert_called_once_with
(
)
r5
r6
}
r7
(
hZU
h
\
j
&
ubaubeubht
)
r8
}
r9
(
hZU
h
\
huh
]
h
hbhyhd
}
r
:
(
hj
]
r
;
hl
]
r
<
hh
]
r
=
hf
]
r
>
hKahn
]
r
?
h
auhqMY
hrh
hU
]
r
(
h
)
rA
}
rB
(
hZX8
Tracking
order
of
calls
and
less
verbose
call
assertionsrC
h
\
j8
h
]
h
hbh
hd
}
rD
(
hj
]
rE
hl
]
rF
hh
]
rG
hf
]
rH
hn
]
rI
uhqMY
hrh
hU
]
rJ
h
X8
Tracking
order
of
calls
and
less
verbose
call
assertionsrK
rL
}
rM
(
hZjC
h
\
jA
ubaubh
)
rN
}
rO
(
hZX
(
The
:
class
:
Mock
class
allows
you
to
track
the
*
order
*
of
method
calls
on
your
mock
objects
through
the
:
attr
:
~
Mock
.
method_calls
attribute
.
This
doesn
'
t
allow
you
to
track
the
order
of
calls
between
separate
mock
objects
however
we
can
use
:
attr
:
~
Mock
.
mock_calls
to
achieve
the
same
effect
.
rP
h
\
j8
h
]
h
hbh
hd
}
rQ
(
hj
]
rR
hl
]
rS
hh
]
rT
hf
]
rU
hn
]
rV
uhqM
[
hrh
hU
]
rW
(
h
X
The
rX
rY
}
rZ
(
hZX
The
r
[
h
\
jN
ubh
)
r
\
}
r
]
(
hZX
:
class
:
Mock
r
^
h
\
jN
h
]
h
hbh
hd
}
r_
(
U
reftyper
X
classra
h
h
X
Mockrb
U
refdomainrc
X
pyrd
hf
]
re
hh
]
rf
U
refexplicitrg
hj
]
rh
hl
]
ri
hn
]
rj
h
h
j
%
Nj
&
j
'
uhqM
[
hU
]
rk
j
)
)
rl
}
rm
(
hZj
^
hd
}
rn
(
hj
]
ro
hl
]
rp
(
h
jd
X
py
-
classrq
ehh
]
rr
hf
]
rs
hn
]
rt
uh
\
j
\
hU
]
ru
h
X
Mockrv
rw
}
rx
(
hZU
h
\
jl
ubahbj7
ubaubh
X
class
allows
you
to
track
the
ry
rz
}
r
{
(
hZX
class
allows
you
to
track
the
r
|
h
\
jN
ubh
)
r
}
}
r
~
(
hZX
*
order
*
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
jN
hU
]
r
h
X
orderr
r
}
r
(
hZU
h
\
j
}
ubahbh
ubh
X2
of
method
calls
on
your
mock
objects
through
the
r
r
}
r
(
hZX2
of
method
calls
on
your
mock
objects
through
the
r
h
\
jN
ubh
)
r
}
r
(
hZX
:
attr
:
~
Mock
.
method_calls
r
h
\
jN
h
]
h
hbh
hd
}
r
(
U
reftyper
X
attrr
h
h
X
Mock
.
method_callsr
U
refdomainr
X
pyr
hf
]
r
hh
]
r
U
refexplicitr
hj
]
r
hl
]
r
hn
]
r
h
h
j
%
Nj
&
j
'
uhqM
[
hU
]
r
j
)
)
r
}
r
(
hZj
hd
}
r
(
hj
]
r
hl
]
r
(
h
j
X
py
-
attrr
ehh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
method_callsr
r
}
r
(
hZU
h
\
j
ubahbj7
ubaubh
Xq
attribute
.
This
doesn
'
t
allow
you
to
track
the
order
of
calls
between
separate
mock
objects
however
we
can
use
r
r
}
r
(
hZXq
attribute
.
This
doesn
'
t
allow
you
to
track
the
order
of
calls
between
separate
mock
objects
however
we
can
use
r
h
\
jN
ubh
)
r
}
r
(
hZX
:
attr
:
~
Mock
.
mock_calls
r
h
\
jN
h
]
h
hbh
hd
}
r
(
U
reftyper
X
attrr
h
h
X
Mock
.
mock_callsr
U
refdomainr
X
pyr
hf
]
r
hh
]
r
U
refexplicitr
hj
]
r
hl
]
r
hn
]
r
h
h
j
%
Nj
&
j
'
uhqM
[
hU
]
r
j
)
)
r
}
r
(
hZj
hd
}
r
(
hj
]
r
hl
]
r
(
h
j
X
py
-
attrr
ehh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
mock_callsr
r
}
r
(
hZU
h
\
j
ubahbj7
ubaubh
X
to
achieve
the
same
effect
.
r
r
}
r
(
hZX
to
achieve
the
same
effect
.
r
h
\
jN
ubeubh
)
r
}
r
(
hZX
Because
mocks
track
calls
to
child
mocks
in
mock_calls
and
accessing
an
arbitrary
attribute
of
a
mock
creates
a
child
mock
we
can
create
our
separate
mocks
from
a
parent
one
.
Calls
to
those
child
mock
will
then
all
be
recorded
in
order
in
the
mock_calls
of
the
parent
:
r
h
\
j8
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
(
h
X
Because
mocks
track
calls
to
child
mocks
in
r
r
}
r
(
hZX
Because
mocks
track
calls
to
child
mocks
in
r
h
\
j
ubj
<
)
r
}
r
(
hZX
mock_calls
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
mock_callsr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
and
accessing
an
arbitrary
attribute
of
a
mock
creates
a
child
mock
we
can
create
our
separate
mocks
from
a
parent
one
.
Calls
to
those
child
mock
will
then
all
be
recorded
in
order
in
the
r
r
}
r
(
hZX
and
accessing
an
arbitrary
attribute
of
a
mock
creates
a
child
mock
we
can
create
our
separate
mocks
from
a
parent
one
.
Calls
to
those
child
mock
will
then
all
be
recorded
in
order
in
the
r
h
\
j
ubj
<
)
r
}
r
(
hZX
mock_calls
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
mock_callsr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
of
the
parent
:
r
r
}
r
(
hZX
of
the
parent
:
r
h
\
j
ubeubj
)
r
}
r
(
hZX
>
>
>
manager
=
Mock
(
)
>
>
>
mock_foo
=
manager
.
foo
>
>
>
mock_bar
=
manager
.
bar
>
>
>
mock_foo
.
something
(
)
<
Mock
name
=
'
mock
.
foo
.
something
(
)
'
id
=
'
.
.
.
'
>
>
>
>
mock_bar
.
other
.
thing
(
)
<
Mock
name
=
'
mock
.
bar
.
other
.
thing
(
)
'
id
=
'
.
.
.
'
>
>
>
>
manager
.
mock_calls
[
call
.
foo
.
something
(
)
call
.
bar
.
other
.
thing
(
)
]
r
h
\
j8
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqMe
hrh
hU
]
r
h
X
>
>
>
manager
=
Mock
(
)
>
>
>
mock_foo
=
manager
.
foo
>
>
>
mock_bar
=
manager
.
bar
>
>
>
mock_foo
.
something
(
)
<
Mock
name
=
'
mock
.
foo
.
something
(
)
'
id
=
'
.
.
.
'
>
>
>
>
mock_bar
.
other
.
thing
(
)
<
Mock
name
=
'
mock
.
bar
.
other
.
thing
(
)
'
id
=
'
.
.
.
'
>
>
>
>
manager
.
mock_calls
[
call
.
foo
.
something
(
)
call
.
bar
.
other
.
thing
(
)
]
r
r
}
r
(
hZU
h
\
j
ubaubh
)
r
}
r
(
hZXz
We
can
then
assert
about
the
calls
including
the
order
by
comparing
with
the
mock_calls
attribute
on
the
manager
mock
:
r
h
\
j8
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqMs
hrh
hU
]
r
(
h
XO
We
can
then
assert
about
the
calls
including
the
order
by
comparing
with
the
r
r
}
r
(
hZXO
We
can
then
assert
about
the
calls
including
the
order
by
comparing
with
the
r
h
\
j
ubj
<
)
r
}
r
!
(
hZX
mock_calls
r
"
hd
}
r
#
(
hj
]
r
hl
]
r
%
hh
]
r
&
hf
]
r
'
hn
]
r
(
uh
\
j
hU
]
r
)
h
X
mock_callsr
*
r
+
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
attribute
on
the
manager
mock
:
r
-
r
.
}
r
/
(
hZX
attribute
on
the
manager
mock
:
r0
h
\
j
ubeubj
)
r1
}
r2
(
hZXq
>
>
>
expected_calls
=
[
call
.
foo
.
something
(
)
call
.
bar
.
other
.
thing
(
)
]
>
>
>
manager
.
mock_calls
=
=
expected_calls
Truer3
h
\
j8
h
]
h
hbj
hd
}
r4
(
U
testnodetyper5
X
doctestr6
h
h
hf
]
r7
hh
]
r8
hj
]
r9
hl
]
r
:
hn
]
r
;
U
groupsr
<
]
r
=
h
ah
}
r
>
uhqMv
hrh
hU
]
r
?
h
Xq
>
>
>
expected_calls
=
[
call
.
foo
.
something
(
)
call
.
bar
.
other
.
thing
(
)
]
>
>
>
manager
.
mock_calls
=
=
expected_calls
Truer
rA
}
rB
(
hZU
h
\
j1
ubaubh
)
rC
}
rD
(
hZX
If
patch
is
creating
and
putting
in
place
your
mocks
then
you
can
attach
them
to
a
manager
mock
using
the
:
meth
:
~
Mock
.
attach_mock
method
.
After
attaching
calls
will
be
recorded
in
mock_calls
of
the
manager
.
rE
h
\
j8
h
]
h
hbh
hd
}
rF
(
hj
]
rG
hl
]
rH
hh
]
rI
hf
]
rJ
hn
]
rK
uhqM
|
hrh
hU
]
rL
(
h
X
If
rM
rN
}
rO
(
hZX
If
rP
h
\
jC
ubj
<
)
rQ
}
rR
(
hZX
patch
rS
hd
}
rT
(
hj
]
rU
hl
]
rV
hh
]
rW
hf
]
rX
hn
]
rY
uh
\
jC
hU
]
rZ
h
X
patchr
[
r
\
}
r
]
(
hZU
h
\
jQ
ubahbjJ
ubh
Xd
is
creating
and
putting
in
place
your
mocks
then
you
can
attach
them
to
a
manager
mock
using
the
r
^
r_
}
r
(
hZXd
is
creating
and
putting
in
place
your
mocks
then
you
can
attach
them
to
a
manager
mock
using
the
ra
h
\
jC
ubh
)
rb
}
rc
(
hZX
:
meth
:
~
Mock
.
attach_mock
rd
h
\
jC
h
]
h
hbh
hd
}
re
(
U
reftyperf
X
methrg
h
h
X
Mock
.
attach_mockrh
U
refdomainri
X
pyrj
hf
]
rk
hh
]
rl
U
refexplicitrm
hj
]
rn
hl
]
ro
hn
]
rp
h
h
j
%
Nj
&
j
'
uhqM
|
hU
]
rq
j
)
)
rr
}
rs
(
hZjd
hd
}
rt
(
hj
]
ru
hl
]
rv
(
h
jj
X
py
-
methrw
ehh
]
rx
hf
]
ry
hn
]
rz
uh
\
jb
hU
]
r
{
h
X
attach_mock
(
)
r
|
r
}
}
r
~
(
hZU
h
\
jr
ubahbj7
ubaubh
X3
method
.
After
attaching
calls
will
be
recorded
in
r
r
}
r
(
hZX3
method
.
After
attaching
calls
will
be
recorded
in
r
h
\
jC
ubj
<
)
r
}
r
(
hZX
mock_calls
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
jC
hU
]
r
h
X
mock_callsr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
of
the
manager
.
r
r
}
r
(
hZX
of
the
manager
.
r
h
\
jC
ubeubj
)
r
}
r
(
hZX
>
>
>
manager
=
MagicMock
(
)
>
>
>
with
patch
(
'
mymodule
.
Class1
'
)
as
MockClass1
:
.
.
.
with
patch
(
'
mymodule
.
Class2
'
)
as
MockClass2
:
.
.
.
manager
.
attach_mock
(
MockClass1
'
MockClass1
'
)
.
.
.
manager
.
attach_mock
(
MockClass2
'
MockClass2
'
)
.
.
.
MockClass1
(
)
.
foo
(
)
.
.
.
MockClass2
(
)
.
bar
(
)
.
.
.
<
MagicMock
name
=
'
mock
.
MockClass1
(
)
.
foo
(
)
'
id
=
'
.
.
.
'
>
<
MagicMock
name
=
'
mock
.
MockClass2
(
)
.
bar
(
)
'
id
=
'
.
.
.
'
>
>
>
>
manager
.
mock_calls
[
call
.
MockClass1
(
)
call
.
MockClass1
(
)
.
foo
(
)
call
.
MockClass2
(
)
call
.
MockClass2
(
)
.
bar
(
)
]
r
h
\
j8
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqM
hrh
hU
]
r
h
X
>
>
>
manager
=
MagicMock
(
)
>
>
>
with
patch
(
'
mymodule
.
Class1
'
)
as
MockClass1
:
.
.
.
with
patch
(
'
mymodule
.
Class2
'
)
as
MockClass2
:
.
.
.
manager
.
attach_mock
(
MockClass1
'
MockClass1
'
)
.
.
.
manager
.
attach_mock
(
MockClass2
'
MockClass2
'
)
.
.
.
MockClass1
(
)
.
foo
(
)
.
.
.
MockClass2
(
)
.
bar
(
)
.
.
.
<
MagicMock
name
=
'
mock
.
MockClass1
(
)
.
foo
(
)
'
id
=
'
.
.
.
'
>
<
MagicMock
name
=
'
mock
.
MockClass2
(
)
.
bar
(
)
'
id
=
'
.
.
.
'
>
>
>
>
manager
.
mock_calls
[
call
.
MockClass1
(
)
call
.
MockClass1
(
)
.
foo
(
)
call
.
MockClass2
(
)
call
.
MockClass2
(
)
.
bar
(
)
]
r
r
}
r
(
hZU
h
\
j
ubaubh
)
r
}
r
(
hZX
=
If
many
calls
have
been
made
but
you
'
re
only
interested
in
a
particular
sequence
of
them
then
an
alternative
is
to
use
the
:
meth
:
~
Mock
.
assert_has_calls
method
.
This
takes
a
list
of
calls
(
constructed
with
the
:
data
:
call
object
)
.
If
that
sequence
of
calls
are
in
:
attr
:
~
Mock
.
mock_calls
then
the
assert
succeeds
.
r
h
\
j8
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
(
h
X
|
If
many
calls
have
been
made
but
you
'
re
only
interested
in
a
particular
sequence
of
them
then
an
alternative
is
to
use
the
r
r
}
r
(
hZX
|
If
many
calls
have
been
made
but
you
'
re
only
interested
in
a
particular
sequence
of
them
then
an
alternative
is
to
use
the
r
h
\
j
ubh
)
r
}
r
(
hZX
:
meth
:
~
Mock
.
assert_has_calls
r
h
\
j
h
]
h
hbh
hd
}
r
(
U
reftyper
X
methr
h
h
X
Mock
.
assert_has_callsr
U
refdomainr
X
pyr
hf
]
r
hh
]
r
U
refexplicitr
hj
]
r
hl
]
r
hn
]
r
h
h
j
%
Nj
&
j
'
uhqM
hU
]
r
j
)
)
r
}
r
(
hZj
hd
}
r
(
hj
]
r
hl
]
r
(
h
j
X
py
-
methr
ehh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
assert_has_calls
(
)
r
r
}
r
(
hZU
h
\
j
ubahbj7
ubaubh
X
:
method
.
This
takes
a
list
of
calls
(
constructed
with
the
r
r
}
r
(
hZX
:
method
.
This
takes
a
list
of
calls
(
constructed
with
the
r
h
\
j
ubh
)
r
}
r
(
hZX
:
data
:
call
r
h
\
j
h
]
h
hbh
hd
}
r
(
U
reftyper
X
datar
h
h
X
callr
U
refdomainr
X
pyr
hf
]
r
hh
]
r
U
refexplicitr
hj
]
r
hl
]
r
hn
]
r
h
h
j
%
Nj
&
j
'
uhqM
hU
]
r
j
)
)
r
}
r
(
hZj
hd
}
r
(
hj
]
r
hl
]
r
(
h
j
X
py
-
datar
ehh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
callr
r
}
r
(
hZU
h
\
j
ubahbj7
ubaubh
X
+
object
)
.
If
that
sequence
of
calls
are
in
r
r
}
r
(
hZX
+
object
)
.
If
that
sequence
of
calls
are
in
r
h
\
j
ubh
)
r
}
r
(
hZX
:
attr
:
~
Mock
.
mock_calls
r
h
\
j
h
]
h
hbh
hd
}
r
(
U
reftyper
X
attrr
h
h
X
Mock
.
mock_callsr
U
refdomainr
X
pyr
hf
]
r
hh
]
r
U
refexplicitr
hj
]
r
hl
]
r
hn
]
r
h
h
j
%
Nj
&
j
'
uhqM
hU
]
r
j
)
)
r
}
r
(
hZj
hd
}
r
(
hj
]
r
hl
]
r
(
h
j
X
py
-
attrr
ehh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
mock_callsr
r
}
r
(
hZU
h
\
j
ubahbj7
ubaubh
X
then
the
assert
succeeds
.
r
r
}
r
(
hZX
then
the
assert
succeeds
.
r
h
\
j
ubeubj
)
r
}
r
(
hZX
>
>
>
m
=
MagicMock
(
)
>
>
>
m
(
)
.
foo
(
)
.
bar
(
)
.
baz
(
)
<
MagicMock
name
=
'
mock
(
)
.
foo
(
)
.
bar
(
)
.
baz
(
)
'
id
=
'
.
.
.
'
>
>
>
>
m
.
one
(
)
.
two
(
)
.
three
(
)
<
MagicMock
name
=
'
mock
.
one
(
)
.
two
(
)
.
three
(
)
'
id
=
'
.
.
.
'
>
>
>
>
calls
=
call
.
one
(
)
.
two
(
)
.
three
(
)
.
call_list
(
)
>
>
>
m
.
assert_has_calls
(
calls
)
r
h
\
j8
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
!
U
groupsr
"
]
r
#
h
ah
}
r
uhqM
hrh
hU
]
r
%
h
X
>
>
>
m
=
MagicMock
(
)
>
>
>
m
(
)
.
foo
(
)
.
bar
(
)
.
baz
(
)
<
MagicMock
name
=
'
mock
(
)
.
foo
(
)
.
bar
(
)
.
baz
(
)
'
id
=
'
.
.
.
'
>
>
>
>
m
.
one
(
)
.
two
(
)
.
three
(
)
<
MagicMock
name
=
'
mock
.
one
(
)
.
two
(
)
.
three
(
)
'
id
=
'
.
.
.
'
>
>
>
>
calls
=
call
.
one
(
)
.
two
(
)
.
three
(
)
.
call_list
(
)
>
>
>
m
.
assert_has_calls
(
calls
)
r
&
r
'
}
r
(
(
hZU
h
\
j
ubaubh
)
r
)
}
r
*
(
hZX
Even
though
the
chained
call
m
.
one
(
)
.
two
(
)
.
three
(
)
aren
'
t
the
only
calls
that
have
been
made
to
the
mock
the
assert
still
succeeds
.
r
+
h
\
j8
h
]
h
hbh
hd
}
r
(
hj
]
r
-
hl
]
r
.
hh
]
r
/
hf
]
r0
hn
]
r1
uhqM
hrh
hU
]
r2
(
h
X
Even
though
the
chained
call
r3
r4
}
r5
(
hZX
Even
though
the
chained
call
r6
h
\
j
)
ubj
<
)
r7
}
r8
(
hZX
m
.
one
(
)
.
two
(
)
.
three
(
)
r9
hd
}
r
:
(
hj
]
r
;
hl
]
r
<
hh
]
r
=
hf
]
r
>
hn
]
r
?
uh
\
j
)
hU
]
r
h
X
m
.
one
(
)
.
two
(
)
.
three
(
)
rA
rB
}
rC
(
hZU
h
\
j7
ubahbjJ
ubh
XR
aren
'
t
the
only
calls
that
have
been
made
to
the
mock
the
assert
still
succeeds
.
rD
rE
}
rF
(
hZXR
aren
'
t
the
only
calls
that
have
been
made
to
the
mock
the
assert
still
succeeds
.
rG
h
\
j
)
ubeubh
)
rH
}
rI
(
hZX
Sometimes
a
mock
may
have
several
calls
made
to
it
and
you
are
only
interested
in
asserting
about
*
some
*
of
those
calls
.
You
may
not
even
care
about
the
order
.
In
this
case
you
can
pass
any_order
=
True
to
assert_has_calls
:
rJ
h
\
j8
h
]
h
hbh
hd
}
rK
(
hj
]
rL
hl
]
rM
hh
]
rN
hf
]
rO
hn
]
rP
uhqM
hrh
hU
]
rQ
(
h
Xc
Sometimes
a
mock
may
have
several
calls
made
to
it
and
you
are
only
interested
in
asserting
about
rR
rS
}
rT
(
hZXc
Sometimes
a
mock
may
have
several
calls
made
to
it
and
you
are
only
interested
in
asserting
about
rU
h
\
jH
ubh
)
rV
}
rW
(
hZX
*
some
*
rX
hd
}
rY
(
hj
]
rZ
hl
]
r
[
hh
]
r
\
hf
]
r
]
hn
]
r
^
uh
\
jH
hU
]
r_
h
X
somer
ra
}
rb
(
hZU
h
\
jV
ubahbh
ubh
XR
of
those
calls
.
You
may
not
even
care
about
the
order
.
In
this
case
you
can
pass
rc
rd
}
re
(
hZXR
of
those
calls
.
You
may
not
even
care
about
the
order
.
In
this
case
you
can
pass
rf
h
\
jH
ubj
<
)
rg
}
rh
(
hZX
any_order
=
True
ri
hd
}
rj
(
hj
]
rk
hl
]
rl
hh
]
rm
hf
]
rn
hn
]
ro
uh
\
jH
hU
]
rp
h
X
any_order
=
Truerq
rr
}
rs
(
hZU
h
\
jg
ubahbjJ
ubh
X
to
rt
ru
}
rv
(
hZX
to
rw
h
\
jH
ubj
<
)
rx
}
ry
(
hZX
assert_has_calls
rz
hd
}
r
{
(
hj
]
r
|
hl
]
r
}
hh
]
r
~
hf
]
r
hn
]
r
uh
\
jH
hU
]
r
h
X
assert_has_callsr
r
}
r
(
hZU
h
\
jx
ubahbjJ
ubh
X
:
r
}
r
(
hZX
:
h
\
jH
ubeubj
)
r
}
r
(
hZX
>
>
>
m
=
MagicMock
(
)
>
>
>
m
(
1
)
m
.
two
(
2
3
)
m
.
seven
(
7
)
m
.
fifty
(
'
50
'
)
(
.
.
.
)
>
>
>
calls
=
[
call
.
fifty
(
'
50
'
)
call
(
1
)
call
.
seven
(
7
)
]
>
>
>
m
.
assert_has_calls
(
calls
any_order
=
True
)
r
h
\
j8
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqM
hrh
hU
]
r
h
X
>
>
>
m
=
MagicMock
(
)
>
>
>
m
(
1
)
m
.
two
(
2
3
)
m
.
seven
(
7
)
m
.
fifty
(
'
50
'
)
(
.
.
.
)
>
>
>
calls
=
[
call
.
fifty
(
'
50
'
)
call
(
1
)
call
.
seven
(
7
)
]
>
>
>
m
.
assert_has_calls
(
calls
any_order
=
True
)
r
r
}
r
(
hZU
h
\
j
ubaubeubht
)
r
}
r
(
hZU
h
\
huh
]
h
hbhyhd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hHahn
]
r
h
auhqM
hrh
hU
]
r
(
h
)
r
}
r
(
hZX
More
complex
argument
matchingr
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
h
X
More
complex
argument
matchingr
r
}
r
(
hZj
h
\
j
ubaubh
)
r
}
r
(
hZX
Using
the
same
basic
concept
as
ANY
we
can
implement
matchers
to
do
more
complex
assertions
on
objects
used
as
arguments
to
mocks
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
(
h
X
Using
the
same
basic
concept
as
r
r
}
r
(
hZX
Using
the
same
basic
concept
as
r
h
\
j
ubj
<
)
r
}
r
(
hZX
ANY
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
ANYr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X_
we
can
implement
matchers
to
do
more
complex
assertions
on
objects
used
as
arguments
to
mocks
.
r
r
}
r
(
hZX_
we
can
implement
matchers
to
do
more
complex
assertions
on
objects
used
as
arguments
to
mocks
.
r
h
\
j
ubeubh
)
r
}
r
(
hZX
Suppose
we
expect
some
object
to
be
passed
to
a
mock
that
by
default
compares
equal
based
on
object
identity
(
which
is
the
Python
default
for
user
defined
classes
)
.
To
use
:
meth
:
~
Mock
.
assert_called_with
we
would
need
to
pass
in
the
exact
same
object
.
If
we
are
only
interested
in
some
of
the
attributes
of
this
object
then
we
can
create
a
matcher
that
will
check
these
attributes
for
us
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
(
h
X
Suppose
we
expect
some
object
to
be
passed
to
a
mock
that
by
default
compares
equal
based
on
object
identity
(
which
is
the
Python
default
for
user
defined
classes
)
.
To
use
r
r
}
r
(
hZX
Suppose
we
expect
some
object
to
be
passed
to
a
mock
that
by
default
compares
equal
based
on
object
identity
(
which
is
the
Python
default
for
user
defined
classes
)
.
To
use
r
h
\
j
ubh
)
r
}
r
(
hZX
:
meth
:
~
Mock
.
assert_called_with
r
h
\
j
h
]
h
hbh
hd
}
r
(
U
reftyper
X
methr
h
h
X
Mock
.
assert_called_withr
U
refdomainr
X
pyr
hf
]
r
hh
]
r
U
refexplicitr
hj
]
r
hl
]
r
hn
]
r
h
h
j
%
Nj
&
j
'
uhqM
hU
]
r
j
)
)
r
}
r
(
hZj
hd
}
r
(
hj
]
r
hl
]
r
(
h
j
X
py
-
methr
ehh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
assert_called_with
(
)
r
r
}
r
(
hZU
h
\
j
ubahbj7
ubaubh
X
we
would
need
to
pass
in
the
exact
same
object
.
If
we
are
only
interested
in
some
of
the
attributes
of
this
object
then
we
can
create
a
matcher
that
will
check
these
attributes
for
us
.
r
r
}
r
(
hZX
we
would
need
to
pass
in
the
exact
same
object
.
If
we
are
only
interested
in
some
of
the
attributes
of
this
object
then
we
can
create
a
matcher
that
will
check
these
attributes
for
us
.
r
h
\
j
ubeubh
)
r
}
r
(
hZX
[
You
can
see
in
this
example
how
a
'
standard
'
call
to
assert_called_with
isn
'
t
sufficient
:
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
(
h
X5
You
can
see
in
this
example
how
a
'
standard
'
call
to
r
r
}
r
(
hZX5
You
can
see
in
this
example
how
a
'
standard
'
call
to
r
h
\
j
ubj
<
)
r
}
r
(
hZX
assert_called_with
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
assert_called_withr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
isn
'
t
sufficient
:
r
r
}
r
(
hZX
isn
'
t
sufficient
:
r
h
\
j
ubeubj
)
r
}
r
(
hZXX
>
>
>
class
Foo
(
object
)
:
.
.
.
def
__init__
(
self
a
b
)
:
.
.
.
self
.
a
self
.
b
=
a
b
.
.
.
>
>
>
mock
=
Mock
(
return_value
=
None
)
>
>
>
mock
(
Foo
(
1
2
)
)
>
>
>
mock
.
assert_called_with
(
Foo
(
1
2
)
)
Traceback
(
most
recent
call
last
)
:
.
.
.
AssertionError
:
Expected
:
call
(
<
__main__
.
Foo
object
at
0x
.
.
.
>
)
Actual
call
:
call
(
<
__main__
.
Foo
object
at
0x
.
.
.
>
)
r
h
\
j
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
!
h
h
hf
]
r
"
hh
]
r
#
hj
]
r
hl
]
r
%
hn
]
r
&
U
groupsr
'
]
r
(
h
ah
}
r
)
uhqM
hrh
hU
]
r
*
h
XX
>
>
>
class
Foo
(
object
)
:
.
.
.
def
__init__
(
self
a
b
)
:
.
.
.
self
.
a
self
.
b
=
a
b
.
.
.
>
>
>
mock
=
Mock
(
return_value
=
None
)
>
>
>
mock
(
Foo
(
1
2
)
)
>
>
>
mock
.
assert_called_with
(
Foo
(
1
2
)
)
Traceback
(
most
recent
call
last
)
:
.
.
.
AssertionError
:
Expected
:
call
(
<
__main__
.
Foo
object
at
0x
.
.
.
>
)
Actual
call
:
call
(
<
__main__
.
Foo
object
at
0x
.
.
.
>
)
r
+
r
}
r
-
(
hZU
h
\
j
ubaubh
)
r
.
}
r
/
(
hZXI
A
comparison
function
for
our
Foo
class
might
look
something
like
this
:
r0
h
\
j
h
]
h
hbh
hd
}
r1
(
hj
]
r2
hl
]
r3
hh
]
r4
hf
]
r5
hn
]
r6
uhqM
hrh
hU
]
r7
(
h
X
A
comparison
function
for
our
r8
r9
}
r
:
(
hZX
A
comparison
function
for
our
r
;
h
\
j
.
ubj
<
)
r
<
}
r
=
(
hZX
Foo
r
>
hd
}
r
?
(
hj
]
r
hl
]
rA
hh
]
rB
hf
]
rC
hn
]
rD
uh
\
j
.
hU
]
rE
h
X
FoorF
rG
}
rH
(
hZU
h
\
j
<
ubahbjJ
ubh
X
&
class
might
look
something
like
this
:
rI
rJ
}
rK
(
hZX
&
class
might
look
something
like
this
:
rL
h
\
j
.
ubeubj
)
rM
}
rN
(
hZX
>
>
>
def
compare
(
self
other
)
:
.
.
.
if
not
type
(
self
)
=
=
type
(
other
)
:
.
.
.
return
False
.
.
.
if
self
.
a
!
=
other
.
a
:
.
.
.
return
False
.
.
.
if
self
.
b
!
=
other
.
b
:
.
.
.
return
False
.
.
.
return
True
.
.
.
rO
h
\
j
h
]
h
hbj
hd
}
rP
(
U
testnodetyperQ
X
doctestrR
h
h
hf
]
rS
hh
]
rT
hj
]
rU
hl
]
rV
hn
]
rW
U
groupsrX
]
rY
h
ah
}
rZ
uhqM
hrh
hU
]
r
[
h
X
>
>
>
def
compare
(
self
other
)
:
.
.
.
if
not
type
(
self
)
=
=
type
(
other
)
:
.
.
.
return
False
.
.
.
if
self
.
a
!
=
other
.
a
:
.
.
.
return
False
.
.
.
if
self
.
b
!
=
other
.
b
:
.
.
.
return
False
.
.
.
return
True
.
.
.
r
\
r
]
}
r
^
(
hZU
h
\
jM
ubaubh
)
r_
}
r
(
hZX
{
And
a
matcher
object
that
can
use
comparison
functions
like
this
for
its
equality
operation
would
look
something
like
this
:
ra
h
\
j
h
]
h
hbh
hd
}
rb
(
hj
]
rc
hl
]
rd
hh
]
re
hf
]
rf
hn
]
rg
uhqM
hrh
hU
]
rh
h
X
{
And
a
matcher
object
that
can
use
comparison
functions
like
this
for
its
equality
operation
would
look
something
like
this
:
ri
rj
}
rk
(
hZja
h
\
j_
ubaubj
)
rl
}
rm
(
hZX
>
>
>
class
Matcher
(
object
)
:
.
.
.
def
__init__
(
self
compare
some_obj
)
:
.
.
.
self
.
compare
=
compare
.
.
.
self
.
some_obj
=
some_obj
.
.
.
def
__eq__
(
self
other
)
:
.
.
.
return
self
.
compare
(
self
.
some_obj
other
)
.
.
.
rn
h
\
j
h
]
h
hbj
hd
}
ro
(
U
testnodetyperp
X
doctestrq
h
h
hf
]
rr
hh
]
rs
hj
]
rt
hl
]
ru
hn
]
rv
U
groupsrw
]
rx
h
ah
}
ry
uhqM
hrh
hU
]
rz
h
X
>
>
>
class
Matcher
(
object
)
:
.
.
.
def
__init__
(
self
compare
some_obj
)
:
.
.
.
self
.
compare
=
compare
.
.
.
self
.
some_obj
=
some_obj
.
.
.
def
__eq__
(
self
other
)
:
.
.
.
return
self
.
compare
(
self
.
some_obj
other
)
.
.
.
r
{
r
|
}
r
}
(
hZU
h
\
jl
ubaubh
)
r
~
}
r
(
hZX
Putting
all
this
together
:
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
h
X
Putting
all
this
together
:
r
r
}
r
(
hZj
h
\
j
~
ubaubj
)
r
}
r
(
hZXR
>
>
>
match_foo
=
Matcher
(
compare
Foo
(
1
2
)
)
>
>
>
mock
.
assert_called_with
(
match_foo
)
r
h
\
j
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqM
hrh
hU
]
r
h
XR
>
>
>
match_foo
=
Matcher
(
compare
Foo
(
1
2
)
)
>
>
>
mock
.
assert_called_with
(
match_foo
)
r
r
}
r
(
hZU
h
\
j
ubaubh
)
r
}
r
(
hZXo
The
Matcher
is
instantiated
with
our
compare
function
and
the
Foo
object
we
want
to
compare
against
.
In
assert_called_with
the
Matcher
equality
method
will
be
called
which
compares
the
object
the
mock
was
called
with
against
the
one
we
created
our
matcher
with
.
If
they
match
then
assert_called_with
passes
and
if
they
don
'
t
an
AssertionError
is
raised
:
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
(
h
X
The
r
r
}
r
(
hZX
The
r
h
\
j
ubj
<
)
r
}
r
(
hZX
Matcher
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
Matcherr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X3
is
instantiated
with
our
compare
function
and
the
r
r
}
r
(
hZX3
is
instantiated
with
our
compare
function
and
the
r
h
\
j
ubj
<
)
r
}
r
(
hZX
Foo
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
Foor
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
'
object
we
want
to
compare
against
.
In
r
r
}
r
(
hZX
'
object
we
want
to
compare
against
.
In
r
h
\
j
ubj
<
)
r
}
r
(
hZX
assert_called_with
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
assert_called_withr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
the
r
r
}
r
(
hZX
the
r
h
\
j
ubj
<
)
r
}
r
(
hZX
Matcher
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
Matcherr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
equality
method
will
be
called
which
compares
the
object
the
mock
was
called
with
against
the
one
we
created
our
matcher
with
.
If
they
match
then
r
r
}
r
(
hZX
equality
method
will
be
called
which
compares
the
object
the
mock
was
called
with
against
the
one
we
created
our
matcher
with
.
If
they
match
then
r
h
\
j
ubj
<
)
r
}
r
(
hZX
assert_called_with
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
assert_called_withr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
passes
and
if
they
don
'
t
an
r
r
}
r
(
hZX
passes
and
if
they
don
'
t
an
r
h
\
j
ubj
<
)
r
}
r
(
hZX
AssertionError
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
AssertionErrorr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
is
raised
:
r
r
}
r
(
hZX
is
raised
:
r
h
\
j
ubeubj
)
r
}
r
(
hZX
>
>
>
match_wrong
=
Matcher
(
compare
Foo
(
3
4
)
)
>
>
>
mock
.
assert_called_with
(
match_wrong
)
Traceback
(
most
recent
call
last
)
:
.
.
.
AssertionError
:
Expected
:
(
(
<
Matcher
object
at
0x
.
.
.
>
)
{
}
)
Called
with
:
(
(
<
Foo
object
at
0x
.
.
.
>
)
{
}
)
r
h
\
j
h
]
h
hbj
hd
}
r
(
U
testnodetyper
X
doctestr
h
h
hf
]
r
hh
]
r
hj
]
r
hl
]
r
hn
]
r
U
groupsr
]
r
h
ah
}
r
uhqM
hrh
hU
]
r
h
X
>
>
>
match_wrong
=
Matcher
(
compare
Foo
(
3
4
)
)
>
>
>
mock
.
assert_called_with
(
match_wrong
)
Traceback
(
most
recent
call
last
)
:
.
.
.
AssertionError
:
Expected
:
(
(
<
Matcher
object
at
0x
.
.
.
>
)
{
}
)
Called
with
:
(
(
<
Foo
object
at
0x
.
.
.
>
)
{
}
)
r
r
!
}
r
"
(
hZU
h
\
j
ubaubh
)
r
#
}
r
(
hZX
With
a
bit
of
tweaking
you
could
have
the
comparison
function
raise
the
AssertionError
directly
and
provide
a
more
useful
failure
message
.
r
%
h
\
j
h
]
h
hbh
hd
}
r
&
(
hj
]
r
'
hl
]
r
(
hh
]
r
)
hf
]
r
*
hn
]
r
+
uhqM
hrh
hU
]
r
(
h
XH
With
a
bit
of
tweaking
you
could
have
the
comparison
function
raise
the
r
-
r
.
}
r
/
(
hZXH
With
a
bit
of
tweaking
you
could
have
the
comparison
function
raise
the
r0
h
\
j
#
ubj
<
)
r1
}
r2
(
hZX
AssertionError
r3
hd
}
r4
(
hj
]
r5
hl
]
r6
hh
]
r7
hf
]
r8
hn
]
r9
uh
\
j
#
hU
]
r
:
h
X
AssertionErrorr
;
r
<
}
r
=
(
hZU
h
\
j1
ubahbjJ
ubh
X4
directly
and
provide
a
more
useful
failure
message
.
r
>
r
?
}
r
(
hZX4
directly
and
provide
a
more
useful
failure
message
.
rA
h
\
j
#
ubeubh
)
rB
}
rC
(
hZXX
As
of
version
1
.
5
the
Python
testing
library
PyHamcrest
<
http
:
/
/
pypi
.
python
.
org
/
pypi
/
PyHamcrest
>
_
provides
similar
functionality
that
may
be
useful
here
in
the
form
of
its
equality
matcher
(
hamcrest
.
library
.
integration
.
match_equality
<
http
:
/
/
packages
.
python
.
org
/
PyHamcrest
/
integration
.
html
#
hamcrest
.
library
.
integration
.
match_equality
>
_
)
.
rD
h
\
j
h
]
h
hbh
hd
}
rE
(
hj
]
rF
hl
]
rG
hh
]
rH
hf
]
rI
hn
]
rJ
uhqM
hrh
hU
]
rK
(
h
X
.
As
of
version
1
.
5
the
Python
testing
library
rL
rM
}
rN
(
hZX
.
As
of
version
1
.
5
the
Python
testing
library
rO
h
\
jB
ubj
)
rP
}
rQ
(
hZX6
PyHamcrest
<
http
:
/
/
pypi
.
python
.
org
/
pypi
/
PyHamcrest
>
_rR
hd
}
rS
(
U
namerT
X
PyHamcrestrU
j
X
&
http
:
/
/
pypi
.
python
.
org
/
pypi
/
PyHamcrestrV
hf
]
rW
hh
]
rX
hj
]
rY
hl
]
rZ
hn
]
r
[
uh
\
jB
hU
]
r
\
h
X
PyHamcrestr
]
r
^
}
r_
(
hZU
h
\
jP
ubahbj
ubhW
)
r
}
ra
(
hZX
)
<
http
:
/
/
pypi
.
python
.
org
/
pypi
/
PyHamcrest
>
rb
j
K
h
\
jB
hbhchd
}
rc
(
U
refurird
jV
hf
]
re
h9ahh
]
rf
hj
]
rg
hl
]
rh
hn
]
ri
h
auhU
]
rj
ubh
X_
provides
similar
functionality
that
may
be
useful
here
in
the
form
of
its
equality
matcher
(
rk
rl
}
rm
(
hZX_
provides
similar
functionality
that
may
be
useful
here
in
the
form
of
its
equality
matcher
(
rn
h
\
jB
ubj
)
ro
}
rp
(
hZX
hamcrest
.
library
.
integration
.
match_equality
<
http
:
/
/
packages
.
python
.
org
/
PyHamcrest
/
integration
.
html
#
hamcrest
.
library
.
integration
.
match_equality
>
_rq
hd
}
rr
(
U
namers
X
+
hamcrest
.
library
.
integration
.
match_equalityrt
j
Xb
http
:
/
/
packages
.
python
.
org
/
PyHamcrest
/
integration
.
html
#
hamcrest
.
library
.
integration
.
match_equalityru
hf
]
rv
hh
]
rw
hj
]
rx
hl
]
ry
hn
]
rz
uh
\
jB
hU
]
r
{
h
X
+
hamcrest
.
library
.
integration
.
match_equalityr
|
r
}
}
r
~
(
hZU
h
\
jo
ubahbj
ubhW
)
r
}
r
(
hZXe
<
http
:
/
/
packages
.
python
.
org
/
PyHamcrest
/
integration
.
html
#
hamcrest
.
library
.
integration
.
match_equality
>
r
j
K
h
\
jB
hbhchd
}
r
(
U
refurir
ju
hf
]
r
h
?
ahh
]
r
hj
]
r
hl
]
r
hn
]
r
h
auhU
]
r
ubh
X
)
.
r
r
}
r
(
hZX
)
.
r
h
\
jB
ubeubeubht
)
r
}
r
(
hZU
h
\
huh
]
h
hbhyhd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
h6ahn
]
r
h
auhqM
hrh
hU
]
r
(
h
)
r
}
r
(
hZX
*
Less
verbose
configuration
of
mock
objectsr
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
h
X
*
Less
verbose
configuration
of
mock
objectsr
r
}
r
(
hZj
h
\
j
ubaubh
)
r
}
r
(
hZXz
This
recipe
for
easier
configuration
of
mock
objects
is
now
part
of
Mock
.
See
the
:
meth
:
~
Mock
.
configure_mock
method
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
(
h
XF
This
recipe
for
easier
configuration
of
mock
objects
is
now
part
of
r
r
}
r
(
hZXF
This
recipe
for
easier
configuration
of
mock
objects
is
now
part
of
r
h
\
j
ubj
<
)
r
}
r
(
hZX
Mock
r
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
Mockr
r
}
r
(
hZU
h
\
j
ubahbjJ
ubh
X
.
See
the
r
r
}
r
(
hZX
.
See
the
r
h
\
j
ubh
)
r
}
r
(
hZX
:
meth
:
~
Mock
.
configure_mock
r
h
\
j
h
]
h
hbh
hd
}
r
(
U
reftyper
X
methr
h
h
X
Mock
.
configure_mockr
U
refdomainr
X
pyr
hf
]
r
hh
]
r
U
refexplicitr
hj
]
r
hl
]
r
hn
]
r
h
h
j
%
Nj
&
j
'
uhqM
hU
]
r
j
)
)
r
}
r
(
hZj
hd
}
r
(
hj
]
r
hl
]
r
(
h
j
X
py
-
methr
ehh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
configure_mock
(
)
r
r
}
r
(
hZU
h
\
j
ubahbj7
ubaubh
X
method
.
r
r
}
r
(
hZX
method
.
r
h
\
j
ubeubeubht
)
r
}
r
(
hZU
h
\
huh
]
h
hbhyhd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
h
>
ahn
]
r
h
auhqM
hrh
hU
]
r
(
h
)
r
}
r
(
hZX
#
Matching
any
argument
in
assertionsr
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
h
X
#
Matching
any
argument
in
assertionsr
r
}
r
(
hZj
h
\
j
ubaubh
)
r
}
r
(
hZX6
This
example
is
now
built
in
to
mock
.
See
:
data
:
ANY
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
hrh
hU
]
r
(
h
X
*
This
example
is
now
built
in
to
mock
.
See
r
r
}
r
(
hZX
*
This
example
is
now
built
in
to
mock
.
See
r
h
\
j
ubh
)
r
}
r
(
hZX
:
data
:
ANY
r
h
\
j
h
]
h
hbh
hd
}
r
(
U
reftyper
X
datar
h
h
X
ANYr
U
refdomainr
X
pyr
hf
]
r
hh
]
r
U
refexplicitr
hj
]
r
hl
]
r
hn
]
r
h
h
j
%
Nj
&
j
'
uhqM
hU
]
r
j
)
)
r
}
r
(
hZj
hd
}
r
(
hj
]
r
hl
]
r
(
h
j
X
py
-
datar
ehh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
!
h
X
ANYr
"
r
#
}
r
(
hZU
h
\
j
ubahbj7
ubaubh
X
.
r
%
}
r
&
(
hZX
.
h
\
j
ubeubeubht
)
r
'
}
r
(
(
hZU
h
\
huh
]
h
hbhyhd
}
r
)
(
hj
]
r
*
hl
]
r
+
hh
]
r
hf
]
r
-
hJahn
]
r
.
h
auhqM
hrh
hU
]
r
/
(
h
)
r0
}
r1
(
hZX
Mocking
Propertiesr2
h
\
j
'
h
]
h
hbh
hd
}
r3
(
hj
]
r4
hl
]
r5
hh
]
r6
hf
]
r7
hn
]
r8
uhqM
hrh
hU
]
r9
h
X
Mocking
Propertiesr
:
r
;
}
r
<
(
hZj2
h
\
j0
ubaubh
)
r
=
}
r
>
(
hZX
This
example
is
now
built
in
to
mock
.
See
:
class
:
PropertyMock
.
r
?
h
\
j
'
h
]
h
hbh
hd
}
r
(
hj
]
rA
hl
]
rB
hh
]
rC
hf
]
rD
hn
]
rE
uhqM
hrh
hU
]
rF
(
h
X
*
This
example
is
now
built
in
to
mock
.
See
rG
rH
}
rI
(
hZX
*
This
example
is
now
built
in
to
mock
.
See
rJ
h
\
j
=
ubh
)
rK
}
rL
(
hZX
:
class
:
PropertyMock
rM
h
\
j
=
h
]
h
hbh
hd
}
rN
(
U
reftyperO
X
classrP
h
h
X
PropertyMockrQ
U
refdomainrR
X
pyrS
hf
]
rT
hh
]
rU
U
refexplicitrV
hj
]
rW
hl
]
rX
hn
]
rY
h
h
j
%
Nj
&
j
'
uhqM
hU
]
rZ
j
)
)
r
[
}
r
\
(
hZjM
hd
}
r
]
(
hj
]
r
^
hl
]
r_
(
h
jS
X
py
-
classr
ehh
]
ra
hf
]
rb
hn
]
rc
uh
\
jK
hU
]
rd
h
X
PropertyMockre
rf
}
rg
(
hZU
h
\
j
[
ubahbj7
ubaubh
X
.
rh
}
ri
(
hZX
.
h
\
j
=
ubeubeubht
)
rj
}
rk
(
hZU
h
\
huh
]
h
hbhyhd
}
rl
(
hj
]
rm
hl
]
rn
hh
]
ro
hf
]
rp
h5ahn
]
rq
h
auhqM
hrh
hU
]
rr
(
h
)
rs
}
rt
(
hZX
Mocking
openru
h
\
jj
h
]
h
hbh
hd
}
rv
(
hj
]
rw
hl
]
rx
hh
]
ry
hf
]
rz
hn
]
r
{
uhqM
hrh
hU
]
r
|
h
X
Mocking
openr
}
r
~
}
r
(
hZju
h
\
js
ubaubh
)
r
}
r
(
hZX
<
This
example
is
now
built
in
to
mock
.
See
:
func
:
mock_open
.
r
h
\
jj
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
!
hrh
hU
]
r
(
h
X
*
This
example
is
now
built
in
to
mock
.
See
r
r
}
r
(
hZX
*
This
example
is
now
built
in
to
mock
.
See
r
h
\
j
ubh
)
r
}
r
(
hZX
:
func
:
mock_open
r
h
\
j
h
]
h
hbh
hd
}
r
(
U
reftyper
X
funcr
h
h
X
mock_openr
U
refdomainr
X
pyr
hf
]
r
hh
]
r
U
refexplicitr
hj
]
r
hl
]
r
hn
]
r
h
h
j
%
Nj
&
j
'
uhqM
!
hU
]
r
j
)
)
r
}
r
(
hZj
hd
}
r
(
hj
]
r
hl
]
r
(
h
j
X
py
-
funcr
ehh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
mock_open
(
)
r
r
}
r
(
hZU
h
\
j
ubahbj7
ubaubh
X
.
r
}
r
(
hZX
.
h
\
j
ubeubeubht
)
r
}
r
(
hZU
h
\
huh
]
h
hbhyhd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hQahn
]
r
h
auhqM
%
hrh
hU
]
r
(
h
)
r
}
r
(
hZX
Mocks
without
some
attributesr
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
%
hrh
hU
]
r
h
X
Mocks
without
some
attributesr
r
}
r
(
hZj
h
\
j
ubaubh
)
r
}
r
(
hZXE
This
example
is
now
built
in
to
mock
.
See
:
ref
:
deleting
-
attributes
.
r
h
\
j
h
]
h
hbh
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uhqM
'
hrh
hU
]
r
(
h
X
*
This
example
is
now
built
in
to
mock
.
See
r
r
}
r
(
hZX
*
This
example
is
now
built
in
to
mock
.
See
r
h
\
j
ubh
)
r
}
r
(
hZX
:
ref
:
deleting
-
attributes
r
h
\
j
h
]
h
hbh
hd
}
r
(
U
reftyper
X
refr
h
h
X
deleting
-
attributesr
U
refdomainr
X
stdr
hf
]
r
hh
]
r
U
refexplicitr
hj
]
r
hl
]
r
hn
]
r
h
h
uhqM
'
hU
]
r
h
)
r
}
r
(
hZj
hd
}
r
(
hj
]
r
hl
]
r
(
h
j
X
std
-
refr
ehh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X
deleting
-
attributesr
r
}
r
(
hZU
h
\
j
ubahbh
ubaubh
X
.
r
}
r
(
hZX
.
h
\
j
ubeubeubeubehZU
U
transformerr
NU
footnote_refsr
}
r
U
refnamesr
}
r
X
unittest2r
]
r
j
:
asU
symbol_footnotesr
]
r
U
autofootnote_refsr
]
r
(
j
j
eU
symbol_footnote_refsr
]
r
U
citationsr
]
r
hrh
U
current_liner
NU
transform_messagesr
]
r
cdocutils
.
nodes
system_message
r
)
r
}
r
(
hZU
hd
}
r
(
hj
]
r
U
levelr
K
hf
]
r
hh
]
r
U
sourcer
h
hl
]
r
hn
]
r
U
liner
K
U
typer
U
INFOr
uhU
]
r
h
)
r
}
r
(
hZU
hd
}
r
(
hj
]
r
hl
]
r
hh
]
r
hf
]
r
hn
]
r
uh
\
j
hU
]
r
h
X6
Hyperlink
target
"
further
-
examples
"
is
not
referenced
.
r
r
}
r
(
hZU
h
\
j
ubahbh
ubahbU
system_messager
ubaU
reporterr
NU
id_startr
K
U
autofootnotesr
]
r
!
(
jY
jr
eU
citation_refsr
"
}
r
#
U
indirect_targetsr
]
r
%
U
settingsr
&
(
cdocutils
.
frontend
Values
r
'
or
(
}
r
)
(
U
footnote_backlinksr
*
K
U
record_dependenciesr
+
NU
rfc_base_urlr
U
http
:
/
/
tools
.
ietf
.
org
/
html
/
r
-
U
tracebackr
.
U
pep_referencesr
/
NU
strip_commentsr0
NU
toc_backlinksr1
U
entryr2
U
language_coder3
U
enr4
U
datestampr5
NU
report_levelr6
K
U
_destinationr7
NU
halt_levelr8
K
U
strip_classesr9
Nh
NU
error_encoding_error_handlerr
:
U
backslashreplacer
;
U
debugr
<
NU
embed_stylesheetr
=
U
output_encoding_error_handlerr
>
U
strictr
?
U
sectnum_xformr
K
U
dump_transformsrA
NU
docinfo_xformrB
K
U
warning_streamrC
NU
pep_file_url_templaterD
U
pep
-
%
04drE
U
exit_status_levelrF
K
U
configrG
NU
strict_visitorrH
NU
cloak_email_addressesrI
U
trim_footnote_reference_spacerJ
U
envrK
NU
dump_pseudo_xmlrL
NU
expose_internalsrM
NU
sectsubtitle_xformrN
U
source_linkrO
NU
rfc_referencesrP
NU
output_encodingrQ
U
utf
-
8rR
U
source_urlrS
NU
input_encodingrT
U
utf
-
8
-
sigrU
U
_disable_configrV
NU
id_prefixrW
U
U
tab_widthrX
K
U
error_encodingrY
U
mac
-
romanrZ
U
_sourcer
[
U
/
compile
/
mock
/
docs
/
examples
.
txtr
\
U
gettext_compactr
]
U
generatorr
^
NU
dump_internalsr_
NU
pep_base_urlr
U
http
:
/
/
www
.
python
.
org
/
dev
/
peps
/
ra
U
syntax_highlightrb
U
shortrc
U
input_encoding_error_handlerrd
j
?
U
auto_id_prefixre
U
idrf
U
doctitle_xformrg
U
strip_elements_with_classesrh
NU
_config_filesri
]
rj
U
file_insertion_enabledrk
K
U
raw_enabledrl
K
U
dump_settingsrm
NubU
symbol_footnote_startrn
K
U
idsro
}
rp
(
h
<
j
h7j
h
=
j
h9j
h5jj
hEj
hSj
h
?
j
hKj8
hNj
hJj
'
hAjM
hTj
hPj
j
j
hGjr
j
j
h
:
jY
h
;
huhQj
hOj
hRj
h
j
h1jZ
hLj
hMjw
hHj
hCj
h4h
hDj
hIhuh2j
h8j
hFj
hBj
h
>
j
h3j
h6j
uU
substitution_namesrq
}
rr
hbhrhd
}
rs
(
hj
]
rt
hf
]
ru
hh
]
rv
U
sourcerw
h
hl
]
rx
hn
]
ry
uU
footnotesrz
]
r
{
U
refidsr
|
}
r
}
(
hI
]
r
~
hXahG
]
r
j
ah
:
]
r
j
auub
.
