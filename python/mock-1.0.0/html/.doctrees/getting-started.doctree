cdocutils
.
nodes
document
q
)
q
}
q
(
U
nametypesq
}
q
(
X
getting
-
startedq
X
using
mockq
NX
mocking
classesq
NX
#
side
effect
functions
and
iterablesq
NX
getting
started
with
mockq
NX
patch
decoratorsq
NX
mock
patching
methodsq
NX
"
mock
for
method
calls
on
an
objectq
NX
tracking
all
callsq
NX
naming
your
mocksq
NX
setting
return
values
and
attributesq
NX
'
creating
a
mock
from
an
existing
objectq
NX
raising
exceptions
with
mocksq
NuU
substitution_defsq
}
q
U
parse_messagesq
]
q
U
current_sourceq
NU
decorationq
NU
autofootnote_startq
K
U
nameidsq
}
q
(
h
U
getting
-
startedq
h
U
using
-
mockq
h
U
mocking
-
classesq
h
U
#
side
-
effect
-
functions
-
and
-
iterablesq
h
U
getting
-
started
-
with
-
mockq
h
U
patch
-
decoratorsq
!
h
U
mock
-
patching
-
methodsq
"
h
U
"
mock
-
for
-
method
-
calls
-
on
-
an
-
objectq
#
h
U
tracking
-
all
-
callsq
h
U
naming
-
your
-
mocksq
%
h
U
setting
-
return
-
values
-
and
-
attributesq
&
h
U
'
creating
-
a
-
mock
-
from
-
an
-
existing
-
objectq
'
h
U
raising
-
exceptions
-
with
-
mocksq
(
uU
childrenq
)
]
q
*
cdocutils
.
nodes
section
q
+
)
q
}
q
-
(
U
rawsourceq
.
U
U
parentq
/
h
U
sourceq0cdocutils
.
nodes
reprunicode
q1X
&
/
compile
/
mock
/
docs
/
getting
-
started
.
txtq2
q3
}
q4bU
tagnameq5U
sectionq6U
attributesq7
}
q8
(
U
dupnamesq9
]
q
:
U
classesq
;
]
q
<
U
backrefsq
=
]
q
>
U
idsq
?
]
q
h
aU
namesqA
]
qBh
auU
lineqCK
U
documentqDh
h
)
]
qE
(
cdocutils
.
nodes
title
qF
)
qG
}
qH
(
h
.
X
Getting
Started
with
MockqIh
/
h
h0h3h5U
titleqJh7
}
qK
(
h9
]
qLh
;
]
qMh
=
]
qNh
?
]
qOhA
]
qPuhCK
hDh
h
)
]
qQcdocutils
.
nodes
Text
qRX
Getting
Started
with
MockqS
qT
}
qU
(
h
.
hIh
/
hGubaubcdocutils
.
nodes
target
qV
)
qW
}
qX
(
h
.
X
.
.
_getting
-
started
:
qYh
/
h
h0h3h5U
targetqZh7
}
q
[
(
h9
]
q
\
h
;
]
q
]
h
=
]
q
^
h
?
]
q_h
ahA
]
q
h
auhCK
hDh
h
)
]
qaubcsphinx
.
addnodes
index
qb
)
qc
}
qd
(
h
.
U
h
/
h
h0h3h5U
indexqeh7
}
qf
(
h
?
]
qgh
=
]
qhh9
]
qih
;
]
qjhA
]
qkU
entriesql
]
qm
(
U
singleqnX
Getting
StartedU
index
-
0qoU
tqpaU
inlineqq
uhCK
hDh
h
)
]
qrubhV
)
qs
}
qt
(
h
.
U
h
/
h
h0h3h5hZh7
}
qu
(
h9
]
qvh
;
]
qwh
=
]
qxh
?
]
qyhoahA
]
qzuhCK
hDh
h
)
]
q
{
ubcdocutils
.
nodes
comment
q
|
)
q
}
}
q
~
(
h
.
X
class
SomeClass
(
object
)
:
static_method
=
None
class_method
=
None
attribute
=
None
sys
.
modules
[
'
package
'
]
=
package
=
Mock
(
name
=
'
package
'
)
sys
.
modules
[
'
package
.
module
'
]
=
module
=
package
.
module
sys
.
modules
[
'
module
'
]
=
package
.
moduleq
h
/
h
h0h3h5U
commentq
h7
}
q
(
U
testnodetypeq
X
testsetupq
U
xml
:
spaceq
U
preserveq
h
?
]
q
h
=
]
q
h9
]
q
h
;
]
q
hA
]
q
U
groupsq
]
q
U
defaultq
aU
optionsq
}
q
uhCK
hDh
h
)
]
q
hRX
class
SomeClass
(
object
)
:
static_method
=
None
class_method
=
None
attribute
=
None
sys
.
modules
[
'
package
'
]
=
package
=
Mock
(
name
=
'
package
'
)
sys
.
modules
[
'
package
.
module
'
]
=
module
=
package
.
module
sys
.
modules
[
'
module
'
]
=
package
.
moduleq
q
}
q
(
h
.
U
h
/
h
}
ubaubh
+
)
q
}
q
(
h
.
U
h
/
h
h0h3h5h6h7
}
q
(
h9
]
q
h
;
]
q
h
=
]
q
h
?
]
q
h
ahA
]
q
h
auhCK
hDh
h
)
]
q
(
hF
)
q
}
q
(
h
.
X
Using
Mockq
h
/
h
h0h3h5hJh7
}
q
(
h9
]
q
h
;
]
q
h
=
]
q
h
?
]
q
hA
]
q
uhCK
hDh
h
)
]
q
hRX
Using
Mockq
q
}
q
(
h
.
h
h
/
h
ubaubh
+
)
q
}
q
(
h
.
U
h
/
h
h0h3h5h6h7
}
q
(
h9
]
q
h
;
]
q
h
=
]
q
h
?
]
q
h
"
ahA
]
q
h
auhCK
hDh
h
)
]
q
(
hF
)
q
}
q
(
h
.
X
Mock
Patching
Methodsq
h
/
h
h0h3h5hJh7
}
q
(
h9
]
q
h
;
]
q
h
=
]
q
h
?
]
q
hA
]
q
uhCK
hDh
h
)
]
q
hRX
Mock
Patching
Methodsq
q
}
q
(
h
.
h
h
/
h
ubaubcdocutils
.
nodes
paragraph
q
)
q
}
q
(
h
.
X
.
Common
uses
for
:
class
:
Mock
objects
include
:
q
h
/
h
h0h3h5U
paragraphq
h7
}
q
(
h9
]
q
h
;
]
q
h
=
]
q
h
?
]
q
hA
]
q
uhCK
hDh
h
)
]
q
(
hRX
Common
uses
for
q
q
}
q
(
h
.
X
Common
uses
for
q
h
/
h
ubcsphinx
.
addnodes
pending_xref
q
)
q
}
q
(
h
.
X
:
class
:
Mock
q
h
/
h
h0h3h5U
pending_xrefq
h7
}
q
(
U
reftypeq
X
classq
U
refwarnq
U
reftargetq
X
Mockq
U
refdomainq
X
pyq
h
?
]
q
h
=
]
q
U
refexplicitq
h9
]
q
h
;
]
q
hA
]
q
U
refdocq
U
getting
-
startedq
U
py
:
classq
NU
py
:
moduleq
NuhCK
h
)
]
q
cdocutils
.
nodes
literal
q
)
q
}
q
(
h
.
h
h7
}
q
(
h9
]
q
h
;
]
q
(
U
xrefq
h
X
py
-
classq
eh
=
]
q
h
?
]
q
hA
]
q
uh
/
h
h
)
]
q
hRX
Mockq
q
}
q
(
h
.
U
h
/
h
ubah5U
literalq
ubaubhRX
objects
include
:
q
q
}
q
(
h
.
X
objects
include
:
q
h
/
h
ubeubcdocutils
.
nodes
bullet_list
q
)
q
}
q
(
h
.
U
h
/
h
h0h3h5U
bullet_listq
h7
}
r
(
U
bulletr
X
*
h
?
]
r
h
=
]
r
h9
]
r
h
;
]
r
hA
]
r
uhCK
hDh
h
)
]
r
(
cdocutils
.
nodes
list_item
r
)
r
}
r
(
h
.
X
Patching
methodsr
h
/
h
h0h3h5U
list_itemr
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCNhDh
h
)
]
r
h
)
r
}
r
(
h
.
j
h
/
j
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCK
h
)
]
r
hRX
Patching
methodsr
r
}
r
(
h
.
j
h
/
j
ubaubaubj
)
r
}
r
!
(
h
.
X
"
Recording
method
calls
on
objects
r
"
h
/
h
h0h3h5j
h7
}
r
#
(
h9
]
r
h
;
]
r
%
h
=
]
r
&
h
?
]
r
'
hA
]
r
(
uhCNhDh
h
)
]
r
)
h
)
r
*
}
r
+
(
h
.
X
!
Recording
method
calls
on
objectsr
h
/
j
h0h3h5h
h7
}
r
-
(
h9
]
r
.
h
;
]
r
/
h
=
]
r0
h
?
]
r1
hA
]
r2
uhCK
h
)
]
r3
hRX
!
Recording
method
calls
on
objectsr4
r5
}
r6
(
h
.
j
h
/
j
*
ubaubaubeubh
)
r7
}
r8
(
h
.
X
You
might
want
to
replace
a
method
on
an
object
to
check
that
it
is
called
with
the
correct
arguments
by
another
part
of
the
system
:
r9
h
/
h
h0h3h5h
h7
}
r
:
(
h9
]
r
;
h
;
]
r
<
h
=
]
r
=
h
?
]
r
>
hA
]
r
?
uhCK
hDh
h
)
]
r
hRX
You
might
want
to
replace
a
method
on
an
object
to
check
that
it
is
called
with
the
correct
arguments
by
another
part
of
the
system
:
rA
rB
}
rC
(
h
.
j9
h
/
j7
ubaubcdocutils
.
nodes
literal_block
rD
)
rE
}
rF
(
h
.
X
>
>
>
real
=
SomeClass
(
)
>
>
>
real
.
method
=
MagicMock
(
name
=
'
method
'
)
>
>
>
real
.
method
(
3
4
5
key
=
'
value
'
)
<
MagicMock
name
=
'
method
(
)
'
id
=
'
.
.
.
'
>
rG
h
/
h
h0h3h5U
literal_blockrH
h7
}
rI
(
U
testnodetyperJ
X
doctestrK
h
h
h
?
]
rL
h
=
]
rM
h9
]
rN
h
;
]
rO
hA
]
rP
U
groupsrQ
]
rR
h
ah
}
rS
uhCK
#
hDh
h
)
]
rT
hRX
>
>
>
real
=
SomeClass
(
)
>
>
>
real
.
method
=
MagicMock
(
name
=
'
method
'
)
>
>
>
real
.
method
(
3
4
5
key
=
'
value
'
)
<
MagicMock
name
=
'
method
(
)
'
id
=
'
.
.
.
'
>
rU
rV
}
rW
(
h
.
U
h
/
jE
ubaubh
)
rX
}
rY
(
h
.
X
Once
our
mock
has
been
used
(
real
.
method
in
this
example
)
it
has
methods
and
attributes
that
allow
you
to
make
assertions
about
how
it
has
been
used
.
rZ
h
/
h
h0h3h5h
h7
}
r
[
(
h9
]
r
\
h
;
]
r
]
h
=
]
r
^
h
?
]
r_
hA
]
r
uhCK
*
hDh
h
)
]
ra
(
hRX
Once
our
mock
has
been
used
(
rb
rc
}
rd
(
h
.
X
Once
our
mock
has
been
used
(
re
h
/
jX
ubcdocutils
.
nodes
title_reference
rf
)
rg
}
rh
(
h
.
X
real
.
method
ri
h7
}
rj
(
h9
]
rk
h
;
]
rl
h
=
]
rm
h
?
]
rn
hA
]
ro
uh
/
jX
h
)
]
rp
hRX
real
.
methodrq
rr
}
rs
(
h
.
U
h
/
jg
ubah5U
title_referencert
ubhRXm
in
this
example
)
it
has
methods
and
attributes
that
allow
you
to
make
assertions
about
how
it
has
been
used
.
ru
rv
}
rw
(
h
.
Xm
in
this
example
)
it
has
methods
and
attributes
that
allow
you
to
make
assertions
about
how
it
has
been
used
.
rx
h
/
jX
ubeubcdocutils
.
nodes
note
ry
)
rz
}
r
{
(
h
.
X
In
most
of
these
examples
the
:
class
:
Mock
and
:
class
:
MagicMock
classes
are
interchangeable
.
As
the
MagicMock
is
the
more
capable
class
it
makes
a
sensible
one
to
use
by
default
.
r
|
h
/
h
h0h3h5U
noter
}
h7
}
r
~
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCNhDh
h
)
]
r
h
)
r
}
r
(
h
.
X
In
most
of
these
examples
the
:
class
:
Mock
and
:
class
:
MagicMock
classes
are
interchangeable
.
As
the
MagicMock
is
the
more
capable
class
it
makes
a
sensible
one
to
use
by
default
.
r
h
/
jz
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCK
/
h
)
]
r
(
hRX
In
most
of
these
examples
the
r
r
}
r
(
h
.
X
In
most
of
these
examples
the
r
h
/
j
ubh
)
r
}
r
(
h
.
X
:
class
:
Mock
r
h
/
j
h0h3h5h
h7
}
r
(
U
reftyper
X
classr
h
h
X
Mockr
U
refdomainr
X
pyr
h
?
]
r
h
=
]
r
U
refexplicitr
h9
]
r
h
;
]
r
hA
]
r
h
h
h
Nh
NuhCK
/
h
)
]
r
h
)
r
}
r
(
h
.
j
h7
}
r
(
h9
]
r
h
;
]
r
(
h
j
X
py
-
classr
eh
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
Mockr
r
}
r
(
h
.
U
h
/
j
ubah5h
ubaubhRX
and
r
r
}
r
(
h
.
X
and
r
h
/
j
ubh
)
r
}
r
(
h
.
X
:
class
:
MagicMock
r
h
/
j
h0h3h5h
h7
}
r
(
U
reftyper
X
classr
h
h
X
MagicMockr
U
refdomainr
X
pyr
h
?
]
r
h
=
]
r
U
refexplicitr
h9
]
r
h
;
]
r
hA
]
r
h
h
h
Nh
NuhCK
/
h
)
]
r
h
)
r
}
r
(
h
.
j
h7
}
r
(
h9
]
r
h
;
]
r
(
h
j
X
py
-
classr
eh
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
MagicMockr
r
}
r
(
h
.
U
h
/
j
ubah5h
ubaubhRX
%
classes
are
interchangeable
.
As
the
r
r
}
r
(
h
.
X
%
classes
are
interchangeable
.
As
the
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
MagicMock
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
MagicMockr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRXE
is
the
more
capable
class
it
makes
a
sensible
one
to
use
by
default
.
r
r
}
r
(
h
.
XE
is
the
more
capable
class
it
makes
a
sensible
one
to
use
by
default
.
r
h
/
j
ubeubaubh
)
r
}
r
(
h
.
X
Once
the
mock
has
been
called
its
:
attr
:
~
Mock
.
called
attribute
is
set
to
True
.
More
importantly
we
can
use
the
:
meth
:
~
Mock
.
assert_called_with
or
:
meth
:
~
Mock
.
assert_called_once_with
method
to
check
that
it
was
called
with
the
correct
arguments
.
r
h
/
h
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCK3hDh
h
)
]
r
(
hRX
"
Once
the
mock
has
been
called
its
r
r
}
r
(
h
.
X
"
Once
the
mock
has
been
called
its
r
h
/
j
ubh
)
r
}
r
(
h
.
X
:
attr
:
~
Mock
.
called
r
h
/
j
h0h3h5h
h7
}
r
(
U
reftyper
X
attrr
h
h
X
Mock
.
calledr
U
refdomainr
X
pyr
h
?
]
r
h
=
]
r
U
refexplicitr
h9
]
r
h
;
]
r
hA
]
r
h
h
h
Nh
NuhCK3h
)
]
r
h
)
r
}
r
(
h
.
j
h7
}
r
(
h9
]
r
h
;
]
r
(
h
j
X
py
-
attrr
eh
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
calledr
r
}
r
(
h
.
U
h
/
j
ubah5h
ubaubhRX
attribute
is
set
to
r
r
}
r
(
h
.
X
attribute
is
set
to
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
True
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
Truer
r
}
r
!
(
h
.
U
h
/
j
ubah5jt
ubhRX
"
.
More
importantly
we
can
use
the
r
"
r
#
}
r
(
h
.
X
"
.
More
importantly
we
can
use
the
r
%
h
/
j
ubh
)
r
&
}
r
'
(
h
.
X
:
meth
:
~
Mock
.
assert_called_with
r
(
h
/
j
h0h3h5h
h7
}
r
)
(
U
reftyper
*
X
methr
+
h
h
X
Mock
.
assert_called_withr
U
refdomainr
-
X
pyr
.
h
?
]
r
/
h
=
]
r0
U
refexplicitr1
h9
]
r2
h
;
]
r3
hA
]
r4
h
h
h
Nh
NuhCK3h
)
]
r5
h
)
r6
}
r7
(
h
.
j
(
h7
}
r8
(
h9
]
r9
h
;
]
r
:
(
h
j
.
X
py
-
methr
;
eh
=
]
r
<
h
?
]
r
=
hA
]
r
>
uh
/
j
&
h
)
]
r
?
hRX
assert_called_with
(
)
r
rA
}
rB
(
h
.
U
h
/
j6
ubah5h
ubaubhRX
or
rC
rD
}
rE
(
h
.
X
or
rF
h
/
j
ubh
)
rG
}
rH
(
h
.
X
%
:
meth
:
~
Mock
.
assert_called_once_with
rI
h
/
j
h0h3h5h
h7
}
rJ
(
U
reftyperK
X
methrL
h
h
X
Mock
.
assert_called_once_withrM
U
refdomainrN
X
pyrO
h
?
]
rP
h
=
]
rQ
U
refexplicitrR
h9
]
rS
h
;
]
rT
hA
]
rU
h
h
h
Nh
NuhCK3h
)
]
rV
h
)
rW
}
rX
(
h
.
jI
h7
}
rY
(
h9
]
rZ
h
;
]
r
[
(
h
jO
X
py
-
methr
\
eh
=
]
r
]
h
?
]
r
^
hA
]
r_
uh
/
jG
h
)
]
r
hRX
assert_called_once_with
(
)
ra
rb
}
rc
(
h
.
U
h
/
jW
ubah5h
ubaubhRX
?
method
to
check
that
it
was
called
with
the
correct
arguments
.
rd
re
}
rf
(
h
.
X
?
method
to
check
that
it
was
called
with
the
correct
arguments
.
rg
h
/
j
ubeubh
)
rh
}
ri
(
h
.
Xg
This
example
tests
that
calling
ProductionClass
(
)
.
method
results
in
a
call
to
the
something
method
:
rj
h
/
h
h0h3h5h
h7
}
rk
(
h9
]
rl
h
;
]
rm
h
=
]
rn
h
?
]
ro
hA
]
rp
uhCK8hDh
h
)
]
rq
(
hRX
This
example
tests
that
calling
rr
rs
}
rt
(
h
.
X
This
example
tests
that
calling
ru
h
/
jh
ubjf
)
rv
}
rw
(
h
.
X
ProductionClass
(
)
.
method
rx
h7
}
ry
(
h9
]
rz
h
;
]
r
{
h
=
]
r
|
h
?
]
r
}
hA
]
r
~
uh
/
jh
h
)
]
r
hRX
ProductionClass
(
)
.
methodr
r
}
r
(
h
.
U
h
/
jv
ubah5jt
ubhRX
results
in
a
call
to
the
r
r
}
r
(
h
.
X
results
in
a
call
to
the
r
h
/
jh
ubjf
)
r
}
r
(
h
.
X
something
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
jh
h
)
]
r
hRX
somethingr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRX
method
:
r
r
}
r
(
h
.
X
method
:
r
h
/
jh
ubeubjD
)
r
}
r
(
h
.
X
>
>
>
>
from
mock
import
MagicMock
>
>
>
class
ProductionClass
(
object
)
:
.
.
.
def
method
(
self
)
:
.
.
.
self
.
something
(
1
2
3
)
.
.
.
def
something
(
self
a
b
c
)
:
.
.
.
pass
.
.
.
>
>
>
real
=
ProductionClass
(
)
>
>
>
real
.
something
=
MagicMock
(
)
>
>
>
real
.
method
(
)
>
>
>
real
.
something
.
assert_called_once_with
(
1
2
3
)
r
h
/
h
h0h3h5jH
h7
}
r
(
U
testnodetyper
X
doctestr
h
h
h
?
]
r
h
=
]
r
h9
]
r
h
;
]
r
hA
]
r
U
groupsr
]
r
h
ah
}
r
uhCK
;
hDh
h
)
]
r
hRX
>
>
>
>
from
mock
import
MagicMock
>
>
>
class
ProductionClass
(
object
)
:
.
.
.
def
method
(
self
)
:
.
.
.
self
.
something
(
1
2
3
)
.
.
.
def
something
(
self
a
b
c
)
:
.
.
.
pass
.
.
.
>
>
>
real
=
ProductionClass
(
)
>
>
>
real
.
something
=
MagicMock
(
)
>
>
>
real
.
method
(
)
>
>
>
real
.
something
.
assert_called_once_with
(
1
2
3
)
r
r
}
r
(
h
.
U
h
/
j
ubaubeubh
+
)
r
}
r
(
h
.
U
h
/
h
h0h3h5h6h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
h
#
ahA
]
r
h
auhCKLhDh
h
)
]
r
(
hF
)
r
}
r
(
h
.
X
"
Mock
for
Method
Calls
on
an
Objectr
h
/
j
h0h3h5hJh7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCKLhDh
h
)
]
r
hRX
"
Mock
for
Method
Calls
on
an
Objectr
r
}
r
(
h
.
j
h
/
j
ubaubh
)
r
}
r
(
h
.
X
In
the
last
example
we
patched
a
method
directly
on
an
object
to
check
that
it
was
called
correctly
.
Another
common
use
case
is
to
pass
an
object
into
a
method
(
or
some
part
of
the
system
under
test
)
and
then
check
that
it
is
used
in
the
correct
way
.
r
h
/
j
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCKNhDh
h
)
]
r
hRX
In
the
last
example
we
patched
a
method
directly
on
an
object
to
check
that
it
was
called
correctly
.
Another
common
use
case
is
to
pass
an
object
into
a
method
(
or
some
part
of
the
system
under
test
)
and
then
check
that
it
is
used
in
the
correct
way
.
r
r
}
r
(
h
.
j
h
/
j
ubaubh
)
r
}
r
(
h
.
Xu
The
simple
ProductionClass
below
has
a
closer
method
.
If
it
is
called
with
an
object
then
it
calls
close
on
it
.
r
h
/
j
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCKShDh
h
)
]
r
(
hRX
The
simple
r
r
}
r
(
h
.
X
The
simple
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
ProductionClass
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
ProductionClassr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRX
below
has
a
r
r
}
r
(
h
.
X
below
has
a
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
closer
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
closerr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRX6
method
.
If
it
is
called
with
an
object
then
it
calls
r
r
}
r
(
h
.
X6
method
.
If
it
is
called
with
an
object
then
it
calls
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
close
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
closer
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRX
on
it
.
r
r
}
r
(
h
.
X
on
it
.
r
h
/
j
ubeubjD
)
r
}
r
(
h
.
Xi
>
>
>
class
ProductionClass
(
object
)
:
.
.
.
def
closer
(
self
something
)
:
.
.
.
something
.
close
(
)
.
.
.
r
h
/
j
h0h3h5jH
h7
}
r
(
U
testnodetyper
X
doctestr
h
h
h
?
]
r
h
=
]
r
h9
]
r
h
;
]
r
hA
]
r
U
groupsr
]
r
h
ah
}
r
uhCKVhDh
h
)
]
r
hRXi
>
>
>
class
ProductionClass
(
object
)
:
.
.
.
def
closer
(
self
something
)
:
.
.
.
something
.
close
(
)
.
.
.
r
r
}
r
(
h
.
U
h
/
j
ubaubh
)
r
}
r
!
(
h
.
Xh
So
to
test
it
we
need
to
pass
in
an
object
with
a
close
method
and
check
that
it
was
called
correctly
.
r
"
h
/
j
h0h3h5h
h7
}
r
#
(
h9
]
r
h
;
]
r
%
h
=
]
r
&
h
?
]
r
'
hA
]
r
(
uhCK
]
hDh
h
)
]
r
)
(
hRX2
So
to
test
it
we
need
to
pass
in
an
object
with
a
r
*
r
+
}
r
(
h
.
X2
So
to
test
it
we
need
to
pass
in
an
object
with
a
r
-
h
/
j
ubjf
)
r
.
}
r
/
(
h
.
X
close
r0
h7
}
r1
(
h9
]
r2
h
;
]
r3
h
=
]
r4
h
?
]
r5
hA
]
r6
uh
/
j
h
)
]
r7
hRX
closer8
r9
}
r
:
(
h
.
U
h
/
j
.
ubah5jt
ubhRX
/
method
and
check
that
it
was
called
correctly
.
r
;
r
<
}
r
=
(
h
.
X
/
method
and
check
that
it
was
called
correctly
.
r
>
h
/
j
ubeubjD
)
r
?
}
r
(
h
.
Xh
>
>
>
real
=
ProductionClass
(
)
>
>
>
mock
=
Mock
(
)
>
>
>
real
.
closer
(
mock
)
>
>
>
mock
.
close
.
assert_called_with
(
)
rA
h
/
j
h0h3h5jH
h7
}
rB
(
U
testnodetyperC
X
doctestrD
h
h
h
?
]
rE
h
=
]
rF
h9
]
rG
h
;
]
rH
hA
]
rI
U
groupsrJ
]
rK
h
ah
}
rL
uhCK
hDh
h
)
]
rM
hRXh
>
>
>
real
=
ProductionClass
(
)
>
>
>
mock
=
Mock
(
)
>
>
>
real
.
closer
(
mock
)
>
>
>
mock
.
close
.
assert_called_with
(
)
rN
rO
}
rP
(
h
.
U
h
/
j
?
ubaubh
)
rQ
}
rR
(
h
.
X
We
don
'
t
have
to
do
any
work
to
provide
the
'
close
'
method
on
our
mock
.
Accessing
close
creates
it
.
So
if
'
close
'
hasn
'
t
already
been
called
then
accessing
it
in
the
test
will
create
it
but
:
meth
:
~
Mock
.
assert_called_with
will
raise
a
failure
exception
.
rS
h
/
j
h0h3h5h
h7
}
rT
(
h9
]
rU
h
;
]
rV
h
=
]
rW
h
?
]
rX
hA
]
rY
uhCKghDh
h
)
]
rZ
(
hRX
We
don
'
t
have
to
do
any
work
to
provide
the
'
close
'
method
on
our
mock
.
Accessing
close
creates
it
.
So
if
'
close
'
hasn
'
t
already
been
called
then
accessing
it
in
the
test
will
create
it
but
r
[
r
\
}
r
]
(
h
.
X
We
don
'
t
have
to
do
any
work
to
provide
the
'
close
'
method
on
our
mock
.
Accessing
close
creates
it
.
So
if
'
close
'
hasn
'
t
already
been
called
then
accessing
it
in
the
test
will
create
it
but
r
^
h
/
jQ
ubh
)
r_
}
r
(
h
.
X
:
meth
:
~
Mock
.
assert_called_with
ra
h
/
jQ
h0h3h5h
h7
}
rb
(
U
reftyperc
X
methrd
h
h
X
Mock
.
assert_called_withre
U
refdomainrf
X
pyrg
h
?
]
rh
h
=
]
ri
U
refexplicitrj
h9
]
rk
h
;
]
rl
hA
]
rm
h
h
h
Nh
NuhCKgh
)
]
rn
h
)
ro
}
rp
(
h
.
ja
h7
}
rq
(
h9
]
rr
h
;
]
rs
(
h
jg
X
py
-
methrt
eh
=
]
ru
h
?
]
rv
hA
]
rw
uh
/
j_
h
)
]
rx
hRX
assert_called_with
(
)
ry
rz
}
r
{
(
h
.
U
h
/
jo
ubah5h
ubaubhRX
will
raise
a
failure
exception
.
r
|
r
}
}
r
~
(
h
.
X
will
raise
a
failure
exception
.
r
h
/
jQ
ubeubeubh
+
)
r
}
r
(
h
.
U
h
/
h
h0h3h5h6h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
h
ahA
]
r
h
auhCKnhDh
h
)
]
r
(
hF
)
r
}
r
(
h
.
X
Mocking
Classesr
h
/
j
h0h3h5hJh7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCKnhDh
h
)
]
r
hRX
Mocking
Classesr
r
}
r
(
h
.
j
h
/
j
ubaubh
)
r
}
r
(
h
.
X
A
common
use
case
is
to
mock
out
classes
instantiated
by
your
code
under
test
.
When
you
patch
a
class
then
that
class
is
replaced
with
a
mock
.
Instances
are
created
by
*
calling
the
class
*
.
This
means
you
access
the
"
mock
instance
"
by
looking
at
the
return
value
of
the
mocked
class
.
r
h
/
j
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCKphDh
h
)
]
r
(
hRX
A
common
use
case
is
to
mock
out
classes
instantiated
by
your
code
under
test
.
When
you
patch
a
class
then
that
class
is
replaced
with
a
mock
.
Instances
are
created
by
r
r
}
r
(
h
.
X
A
common
use
case
is
to
mock
out
classes
instantiated
by
your
code
under
test
.
When
you
patch
a
class
then
that
class
is
replaced
with
a
mock
.
Instances
are
created
by
r
h
/
j
ubcdocutils
.
nodes
emphasis
r
)
r
}
r
(
h
.
X
*
calling
the
class
*
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
calling
the
classr
r
}
r
(
h
.
U
h
/
j
ubah5U
emphasisr
ubhRX_
.
This
means
you
access
the
"
mock
instance
"
by
looking
at
the
return
value
of
the
mocked
class
.
r
r
}
r
(
h
.
X_
.
This
means
you
access
the
"
mock
instance
"
by
looking
at
the
return
value
of
the
mocked
class
.
r
h
/
j
ubeubh
)
r
}
r
(
h
.
X
In
the
example
below
we
have
a
function
some_function
that
instantiates
Foo
and
calls
a
method
on
it
.
The
call
to
patch
replaces
the
class
Foo
with
a
mock
.
The
Foo
instance
is
the
result
of
calling
the
mock
so
it
is
configured
by
modifying
the
mock
:
attr
:
~
Mock
.
return_value
.
r
h
/
j
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCKuhDh
h
)
]
r
(
hRX
(
In
the
example
below
we
have
a
function
r
r
}
r
(
h
.
X
(
In
the
example
below
we
have
a
function
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
some_function
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
some_functionr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRX
that
instantiates
r
r
}
r
(
h
.
X
that
instantiates
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
Foo
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
Foor
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRX
'
and
calls
a
method
on
it
.
The
call
to
r
r
}
r
(
h
.
X
'
and
calls
a
method
on
it
.
The
call
to
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
patch
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
patchr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRX
replaces
the
class
r
r
}
r
(
h
.
X
replaces
the
class
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
Foo
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
Foor
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRX
with
a
mock
.
The
r
r
}
r
(
h
.
X
with
a
mock
.
The
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
Foo
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
Foor
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRXW
instance
is
the
result
of
calling
the
mock
so
it
is
configured
by
modifying
the
mock
r
r
}
r
(
h
.
XW
instance
is
the
result
of
calling
the
mock
so
it
is
configured
by
modifying
the
mock
r
h
/
j
ubh
)
r
}
r
(
h
.
X
:
attr
:
~
Mock
.
return_value
r
h
/
j
h0h3h5h
h7
}
r
(
U
reftyper
X
attrr
h
h
X
Mock
.
return_valuer
U
refdomainr
!
X
pyr
"
h
?
]
r
#
h
=
]
r
U
refexplicitr
%
h9
]
r
&
h
;
]
r
'
hA
]
r
(
h
h
h
Nh
NuhCKuh
)
]
r
)
h
)
r
*
}
r
+
(
h
.
j
h7
}
r
(
h9
]
r
-
h
;
]
r
.
(
h
j
"
X
py
-
attrr
/
eh
=
]
r0
h
?
]
r1
hA
]
r2
uh
/
j
h
)
]
r3
hRX
return_valuer4
r5
}
r6
(
h
.
U
h
/
j
*
ubah5h
ubaubhRX
.
r7
}
r8
(
h
.
X
.
h
/
j
ubeubjD
)
r9
}
r
:
(
h
.
X
#
>
>
>
def
some_function
(
)
:
.
.
.
instance
=
module
.
Foo
(
)
.
.
.
return
instance
.
method
(
)
.
.
.
>
>
>
with
patch
(
'
module
.
Foo
'
)
as
mock
:
.
.
.
instance
=
mock
.
return_value
.
.
.
instance
.
method
.
return_value
=
'
the
result
'
.
.
.
result
=
some_function
(
)
.
.
.
assert
result
=
=
'
the
result
'
r
;
h
/
j
h0h3h5jH
h7
}
r
<
(
U
testnodetyper
=
X
doctestr
>
h
h
h
?
]
r
?
h
=
]
r
h9
]
rA
h
;
]
rB
hA
]
rC
U
groupsrD
]
rE
h
ah
}
rF
uhCKzhDh
h
)
]
rG
hRX
#
>
>
>
def
some_function
(
)
:
.
.
.
instance
=
module
.
Foo
(
)
.
.
.
return
instance
.
method
(
)
.
.
.
>
>
>
with
patch
(
'
module
.
Foo
'
)
as
mock
:
.
.
.
instance
=
mock
.
return_value
.
.
.
instance
.
method
.
return_value
=
'
the
result
'
.
.
.
result
=
some_function
(
)
.
.
.
assert
result
=
=
'
the
result
'
rH
rI
}
rJ
(
h
.
U
h
/
j9
ubaubeubh
+
)
rK
}
rL
(
h
.
U
h
/
h
h0h3h5h6h7
}
rM
(
h9
]
rN
h
;
]
rO
h
=
]
rP
h
?
]
rQ
h
%
ahA
]
rR
h
auhCK
hDh
h
)
]
rS
(
hF
)
rT
}
rU
(
h
.
X
Naming
your
mocksrV
h
/
jK
h0h3h5hJh7
}
rW
(
h9
]
rX
h
;
]
rY
h
=
]
rZ
h
?
]
r
[
hA
]
r
\
uhCK
hDh
h
)
]
r
]
hRX
Naming
your
mocksr
^
r_
}
r
(
h
.
jV
h
/
jT
ubaubh
)
ra
}
rb
(
h
.
X
It
can
be
useful
to
give
your
mocks
a
name
.
The
name
is
shown
in
the
repr
of
the
mock
and
can
be
helpful
when
the
mock
appears
in
test
failure
messages
.
The
name
is
also
propagated
to
attributes
or
methods
of
the
mock
:
rc
h
/
jK
h0h3h5h
h7
}
rd
(
h9
]
re
h
;
]
rf
h
=
]
rg
h
?
]
rh
hA
]
ri
uhCK
hDh
h
)
]
rj
hRX
It
can
be
useful
to
give
your
mocks
a
name
.
The
name
is
shown
in
the
repr
of
the
mock
and
can
be
helpful
when
the
mock
appears
in
test
failure
messages
.
The
name
is
also
propagated
to
attributes
or
methods
of
the
mock
:
rk
rl
}
rm
(
h
.
jc
h
/
ja
ubaubjD
)
rn
}
ro
(
h
.
X
>
>
>
mock
=
MagicMock
(
name
=
'
foo
'
)
>
>
>
mock
<
MagicMock
name
=
'
foo
'
id
=
'
.
.
.
'
>
>
>
>
mock
.
method
<
MagicMock
name
=
'
foo
.
method
'
id
=
'
.
.
.
'
>
rp
h
/
jK
h0h3h5jH
h7
}
rq
(
U
testnodetyperr
X
doctestrs
h
h
h
?
]
rt
h
=
]
ru
h9
]
rv
h
;
]
rw
hA
]
rx
U
groupsry
]
rz
h
ah
}
r
{
uhCK
hDh
h
)
]
r
|
hRX
>
>
>
mock
=
MagicMock
(
name
=
'
foo
'
)
>
>
>
mock
<
MagicMock
name
=
'
foo
'
id
=
'
.
.
.
'
>
>
>
>
mock
.
method
<
MagicMock
name
=
'
foo
.
method
'
id
=
'
.
.
.
'
>
r
}
r
~
}
r
(
h
.
U
h
/
jn
ubaubeubh
+
)
r
}
r
(
h
.
U
h
/
h
h0h3h5h6h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
h
ahA
]
r
h
auhCK
hDh
h
)
]
r
(
hF
)
r
}
r
(
h
.
X
Tracking
all
Callsr
h
/
j
h0h3h5hJh7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCK
hDh
h
)
]
r
hRX
Tracking
all
Callsr
r
}
r
(
h
.
j
h
/
j
ubaubh
)
r
}
r
(
h
.
X
Often
you
want
to
track
more
than
a
single
call
to
a
method
.
The
:
attr
:
~
Mock
.
mock_calls
attribute
records
all
calls
to
child
attributes
of
the
mock
-
and
also
to
their
children
.
r
h
/
j
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCK
hDh
h
)
]
r
(
hRXA
Often
you
want
to
track
more
than
a
single
call
to
a
method
.
The
r
r
}
r
(
h
.
XA
Often
you
want
to
track
more
than
a
single
call
to
a
method
.
The
r
h
/
j
ubh
)
r
}
r
(
h
.
X
:
attr
:
~
Mock
.
mock_calls
r
h
/
j
h0h3h5h
h7
}
r
(
U
reftyper
X
attrr
h
h
X
Mock
.
mock_callsr
U
refdomainr
X
pyr
h
?
]
r
h
=
]
r
U
refexplicitr
h9
]
r
h
;
]
r
hA
]
r
h
h
h
Nh
NuhCK
h
)
]
r
h
)
r
}
r
(
h
.
j
h7
}
r
(
h9
]
r
h
;
]
r
(
h
j
X
py
-
attrr
eh
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
mock_callsr
r
}
r
(
h
.
U
h
/
j
ubah5h
ubaubhRXZ
attribute
records
all
calls
to
child
attributes
of
the
mock
-
and
also
to
their
children
.
r
r
}
r
(
h
.
XZ
attribute
records
all
calls
to
child
attributes
of
the
mock
-
and
also
to
their
children
.
r
h
/
j
ubeubjD
)
r
}
r
(
h
.
X
>
>
>
mock
=
MagicMock
(
)
>
>
>
mock
.
method
(
)
<
MagicMock
name
=
'
mock
.
method
(
)
'
id
=
'
.
.
.
'
>
>
>
>
mock
.
attribute
.
method
(
10
x
=
53
)
<
MagicMock
name
=
'
mock
.
attribute
.
method
(
)
'
id
=
'
.
.
.
'
>
>
>
>
mock
.
mock_calls
[
call
.
method
(
)
call
.
attribute
.
method
(
10
x
=
53
)
]
r
h
/
j
h0h3h5jH
h7
}
r
(
U
testnodetyper
X
doctestr
h
h
h
?
]
r
h
=
]
r
h9
]
r
h
;
]
r
hA
]
r
U
groupsr
]
r
h
ah
}
r
uhCK
hDh
h
)
]
r
hRX
>
>
>
mock
=
MagicMock
(
)
>
>
>
mock
.
method
(
)
<
MagicMock
name
=
'
mock
.
method
(
)
'
id
=
'
.
.
.
'
>
>
>
>
mock
.
attribute
.
method
(
10
x
=
53
)
<
MagicMock
name
=
'
mock
.
attribute
.
method
(
)
'
id
=
'
.
.
.
'
>
>
>
>
mock
.
mock_calls
[
call
.
method
(
)
call
.
attribute
.
method
(
10
x
=
53
)
]
r
r
}
r
(
h
.
U
h
/
j
ubaubh
)
r
}
r
(
h
.
X
)
If
you
make
an
assertion
about
mock_calls
and
any
unexpected
methods
have
been
called
then
the
assertion
will
fail
.
This
is
useful
because
as
well
as
asserting
that
the
calls
you
expected
have
been
made
you
are
also
checking
that
they
were
made
in
the
right
order
and
with
no
additional
calls
:
r
h
/
j
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCK
hDh
h
)
]
r
(
hRX
If
you
make
an
assertion
about
r
r
}
r
(
h
.
X
If
you
make
an
assertion
about
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
mock_calls
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
mock_callsr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRX
and
any
unexpected
methods
have
been
called
then
the
assertion
will
fail
.
This
is
useful
because
as
well
as
asserting
that
the
calls
you
expected
have
been
made
you
are
also
checking
that
they
were
made
in
the
right
order
and
with
no
additional
calls
:
r
r
}
r
(
h
.
X
and
any
unexpected
methods
have
been
called
then
the
assertion
will
fail
.
This
is
useful
because
as
well
as
asserting
that
the
calls
you
expected
have
been
made
you
are
also
checking
that
they
were
made
in
the
right
order
and
with
no
additional
calls
:
r
h
/
j
ubeubh
)
r
}
r
(
h
.
XS
You
use
the
:
data
:
call
object
to
construct
lists
for
comparing
with
mock_calls
:
r
h
/
j
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCK
hDh
h
)
]
r
(
hRX
You
use
the
r
r
}
r
(
h
.
X
You
use
the
r
h
/
j
ubh
)
r
}
r
(
h
.
X
:
data
:
call
r
h
/
j
h0h3h5h
h7
}
r
(
U
reftyper
X
datar
h
h
X
callr
U
refdomainr
X
pyr
h
?
]
r
h
=
]
r
U
refexplicitr
h9
]
r
h
;
]
r
hA
]
r
h
h
h
Nh
NuhCK
h
)
]
r
h
)
r
}
r
(
h
.
j
h7
}
r
(
h9
]
r
h
;
]
r
(
h
j
X
py
-
datar
eh
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
callr
r
}
r
(
h
.
U
h
/
j
ubah5h
ubaubhRX
.
object
to
construct
lists
for
comparing
with
r
!
r
"
}
r
#
(
h
.
X
.
object
to
construct
lists
for
comparing
with
r
h
/
j
ubjf
)
r
%
}
r
&
(
h
.
X
mock_calls
r
'
h7
}
r
(
(
h9
]
r
)
h
;
]
r
*
h
=
]
r
+
h
?
]
r
hA
]
r
-
uh
/
j
h
)
]
r
.
hRX
mock_callsr
/
r0
}
r1
(
h
.
U
h
/
j
%
ubah5jt
ubhRX
:
r2
}
r3
(
h
.
X
:
h
/
j
ubeubjD
)
r4
}
r5
(
h
.
Xd
>
>
>
expected
=
[
call
.
method
(
)
call
.
attribute
.
method
(
10
x
=
53
)
]
>
>
>
mock
.
mock_calls
=
=
expected
Truer6
h
/
j
h0h3h5jH
h7
}
r7
(
U
testnodetyper8
X
doctestr9
h
h
h
?
]
r
:
h
=
]
r
;
h9
]
r
<
h
;
]
r
=
hA
]
r
>
U
groupsr
?
]
r
h
ah
}
rA
uhCK
hDh
h
)
]
rB
hRXd
>
>
>
expected
=
[
call
.
method
(
)
call
.
attribute
.
method
(
10
x
=
53
)
]
>
>
>
mock
.
mock_calls
=
=
expected
TruerC
rD
}
rE
(
h
.
U
h
/
j4
ubaubeubh
+
)
rF
}
rG
(
h
.
U
h
/
h
h0h3h5h6h7
}
rH
(
h9
]
rI
h
;
]
rJ
h
=
]
rK
h
?
]
rL
h
&
ahA
]
rM
h
auhCK
hDh
h
)
]
rN
(
hF
)
rO
}
rP
(
h
.
X
Setting
Return
Values
and
AttributesrQ
h
/
jF
h0h3h5hJh7
}
rR
(
h9
]
rS
h
;
]
rT
h
=
]
rU
h
?
]
rV
hA
]
rW
uhCK
hDh
h
)
]
rX
hRX
Setting
Return
Values
and
AttributesrY
rZ
}
r
[
(
h
.
jQ
h
/
jO
ubaubh
)
r
\
}
r
]
(
h
.
X
=
Setting
the
return
values
on
a
mock
object
is
trivially
easy
:
r
^
h
/
jF
h0h3h5h
h7
}
r_
(
h9
]
r
h
;
]
ra
h
=
]
rb
h
?
]
rc
hA
]
rd
uhCK
hDh
h
)
]
re
hRX
=
Setting
the
return
values
on
a
mock
object
is
trivially
easy
:
rf
rg
}
rh
(
h
.
j
^
h
/
j
\
ubaubjD
)
ri
}
rj
(
h
.
X8
>
>
>
mock
=
Mock
(
)
>
>
>
mock
.
return_value
=
3
>
>
>
mock
(
)
3rk
h
/
jF
h0h3h5jH
h7
}
rl
(
U
testnodetyperm
X
doctestrn
h
h
h
?
]
ro
h
=
]
rp
h9
]
rq
h
;
]
rr
hA
]
rs
U
groupsrt
]
ru
h
ah
}
rv
uhCK
hDh
h
)
]
rw
hRX8
>
>
>
mock
=
Mock
(
)
>
>
>
mock
.
return_value
=
3
>
>
>
mock
(
)
3rx
ry
}
rz
(
h
.
U
h
/
ji
ubaubh
)
r
{
}
r
|
(
h
.
X6
Of
course
you
can
do
the
same
for
methods
on
the
mock
:
r
}
h
/
jF
h0h3h5h
h7
}
r
~
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCK
hDh
h
)
]
r
hRX6
Of
course
you
can
do
the
same
for
methods
on
the
mock
:
r
r
}
r
(
h
.
j
}
h
/
j
{
ubaubjD
)
r
}
r
(
h
.
XF
>
>
>
mock
=
Mock
(
)
>
>
>
mock
.
method
.
return_value
=
3
>
>
>
mock
.
method
(
)
3r
h
/
jF
h0h3h5jH
h7
}
r
(
U
testnodetyper
X
doctestr
h
h
h
?
]
r
h
=
]
r
h9
]
r
h
;
]
r
hA
]
r
U
groupsr
]
r
h
ah
}
r
uhCK
hDh
h
)
]
r
hRXF
>
>
>
mock
=
Mock
(
)
>
>
>
mock
.
method
.
return_value
=
3
>
>
>
mock
.
method
(
)
3r
r
}
r
(
h
.
U
h
/
j
ubaubh
)
r
}
r
(
h
.
X4
The
return
value
can
also
be
set
in
the
constructor
:
r
h
/
jF
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCK
hDh
h
)
]
r
hRX4
The
return
value
can
also
be
set
in
the
constructor
:
r
r
}
r
(
h
.
j
h
/
j
ubaubjD
)
r
}
r
(
h
.
X
>
>
>
mock
=
Mock
(
return_value
=
3
)
>
>
>
mock
(
)
3r
h
/
jF
h0h3h5jH
h7
}
r
(
U
testnodetyper
X
doctestr
h
h
h
?
]
r
h
=
]
r
h9
]
r
h
;
]
r
hA
]
r
U
groupsr
]
r
h
ah
}
r
uhCK
hDh
h
)
]
r
hRX
>
>
>
mock
=
Mock
(
return_value
=
3
)
>
>
>
mock
(
)
3r
r
}
r
(
h
.
U
h
/
j
ubaubh
)
r
}
r
(
h
.
X
:
If
you
need
an
attribute
setting
on
your
mock
just
do
it
:
r
h
/
jF
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCK
hDh
h
)
]
r
hRX
:
If
you
need
an
attribute
setting
on
your
mock
just
do
it
:
r
r
}
r
(
h
.
j
h
/
j
ubaubjD
)
r
}
r
(
h
.
X
-
>
>
>
mock
=
Mock
(
)
>
>
>
mock
.
x
=
3
>
>
>
mock
.
x
3r
h
/
jF
h0h3h5jH
h7
}
r
(
U
testnodetyper
X
doctestr
h
h
h
?
]
r
h
=
]
r
h9
]
r
h
;
]
r
hA
]
r
U
groupsr
]
r
h
ah
}
r
uhCK
hDh
h
)
]
r
hRX
-
>
>
>
mock
=
Mock
(
)
>
>
>
mock
.
x
=
3
>
>
>
mock
.
x
3r
r
}
r
(
h
.
U
h
/
j
ubaubh
)
r
}
r
(
h
.
X
Sometimes
you
want
to
mock
up
a
more
complex
situation
like
for
example
mock
.
connection
.
cursor
(
)
.
execute
(
"
SELECT
1
"
)
.
If
we
wanted
this
call
to
return
a
list
then
we
have
to
configure
the
result
of
the
nested
call
.
r
h
/
jF
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCK
hDh
h
)
]
r
(
hRXI
Sometimes
you
want
to
mock
up
a
more
complex
situation
like
for
example
r
r
}
r
(
h
.
XI
Sometimes
you
want
to
mock
up
a
more
complex
situation
like
for
example
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
.
mock
.
connection
.
cursor
(
)
.
execute
(
"
SELECT
1
"
)
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
mock
.
connection
.
cursor
(
)
.
execute
(
"
SELECT
1
"
)
r
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRXc
.
If
we
wanted
this
call
to
return
a
list
then
we
have
to
configure
the
result
of
the
nested
call
.
r
r
}
r
(
h
.
Xc
.
If
we
wanted
this
call
to
return
a
list
then
we
have
to
configure
the
result
of
the
nested
call
.
r
h
/
j
ubeubh
)
r
}
r
(
h
.
Xr
We
can
use
:
data
:
call
to
construct
the
set
of
calls
in
a
"
chained
call
"
like
this
for
easy
assertion
afterwards
:
r
h
/
jF
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCK
hDh
h
)
]
r
(
hRX
We
can
use
r
r
}
r
(
h
.
X
We
can
use
r
h
/
j
ubh
)
r
}
r
(
h
.
X
:
data
:
call
r
h
/
j
h0h3h5h
h7
}
r
(
U
reftyper
X
datar
h
h
X
callr
U
refdomainr
X
pyr
h
?
]
r
h
=
]
r
U
refexplicitr
h9
]
r
h
;
]
r
hA
]
r
h
h
h
Nh
NuhCK
h
)
]
r
h
)
r
}
r
(
h
.
j
h7
}
r
(
h9
]
r
h
;
]
r
(
h
j
X
py
-
datar
eh
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
callr
r
}
r
!
(
h
.
U
h
/
j
ubah5h
ubaubhRX
[
to
construct
the
set
of
calls
in
a
"
chained
call
"
like
this
for
easy
assertion
afterwards
:
r
"
r
#
}
r
(
h
.
X
[
to
construct
the
set
of
calls
in
a
"
chained
call
"
like
this
for
easy
assertion
afterwards
:
r
%
h
/
j
ubeubjD
)
r
&
}
r
'
(
h
.
Xo
>
>
>
mock
=
Mock
(
)
>
>
>
cursor
=
mock
.
connection
.
cursor
.
return_value
>
>
>
cursor
.
execute
.
return_value
=
[
'
foo
'
]
>
>
>
mock
.
connection
.
cursor
(
)
.
execute
(
"
SELECT
1
"
)
[
'
foo
'
]
>
>
>
expected
=
call
.
connection
.
cursor
(
)
.
execute
(
"
SELECT
1
"
)
.
call_list
(
)
>
>
>
mock
.
mock_calls
[
call
.
connection
.
cursor
(
)
call
.
connection
.
cursor
(
)
.
execute
(
'
SELECT
1
'
)
]
>
>
>
mock
.
mock_calls
=
=
expected
Truer
(
h
/
jF
h0h3h5jH
h7
}
r
)
(
U
testnodetyper
*
X
doctestr
+
h
h
h
?
]
r
h
=
]
r
-
h9
]
r
.
h
;
]
r
/
hA
]
r0
U
groupsr1
]
r2
h
ah
}
r3
uhCK
hDh
h
)
]
r4
hRXo
>
>
>
mock
=
Mock
(
)
>
>
>
cursor
=
mock
.
connection
.
cursor
.
return_value
>
>
>
cursor
.
execute
.
return_value
=
[
'
foo
'
]
>
>
>
mock
.
connection
.
cursor
(
)
.
execute
(
"
SELECT
1
"
)
[
'
foo
'
]
>
>
>
expected
=
call
.
connection
.
cursor
(
)
.
execute
(
"
SELECT
1
"
)
.
call_list
(
)
>
>
>
mock
.
mock_calls
[
call
.
connection
.
cursor
(
)
call
.
connection
.
cursor
(
)
.
execute
(
'
SELECT
1
'
)
]
>
>
>
mock
.
mock_calls
=
=
expected
Truer5
r6
}
r7
(
h
.
U
h
/
j
&
ubaubh
)
r8
}
r9
(
h
.
Xp
It
is
the
call
to
.
call_list
(
)
that
turns
our
call
object
into
a
list
of
calls
representing
the
chained
calls
.
r
:
h
/
jF
h0h3h5h
h7
}
r
;
(
h9
]
r
<
h
;
]
r
=
h
=
]
r
>
h
?
]
r
?
hA
]
r
uhCK
hDh
h
)
]
rA
(
hRX
It
is
the
call
to
rB
rC
}
rD
(
h
.
X
It
is
the
call
to
rE
h
/
j8
ubjf
)
rF
}
rG
(
h
.
X
.
call_list
(
)
rH
h7
}
rI
(
h9
]
rJ
h
;
]
rK
h
=
]
rL
h
?
]
rM
hA
]
rN
uh
/
j8
h
)
]
rO
hRX
.
call_list
(
)
rP
rQ
}
rR
(
h
.
U
h
/
jF
ubah5jt
ubhRXP
that
turns
our
call
object
into
a
list
of
calls
representing
the
chained
calls
.
rS
rT
}
rU
(
h
.
XP
that
turns
our
call
object
into
a
list
of
calls
representing
the
chained
calls
.
rV
h
/
j8
ubeubeubh
+
)
rW
}
rX
(
h
.
U
h
/
h
h0h3h5h6h7
}
rY
(
h9
]
rZ
h
;
]
r
[
h
=
]
r
\
h
?
]
r
]
h
(
ahA
]
r
^
h
auhCK
hDh
h
)
]
r_
(
hF
)
r
}
ra
(
h
.
X
Raising
exceptions
with
mocksrb
h
/
jW
h0h3h5hJh7
}
rc
(
h9
]
rd
h
;
]
re
h
=
]
rf
h
?
]
rg
hA
]
rh
uhCK
hDh
h
)
]
ri
hRX
Raising
exceptions
with
mocksrj
rk
}
rl
(
h
.
jb
h
/
j
ubaubh
)
rm
}
rn
(
h
.
X
A
useful
attribute
is
:
attr
:
~
Mock
.
side_effect
.
If
you
set
this
to
an
exception
class
or
instance
then
the
exception
will
be
raised
when
the
mock
is
called
.
ro
h
/
jW
h0h3h5h
h7
}
rp
(
h9
]
rq
h
;
]
rr
h
=
]
rs
h
?
]
rt
hA
]
ru
uhCK
hDh
h
)
]
rv
(
hRX
A
useful
attribute
is
rw
rx
}
ry
(
h
.
X
A
useful
attribute
is
rz
h
/
jm
ubh
)
r
{
}
r
|
(
h
.
X
:
attr
:
~
Mock
.
side_effect
r
}
h
/
jm
h0h3h5h
h7
}
r
~
(
U
reftyper
X
attrr
h
h
X
Mock
.
side_effectr
U
refdomainr
X
pyr
h
?
]
r
h
=
]
r
U
refexplicitr
h9
]
r
h
;
]
r
hA
]
r
h
h
h
Nh
NuhCK
h
)
]
r
h
)
r
}
r
(
h
.
j
}
h7
}
r
(
h9
]
r
h
;
]
r
(
h
j
X
py
-
attrr
eh
=
]
r
h
?
]
r
hA
]
r
uh
/
j
{
h
)
]
r
hRX
side_effectr
r
}
r
(
h
.
U
h
/
j
ubah5h
ubaubhRXn
.
If
you
set
this
to
an
exception
class
or
instance
then
the
exception
will
be
raised
when
the
mock
is
called
.
r
r
}
r
(
h
.
Xn
.
If
you
set
this
to
an
exception
class
or
instance
then
the
exception
will
be
raised
when
the
mock
is
called
.
r
h
/
jm
ubeubjD
)
r
}
r
(
h
.
Xt
>
>
>
mock
=
Mock
(
side_effect
=
Exception
(
'
Boom
!
'
)
)
>
>
>
mock
(
)
Traceback
(
most
recent
call
last
)
:
.
.
.
Exception
:
Boom
!
r
h
/
jW
h0h3h5jH
h7
}
r
(
U
testnodetyper
X
doctestr
h
h
h
?
]
r
h
=
]
r
h9
]
r
h
;
]
r
hA
]
r
U
groupsr
]
r
h
ah
}
r
uhCK
hDh
h
)
]
r
hRXt
>
>
>
mock
=
Mock
(
side_effect
=
Exception
(
'
Boom
!
'
)
)
>
>
>
mock
(
)
Traceback
(
most
recent
call
last
)
:
.
.
.
Exception
:
Boom
!
r
r
}
r
(
h
.
U
h
/
j
ubaubeubh
+
)
r
}
r
(
h
.
U
h
/
h
h0h3h5h6h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
h
ahA
]
r
h
auhCM
hDh
h
)
]
r
(
hF
)
r
}
r
(
h
.
X
#
Side
effect
functions
and
iterablesr
h
/
j
h0h3h5hJh7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCM
hDh
h
)
]
r
hRX
#
Side
effect
functions
and
iterablesr
r
}
r
(
h
.
j
h
/
j
ubaubh
)
r
}
r
(
h
.
X
side_effect
can
also
be
set
to
a
function
or
an
iterable
.
The
use
case
for
side_effect
as
an
iterable
is
where
your
mock
is
going
to
be
called
several
times
and
you
want
each
call
to
return
a
different
value
.
When
you
set
side_effect
to
an
iterable
every
call
to
the
mock
returns
the
next
value
from
the
iterable
:
r
h
/
j
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCM
hDh
h
)
]
r
(
jf
)
r
}
r
(
h
.
X
side_effect
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
side_effectr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRX
can
also
be
set
to
a
function
or
an
iterable
.
The
use
case
for
r
r
}
r
(
h
.
X
can
also
be
set
to
a
function
or
an
iterable
.
The
use
case
for
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
side_effect
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
side_effectr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRX
as
an
iterable
is
where
your
mock
is
going
to
be
called
several
times
and
you
want
each
call
to
return
a
different
value
.
When
you
set
r
r
}
r
(
h
.
X
as
an
iterable
is
where
your
mock
is
going
to
be
called
several
times
and
you
want
each
call
to
return
a
different
value
.
When
you
set
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
side_effect
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
side_effectr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRXP
to
an
iterable
every
call
to
the
mock
returns
the
next
value
from
the
iterable
:
r
r
}
r
(
h
.
XP
to
an
iterable
every
call
to
the
mock
returns
the
next
value
from
the
iterable
:
r
h
/
j
ubeubjD
)
r
}
r
(
h
.
XR
>
>
>
mock
=
MagicMock
(
side_effect
=
[
4
5
6
]
)
>
>
>
mock
(
)
4
>
>
>
mock
(
)
5
>
>
>
mock
(
)
6r
h
/
j
h0h3h5jH
h7
}
r
(
U
testnodetyper
X
doctestr
h
h
h
?
]
r
h
=
]
r
h9
]
r
h
;
]
r
hA
]
r
U
groupsr
]
r
h
ah
}
r
uhCM
hDh
h
)
]
r
hRXR
>
>
>
mock
=
MagicMock
(
side_effect
=
[
4
5
6
]
)
>
>
>
mock
(
)
4
>
>
>
mock
(
)
5
>
>
>
mock
(
)
6r
r
}
r
(
h
.
U
h
/
j
ubaubh
)
r
}
r
(
h
.
X
For
more
advanced
use
cases
like
dynamically
varying
the
return
values
depending
on
what
the
mock
is
called
with
side_effect
can
be
a
function
.
The
function
will
be
called
with
the
same
arguments
as
the
mock
.
Whatever
the
function
returns
is
what
the
call
returns
:
r
h
/
j
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCM
hDh
h
)
]
r
(
hRXs
For
more
advanced
use
cases
like
dynamically
varying
the
return
values
depending
on
what
the
mock
is
called
with
r
r
}
r
(
h
.
Xs
For
more
advanced
use
cases
like
dynamically
varying
the
return
values
depending
on
what
the
mock
is
called
with
r
h
/
j
ubjf
)
r
!
}
r
"
(
h
.
X
side_effect
r
#
h7
}
r
(
h9
]
r
%
h
;
]
r
&
h
=
]
r
'
h
?
]
r
(
hA
]
r
)
uh
/
j
h
)
]
r
*
hRX
side_effectr
+
r
}
r
-
(
h
.
U
h
/
j
!
ubah5jt
ubhRX
can
be
a
function
.
The
function
will
be
called
with
the
same
arguments
as
the
mock
.
Whatever
the
function
returns
is
what
the
call
returns
:
r
.
r
/
}
r0
(
h
.
X
can
be
a
function
.
The
function
will
be
called
with
the
same
arguments
as
the
mock
.
Whatever
the
function
returns
is
what
the
call
returns
:
r1
h
/
j
ubeubjD
)
r2
}
r3
(
h
.
X
>
>
>
vals
=
{
(
1
2
)
:
1
(
2
3
)
:
2
}
>
>
>
def
side_effect
(
*
args
)
:
.
.
.
return
vals
[
args
]
.
.
.
>
>
>
mock
=
MagicMock
(
side_effect
=
side_effect
)
>
>
>
mock
(
1
2
)
1
>
>
>
mock
(
2
3
)
2r4
h
/
j
h0h3h5jH
h7
}
r5
(
U
testnodetyper6
X
doctestr7
h
h
h
?
]
r8
h
=
]
r9
h9
]
r
:
h
;
]
r
;
hA
]
r
<
U
groupsr
=
]
r
>
h
ah
}
r
?
uhCM
hDh
h
)
]
r
hRX
>
>
>
vals
=
{
(
1
2
)
:
1
(
2
3
)
:
2
}
>
>
>
def
side_effect
(
*
args
)
:
.
.
.
return
vals
[
args
]
.
.
.
>
>
>
mock
=
MagicMock
(
side_effect
=
side_effect
)
>
>
>
mock
(
1
2
)
1
>
>
>
mock
(
2
3
)
2rA
rB
}
rC
(
h
.
U
h
/
j2
ubaubeubh
+
)
rD
}
rE
(
h
.
U
h
/
h
h0h3h5h6h7
}
rF
(
h9
]
rG
h
;
]
rH
h
=
]
rI
h
?
]
rJ
h
'
ahA
]
rK
h
auhCM
.
hDh
h
)
]
rL
(
hF
)
rM
}
rN
(
h
.
X
'
Creating
a
Mock
from
an
Existing
ObjectrO
h
/
jD
h0h3h5hJh7
}
rP
(
h9
]
rQ
h
;
]
rR
h
=
]
rS
h
?
]
rT
hA
]
rU
uhCM
.
hDh
h
)
]
rV
hRX
'
Creating
a
Mock
from
an
Existing
ObjectrW
rX
}
rY
(
h
.
jO
h
/
jM
ubaubh
)
rZ
}
r
[
(
h
.
X
One
problem
with
over
use
of
mocking
is
that
it
couples
your
tests
to
the
implementation
of
your
mocks
rather
than
your
real
code
.
Suppose
you
have
a
class
that
implements
some_method
.
In
a
test
for
another
class
you
provide
a
mock
of
this
object
that
*
also
*
provides
some_method
.
If
later
you
refactor
the
first
class
so
that
it
no
longer
has
some_method
-
then
your
tests
will
continue
to
pass
even
though
your
code
is
now
broken
!
r
\
h
/
jD
h0h3h5h
h7
}
r
]
(
h9
]
r
^
h
;
]
r_
h
=
]
r
h
?
]
ra
hA
]
rb
uhCM0
hDh
h
)
]
rc
(
hRX
One
problem
with
over
use
of
mocking
is
that
it
couples
your
tests
to
the
implementation
of
your
mocks
rather
than
your
real
code
.
Suppose
you
have
a
class
that
implements
rd
re
}
rf
(
h
.
X
One
problem
with
over
use
of
mocking
is
that
it
couples
your
tests
to
the
implementation
of
your
mocks
rather
than
your
real
code
.
Suppose
you
have
a
class
that
implements
rg
h
/
jZ
ubjf
)
rh
}
ri
(
h
.
X
some_method
rj
h7
}
rk
(
h9
]
rl
h
;
]
rm
h
=
]
rn
h
?
]
ro
hA
]
rp
uh
/
jZ
h
)
]
rq
hRX
some_methodrr
rs
}
rt
(
h
.
U
h
/
jh
ubah5jt
ubhRXF
.
In
a
test
for
another
class
you
provide
a
mock
of
this
object
that
ru
rv
}
rw
(
h
.
XF
.
In
a
test
for
another
class
you
provide
a
mock
of
this
object
that
rx
h
/
jZ
ubj
)
ry
}
rz
(
h
.
X
*
also
*
r
{
h7
}
r
|
(
h9
]
r
}
h
;
]
r
~
h
=
]
r
h
?
]
r
hA
]
r
uh
/
jZ
h
)
]
r
hRX
alsor
r
}
r
(
h
.
U
h
/
jy
ubah5j
ubhRX
provides
r
r
}
r
(
h
.
X
provides
r
h
/
jZ
ubjf
)
r
}
r
(
h
.
X
some_method
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
jZ
h
)
]
r
hRX
some_methodr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRXB
.
If
later
you
refactor
the
first
class
so
that
it
no
longer
has
r
r
}
r
(
h
.
XB
.
If
later
you
refactor
the
first
class
so
that
it
no
longer
has
r
h
/
jZ
ubjf
)
r
}
r
(
h
.
X
some_method
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
jZ
h
)
]
r
hRX
some_methodr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRXM
-
then
your
tests
will
continue
to
pass
even
though
your
code
is
now
broken
!
r
r
}
r
(
h
.
XM
-
then
your
tests
will
continue
to
pass
even
though
your
code
is
now
broken
!
r
h
/
jZ
ubeubh
)
r
}
r
(
h
.
X
Mock
allows
you
to
provide
an
object
as
a
specification
for
the
mock
using
the
spec
keyword
argument
.
Accessing
methods
/
attributes
on
the
mock
that
don
'
t
exist
on
your
specification
object
will
immediately
raise
an
attribute
error
.
If
you
change
the
implementation
of
your
specification
then
tests
that
use
that
class
will
start
failing
immediately
without
you
having
to
instantiate
the
class
in
those
tests
.
r
h
/
jD
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCM7
hDh
h
)
]
r
(
jf
)
r
}
r
(
h
.
X
Mock
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
Mockr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRXL
allows
you
to
provide
an
object
as
a
specification
for
the
mock
using
the
r
r
}
r
(
h
.
XL
allows
you
to
provide
an
object
as
a
specification
for
the
mock
using
the
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
spec
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
specr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRXH
keyword
argument
.
Accessing
methods
/
attributes
on
the
mock
that
don
'
t
exist
on
your
specification
object
will
immediately
raise
an
attribute
error
.
If
you
change
the
implementation
of
your
specification
then
tests
that
use
that
class
will
start
failing
immediately
without
you
having
to
instantiate
the
class
in
those
tests
.
r
r
}
r
(
h
.
XH
keyword
argument
.
Accessing
methods
/
attributes
on
the
mock
that
don
'
t
exist
on
your
specification
object
will
immediately
raise
an
attribute
error
.
If
you
change
the
implementation
of
your
specification
then
tests
that
use
that
class
will
start
failing
immediately
without
you
having
to
instantiate
the
class
in
those
tests
.
r
h
/
j
ubeubjD
)
r
}
r
(
h
.
X
>
>
>
mock
=
Mock
(
spec
=
SomeClass
)
>
>
>
mock
.
old_method
(
)
Traceback
(
most
recent
call
last
)
:
.
.
.
AttributeError
:
object
has
no
attribute
'
old_method
'
r
h
/
jD
h0h3h5jH
h7
}
r
(
U
testnodetyper
X
doctestr
h
h
h
?
]
r
h
=
]
r
h9
]
r
h
;
]
r
hA
]
r
U
groupsr
]
r
h
ah
}
r
uhCM
>
hDh
h
)
]
r
hRX
>
>
>
mock
=
Mock
(
spec
=
SomeClass
)
>
>
>
mock
.
old_method
(
)
Traceback
(
most
recent
call
last
)
:
.
.
.
AttributeError
:
object
has
no
attribute
'
old_method
'
r
r
}
r
(
h
.
U
h
/
j
ubaubh
)
r
}
r
(
h
.
X
If
you
want
a
stronger
form
of
specification
that
prevents
the
setting
of
arbitrary
attributes
as
well
as
the
getting
of
them
then
you
can
use
spec_set
instead
of
spec
.
r
h
/
jD
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCMF
hDh
h
)
]
r
(
hRX
If
you
want
a
stronger
form
of
specification
that
prevents
the
setting
of
arbitrary
attributes
as
well
as
the
getting
of
them
then
you
can
use
r
r
}
r
(
h
.
X
If
you
want
a
stronger
form
of
specification
that
prevents
the
setting
of
arbitrary
attributes
as
well
as
the
getting
of
them
then
you
can
use
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
spec_set
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
spec_setr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRX
instead
of
r
r
}
r
(
h
.
X
instead
of
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
spec
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
specr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRX
.
r
}
r
(
h
.
X
.
h
/
j
ubeubeubeubh
+
)
r
}
r
(
h
.
U
h
/
h
h0h3h5h6h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
h
!
ahA
]
r
h
auhCMM
hDh
h
)
]
r
(
hF
)
r
!
}
r
"
(
h
.
X
Patch
Decoratorsr
#
h
/
j
h0h3h5hJh7
}
r
(
h9
]
r
%
h
;
]
r
&
h
=
]
r
'
h
?
]
r
(
hA
]
r
)
uhCMM
hDh
h
)
]
r
*
hRX
Patch
Decoratorsr
+
r
}
r
-
(
h
.
j
#
h
/
j
!
ubaubjy
)
r
.
}
r
/
(
h
.
X
With
patch
it
matters
that
you
patch
objects
in
the
namespace
where
they
are
looked
up
.
This
is
normally
straightforward
but
for
a
quick
guide
read
:
ref
:
where
to
patch
<
where
-
to
-
patch
>
.
r0
h
/
j
h0h3h5j
}
h7
}
r1
(
h9
]
r2
h
;
]
r3
h
=
]
r4
h
?
]
r5
hA
]
r6
uhCNhDh
h
)
]
r7
h
)
r8
}
r9
(
h
.
X
With
patch
it
matters
that
you
patch
objects
in
the
namespace
where
they
are
looked
up
.
This
is
normally
straightforward
but
for
a
quick
guide
read
:
ref
:
where
to
patch
<
where
-
to
-
patch
>
.
r
:
h
/
j
.
h0h3h5h
h7
}
r
;
(
h9
]
r
<
h
;
]
r
=
h
=
]
r
>
h
?
]
r
?
hA
]
r
uhCMQ
h
)
]
rA
(
hRX
With
rB
rC
}
rD
(
h
.
X
With
rE
h
/
j8
ubjf
)
rF
}
rG
(
h
.
X
patch
rH
h7
}
rI
(
h9
]
rJ
h
;
]
rK
h
=
]
rL
h
?
]
rM
hA
]
rN
uh
/
j8
h
)
]
rO
hRX
patchrP
rQ
}
rR
(
h
.
U
h
/
jF
ubah5jt
ubhRX
it
matters
that
you
patch
objects
in
the
namespace
where
they
are
looked
up
.
This
is
normally
straightforward
but
for
a
quick
guide
read
rS
rT
}
rU
(
h
.
X
it
matters
that
you
patch
objects
in
the
namespace
where
they
are
looked
up
.
This
is
normally
straightforward
but
for
a
quick
guide
read
rV
h
/
j8
ubh
)
rW
}
rX
(
h
.
X
&
:
ref
:
where
to
patch
<
where
-
to
-
patch
>
rY
h
/
j8
h0h3h5h
h7
}
rZ
(
U
reftyper
[
X
refr
\
h
h
X
where
-
to
-
patchr
]
U
refdomainr
^
X
stdr_
h
?
]
r
h
=
]
ra
U
refexplicitrb
h9
]
rc
h
;
]
rd
hA
]
re
h
h
uhCMQ
h
)
]
rf
j
)
rg
}
rh
(
h
.
jY
h7
}
ri
(
h9
]
rj
h
;
]
rk
(
h
j_
X
std
-
refrl
eh
=
]
rm
h
?
]
rn
hA
]
ro
uh
/
jW
h
)
]
rp
hRX
where
to
patchrq
rr
}
rs
(
h
.
U
h
/
jg
ubah5j
ubaubhRX
.
rt
}
ru
(
h
.
X
.
h
/
j8
ubeubaubh
)
rv
}
rw
(
h
.
X
[
A
common
need
in
tests
is
to
patch
a
class
attribute
or
a
module
attribute
for
example
patching
a
builtin
or
patching
a
class
in
a
module
to
test
that
it
is
instantiated
.
Modules
and
classes
are
effectively
global
so
patching
on
them
has
to
be
undone
after
the
test
or
the
patch
will
persist
into
other
tests
and
cause
hard
to
diagnose
problems
.
rx
h
/
j
h0h3h5h
h7
}
ry
(
h9
]
rz
h
;
]
r
{
h
=
]
r
|
h
?
]
r
}
hA
]
r
~
uhCMV
hDh
h
)
]
r
hRX
[
A
common
need
in
tests
is
to
patch
a
class
attribute
or
a
module
attribute
for
example
patching
a
builtin
or
patching
a
class
in
a
module
to
test
that
it
is
instantiated
.
Modules
and
classes
are
effectively
global
so
patching
on
them
has
to
be
undone
after
the
test
or
the
patch
will
persist
into
other
tests
and
cause
hard
to
diagnose
problems
.
r
r
}
r
(
h
.
jx
h
/
jv
ubaubh
)
r
}
r
(
h
.
X
mock
provides
three
convenient
decorators
for
this
:
patch
patch
.
object
and
patch
.
dict
.
patch
takes
a
single
string
of
the
form
package
.
module
.
Class
.
attribute
to
specify
the
attribute
you
are
patching
.
It
also
optionally
takes
a
value
that
you
want
the
attribute
(
or
class
or
whatever
)
to
be
replaced
with
.
'
patch
.
object
'
takes
an
object
and
the
name
of
the
attribute
you
would
like
patched
plus
optionally
the
value
to
patch
it
with
.
r
h
/
j
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCM
\
hDh
h
)
]
r
(
hRX4
mock
provides
three
convenient
decorators
for
this
:
r
r
}
r
(
h
.
X4
mock
provides
three
convenient
decorators
for
this
:
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
patch
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
patchr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRX
r
r
}
r
(
h
.
X
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
patch
.
object
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
patch
.
objectr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRX
and
r
r
}
r
(
h
.
X
and
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
patch
.
dict
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
patch
.
dictr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRX
.
r
r
}
r
(
h
.
X
.
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
patch
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
patchr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRX
takes
a
single
string
of
the
form
r
r
}
r
(
h
.
X
takes
a
single
string
of
the
form
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
package
.
module
.
Class
.
attribute
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
package
.
module
.
Class
.
attributer
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRX
to
specify
the
attribute
you
are
patching
.
It
also
optionally
takes
a
value
that
you
want
the
attribute
(
or
class
or
whatever
)
to
be
replaced
with
.
'
patch
.
object
'
takes
an
object
and
the
name
of
the
attribute
you
would
like
patched
plus
optionally
the
value
to
patch
it
with
.
r
r
}
r
(
h
.
X
to
specify
the
attribute
you
are
patching
.
It
also
optionally
takes
a
value
that
you
want
the
attribute
(
or
class
or
whatever
)
to
be
replaced
with
.
'
patch
.
object
'
takes
an
object
and
the
name
of
the
attribute
you
would
like
patched
plus
optionally
the
value
to
patch
it
with
.
r
h
/
j
ubeubh
)
r
}
r
(
h
.
X
patch
.
object
:
r
h
/
j
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCMd
hDh
h
)
]
r
(
jf
)
r
}
r
(
h
.
X
patch
.
object
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
patch
.
objectr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRX
:
r
}
r
(
h
.
X
:
h
/
j
ubeubjD
)
r
}
r
(
h
.
X
>
>
>
original
=
SomeClass
.
attribute
>
>
>
patch
.
object
(
SomeClass
'
attribute
'
sentinel
.
attribute
)
.
.
.
def
test
(
)
:
.
.
.
assert
SomeClass
.
attribute
=
=
sentinel
.
attribute
.
.
.
>
>
>
test
(
)
>
>
>
assert
SomeClass
.
attribute
=
=
original
>
>
>
patch
(
'
package
.
module
.
attribute
'
sentinel
.
attribute
)
.
.
.
def
test
(
)
:
.
.
.
from
package
.
module
import
attribute
.
.
.
assert
attribute
is
sentinel
.
attribute
.
.
.
>
>
>
test
(
)
r
h
/
j
h0h3h5jH
h7
}
r
(
U
testnodetyper
X
doctestr
h
h
h
?
]
r
h
=
]
r
h9
]
r
h
;
]
r
hA
]
r
U
groupsr
]
r
h
ah
}
r
uhCMf
hDh
h
)
]
r
hRX
>
>
>
original
=
SomeClass
.
attribute
>
>
>
patch
.
object
(
SomeClass
'
attribute
'
sentinel
.
attribute
)
.
.
.
def
test
(
)
:
.
.
.
assert
SomeClass
.
attribute
=
=
sentinel
.
attribute
.
.
.
>
>
>
test
(
)
>
>
>
assert
SomeClass
.
attribute
=
=
original
>
>
>
patch
(
'
package
.
module
.
attribute
'
sentinel
.
attribute
)
.
.
.
def
test
(
)
:
.
.
.
from
package
.
module
import
attribute
.
.
.
assert
attribute
is
sentinel
.
attribute
.
.
.
>
>
>
test
(
)
r
r
}
r
(
h
.
U
h
/
j
ubaubh
)
r
}
r
(
h
.
Xb
If
you
are
patching
a
module
(
including
__builtin__
)
then
use
patch
instead
of
patch
.
object
:
r
h
/
j
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCMw
hDh
h
)
]
r
(
hRX
(
If
you
are
patching
a
module
(
including
r
r
}
r
(
h
.
X
(
If
you
are
patching
a
module
(
including
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
__builtin__
r
!
h7
}
r
"
(
h9
]
r
#
h
;
]
r
h
=
]
r
%
h
?
]
r
&
hA
]
r
'
uh
/
j
h
)
]
r
(
hRX
__builtin__r
)
r
*
}
r
+
(
h
.
U
h
/
j
ubah5jt
ubhRX
)
then
use
r
r
-
}
r
.
(
h
.
X
)
then
use
r
/
h
/
j
ubjf
)
r0
}
r1
(
h
.
X
patch
r2
h7
}
r3
(
h9
]
r4
h
;
]
r5
h
=
]
r6
h
?
]
r7
hA
]
r8
uh
/
j
h
)
]
r9
hRX
patchr
:
r
;
}
r
<
(
h
.
U
h
/
j0
ubah5jt
ubhRX
instead
of
r
=
r
>
}
r
?
(
h
.
X
instead
of
r
h
/
j
ubjf
)
rA
}
rB
(
h
.
X
patch
.
object
rC
h7
}
rD
(
h9
]
rE
h
;
]
rF
h
=
]
rG
h
?
]
rH
hA
]
rI
uh
/
j
h
)
]
rJ
hRX
patch
.
objectrK
rL
}
rM
(
h
.
U
h
/
jA
ubah5jt
ubhRX
:
rN
}
rO
(
h
.
X
:
h
/
j
ubeubjD
)
rP
}
rQ
(
h
.
X
>
>
>
mock
=
MagicMock
(
return_value
=
sentinel
.
file_handle
)
>
>
>
with
patch
(
'
__builtin__
.
open
'
mock
)
:
.
.
.
handle
=
open
(
'
filename
'
'
r
'
)
.
.
.
>
>
>
mock
.
assert_called_with
(
'
filename
'
'
r
'
)
>
>
>
assert
handle
=
=
sentinel
.
file_handle
"
incorrect
file
handle
returned
"
rR
h
/
j
h0h3h5jH
h7
}
rS
(
U
testnodetyperT
X
doctestrU
h
h
h
?
]
rV
h
=
]
rW
h9
]
rX
h
;
]
rY
hA
]
rZ
U
groupsr
[
]
r
\
h
ah
}
r
]
uhCMz
hDh
h
)
]
r
^
hRX
>
>
>
mock
=
MagicMock
(
return_value
=
sentinel
.
file_handle
)
>
>
>
with
patch
(
'
__builtin__
.
open
'
mock
)
:
.
.
.
handle
=
open
(
'
filename
'
'
r
'
)
.
.
.
>
>
>
mock
.
assert_called_with
(
'
filename
'
'
r
'
)
>
>
>
assert
handle
=
=
sentinel
.
file_handle
"
incorrect
file
handle
returned
"
r_
r
}
ra
(
h
.
U
h
/
jP
ubaubh
)
rb
}
rc
(
h
.
XH
The
module
name
can
be
'
dotted
'
in
the
form
package
.
module
if
needed
:
rd
h
/
j
h0h3h5h
h7
}
re
(
h9
]
rf
h
;
]
rg
h
=
]
rh
h
?
]
ri
hA
]
rj
uhCM
hDh
h
)
]
rk
(
hRX
-
The
module
name
can
be
'
dotted
'
in
the
form
rl
rm
}
rn
(
h
.
X
-
The
module
name
can
be
'
dotted
'
in
the
form
ro
h
/
jb
ubjf
)
rp
}
rq
(
h
.
X
package
.
module
rr
h7
}
rs
(
h9
]
rt
h
;
]
ru
h
=
]
rv
h
?
]
rw
hA
]
rx
uh
/
jb
h
)
]
ry
hRX
package
.
modulerz
r
{
}
r
|
(
h
.
U
h
/
jp
ubah5jt
ubhRX
if
needed
:
r
}
r
~
}
r
(
h
.
X
if
needed
:
r
h
/
jb
ubeubjD
)
r
}
r
(
h
.
X
>
>
>
patch
(
'
package
.
module
.
ClassName
.
attribute
'
sentinel
.
attribute
)
.
.
.
def
test
(
)
:
.
.
.
from
package
.
module
import
ClassName
.
.
.
assert
ClassName
.
attribute
=
=
sentinel
.
attribute
.
.
.
>
>
>
test
(
)
r
h
/
j
h0h3h5jH
h7
}
r
(
U
testnodetyper
X
doctestr
h
h
h
?
]
r
h
=
]
r
h9
]
r
h
;
]
r
hA
]
r
U
groupsr
]
r
h
ah
}
r
uhCM
hDh
h
)
]
r
hRX
>
>
>
patch
(
'
package
.
module
.
ClassName
.
attribute
'
sentinel
.
attribute
)
.
.
.
def
test
(
)
:
.
.
.
from
package
.
module
import
ClassName
.
.
.
assert
ClassName
.
attribute
=
=
sentinel
.
attribute
.
.
.
>
>
>
test
(
)
r
r
}
r
(
h
.
U
h
/
j
ubaubh
)
r
}
r
(
h
.
X
?
A
nice
pattern
is
to
actually
decorate
test
methods
themselves
:
r
h
/
j
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCM
hDh
h
)
]
r
hRX
?
A
nice
pattern
is
to
actually
decorate
test
methods
themselves
:
r
r
}
r
(
h
.
j
h
/
j
ubaubjD
)
r
}
r
(
h
.
XO
>
>
>
class
MyTest
(
unittest2
.
TestCase
)
:
.
.
.
patch
.
object
(
SomeClass
'
attribute
'
sentinel
.
attribute
)
.
.
.
def
test_something
(
self
)
:
.
.
.
self
.
assertEqual
(
SomeClass
.
attribute
sentinel
.
attribute
)
.
.
.
>
>
>
original
=
SomeClass
.
attribute
>
>
>
MyTest
(
'
test_something
'
)
.
test_something
(
)
>
>
>
assert
SomeClass
.
attribute
=
=
originalr
h
/
j
h0h3h5jH
h7
}
r
(
U
testnodetyper
X
doctestr
h
h
h
?
]
r
h
=
]
r
h9
]
r
h
;
]
r
hA
]
r
U
groupsr
]
r
h
ah
}
r
uhCM
hDh
h
)
]
r
hRXO
>
>
>
class
MyTest
(
unittest2
.
TestCase
)
:
.
.
.
patch
.
object
(
SomeClass
'
attribute
'
sentinel
.
attribute
)
.
.
.
def
test_something
(
self
)
:
.
.
.
self
.
assertEqual
(
SomeClass
.
attribute
sentinel
.
attribute
)
.
.
.
>
>
>
original
=
SomeClass
.
attribute
>
>
>
MyTest
(
'
test_something
'
)
.
test_something
(
)
>
>
>
assert
SomeClass
.
attribute
=
=
originalr
r
}
r
(
h
.
U
h
/
j
ubaubh
)
r
}
r
(
h
.
X
If
you
want
to
patch
with
a
Mock
you
can
use
patch
with
only
one
argument
(
or
patch
.
object
with
two
arguments
)
.
The
mock
will
be
created
for
you
and
passed
into
the
test
function
/
method
:
r
h
/
j
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCM
hDh
h
)
]
r
(
hRX
.
If
you
want
to
patch
with
a
Mock
you
can
use
r
r
}
r
(
h
.
X
.
If
you
want
to
patch
with
a
Mock
you
can
use
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
patch
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
patchr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRX
with
only
one
argument
(
or
r
r
}
r
(
h
.
X
with
only
one
argument
(
or
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
patch
.
object
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
patch
.
objectr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRXb
with
two
arguments
)
.
The
mock
will
be
created
for
you
and
passed
into
the
test
function
/
method
:
r
r
}
r
(
h
.
Xb
with
two
arguments
)
.
The
mock
will
be
created
for
you
and
passed
into
the
test
function
/
method
:
r
h
/
j
ubeubjD
)
r
}
r
(
h
.
X
>
>
>
class
MyTest
(
unittest2
.
TestCase
)
:
.
.
.
patch
.
object
(
SomeClass
'
static_method
'
)
.
.
.
def
test_something
(
self
mock_method
)
:
.
.
.
SomeClass
.
static_method
(
)
.
.
.
mock_method
.
assert_called_with
(
)
.
.
.
>
>
>
MyTest
(
'
test_something
'
)
.
test_something
(
)
r
h
/
j
h0h3h5jH
h7
}
r
(
U
testnodetyper
X
doctestr
h
h
h
?
]
r
h
=
]
r
h9
]
r
h
;
]
r
hA
]
r
U
groupsr
]
r
h
ah
}
r
uhCM
hDh
h
)
]
r
hRX
>
>
>
class
MyTest
(
unittest2
.
TestCase
)
:
.
.
.
patch
.
object
(
SomeClass
'
static_method
'
)
.
.
.
def
test_something
(
self
mock_method
)
:
.
.
.
SomeClass
.
static_method
(
)
.
.
.
mock_method
.
assert_called_with
(
)
.
.
.
>
>
>
MyTest
(
'
test_something
'
)
.
test_something
(
)
r
r
}
r
(
h
.
U
h
/
j
ubaubh
)
r
}
r
(
h
.
X
>
You
can
stack
up
multiple
patch
decorators
using
this
pattern
:
r
h
/
j
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCM
hDh
h
)
]
r
hRX
>
You
can
stack
up
multiple
patch
decorators
using
this
pattern
:
r
r
}
r
(
h
.
j
h
/
j
ubaubjD
)
r
}
r
(
h
.
Xs
>
>
>
class
MyTest
(
unittest2
.
TestCase
)
:
.
.
.
patch
(
'
package
.
module
.
ClassName1
'
)
.
.
.
patch
(
'
package
.
module
.
ClassName2
'
)
.
.
.
def
test_something
(
self
MockClass2
MockClass1
)
:
.
.
.
self
.
assertTrue
(
package
.
module
.
ClassName1
is
MockClass1
)
.
.
.
self
.
assertTrue
(
package
.
module
.
ClassName2
is
MockClass2
)
.
.
.
>
>
>
MyTest
(
'
test_something
'
)
.
test_something
(
)
r
h
/
j
h0h3h5jH
h7
}
r
(
U
testnodetyper
X
doctestr
h
h
h
?
]
r
h
=
]
r
h9
]
r
h
;
]
r
hA
]
r
U
groupsr
]
r
h
ah
}
r
uhCM
hDh
h
)
]
r
hRXs
>
>
>
class
MyTest
(
unittest2
.
TestCase
)
:
.
.
.
patch
(
'
package
.
module
.
ClassName1
'
)
.
.
.
patch
(
'
package
.
module
.
ClassName2
'
)
.
.
.
def
test_something
(
self
MockClass2
MockClass1
)
:
.
.
.
self
.
assertTrue
(
package
.
module
.
ClassName1
is
MockClass1
)
.
.
.
self
.
assertTrue
(
package
.
module
.
ClassName2
is
MockClass2
)
.
.
.
>
>
>
MyTest
(
'
test_something
'
)
.
test_something
(
)
r
r
}
r
(
h
.
U
h
/
j
ubaubh
)
r
}
r
(
h
.
X
When
you
nest
patch
decorators
the
mocks
are
passed
in
to
the
decorated
function
in
the
same
order
they
applied
(
the
normal
*
python
*
order
that
decorators
are
applied
)
.
This
means
from
the
bottom
up
so
in
the
example
above
the
mock
for
test_module
.
ClassName2
is
passed
in
first
.
r
h
/
j
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCM
hDh
h
)
]
r
(
hRX
|
When
you
nest
patch
decorators
the
mocks
are
passed
in
to
the
decorated
function
in
the
same
order
they
applied
(
the
normal
r
r
}
r
(
h
.
X
|
When
you
nest
patch
decorators
the
mocks
are
passed
in
to
the
decorated
function
in
the
same
order
they
applied
(
the
normal
r
h
/
j
ubj
)
r
!
}
r
"
(
h
.
X
*
python
*
r
#
h7
}
r
(
h9
]
r
%
h
;
]
r
&
h
=
]
r
'
h
?
]
r
(
hA
]
r
)
uh
/
j
h
)
]
r
*
hRX
pythonr
+
r
}
r
-
(
h
.
U
h
/
j
!
ubah5j
ubhRXi
order
that
decorators
are
applied
)
.
This
means
from
the
bottom
up
so
in
the
example
above
the
mock
for
r
.
r
/
}
r0
(
h
.
Xi
order
that
decorators
are
applied
)
.
This
means
from
the
bottom
up
so
in
the
example
above
the
mock
for
r1
h
/
j
ubjf
)
r2
}
r3
(
h
.
X
test_module
.
ClassName2
r4
h7
}
r5
(
h9
]
r6
h
;
]
r7
h
=
]
r8
h
?
]
r9
hA
]
r
:
uh
/
j
h
)
]
r
;
hRX
test_module
.
ClassName2r
<
r
=
}
r
>
(
h
.
U
h
/
j2
ubah5jt
ubhRX
is
passed
in
first
.
r
?
r
}
rA
(
h
.
X
is
passed
in
first
.
rB
h
/
j
ubeubh
)
rC
}
rD
(
h
.
X
There
is
also
:
func
:
patch
.
dict
for
setting
values
in
a
dictionary
just
during
a
scope
and
restoring
the
dictionary
to
its
original
state
when
the
test
ends
:
rE
h
/
j
h0h3h5h
h7
}
rF
(
h9
]
rG
h
;
]
rH
h
=
]
rI
h
?
]
rJ
hA
]
rK
uhCM
hDh
h
)
]
rL
(
hRX
There
is
also
rM
rN
}
rO
(
h
.
X
There
is
also
rP
h
/
jC
ubh
)
rQ
}
rR
(
h
.
X
:
func
:
patch
.
dict
rS
h
/
jC
h0h3h5h
h7
}
rT
(
U
reftyperU
X
funcrV
h
h
X
patch
.
dictrW
U
refdomainrX
X
pyrY
h
?
]
rZ
h
=
]
r
[
U
refexplicitr
\
h9
]
r
]
h
;
]
r
^
hA
]
r_
h
h
h
Nh
NuhCM
h
)
]
r
h
)
ra
}
rb
(
h
.
jS
h7
}
rc
(
h9
]
rd
h
;
]
re
(
h
jY
X
py
-
funcrf
eh
=
]
rg
h
?
]
rh
hA
]
ri
uh
/
jQ
h
)
]
rj
hRX
patch
.
dict
(
)
rk
rl
}
rm
(
h
.
U
h
/
ja
ubah5h
ubaubhRX
~
for
setting
values
in
a
dictionary
just
during
a
scope
and
restoring
the
dictionary
to
its
original
state
when
the
test
ends
:
rn
ro
}
rp
(
h
.
X
~
for
setting
values
in
a
dictionary
just
during
a
scope
and
restoring
the
dictionary
to
its
original
state
when
the
test
ends
:
rq
h
/
jC
ubeubjD
)
rr
}
rs
(
h
.
X
>
>
>
foo
=
{
'
key
'
:
'
value
'
}
>
>
>
original
=
foo
.
copy
(
)
>
>
>
with
patch
.
dict
(
foo
{
'
newkey
'
:
'
newvalue
'
}
clear
=
True
)
:
.
.
.
assert
foo
=
=
{
'
newkey
'
:
'
newvalue
'
}
.
.
.
>
>
>
assert
foo
=
=
originalrt
h
/
j
h0h3h5jH
h7
}
ru
(
U
testnodetyperv
X
doctestrw
h
h
h
?
]
rx
h
=
]
ry
h9
]
rz
h
;
]
r
{
hA
]
r
|
U
groupsr
}
]
r
~
h
ah
}
r
uhCM
hDh
h
)
]
r
hRX
>
>
>
foo
=
{
'
key
'
:
'
value
'
}
>
>
>
original
=
foo
.
copy
(
)
>
>
>
with
patch
.
dict
(
foo
{
'
newkey
'
:
'
newvalue
'
}
clear
=
True
)
:
.
.
.
assert
foo
=
=
{
'
newkey
'
:
'
newvalue
'
}
.
.
.
>
>
>
assert
foo
=
=
originalr
r
}
r
(
h
.
U
h
/
jr
ubaubh
)
r
}
r
(
h
.
XM
patch
patch
.
object
and
patch
.
dict
can
all
be
used
as
context
managers
.
r
h
/
j
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCM
hDh
h
)
]
r
(
jf
)
r
}
r
(
h
.
X
patch
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
patchr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRX
r
r
}
r
(
h
.
X
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
patch
.
object
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
patch
.
objectr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRX
and
r
r
}
r
(
h
.
X
and
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
patch
.
dict
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
patch
.
dictr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRX
%
can
all
be
used
as
context
managers
.
r
r
}
r
(
h
.
X
%
can
all
be
used
as
context
managers
.
r
h
/
j
ubeubh
)
r
}
r
(
h
.
X
~
Where
you
use
patch
to
create
a
mock
for
you
you
can
get
a
reference
to
the
mock
using
the
"
as
"
form
of
the
with
statement
:
r
h
/
j
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCM
hDh
h
)
]
r
(
hRX
Where
you
use
r
r
}
r
(
h
.
X
Where
you
use
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
patch
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
patchr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRXi
to
create
a
mock
for
you
you
can
get
a
reference
to
the
mock
using
the
"
as
"
form
of
the
with
statement
:
r
r
}
r
(
h
.
Xi
to
create
a
mock
for
you
you
can
get
a
reference
to
the
mock
using
the
"
as
"
form
of
the
with
statement
:
r
h
/
j
ubeubjD
)
r
}
r
(
h
.
X
(
>
>
>
class
ProductionClass
(
object
)
:
.
.
.
def
method
(
self
)
:
.
.
.
pass
.
.
.
>
>
>
with
patch
.
object
(
ProductionClass
'
method
'
)
as
mock_method
:
.
.
.
mock_method
.
return_value
=
None
.
.
.
real
=
ProductionClass
(
)
.
.
.
real
.
method
(
1
2
3
)
.
.
.
>
>
>
mock_method
.
assert_called_with
(
1
2
3
)
r
h
/
j
h0h3h5jH
h7
}
r
(
U
testnodetyper
X
doctestr
h
h
h
?
]
r
h
=
]
r
h9
]
r
h
;
]
r
hA
]
r
U
groupsr
]
r
h
ah
}
r
uhCM
hDh
h
)
]
r
hRX
(
>
>
>
class
ProductionClass
(
object
)
:
.
.
.
def
method
(
self
)
:
.
.
.
pass
.
.
.
>
>
>
with
patch
.
object
(
ProductionClass
'
method
'
)
as
mock_method
:
.
.
.
mock_method
.
return_value
=
None
.
.
.
real
=
ProductionClass
(
)
.
.
.
real
.
method
(
1
2
3
)
.
.
.
>
>
>
mock_method
.
assert_called_with
(
1
2
3
)
r
r
}
r
(
h
.
U
h
/
j
ubaubh
)
r
}
r
(
h
.
X
As
an
alternative
patch
patch
.
object
and
patch
.
dict
can
be
used
as
class
decorators
.
When
used
in
this
way
it
is
the
same
as
applying
the
decorator
indvidually
to
every
method
whose
name
starts
with
"
test
"
.
r
h
/
j
h0h3h5h
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uhCM
hDh
h
)
]
r
(
hRX
As
an
alternative
r
r
}
r
(
h
.
X
As
an
alternative
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
patch
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
patchr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRX
r
r
}
r
(
h
.
X
r
h
/
j
ubjf
)
r
}
r
(
h
.
X
patch
.
object
r
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
patch
.
objectr
r
}
r
(
h
.
U
h
/
j
ubah5jt
ubhRX
and
r
r
}
r
(
h
.
X
and
r
!
h
/
j
ubjf
)
r
"
}
r
#
(
h
.
X
patch
.
dict
r
h7
}
r
%
(
h9
]
r
&
h
;
]
r
'
h
=
]
r
(
h
?
]
r
)
hA
]
r
*
uh
/
j
h
)
]
r
+
hRX
patch
.
dictr
r
-
}
r
.
(
h
.
U
h
/
j
"
ubah5jt
ubhRX
can
be
used
as
class
decorators
.
When
used
in
this
way
it
is
the
same
as
applying
the
decorator
indvidually
to
every
method
whose
name
starts
with
"
test
"
.
r
/
r0
}
r1
(
h
.
X
can
be
used
as
class
decorators
.
When
used
in
this
way
it
is
the
same
as
applying
the
decorator
indvidually
to
every
method
whose
name
starts
with
"
test
"
.
r2
h
/
j
ubeubh
)
r3
}
r4
(
h
.
XF
For
some
more
advanced
examples
see
the
:
ref
:
further
-
examples
page
.
r5
h
/
j
h0h3h5h
h7
}
r6
(
h9
]
r7
h
;
]
r8
h
=
]
r9
h
?
]
r
:
hA
]
r
;
uhCM
hDh
h
)
]
r
<
(
hRX
)
For
some
more
advanced
examples
see
the
r
=
r
>
}
r
?
(
h
.
X
)
For
some
more
advanced
examples
see
the
r
h
/
j3
ubh
)
rA
}
rB
(
h
.
X
:
ref
:
further
-
examples
rC
h
/
j3
h0h3h5h
h7
}
rD
(
U
reftyperE
X
refrF
h
h
X
further
-
examplesrG
U
refdomainrH
X
stdrI
h
?
]
rJ
h
=
]
rK
U
refexplicitrL
h9
]
rM
h
;
]
rN
hA
]
rO
h
h
uhCM
h
)
]
rP
j
)
rQ
}
rR
(
h
.
jC
h7
}
rS
(
h9
]
rT
h
;
]
rU
(
h
jI
X
std
-
refrV
eh
=
]
rW
h
?
]
rX
hA
]
rY
uh
/
jA
h
)
]
rZ
hRX
further
-
examplesr
[
r
\
}
r
]
(
h
.
U
h
/
jQ
ubah5j
ubaubhRX
page
.
r
^
r_
}
r
(
h
.
X
page
.
ra
h
/
j3
ubeubeubeubah
.
U
U
transformerrb
NU
footnote_refsrc
}
rd
U
refnamesre
}
rf
U
symbol_footnotesrg
]
rh
U
autofootnote_refsri
]
rj
U
symbol_footnote_refsrk
]
rl
U
citationsrm
]
rn
hDh
U
current_linero
NU
transform_messagesrp
]
rq
(
cdocutils
.
nodes
system_message
rr
)
rs
}
rt
(
h
.
U
h7
}
ru
(
h9
]
rv
U
levelrw
K
h
?
]
rx
h
=
]
ry
U
sourcerz
h3h
;
]
r
{
hA
]
r
|
U
liner
}
K
U
typer
~
U
INFOr
uh
)
]
r
h
)
r
}
r
(
h
.
U
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
js
h
)
]
r
hRX5
Hyperlink
target
"
getting
-
started
"
is
not
referenced
.
r
r
}
r
(
h
.
U
h
/
j
ubah5h
ubah5U
system_messager
ubjr
)
r
}
r
(
h
.
U
h7
}
r
(
h9
]
r
U
levelr
K
h
?
]
r
h
=
]
r
U
sourcer
h3h
;
]
r
hA
]
r
U
liner
K
U
typer
j
uh
)
]
r
h
)
r
}
r
(
h
.
U
h7
}
r
(
h9
]
r
h
;
]
r
h
=
]
r
h
?
]
r
hA
]
r
uh
/
j
h
)
]
r
hRX
-
Hyperlink
target
"
index
-
0
"
is
not
referenced
.
r
r
}
r
(
h
.
U
h
/
j
ubah5h
ubah5j
ubeU
reporterr
NU
id_startr
K
U
autofootnotesr
]
r
U
citation_refsr
}
r
U
indirect_targetsr
]
r
U
settingsr
(
cdocutils
.
frontend
Values
r
or
}
r
(
U
footnote_backlinksr
K
U
record_dependenciesr
NU
rfc_base_urlr
U
http
:
/
/
tools
.
ietf
.
org
/
html
/
r
U
tracebackr
U
pep_referencesr
NU
strip_commentsr
NU
toc_backlinksr
U
entryr
U
language_coder
U
enr
U
datestampr
NU
report_levelr
K
U
_destinationr
NU
halt_levelr
K
U
strip_classesr
NhJNU
error_encoding_error_handlerr
U
backslashreplacer
U
debugr
NU
embed_stylesheetr
U
output_encoding_error_handlerr
U
strictr
U
sectnum_xformr
K
U
dump_transformsr
NU
docinfo_xformr
K
U
warning_streamr
NU
pep_file_url_templater
U
pep
-
%
04dr
U
exit_status_levelr
K
U
configr
NU
strict_visitorr
NU
cloak_email_addressesr
U
trim_footnote_reference_spacer
U
envr
NU
dump_pseudo_xmlr
NU
expose_internalsr
NU
sectsubtitle_xformr
U
source_linkr
NU
rfc_referencesr
NU
output_encodingr
U
utf
-
8r
U
source_urlr
NU
input_encodingr
U
utf
-
8
-
sigr
U
_disable_configr
NU
id_prefixr
U
U
tab_widthr
K
U
error_encodingr
U
mac
-
romanr
U
_sourcer
U
&
/
compile
/
mock
/
docs
/
getting
-
started
.
txtr
U
gettext_compactr
U
generatorr
NU
dump_internalsr
NU
pep_base_urlr
U
http
:
/
/
www
.
python
.
org
/
dev
/
peps
/
r
U
syntax_highlightr
U
shortr
U
input_encoding_error_handlerr
j
U
auto_id_prefixr
U
idr
U
doctitle_xformr
U
strip_elements_with_classesr
NU
_config_filesr
]
r
U
file_insertion_enabledr
K
U
raw_enabledr
K
U
dump_settingsr
NubU
symbol_footnote_startr
K
U
idsr
}
r
(
h
!
j
h
j
h
hWh
'
jD
h
h
h
#
j
h
&
jF
h
"
h
hohsh
(
jW
h
j
h
j
h
%
jK
h
h
uU
substitution_namesr
}
r
h5hDh7
}
r
(
h9
]
r
h
?
]
r
h
=
]
r
U
sourcer
h3h
;
]
r
hA
]
r
uU
footnotesr
]
r
U
refidsr
}
r
ub
.
