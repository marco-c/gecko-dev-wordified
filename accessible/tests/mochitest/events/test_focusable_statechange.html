<
html
>
<
head
>
<
title
>
Test
removal
of
focused
accessible
<
/
title
>
<
link
rel
=
"
stylesheet
"
type
=
"
text
/
css
"
href
=
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
test
.
css
"
/
>
<
script
src
=
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
SimpleTest
.
js
"
>
<
/
script
>
<
script
type
=
"
application
/
javascript
"
src
=
"
.
.
/
common
.
js
"
>
<
/
script
>
<
script
type
=
"
application
/
javascript
"
src
=
"
.
.
/
role
.
js
"
>
<
/
script
>
<
script
type
=
"
application
/
javascript
"
src
=
"
.
.
/
states
.
js
"
>
<
/
script
>
<
script
type
=
"
application
/
javascript
"
src
=
"
.
.
/
promisified
-
events
.
js
"
>
<
/
script
>
<
script
type
=
"
application
/
javascript
"
>
function
focusableStateChange
(
id
enabled
)
{
return
[
EVENT_STATE_CHANGE
e
=
>
{
e
.
QueryInterface
(
nsIAccessibleStateChangeEvent
)
;
return
getAccessible
(
id
)
=
=
e
.
accessible
&
&
e
.
state
=
=
STATE_FOCUSABLE
&
&
(
enabled
=
=
undefined
|
|
e
.
isEnabled
=
=
enabled
)
;
}
]
;
}
async
function
doTests
(
)
{
info
(
"
disable
buttons
.
"
)
;
/
/
Expect
focusable
change
with
'
disabled
'
/
/
and
don
'
t
expect
it
with
'
aria
-
disabled
'
.
let
p
=
waitForEvents
(
{
expected
:
[
focusableStateChange
(
"
button2
"
false
)
]
unexpected
:
[
focusableStateChange
(
"
button1
"
)
]
}
)
;
getNode
(
"
button1
"
)
.
setAttribute
(
"
aria
-
disabled
"
"
true
"
)
;
getNode
(
"
button2
"
)
.
disabled
=
true
;
await
p
;
info
(
"
re
-
enable
button
"
)
;
/
/
Expect
focusable
change
with
'
disabled
'
/
/
and
don
'
t
expect
it
with
'
aria
-
disabled
'
.
p
=
waitForEvents
(
{
expected
:
[
focusableStateChange
(
"
button2
"
true
)
]
unexpected
:
[
focusableStateChange
(
"
button1
"
)
]
}
)
;
getNode
(
"
button1
"
)
.
setAttribute
(
"
aria
-
disabled
"
"
false
"
)
;
getNode
(
"
button2
"
)
.
disabled
=
false
;
await
p
;
info
(
"
add
tabindex
"
)
;
/
/
Expect
focusable
change
on
non
-
input
/
/
and
don
'
t
expect
event
on
an
already
focusable
input
.
p
=
waitForEvents
(
{
expected
:
[
focusableStateChange
(
"
div
"
true
)
]
unexpected
:
[
focusableStateChange
(
"
button2
"
)
]
}
)
;
getNode
(
"
button2
"
)
.
tabIndex
=
"
0
"
;
getNode
(
"
div
"
)
.
tabIndex
=
"
0
"
;
await
p
;
info
(
"
remove
tabindex
"
)
;
/
/
Expect
focusable
change
when
removing
tabindex
.
p
=
waitForEvent
(
.
.
.
focusableStateChange
(
"
div
"
false
)
)
;
getNode
(
"
div
"
)
.
removeAttribute
(
"
tabindex
"
)
;
await
p
;
/
/
When
an
element
that
has
overflow
content
gets
set
to
/
/
"
auto
"
scrollbars
appear
and
the
element
should
become
focusable
.
info
(
"
change
to
overflow
:
auto
"
)
;
p
=
waitForEvent
(
.
.
.
focusableStateChange
(
"
scrollable1
"
true
)
)
;
getNode
(
"
scrollable1
"
)
.
style
.
overflow
=
"
auto
"
;
await
p
;
/
/
If
an
overflow
:
auto
element
'
s
children
change
to
fit
/
/
within
its
bounds
the
scrollability
goes
away
and
the
/
/
element
becomes
not
focusable
.
info
(
"
clamp
height
to
parent
"
)
;
p
=
waitForEvent
(
.
.
.
focusableStateChange
(
"
scrollable1
"
false
)
)
;
getNode
(
"
in
-
scrollable1
"
)
.
style
.
height
=
"
100
%
"
;
await
p
;
/
/
If
an
overflow
:
auto
element
'
s
children
become
larger
/
/
than
its
bounding
box
it
becomes
scrollable
and
focusable
/
/
again
.
If
the
element
is
contenteditable
it
is
already
focusable
/
/
so
we
don
'
t
expect
an
event
for
that
.
info
(
"
unclamp
height
from
parent
"
)
;
p
=
waitForEvents
(
{
expected
:
[
focusableStateChange
(
"
scrollable1
"
true
)
]
unexpected
:
[
focusableStateChange
(
"
scrollable2
"
)
]
}
)
;
getNode
(
"
in
-
scrollable2
"
)
.
style
.
height
=
"
200
%
"
;
getNode
(
"
in
-
scrollable1
"
)
.
style
.
height
=
"
200
%
"
;
await
p
;
/
/
overflow
:
hidden
disables
scrollability
and
focusability
.
/
/
An
overflowing
textarea
should
not
fire
an
event
since
it
/
/
is
always
focusable
.
info
(
"
change
to
overflow
:
hidden
"
)
;
p
=
waitForEvents
(
{
expected
:
[
focusableStateChange
(
"
scrollable1
"
false
)
]
unexpected
:
[
focusableStateChange
(
"
textarea
"
)
]
}
)
;
getNode
(
"
textarea
"
)
.
value
=
"
one
\
ntwo
\
nthree
\
nfour
\
nfive
"
;
getNode
(
"
scrollable1
"
)
.
style
.
overflow
=
"
hidden
"
;
await
p
;
/
/
contenteditable
makes
things
focusable
p
=
waitForEvent
(
.
.
.
focusableStateChange
(
"
scrollable1
"
true
)
)
;
getNode
(
"
scrollable1
"
)
.
contentEditable
=
"
true
"
;
await
p
;
/
/
A
disabled
textarea
will
file
a
focusable
state
change
event
.
/
/
A
disabled
overflow
:
auto
div
won
'
t
.
info
(
"
change
to
overflow
:
hidden
"
)
;
p
=
waitForEvents
(
{
expected
:
[
focusableStateChange
(
"
textarea
"
false
)
]
unexpected
:
[
focusableStateChange
(
"
scrollable2
"
)
]
}
)
;
getNode
(
"
textarea
"
)
.
disabled
=
true
;
getNode
(
"
scrollable2
"
)
.
setAttribute
(
"
disabled
"
"
true
"
)
;
await
p
;
SimpleTest
.
finish
(
)
;
}
SimpleTest
.
waitForExplicitFinish
(
)
;
addA11yLoadEvent
(
doTests
)
;
<
/
script
>
<
/
head
>
<
body
>
<
p
id
=
"
display
"
>
<
/
p
>
<
div
id
=
"
content
"
style
=
"
display
:
none
"
>
<
/
div
>
<
pre
id
=
"
test
"
>
<
/
pre
>
<
button
id
=
"
button1
"
>
<
/
button
>
<
button
id
=
"
button2
"
>
<
/
button
>
<
div
id
=
"
div
"
>
Hello
<
/
div
>
<
div
id
=
"
scrollable1
"
role
=
"
group
"
style
=
"
width
:
50px
;
height
:
50px
;
overflow
:
hidden
;
"
>
<
div
id
=
"
in
-
scrollable1
"
style
=
"
width
:
100
%
;
height
:
200
%
;
"
>
<
/
div
>
<
/
div
>
<
div
id
=
"
scrollable2
"
role
=
"
group
"
style
=
"
width
:
50px
;
height
:
50px
;
overflow
:
auto
;
"
contenteditable
=
"
true
"
>
<
div
id
=
"
in
-
scrollable2
"
style
=
"
width
:
100
%
;
height
:
100
%
;
"
>
<
/
div
>
<
/
div
>
<
textarea
id
=
"
textarea
"
rows
=
"
3
"
cols
=
"
30
"
>
<
/
textarea
>
<
/
body
>
<
/
html
>
