#
!
/
usr
/
bin
/
python3
#
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
#
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
#
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
"
"
"
Script
to
parse
and
print
UI
test
JUnit
results
from
a
FullJUnitReport
.
xml
file
.
This
script
processes
JUnit
test
results
generated
by
Flank
and
Firebase
Test
Lab
.
It
reads
test
results
from
a
specified
directory
containing
a
full
JUnit
report
parses
the
results
to
identify
test
failures
and
flaky
tests
and
prints
a
formatted
table
summarizing
these
results
to
the
console
.
-
Parses
JUnit
XML
test
result
files
including
custom
'
flaky
'
attributes
.
-
Identifies
and
displays
unique
test
failures
and
flaky
tests
.
-
Prints
the
results
in
a
readable
table
format
using
BeautifulTable
.
-
Provides
detailed
failure
messages
and
test
case
information
.
-
Designed
for
use
in
Taskcluster
following
a
Firebase
Test
Lab
test
execution
.
Flank
:
https
:
/
/
flank
.
github
.
io
/
flank
/
Usage
:
    
python3
parse
-
junit
-
results
.
py
-
-
results
<
path_to_results_directory
>
"
"
"
import
argparse
import
sys
import
xml
from
pathlib
import
Path
from
beautifultable
import
BeautifulTable
from
junitparser
import
Attr
Failure
JUnitXml
TestCase
TestSuite
def
parse_args
(
cmdln_args
)
:
    
parser
=
argparse
.
ArgumentParser
(
        
description
=
"
Parse
and
print
UI
test
JUnit
results
"
    
)
    
parser
.
add_argument
(
        
"
-
-
results
"
        
type
=
Path
        
help
=
"
Directory
containing
task
artifact
results
"
        
required
=
True
    
)
    
return
parser
.
parse_args
(
args
=
cmdln_args
)
class
test_suite
(
TestSuite
)
:
    
flakes
=
Attr
(
)
class
test_case
(
TestCase
)
:
    
flaky
=
Attr
(
)
def
parse_print_failure_results
(
results
)
:
    
"
"
"
    
Parses
the
given
JUnit
test
results
and
prints
a
formatted
table
of
failures
and
flaky
tests
.
    
Args
:
        
results
(
JUnitXml
)
:
Parsed
JUnit
XML
results
.
    
Returns
:
        
int
:
The
number
of
test
failures
.
    
The
function
processes
each
test
suite
and
each
test
case
within
the
suite
.
    
If
a
test
case
has
a
result
that
is
an
instance
of
Failure
it
is
added
to
the
table
.
    
The
test
case
is
marked
as
'
Flaky
'
if
the
flaky
attribute
is
set
to
"
true
"
otherwise
it
is
marked
as
'
Failure
'
.
    
Example
of
possible
JUnit
XML
(
FullJUnitReport
.
xml
)
:
    
<
testsuites
>
        
<
testsuite
name
=
"
ExampleSuite
"
tests
=
"
2
"
failures
=
"
1
"
flakes
=
"
1
"
time
=
"
0
.
003
"
>
            
<
testcase
classname
=
"
example
.
TestClass
"
name
=
"
testSuccess
"
flaky
=
"
true
"
time
=
"
0
.
001
"
>
                
<
failure
message
=
"
Assertion
failed
"
>
Expected
true
but
was
false
<
/
failure
>
            
<
/
testcase
>
            
<
testcase
classname
=
"
example
.
TestClass
"
name
=
"
testFailure
"
time
=
"
0
.
002
"
>
                
<
failure
message
=
"
Assertion
failed
"
>
Expected
true
but
was
false
<
/
failure
>
                
<
failure
message
=
"
Assertion
failed
"
>
Expected
true
but
was
false
<
/
failure
>
            
<
/
testcase
>
        
<
/
testsuite
>
    
<
/
testsuites
>
    
"
"
"
    
table
=
BeautifulTable
(
maxwidth
=
256
)
    
table
.
columns
.
header
=
[
"
UI
Test
"
"
Outcome
"
"
Details
"
]
    
table
.
columns
.
alignment
=
BeautifulTable
.
ALIGN_LEFT
    
table
.
set_style
(
BeautifulTable
.
STYLE_GRID
)
    
failure_count
=
0
    
#
Dictionary
to
store
the
last
seen
failure
details
for
each
test
case
    
last_seen_failures
=
{
}
    
for
suite
in
results
:
        
cur_suite
=
test_suite
.
fromelem
(
suite
)
        
for
case
in
cur_suite
:
            
cur_case
=
test_case
.
fromelem
(
case
)
            
if
cur_case
.
result
:
                
for
entry
in
case
.
result
:
                    
if
isinstance
(
entry
Failure
)
:
                        
flaky_status
=
getattr
(
cur_case
"
flaky
"
"
false
"
)
=
=
"
true
"
                        
if
flaky_status
:
                            
test_id
=
"
%
s
#
%
s
"
%
(
case
.
classname
case
.
name
)
                            
details
=
(
                                
entry
.
text
.
replace
(
"
\
t
"
"
"
)
if
entry
.
text
else
"
"
                            
)
                            
#
Check
if
the
current
failure
details
are
different
from
the
last
seen
ones
                            
if
details
!
=
last_seen_failures
.
get
(
test_id
"
"
)
:
                                
table
.
rows
.
append
(
                                    
[
                                        
test_id
                                        
"
Flaky
"
                                        
details
                                    
]
                                
)
                            
last_seen_failures
[
test_id
]
=
details
                        
else
:
                            
test_id
=
"
%
s
#
%
s
"
%
(
case
.
classname
case
.
name
)
                            
details
=
(
                                
entry
.
text
.
replace
(
"
\
t
"
"
"
)
if
entry
.
text
else
"
"
                            
)
                            
#
Check
if
the
current
failure
details
are
different
from
the
last
seen
ones
                            
if
details
!
=
last_seen_failures
.
get
(
test_id
"
"
)
:
                                
table
.
rows
.
append
(
                                    
[
                                        
test_id
                                        
"
Failure
"
                                        
details
                                    
]
                                
)
                                
print
(
f
"
TEST
-
UNEXPECTED
-
FAIL
|
{
test_id
}
|
{
details
}
"
)
                                
failure_count
+
=
1
                            
#
Update
the
last
seen
failure
details
for
this
test
case
                            
last_seen_failures
[
test_id
]
=
details
    
print
(
table
)
    
return
failure_count
def
load_results_file
(
filename
)
:
    
ret
=
None
    
try
:
        
f
=
open
(
filename
)
        
try
:
            
ret
=
JUnitXml
.
fromfile
(
f
)
        
except
xml
.
etree
.
ElementTree
.
ParseError
as
e
:
            
print
(
f
"
Error
parsing
{
filename
}
file
:
{
e
}
"
)
        
finally
:
            
f
.
close
(
)
    
except
OSError
as
e
:
        
print
(
e
)
    
return
ret
def
main
(
)
:
    
args
=
parse_args
(
sys
.
argv
[
1
:
]
)
    
failure_count
=
0
    
junitxml
=
load_results_file
(
args
.
results
.
joinpath
(
"
FullJUnitReport
.
xml
"
)
)
    
if
junitxml
:
        
failure_count
=
parse_print_failure_results
(
junitxml
)
    
return
failure_count
if
__name__
=
=
"
__main__
"
:
    
sys
.
exit
(
main
(
)
)
