#
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
#
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
file
#
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
from
__future__
import
print_function
import
buildconfig
import
os
import
sys
import
yaml
from
collections
import
defaultdict
from
io
import
BytesIO
from
mozbuild
.
preprocessor
import
Preprocessor
from
mozbuild
.
util
import
ensureParentDir
FileAvoidWrite
VALID_KEYS
=
{
    
'
name
'
    
'
type
'
    
'
value
'
    
'
mirror
'
    
'
do_not_use_directly
'
    
'
include
'
}
VALID_BOOL_TYPES
=
{
    
'
bool
'
    
#
These
ones
are
defined
in
StaticPrefsBase
.
h
.
    
'
RelaxedAtomicBool
'
    
'
ReleaseAcquireAtomicBool
'
    
'
SequentiallyConsistentAtomicBool
'
}
VALID_TYPES
=
VALID_BOOL_TYPES
.
union
(
{
    
'
int32_t
'
    
'
uint32_t
'
    
'
float
'
    
#
These
ones
are
defined
in
StaticPrefsBase
.
h
.
    
'
String
'
    
'
RelaxedAtomicInt32
'
    
'
RelaxedAtomicUint32
'
    
'
ReleaseAcquireAtomicInt32
'
    
'
ReleaseAcquireAtomicUint32
'
    
'
SequentiallyConsistentAtomicInt32
'
    
'
SequentiallyConsistentAtomicUint32
'
    
'
AtomicFloat
'
}
)
FIRST_LINE
=
'
/
/
This
file
was
generated
by
generate_static_pref_list
.
py
.
DO
NOT
EDIT
.
'
MIRROR_TEMPLATES
=
{
    
'
never
'
:
'
'
'
\
NEVER_PREF
(
"
{
name
}
"
{
typ
}
{
value
}
)
'
'
'
    
'
once
'
:
'
'
'
\
ONCE_PREF
(
  
"
{
name
}
"
   
{
base_id
}
   
{
full_id
}
  
{
typ
}
{
value
}
)
'
'
'
    
'
always
'
:
'
'
'
\
ALWAYS_PREF
(
  
"
{
name
}
"
   
{
base_id
}
   
{
full_id
}
  
{
typ
}
{
value
}
)
'
'
'
}
STATIC_PREFS_GROUP_H_TEMPLATE1
=
'
'
'
\
/
/
Include
it
to
gain
access
to
StaticPrefs
:
:
{
group
}
_
*
.
#
ifndef
mozilla_StaticPrefs_
{
group
}
_h
#
define
mozilla_StaticPrefs_
{
group
}
_h
'
'
'
STATIC_PREFS_GROUP_H_TEMPLATE2
=
'
'
'
\
#
include
"
mozilla
/
StaticPrefListBegin
.
h
"
#
include
"
mozilla
/
StaticPrefList_
{
group
}
.
h
"
#
include
"
mozilla
/
StaticPrefListEnd
.
h
"
#
endif
/
/
mozilla_StaticPrefs_
{
group
}
_h
'
'
'
def
error
(
msg
)
:
    
raise
ValueError
(
msg
)
def
mk_id
(
name
)
:
    
"
Replace
'
.
'
and
'
-
'
with
'
_
'
e
.
g
.
'
foo
.
bar
-
baz
'
becomes
'
foo_bar_baz
'
.
"
    
return
name
.
replace
(
'
.
'
'
_
'
)
.
replace
(
'
-
'
'
_
'
)
def
mk_group
(
pref
)
:
    
name
=
pref
[
'
name
'
]
    
return
mk_id
(
name
.
split
(
'
.
'
1
)
[
0
]
)
def
check_pref_list
(
pref_list
)
:
    
#
Pref
names
seen
so
far
.
Used
to
detect
any
duplicates
.
    
seen_names
=
set
(
)
    
#
The
previous
pref
.
Used
to
detect
mis
-
ordered
prefs
.
    
prev_pref
=
None
    
for
pref
in
pref_list
:
        
#
Check
all
given
keys
are
known
ones
.
        
for
key
in
pref
:
            
if
key
not
in
VALID_KEYS
:
                
error
(
'
invalid
key
{
}
'
.
format
(
key
)
)
        
#
'
name
'
must
be
present
valid
and
in
the
right
section
.
        
if
'
name
'
not
in
pref
:
            
error
(
'
missing
name
key
'
)
        
name
=
pref
[
'
name
'
]
        
if
type
(
name
)
!
=
str
:
            
error
(
'
non
-
string
name
value
{
}
'
.
format
(
name
)
)
        
if
'
.
'
not
in
name
:
            
error
(
'
name
value
{
}
lacks
a
\
'
.
\
'
'
.
format
(
name
)
)
        
if
name
in
seen_names
:
            
error
(
'
{
}
pref
is
defined
more
than
once
'
.
format
(
name
)
)
        
seen_names
.
add
(
name
)
        
#
Prefs
must
be
ordered
appropriately
.
        
if
prev_pref
:
            
if
mk_group
(
prev_pref
)
>
mk_group
(
pref
)
:
                
error
(
'
{
}
pref
must
come
before
{
}
pref
'
                      
.
format
(
name
prev_pref
[
'
name
'
]
)
)
        
#
'
type
'
must
be
present
and
valid
.
        
if
'
type
'
not
in
pref
:
            
error
(
'
missing
type
key
for
pref
{
}
'
.
format
(
name
)
)
        
typ
=
pref
[
'
type
'
]
        
if
typ
not
in
VALID_TYPES
:
            
error
(
'
invalid
type
value
{
}
for
pref
{
}
'
.
format
(
typ
name
)
)
        
#
'
value
'
must
be
present
and
valid
.
        
if
'
value
'
not
in
pref
:
            
error
(
'
missing
value
key
for
pref
{
}
'
.
format
(
name
)
)
        
value
=
pref
[
'
value
'
]
        
if
typ
=
=
'
String
'
:
            
if
type
(
value
)
!
=
str
:
                
error
(
'
non
-
string
value
value
{
}
for
String
pref
{
}
;
'
                      
'
add
double
quotes
'
                      
.
format
(
value
name
)
)
        
elif
typ
in
VALID_BOOL_TYPES
:
            
if
value
not
in
(
True
False
)
:
                
error
(
'
invalid
boolean
value
{
}
for
pref
{
}
'
                      
.
format
(
value
name
)
)
        
#
'
mirror
'
must
be
present
and
valid
.
        
if
'
mirror
'
not
in
pref
:
            
error
(
'
missing
mirror
key
for
pref
{
}
'
.
format
(
name
)
)
        
mirror
=
pref
[
'
mirror
'
]
        
if
mirror
not
in
MIRROR_TEMPLATES
:
            
error
(
'
invalid
mirror
value
{
}
for
pref
{
}
'
                  
.
format
(
mirror
name
)
)
        
#
Check
'
do_not_use_directly
'
if
present
.
        
if
'
do_not_use_directly
'
in
pref
:
            
do_not_use_directly
=
pref
[
'
do_not_use_directly
'
]
            
if
type
(
do_not_use_directly
)
!
=
bool
:
                
error
(
'
non
-
boolean
do_not_use_directly
value
{
}
for
pref
'
                      
'
{
}
'
.
format
(
do_not_use_directly
name
)
)
            
if
do_not_use_directly
and
mirror
=
=
'
never
'
:
                
error
(
'
do_not_use_directly
uselessly
set
with
mirror
value
'
                      
'
never
for
pref
{
}
'
.
format
(
pref
[
'
name
'
]
)
)
        
#
Check
'
include
'
if
present
.
        
if
'
include
'
in
pref
:
            
include
=
pref
[
'
include
'
]
            
if
type
(
include
)
!
=
str
:
                
error
(
'
non
-
string
include
value
{
}
for
pref
{
}
'
                      
.
format
(
include
name
)
)
            
if
include
.
startswith
(
'
<
'
)
and
not
include
.
endswith
(
'
>
'
)
:
                
error
(
'
include
value
{
}
starts
with
<
but
does
not
'
                      
'
end
with
>
for
pref
{
}
'
.
format
(
include
name
)
)
        
prev_pref
=
pref
def
generate_code
(
pref_list
)
:
    
check_pref_list
(
pref_list
)
    
#
The
required
includes
for
StaticPrefs_
<
group
>
.
h
.
    
includes
=
defaultdict
(
set
)
    
#
StaticPrefList_
<
group
>
.
h
contains
all
the
pref
definitions
for
this
    
#
group
.
    
static_pref_list_group_h
=
defaultdict
(
lambda
:
[
FIRST_LINE
'
'
]
)
    
#
Generate
the
per
-
pref
code
(
spread
across
multiple
files
)
.
    
for
pref
in
pref_list
:
        
name
=
pref
[
'
name
'
]
        
typ
=
pref
[
'
type
'
]
        
value
=
pref
[
'
value
'
]
        
mirror
=
pref
[
'
mirror
'
]
        
do_not_use_directly
=
pref
.
get
(
'
do_not_use_directly
'
)
        
include
=
pref
.
get
(
'
include
'
)
        
base_id
=
mk_id
(
pref
[
'
name
'
]
)
        
full_id
=
base_id
        
if
mirror
=
=
'
once
'
:
            
full_id
+
=
'
_AtStartup
'
        
if
do_not_use_directly
:
            
full_id
+
=
'
_DoNotUseDirectly
'
        
group
=
mk_group
(
pref
)
        
if
include
:
            
if
not
include
.
startswith
(
'
<
'
)
:
                
#
It
'
s
not
a
system
header
.
Add
double
quotes
.
                
include
=
'
"
{
}
"
'
.
format
(
include
)
            
includes
[
group
]
.
add
(
include
)
        
if
typ
=
=
'
String
'
:
            
#
Quote
string
literals
and
escape
double
-
quote
chars
.
            
value
=
'
"
{
}
"
'
.
format
(
value
.
replace
(
'
"
'
'
\
\
"
'
)
)
        
elif
typ
in
VALID_BOOL_TYPES
:
            
#
Convert
Python
bools
to
C
+
+
bools
.
            
if
value
is
True
:
                
value
=
'
true
'
            
elif
value
is
False
:
                
value
=
'
false
'
        
#
Append
the
C
+
+
definition
to
the
relevant
output
file
'
s
code
.
        
static_pref_list_group_h
[
group
]
.
append
(
MIRROR_TEMPLATES
[
mirror
]
.
format
(
            
name
=
name
            
base_id
=
base_id
            
full_id
=
full_id
            
typ
=
typ
            
value
=
value
        
)
)
        
#
Delete
this
so
that
group
can
be
reused
below
without
Flake8
        
#
complaining
.
        
del
group
    
#
StaticPrefListAll
.
h
contains
one
#
include
"
mozilla
/
StaticPrefList_X
.
h
    
#
line
per
pref
group
.
    
static_pref_list_all_h
=
[
FIRST_LINE
'
'
]
    
static_pref_list_all_h
.
extend
(
        
'
#
include
"
mozilla
/
StaticPrefList_
{
}
.
h
"
'
.
format
(
group
)
        
for
group
in
sorted
(
static_pref_list_group_h
)
    
)
    
static_pref_list_all_h
.
append
(
'
'
)
    
#
StaticPrefsAll
.
h
contains
one
#
include
"
mozilla
/
StaticPrefs_X
.
h
line
per
    
#
pref
group
.
    
static_prefs_all_h
=
[
FIRST_LINE
'
'
]
    
static_prefs_all_h
.
extend
(
        
'
#
include
"
mozilla
/
StaticPrefs_
{
}
.
h
"
'
.
format
(
group
)
        
for
group
in
sorted
(
static_pref_list_group_h
)
    
)
    
static_prefs_all_h
.
append
(
'
'
)
    
#
StaticPrefs_
<
group
>
.
h
wraps
StaticPrefList_
<
group
>
.
h
.
It
is
the
header
    
#
used
directly
by
application
code
.
    
static_prefs_group_h
=
defaultdict
(
list
)
    
for
group
in
sorted
(
static_pref_list_group_h
)
:
        
static_prefs_group_h
[
group
]
=
[
FIRST_LINE
]
        
static_prefs_group_h
[
group
]
.
append
(
STATIC_PREFS_GROUP_H_TEMPLATE1
.
format
(
group
=
group
)
)
        
if
group
in
includes
:
            
#
Add
any
necessary
includes
from
'
h_include
'
values
.
            
for
include
in
sorted
(
includes
[
group
]
)
:
                
static_prefs_group_h
[
group
]
.
append
(
'
#
include
{
}
'
.
format
(
include
)
)
            
static_prefs_group_h
[
group
]
.
append
(
'
'
)
        
static_prefs_group_h
[
group
]
.
append
(
STATIC_PREFS_GROUP_H_TEMPLATE2
.
format
(
group
=
group
)
)
    
def
fold
(
lines
)
:
        
return
'
\
n
'
.
join
(
lines
)
    
return
{
        
'
static_pref_list_all_h
'
:
fold
(
static_pref_list_all_h
)
        
'
static_prefs_all_h
'
:
fold
(
static_prefs_all_h
)
        
'
static_pref_list_group_h
'
:
{
k
:
fold
(
v
)
for
k
v
in
static_pref_list_group_h
.
items
(
)
}
        
'
static_prefs_group_h
'
:
{
k
:
fold
(
v
)
for
k
v
in
static_prefs_group_h
.
items
(
)
}
    
}
def
emit_code
(
fd
pref_list_filename
)
:
    
pp
=
Preprocessor
(
)
    
pp
.
context
.
update
(
buildconfig
.
defines
[
'
ALLDEFINES
'
]
)
    
#
A
necessary
hack
until
MOZ_DEBUG_FLAGS
are
part
of
buildconfig
.
defines
.
    
if
buildconfig
.
substs
.
get
(
'
MOZ_DEBUG
'
)
:
        
pp
.
context
[
'
DEBUG
'
]
=
'
1
'
    
pp
.
out
=
BytesIO
(
)
    
pp
.
do_filter
(
'
substitution
'
)
    
pp
.
do_include
(
pref_list_filename
)
    
try
:
        
pref_list
=
yaml
.
safe_load
(
pp
.
out
.
getvalue
(
)
)
        
code
=
generate_code
(
pref_list
)
    
except
(
IOError
ValueError
)
as
e
:
        
print
(
'
{
}
:
error
:
\
n
{
}
\
n
'
              
.
format
(
pref_list_filename
e
)
)
        
sys
.
exit
(
1
)
    
#
When
generating
multiple
files
from
a
script
the
build
system
treats
the
    
#
first
named
output
file
(
StaticPrefListAll
.
h
in
this
case
)
specially
-
-
it
    
#
is
created
elsewhere
and
written
to
via
fd
.
    
fd
.
write
(
code
[
'
static_pref_list_all_h
'
]
)
    
#
We
must
create
the
remaining
output
files
ourselves
.
This
requires
    
#
creating
the
output
directory
directly
if
it
doesn
'
t
already
exist
.
    
ensureParentDir
(
fd
.
name
)
    
init_dirname
=
os
.
path
.
dirname
(
fd
.
name
)
    
with
FileAvoidWrite
(
'
StaticPrefsAll
.
h
'
)
as
fd
:
        
fd
.
write
(
code
[
'
static_prefs_all_h
'
]
)
    
for
group
text
in
sorted
(
code
[
'
static_pref_list_group_h
'
]
.
items
(
)
)
:
        
filename
=
'
StaticPrefList_
{
}
.
h
'
.
format
(
group
)
        
with
FileAvoidWrite
(
os
.
path
.
join
(
init_dirname
filename
)
)
as
fd
:
            
fd
.
write
(
text
)
    
for
group
text
in
sorted
(
code
[
'
static_prefs_group_h
'
]
.
items
(
)
)
:
        
filename
=
'
StaticPrefs_
{
}
.
h
'
.
format
(
group
)
        
with
FileAvoidWrite
(
filename
)
as
fd
:
            
fd
.
write
(
text
)
