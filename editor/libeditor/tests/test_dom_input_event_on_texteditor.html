<
html
>
<
head
>
<
title
>
Test
for
input
event
of
text
editor
<
/
title
>
<
script
src
=
"
/
tests
/
SimpleTest
/
SimpleTest
.
js
"
>
<
/
script
>
<
script
src
=
"
/
tests
/
SimpleTest
/
EventUtils
.
js
"
>
<
/
script
>
<
link
rel
=
"
stylesheet
"
type
=
"
text
/
css
"
href
=
"
/
tests
/
SimpleTest
/
test
.
css
"
/
>
<
/
head
>
<
body
>
<
div
id
=
"
display
"
>
<
input
type
=
"
text
"
id
=
"
input
"
>
<
textarea
id
=
"
textarea
"
>
<
/
textarea
>
<
/
div
>
<
div
id
=
"
content
"
style
=
"
display
:
none
"
>
<
/
div
>
<
pre
id
=
"
test
"
>
<
/
pre
>
<
script
class
=
"
testbody
"
type
=
"
application
/
javascript
"
>
"
use
strict
"
;
SimpleTest
.
waitForExplicitFinish
(
)
;
SimpleTest
.
expectAssertions
(
0
1
)
;
/
/
In
a11y
module
SimpleTest
.
waitForFocus
(
runTests
window
)
;
const
kIsWin
=
navigator
.
platform
.
indexOf
(
"
Win
"
)
=
=
0
;
const
kIsMac
=
navigator
.
platform
.
indexOf
(
"
Mac
"
)
=
=
0
;
async
function
runTests
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
input_events
.
beforeinput
.
enabled
"
true
]
]
}
)
;
const
kWordSelectEatSpaceToNextWord
=
SpecialPowers
.
getBoolPref
(
"
layout
.
word_select
.
eat_space_to_next_word
"
)
;
function
doTests
(
aElement
aDescription
aIsTextarea
)
{
aDescription
+
=
"
:
"
;
aElement
.
focus
(
)
;
aElement
.
value
=
"
"
;
let
initializing
=
false
;
let
cancelBeforeInput
=
false
;
let
beforeInputEvent
=
null
;
let
inputEvent
=
null
;
let
action
=
"
"
;
let
beforeInputHandler
=
(
aEvent
)
=
>
{
if
(
initializing
)
{
return
;
}
ok
(
!
beforeInputEvent
{
aDescription
}
Multiple
"
beforeinput
"
events
are
fired
at
{
action
}
(
inputType
:
"
{
aEvent
.
inputType
}
"
data
:
{
aEvent
.
data
}
)
)
;
if
(
cancelBeforeInput
)
{
aEvent
.
preventDefault
(
)
;
}
ok
(
aEvent
.
isTrusted
{
aDescription
}
"
beforeinput
"
event
at
{
action
}
must
be
trusted
)
;
is
(
aEvent
.
target
aElement
{
aDescription
}
"
beforeinput
"
event
at
{
action
}
is
fired
on
unexpected
element
:
{
aEvent
.
target
.
tagName
}
)
;
ok
(
aEvent
instanceof
InputEvent
{
aDescription
}
"
beforeinput
"
event
at
{
action
}
should
be
dispatched
with
InputEvent
interface
)
;
ok
(
aEvent
.
bubbles
{
aDescription
}
"
beforeinput
"
event
at
{
action
}
must
be
bubbles
)
;
beforeInputEvent
=
aEvent
;
}
;
let
inputHandler
=
(
aEvent
)
=
>
{
if
(
initializing
)
{
return
;
}
ok
(
!
inputEvent
{
aDescription
}
Multiple
"
input
"
events
are
fired
at
{
action
}
(
inputType
:
"
{
aEvent
.
inputType
}
"
data
:
{
aEvent
.
data
}
)
)
;
ok
(
aEvent
.
isTrusted
{
aDescription
}
"
input
"
event
at
{
action
}
must
be
trusted
)
;
is
(
aEvent
.
target
aElement
"
input
"
event
at
{
action
}
is
fired
on
unexpected
element
:
{
aEvent
.
target
.
tagName
}
)
;
ok
(
aEvent
instanceof
InputEvent
{
aDescription
}
"
input
"
event
at
{
action
}
should
be
dispatched
with
InputEvent
interface
)
;
ok
(
!
aEvent
.
cancelable
{
aDescription
}
"
input
"
event
at
{
action
}
must
not
be
cancelable
)
;
ok
(
aEvent
.
bubbles
{
aDescription
}
"
input
"
event
at
{
action
}
must
be
bubbles
)
;
let
duration
=
Math
.
abs
(
window
.
performance
.
now
(
)
-
aEvent
.
timeStamp
)
;
ok
(
duration
<
30
*
1000
{
aDescription
}
perhaps
timestamp
wasn
'
t
set
correctly
:
{
aEvent
.
timeStamp
}
(
expected
it
to
be
within
30s
of
+
the
current
time
but
it
differed
by
{
duration
}
ms
)
)
;
inputEvent
=
aEvent
;
}
;
/
*
*
*
Helper
methods
to
very
editor
value
beforeinput
event
and
input
event
.
*
*
param
aTestData
The
test
data
to
verify
.
*
param
aExpectedEditorValue
*
Set
string
value
if
the
test
needs
to
check
aElement
.
value
.
*
Set
undefined
if
the
test
does
not
need
to
check
it
.
*
param
aExpectedBeforeInputEvent
*
Set
object
which
has
cancelable
inputType
and
data
if
*
a
"
beforeinput
"
event
should
be
fired
.
*
Set
null
if
"
beforeinput
"
event
shouldn
'
t
be
fired
.
*
param
aExpectedInputEvent
*
Set
object
which
has
inputType
and
data
if
an
"
input
"
event
*
should
be
fired
if
aTestData
.
cancelBeforeInput
is
not
true
.
*
Set
null
if
"
input
"
event
shouldn
'
t
be
fired
.
*
Note
that
if
expected
"
beforeinput
"
event
is
cancelable
and
*
aTestData
.
cancelBeforeInput
is
true
this
is
ignored
.
*
/
function
verify
(
aTestData
aExpectedEditorValue
aExpectedBeforeInputEvent
aExpectedInputEvent
)
{
try
{
if
(
aExpectedEditorValue
!
=
=
undefined
)
{
is
(
aElement
.
value
aExpectedEditorValue
{
aDescription
}
the
value
should
be
"
{
aExpectedEditorValue
}
"
after
{
aTestData
.
action
}
)
;
}
if
(
aExpectedBeforeInputEvent
=
=
=
null
|
|
aExpectedBeforeInputEvent
=
=
=
undefined
)
{
ok
(
!
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
shouldn
'
t
have
been
fired
at
{
aTestData
.
action
}
)
;
}
else
{
ok
(
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
beforeInputEvent
.
cancelable
aExpectedBeforeInputEvent
.
cancelable
{
aDescription
}
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
be
{
aExpectedBeforeInputEvent
.
cancelable
?
"
cancelable
"
:
"
not
cancelable
"
}
)
;
is
(
beforeInputEvent
.
inputType
aExpectedBeforeInputEvent
.
inputType
{
aDescription
}
inputType
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
be
"
{
aExpectedBeforeInputEvent
.
inputType
}
"
)
;
is
(
beforeInputEvent
.
data
aExpectedBeforeInputEvent
.
data
{
aDescription
}
data
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
be
{
aExpectedBeforeInputEvent
.
data
=
=
=
null
?
"
null
"
:
"
{
aExpectedBeforeInputEvent
.
data
}
"
}
)
;
is
(
beforeInputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
}
if
(
(
aTestData
.
cancelBeforeInput
=
=
=
true
&
&
aExpectedBeforeInputEvent
&
&
aExpectedBeforeInputEvent
.
cancelable
)
|
|
aExpectedInputEvent
=
=
=
null
|
|
aExpectedInputEvent
=
=
=
undefined
)
{
ok
(
!
inputEvent
{
aDescription
}
"
input
"
event
shouldn
'
t
have
been
fired
at
{
aTestData
.
action
}
)
;
}
else
{
ok
(
inputEvent
{
aDescription
}
"
input
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
inputEvent
.
cancelable
false
{
aDescription
}
"
input
"
event
by
{
aTestData
.
action
}
should
be
not
be
cancelable
)
;
is
(
inputEvent
.
inputType
aExpectedInputEvent
.
inputType
{
aDescription
}
inputType
of
"
input
"
event
by
{
aTestData
.
action
}
should
be
"
{
aExpectedInputEvent
.
inputType
}
"
)
;
is
(
inputEvent
.
data
aExpectedInputEvent
.
data
{
aDescription
}
data
of
"
input
"
event
by
{
aTestData
.
action
}
should
be
{
aExpectedInputEvent
.
data
=
=
=
null
?
"
null
"
:
"
{
aExpectedInputEvent
.
data
}
"
}
)
;
is
(
inputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
input
"
event
by
{
aTestData
.
action
}
should
be
null
)
;
is
(
inputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
input
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
}
return
true
;
}
catch
(
ex
)
{
ok
(
false
{
aDescription
}
unexpected
exception
at
verifying
test
result
of
"
{
aTestData
.
action
}
"
:
{
ex
.
toString
(
)
}
)
;
return
false
;
}
}
aElement
.
addEventListener
(
"
beforeinput
"
beforeInputHandler
true
)
;
aElement
.
addEventListener
(
"
input
"
inputHandler
true
)
;
function
test_typing_a_in_empty_editor
(
aTestData
)
{
aElement
.
value
=
"
"
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
sendString
(
"
a
"
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
"
"
:
"
a
"
{
cancelable
:
true
inputType
:
"
insertText
"
data
:
"
a
"
}
{
inputType
:
"
insertText
"
data
:
"
a
"
}
)
;
}
test_typing_a_in_empty_editor
(
{
action
:
'
typing
"
a
"
and
canceling
beforeinput
'
cancelBeforeInput
:
true
}
)
;
test_typing_a_in_empty_editor
(
{
action
:
'
typing
"
a
"
'
cancelBeforeInput
:
false
}
)
;
function
test_typing_backspace_to_delete_last_character
(
aTestData
)
{
aElement
.
value
=
"
a
"
;
aElement
.
setSelectionStart
=
"
a
"
.
length
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
KEY_Backspace
"
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
"
a
"
:
"
"
{
cancelable
:
true
inputType
:
"
deleteContentBackward
"
data
:
null
}
{
inputType
:
"
deleteContentBackward
"
data
:
null
}
)
;
}
test_typing_backspace_to_delete_last_character
(
{
actin
:
'
typing
"
Backspace
"
to
delete
"
a
"
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_typing_backspace_to_delete_last_character
(
{
actin
:
'
typing
"
Backspace
"
to
delete
"
a
"
'
cancelBeforeInput
:
false
}
)
;
function
test_typing_enter_in_empty_editor
(
aTestData
)
{
aElement
.
value
=
"
"
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
KEY_Enter
"
)
;
if
(
aIsTextarea
)
{
let
expectedValue
=
aTestData
.
cancelBeforeInput
?
"
"
:
"
\
n
"
;
verify
(
aTestData
expectedValue
{
cancelable
:
true
inputType
:
"
insertLineBreak
"
data
:
null
}
{
inputType
:
"
insertLineBreak
"
data
:
null
}
)
;
}
else
{
verify
(
aTestData
"
"
{
cancelable
:
true
inputType
:
"
insertLineBreak
"
data
:
null
}
null
)
;
}
}
test_typing_enter_in_empty_editor
(
{
action
:
'
typing
"
Enter
"
in
empty
editor
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_typing_enter_in_empty_editor
(
{
action
:
'
typing
"
Enter
"
in
empty
editor
'
cancelBeforeInput
:
false
}
)
;
(
function
test_setting_value
(
aTestData
)
{
initializing
=
true
;
aElement
.
value
=
"
"
;
initializing
=
false
;
cancelBeforeInput
=
false
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
aElement
.
value
=
"
foo
-
bar
"
;
action
=
aTestData
.
action
;
ok
(
!
aTestData
.
cancelBeforeInput
{
aDescription
}
cancelBeforeInput
must
not
be
true
for
{
aTestData
.
action
}
)
;
verify
(
aTestData
"
foo
-
bar
"
null
null
)
;
}
)
(
{
action
:
"
setting
non
-
empty
value
"
}
)
;
(
function
test_setting_empty_value
(
aTestData
)
{
initializing
=
true
;
aElement
.
value
=
"
foo
-
bar
"
;
initializing
=
false
;
cancelBeforeInput
=
false
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
aElement
.
value
=
"
"
;
action
=
"
setting
empty
value
"
;
ok
(
!
aTestData
.
cancelBeforeInput
{
aDescription
}
cancelBeforeInput
must
not
be
true
for
{
aTestData
.
action
}
)
;
verify
(
aTestData
"
"
null
null
)
;
}
)
(
{
action
:
"
setting
empty
value
"
}
)
;
(
function
test_typing_space_in_empty_editor
(
aTestData
)
{
initializing
=
true
;
aElement
.
value
=
"
"
;
initializing
=
false
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
sendString
(
"
"
)
;
ok
(
!
aTestData
.
cancelBeforeInput
{
aDescription
}
cancelBeforeInput
must
not
be
true
for
{
aTestData
.
action
}
)
;
verify
(
aTestData
"
"
{
cancelable
:
true
inputType
:
"
insertText
"
data
:
"
"
}
{
inputType
:
"
insertText
"
data
:
"
"
}
)
;
}
)
(
{
action
:
"
typing
space
"
}
)
;
(
function
test_typing_delete_at_end_of_editor
(
aTestData
)
{
initializing
=
true
;
aElement
.
value
=
"
"
;
initializing
=
false
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
KEY_Delete
"
)
;
ok
(
!
aTestData
.
cancelBeforeInput
{
aDescription
}
cancelBeforeInput
must
not
be
true
for
{
aTestData
.
action
}
)
;
verify
(
aTestData
"
"
{
cancelable
:
true
inputType
:
"
deleteContentForward
"
data
:
null
}
null
)
;
}
)
(
{
action
:
'
typing
"
Delete
"
at
end
of
editor
'
}
)
;
(
function
test_typing_arrow_left_to_move_caret
(
aTestData
)
{
initializing
=
true
;
aElement
.
value
=
"
"
;
aElement
.
selectionStart
=
1
;
initializing
=
false
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
KEY_ArrowLeft
"
)
;
ok
(
!
aTestData
.
cancelBeforeInput
{
aDescription
}
cancelBeforeInput
must
not
be
true
for
{
aTestData
.
action
}
)
;
verify
(
aTestData
"
"
null
null
)
;
}
)
(
{
action
:
'
typing
"
ArrowLeft
"
to
move
caret
'
}
)
;
function
test_typing_delete_to_delete_last_character
(
aTestData
)
{
aElement
.
value
=
"
"
;
aElement
.
selectionStart
=
0
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
KEY_Delete
"
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
"
"
:
"
"
{
cancelable
:
true
inputType
:
"
deleteContentForward
"
data
:
null
}
{
inputType
:
"
deleteContentForward
"
data
:
null
}
)
;
}
test_typing_delete_to_delete_last_character
(
{
action
:
'
typing
"
Delete
"
to
delete
space
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_typing_delete_to_delete_last_character
(
{
action
:
'
typing
"
Delete
"
to
delete
space
'
cancelBeforeInput
:
false
}
)
;
function
test_undoing_deleting_last_character
(
aTestData
)
{
initializing
=
true
;
aElement
.
value
=
"
a
"
;
aElement
.
selectionStart
=
0
;
synthesizeKey
(
"
KEY_Delete
"
)
;
initializing
=
false
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
z
"
{
accelKey
:
true
}
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
"
"
:
"
a
"
{
cancelable
:
true
inputType
:
"
historyUndo
"
data
:
null
}
{
inputType
:
"
historyUndo
"
data
:
null
}
)
;
}
test_undoing_deleting_last_character
(
{
action
:
'
undoing
deleting
last
character
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_undoing_deleting_last_character
(
{
action
:
"
undoing
deleting
last
character
"
cancelBeforeInput
:
false
}
)
;
(
function
test_undoing_without_undoable_transaction
(
aTestData
)
{
initializing
=
true
;
aElement
.
value
=
"
a
"
;
aElement
.
selectionStart
=
0
;
synthesizeKey
(
"
KEY_Delete
"
)
;
synthesizeKey
(
"
z
"
{
accelKey
:
true
}
)
;
initializing
=
false
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
z
"
{
accelKey
:
true
}
)
;
ok
(
!
aTestData
.
cancelBeforeInput
{
aDescription
}
cancelBeforeInput
must
not
be
true
for
{
aTestData
.
action
}
)
;
verify
(
aTestData
"
a
"
null
null
)
;
}
)
(
{
action
:
"
trying
to
undo
without
undoable
transaction
"
}
)
;
function
test_redoing_deleting_last_character
(
aTestData
)
{
initializing
=
true
;
aElement
.
value
=
"
a
"
;
aElement
.
selectionStart
=
0
;
synthesizeKey
(
"
KEY_Delete
"
)
;
synthesizeKey
(
"
z
"
{
accelKey
:
true
}
)
;
initializing
=
false
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
Z
"
{
accelKey
:
true
shiftKey
:
true
}
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
"
a
"
:
"
"
{
cancelable
:
true
inputType
:
"
historyRedo
"
data
:
null
}
{
inputType
:
"
historyRedo
"
data
:
null
}
)
;
}
test_redoing_deleting_last_character
(
{
action
:
'
redoing
deleting
last
character
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_redoing_deleting_last_character
(
{
action
:
"
redoing
deleting
last
character
"
cancelBeforeInput
:
false
}
)
;
(
function
test_redoing_without_redoable_transaction
(
aTestData
)
{
initializing
=
true
;
aElement
.
value
=
"
a
"
;
aElement
.
selectionStart
=
0
;
synthesizeKey
(
"
KEY_Delete
"
)
;
synthesizeKey
(
"
z
"
{
accelKey
:
true
}
)
;
synthesizeKey
(
"
Z
"
{
accelKey
:
true
shiftKey
:
true
}
)
;
initializing
=
false
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
Z
"
{
accelKey
:
true
shiftKey
:
true
}
)
;
verify
(
aTestData
"
"
null
null
)
;
}
)
(
{
action
:
"
trying
to
redo
without
redoable
transaction
"
}
)
;
function
test_typing_backspace_with_selecting_all_characters
(
aTestData
)
{
aElement
.
value
=
"
abc
"
;
aElement
.
focus
(
)
;
aElement
.
select
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
synthesizeKey
(
"
KEY_Backspace
"
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
"
abc
"
:
"
"
{
cancelable
:
true
inputType
:
"
deleteContentBackward
"
data
:
null
}
{
inputType
:
"
deleteContentBackward
"
data
:
null
}
)
;
}
test_typing_backspace_with_selecting_all_characters
(
{
action
:
'
typing
"
Backspace
"
to
delete
all
selected
characters
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_typing_backspace_with_selecting_all_characters
(
{
action
:
'
typing
"
Backspace
"
to
delete
all
selected
characters
'
cancelBeforeInput
:
false
}
)
;
function
test_typing_delete_with_selecting_all_characters
(
aTestData
)
{
aElement
.
value
=
"
abc
"
;
aElement
.
focus
(
)
;
aElement
.
select
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
KEY_Delete
"
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
"
abc
"
:
"
"
{
cancelable
:
true
inputType
:
"
deleteContentForward
"
data
:
null
}
{
inputType
:
"
deleteContentForward
"
data
:
null
}
)
;
}
test_typing_delete_with_selecting_all_characters
(
{
action
:
'
typing
"
Delete
"
to
delete
all
selected
characters
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_typing_delete_with_selecting_all_characters
(
{
action
:
'
typing
"
Delete
"
to
delete
all
selected
characters
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
false
}
)
;
function
test_deleting_word_backward_from_its_end
(
aTestData
)
{
aElement
.
value
=
"
abc
def
"
;
aElement
.
focus
(
)
;
document
.
documentElement
.
scrollTop
;
/
/
XXX
Needs
reflow
here
for
working
with
nsFrameSelection
must
be
a
bug
.
aElement
.
setSelectionRange
(
"
abc
def
"
.
length
"
abc
def
"
.
length
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
SpecialPowers
.
doCommand
(
window
"
cmd_deleteWordBackward
"
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
"
abc
def
"
:
"
abc
"
{
cancelable
:
true
inputType
:
"
deleteWordBackward
"
data
:
null
}
{
inputType
:
"
deleteWordBackward
"
data
:
null
}
)
;
}
test_deleting_word_backward_from_its_end
(
{
action
:
'
deleting
word
backward
from
its
end
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_deleting_word_backward_from_its_end
(
{
action
:
'
deleting
word
backward
from
its
end
'
cancelBeforeInput
:
false
}
)
;
function
test_deleting_word_forward_from_its_start
(
aTestData
)
{
aElement
.
value
=
"
abc
def
"
;
aElement
.
focus
(
)
;
document
.
documentElement
.
scrollTop
;
/
/
XXX
Needs
reflow
here
for
working
with
nsFrameSelection
must
be
a
bug
.
aElement
.
setSelectionRange
(
0
0
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
SpecialPowers
.
doCommand
(
window
"
cmd_deleteWordForward
"
)
;
let
expectedValue
;
if
(
aTestData
.
cancelBeforeInput
)
{
expectedValue
=
"
abc
def
"
;
}
else
{
expectedValue
=
kWordSelectEatSpaceToNextWord
?
"
def
"
:
"
def
"
;
}
verify
(
aTestData
expectedValue
{
cancelable
:
true
inputType
:
"
deleteWordForward
"
data
:
null
}
{
inputType
:
"
deleteWordForward
"
data
:
null
}
)
;
}
test_deleting_word_forward_from_its_start
(
{
action
:
'
deleting
word
forward
from
its
start
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_deleting_word_forward_from_its_start
(
{
action
:
"
deleting
word
forward
from
its
start
"
cancelBeforeInput
:
false
}
)
;
(
function
test_deleting_word_backward_from_middle_of_second_word
(
aTestData
)
{
aElement
.
value
=
"
abc
def
"
;
aElement
.
focus
(
)
;
document
.
documentElement
.
scrollTop
;
/
/
XXX
Needs
reflow
here
for
working
with
nsFrameSelection
must
be
a
bug
.
aElement
.
setSelectionRange
(
"
abc
d
"
.
length
"
abc
de
"
.
length
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
SpecialPowers
.
doCommand
(
window
"
cmd_deleteWordBackward
"
)
;
ok
(
!
aTestData
.
cancelBeforeInput
{
aDescription
}
cancelBeforeInput
must
not
be
true
for
{
aTestData
.
action
}
)
;
/
/
Only
on
Windows
we
collapse
selection
to
start
before
handling
this
command
.
verify
(
aTestData
kIsWin
?
"
abc
ef
"
:
"
abc
df
"
{
cancelable
:
true
inputType
:
kIsWin
?
"
deleteWordBackward
"
:
"
deleteContentBackward
"
data
:
null
}
{
inputType
:
kIsWin
?
"
deleteWordBackward
"
:
"
deleteContentBackward
"
data
:
null
}
)
;
}
)
(
{
action
:
"
removing
characters
backward
from
middle
of
second
word
"
}
)
;
(
function
test_deleting_word_forward_from_middle_of_first_word
(
aTestData
)
{
aElement
.
value
=
"
abc
def
"
;
aElement
.
focus
(
)
;
document
.
documentElement
.
scrollTop
;
/
/
XXX
Needs
reflow
here
for
working
with
nsFrameSelection
must
be
a
bug
.
aElement
.
setSelectionRange
(
"
a
"
.
length
"
ab
"
.
length
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
SpecialPowers
.
doCommand
(
window
"
cmd_deleteWordForward
"
)
;
ok
(
!
aTestData
.
cancelBeforeInput
{
aDescription
}
cancelBeforeInput
must
not
be
true
for
{
aTestData
.
action
}
)
;
/
/
Only
on
Windows
we
collapse
selection
to
start
before
handling
this
command
.
let
expectedValue
=
"
ac
def
"
;
if
(
kIsWin
)
{
expectedValue
=
kWordSelectEatSpaceToNextWord
?
"
adef
"
:
"
a
def
"
;
}
verify
(
aTestData
expectedValue
{
cancelable
:
true
inputType
:
kIsWin
?
"
deleteWordForward
"
:
"
deleteContentForward
"
data
:
null
}
{
inputType
:
kIsWin
?
"
deleteWordForward
"
:
"
deleteContentForward
"
data
:
null
}
)
;
}
)
(
{
action
:
"
removing
characters
forward
from
middle
of
first
word
"
}
)
;
(
function
test_deleting_characters_backward_to_start_of_line
(
aTestData
)
{
aElement
.
value
=
"
abc
def
"
;
aElement
.
focus
(
)
;
document
.
documentElement
.
scrollTop
;
/
/
XXX
Needs
reflow
here
for
working
with
nsFrameSelection
must
be
a
bug
.
aElement
.
setSelectionRange
(
"
abc
d
"
.
length
"
abc
d
"
.
length
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
SpecialPowers
.
doCommand
(
window
"
cmd_deleteToBeginningOfLine
"
)
;
ok
(
!
aTestData
.
cancelBeforeInput
{
aDescription
}
cancelBeforeInput
must
not
be
true
for
{
aTestData
.
action
}
)
;
verify
(
aTestData
"
ef
"
{
cancelable
:
true
inputType
:
"
deleteSoftLineBackward
"
data
:
null
}
{
inputType
:
"
deleteSoftLineBackward
"
data
:
null
}
)
;
}
)
(
{
action
:
"
removing
characters
backward
to
start
of
line
"
}
)
;
(
function
test_deleting_characters_forward_to_end_of_line
(
aTestData
)
{
aElement
.
value
=
"
abc
def
"
;
aElement
.
focus
(
)
;
document
.
documentElement
.
scrollTop
;
/
/
XXX
Needs
reflow
here
for
working
with
nsFrameSelection
must
be
a
bug
.
aElement
.
setSelectionRange
(
"
ab
"
.
length
"
ab
"
.
length
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
SpecialPowers
.
doCommand
(
window
"
cmd_deleteToEndOfLine
"
)
;
ok
(
!
aTestData
.
cancelBeforeInput
{
aDescription
}
cancelBeforeInput
must
not
be
true
for
{
aTestData
.
action
}
)
;
verify
(
aTestData
"
ab
"
{
cancelable
:
true
inputType
:
"
deleteSoftLineForward
"
data
:
null
}
{
inputType
:
"
deleteSoftLineForward
"
data
:
null
}
)
;
}
)
(
{
action
:
"
removing
characters
forward
to
end
of
line
"
}
)
;
(
function
test_deleting_characters_backward_to_start_of_line_with_non_collapsed_selection
(
aTestData
)
{
aElement
.
value
=
"
abc
def
"
;
aElement
.
focus
(
)
;
document
.
documentElement
.
scrollTop
;
/
/
XXX
Needs
reflow
here
for
working
with
nsFrameSelection
must
be
a
bug
.
aElement
.
setSelectionRange
(
"
abc
d
"
.
length
"
abc_de
"
.
length
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
SpecialPowers
.
doCommand
(
window
"
cmd_deleteToBeginningOfLine
"
)
;
ok
(
!
aTestData
.
cancelBeforeInput
{
aDescription
}
cancelBeforeInput
must
not
be
true
for
{
aTestData
.
action
}
)
;
/
/
Only
on
Windows
we
collapse
selection
to
start
before
handling
this
command
.
verify
(
aTestData
kIsWin
?
"
ef
"
:
"
abc
df
"
{
cancelable
:
true
inputType
:
kIsWin
?
"
deleteSoftLineBackward
"
:
"
deleteContentBackward
"
data
:
null
}
{
inputType
:
kIsWin
?
"
deleteSoftLineBackward
"
:
"
deleteContentBackward
"
data
:
null
}
)
;
}
)
(
{
action
:
"
removing
characters
backward
to
start
of
line
(
with
selection
in
second
word
)
"
}
)
;
(
function
test_deleting_characters_forward_to_end_of_line_with_non_collapsed_selection
(
aTestData
)
{
aElement
.
value
=
"
abc
def
"
;
aElement
.
focus
(
)
;
document
.
documentElement
.
scrollTop
;
/
/
XXX
Needs
reflow
here
for
working
with
nsFrameSelection
must
be
a
bug
.
aElement
.
setSelectionRange
(
"
a
"
.
length
"
ab
"
.
length
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
SpecialPowers
.
doCommand
(
window
"
cmd_deleteToEndOfLine
"
)
;
ok
(
!
aTestData
.
cancelBeforeInput
{
aDescription
}
cancelBeforeInput
must
not
be
true
for
{
aTestData
.
action
}
)
;
/
/
Only
on
Windows
we
collapse
selection
to
start
before
handling
this
command
.
verify
(
aTestData
kIsWin
?
"
a
"
:
"
ac
def
"
{
cancelable
:
true
inputType
:
kIsWin
?
"
deleteSoftLineForward
"
:
"
deleteContentForward
"
data
:
null
}
{
inputType
:
kIsWin
?
"
deleteSoftLineForward
"
:
"
deleteContentForward
"
data
:
null
}
)
;
}
)
(
{
action
:
"
removing
characters
forward
to
end
of
line
(
with
selection
in
second
word
)
"
}
)
;
function
test_switching_text_direction_from_default
(
aTestData
)
{
try
{
aElement
.
removeAttribute
(
"
dir
"
)
;
aElement
.
scrollTop
;
/
/
XXX
Update
the
root
frame
aElement
.
focus
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
SpecialPowers
.
doCommand
(
window
"
cmd_switchTextDirection
"
)
;
if
(
aTestData
.
cancelBeforeInput
)
{
is
(
aElement
.
getAttribute
(
"
dir
"
)
null
{
aDescription
}
dir
attribute
of
the
element
shouldn
'
t
have
been
set
by
{
aTestData
.
action
}
)
;
}
else
{
is
(
aElement
.
getAttribute
(
"
dir
"
)
"
rtl
"
{
aDescription
}
dir
attribute
of
the
element
should
'
ve
been
set
to
"
rtl
"
by
{
aTestData
.
action
}
)
;
}
verify
(
aTestData
undefined
{
cancelable
:
true
inputType
:
"
formatSetBlockTextDirection
"
data
:
"
rtl
"
}
{
inputType
:
"
formatSetBlockTextDirection
"
data
:
"
rtl
"
}
)
;
}
finally
{
aElement
.
removeAttribute
(
"
dir
"
)
;
aElement
.
scrollTop
;
/
/
XXX
Update
the
root
frame
}
}
test_switching_text_direction_from_default
(
{
action
:
'
switching
text
direction
from
default
to
"
rtl
"
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_switching_text_direction_from_default
(
{
action
:
'
switching
text
direction
from
default
to
"
rtl
"
'
cancelBeforeInput
:
false
}
)
;
function
test_switching_text_direction_from_rtl_to_ltr
(
aTestData
)
{
try
{
aElement
.
setAttribute
(
"
dir
"
"
rtl
"
)
;
aElement
.
scrollTop
;
/
/
XXX
Update
the
root
frame
aElement
.
focus
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
SpecialPowers
.
doCommand
(
window
"
cmd_switchTextDirection
"
)
;
let
expectedDirValue
=
aTestData
.
cancelBeforeInput
?
"
rtl
"
:
"
ltr
"
;
is
(
aElement
.
getAttribute
(
"
dir
"
)
expectedDirValue
{
aDescription
}
dir
attribute
of
the
element
should
be
"
{
expectedDirValue
}
"
after
{
aTestData
.
action
}
)
;
verify
(
aTestData
undefined
{
cancelable
:
true
inputType
:
"
formatSetBlockTextDirection
"
data
:
"
ltr
"
}
{
inputType
:
"
formatSetBlockTextDirection
"
data
:
"
ltr
"
}
)
;
}
finally
{
aElement
.
removeAttribute
(
"
dir
"
)
;
aElement
.
scrollTop
;
/
/
XXX
Update
the
root
frame
}
}
test_switching_text_direction_from_rtl_to_ltr
(
{
action
:
'
switching
text
direction
from
"
rtl
"
to
"
ltr
"
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_switching_text_direction_from_rtl_to_ltr
(
{
action
:
'
switching
text
direction
from
"
rtl
"
to
"
ltr
"
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
false
}
)
;
aElement
.
removeEventListener
(
"
beforeinput
"
beforeInputHandler
true
)
;
aElement
.
removeEventListener
(
"
input
"
inputHandler
true
)
;
}
doTests
(
document
.
getElementById
(
"
input
"
)
"
<
input
type
=
\
"
text
\
"
>
"
false
)
;
doTests
(
document
.
getElementById
(
"
textarea
"
)
"
<
textarea
>
"
true
)
;
SimpleTest
.
finish
(
)
;
}
<
/
script
>
<
/
body
>
<
/
html
>
