<
html
>
<
head
>
<
title
>
Test
for
input
event
of
text
editor
<
/
title
>
<
script
src
=
"
/
tests
/
SimpleTest
/
SimpleTest
.
js
"
>
<
/
script
>
<
script
src
=
"
/
tests
/
SimpleTest
/
EventUtils
.
js
"
>
<
/
script
>
<
link
rel
=
"
stylesheet
"
type
=
"
text
/
css
"
href
=
"
/
tests
/
SimpleTest
/
test
.
css
"
/
>
<
/
head
>
<
body
>
<
div
id
=
"
display
"
>
<
input
type
=
"
text
"
id
=
"
input
"
>
<
textarea
id
=
"
textarea
"
>
<
/
textarea
>
<
/
div
>
<
div
id
=
"
content
"
style
=
"
display
:
none
"
>
<
/
div
>
<
pre
id
=
"
test
"
>
<
/
pre
>
<
script
class
=
"
testbody
"
type
=
"
application
/
javascript
"
>
"
use
strict
"
;
SimpleTest
.
waitForExplicitFinish
(
)
;
SimpleTest
.
expectAssertions
(
0
1
)
;
/
/
In
a11y
module
SimpleTest
.
waitForFocus
(
runTests
window
)
;
const
kIsWin
=
navigator
.
platform
.
indexOf
(
"
Win
"
)
=
=
0
;
const
kIsMac
=
navigator
.
platform
.
indexOf
(
"
Mac
"
)
=
=
0
;
async
function
runTests
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
input_events
.
beforeinput
.
enabled
"
true
]
]
}
)
;
const
kWordSelectEatSpaceToNextWord
=
SpecialPowers
.
getBoolPref
(
"
layout
.
word_select
.
eat_space_to_next_word
"
)
;
function
doTests
(
aElement
aDescription
aIsTextarea
)
{
aDescription
+
=
"
:
"
;
aElement
.
focus
(
)
;
aElement
.
value
=
"
"
;
let
initializing
=
false
;
let
cancelBeforeInput
=
false
;
let
beforeInputEvent
=
null
;
let
inputEvent
=
null
;
let
action
=
"
"
;
let
beforeInputHandler
=
(
aEvent
)
=
>
{
if
(
initializing
)
{
return
;
}
ok
(
!
beforeInputEvent
{
aDescription
}
Multiple
"
beforeinput
"
events
are
fired
at
{
action
}
(
inputType
:
"
{
aEvent
.
inputType
}
"
data
:
{
aEvent
.
data
}
)
)
;
if
(
cancelBeforeInput
)
{
aEvent
.
preventDefault
(
)
;
}
ok
(
aEvent
.
isTrusted
{
aDescription
}
"
beforeinput
"
event
at
{
action
}
must
be
trusted
)
;
is
(
aEvent
.
target
aElement
{
aDescription
}
"
beforeinput
"
event
at
{
action
}
is
fired
on
unexpected
element
:
{
aEvent
.
target
.
tagName
}
)
;
ok
(
aEvent
instanceof
InputEvent
{
aDescription
}
"
beforeinput
"
event
at
{
action
}
should
be
dispatched
with
InputEvent
interface
)
;
ok
(
aEvent
.
bubbles
{
aDescription
}
"
beforeinput
"
event
at
{
action
}
must
be
bubbles
)
;
beforeInputEvent
=
aEvent
;
}
;
let
inputHandler
=
(
aEvent
)
=
>
{
if
(
initializing
)
{
return
;
}
ok
(
!
inputEvent
{
aDescription
}
Multiple
"
input
"
events
are
fired
at
{
action
}
(
inputType
:
"
{
aEvent
.
inputType
}
"
data
:
{
aEvent
.
data
}
)
)
;
ok
(
aEvent
.
isTrusted
{
aDescription
}
"
input
"
event
at
{
action
}
must
be
trusted
)
;
is
(
aEvent
.
target
aElement
"
input
"
event
at
{
action
}
is
fired
on
unexpected
element
:
{
aEvent
.
target
.
tagName
}
)
;
ok
(
aEvent
instanceof
InputEvent
{
aDescription
}
"
input
"
event
at
{
action
}
should
be
dispatched
with
InputEvent
interface
)
;
ok
(
!
aEvent
.
cancelable
{
aDescription
}
"
input
"
event
at
{
action
}
must
not
be
cancelable
)
;
ok
(
aEvent
.
bubbles
{
aDescription
}
"
input
"
event
at
{
action
}
must
be
bubbles
)
;
let
duration
=
Math
.
abs
(
window
.
performance
.
now
(
)
-
aEvent
.
timeStamp
)
;
ok
(
duration
<
30
*
1000
{
aDescription
}
perhaps
timestamp
wasn
'
t
set
correctly
:
{
aEvent
.
timeStamp
}
(
expected
it
to
be
within
30s
of
+
the
current
time
but
it
differed
by
{
duration
}
ms
)
)
;
inputEvent
=
aEvent
;
}
;
aElement
.
addEventListener
(
"
beforeinput
"
beforeInputHandler
true
)
;
aElement
.
addEventListener
(
"
input
"
inputHandler
true
)
;
function
test_typing_a_in_empty_editor
(
aTestData
)
{
aElement
.
value
=
"
"
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
sendString
(
"
a
"
)
;
let
expectedValue
=
aTestData
.
cancelBeforeInput
?
"
"
:
"
a
"
;
is
(
aElement
.
value
expectedValue
{
aDescription
}
the
value
should
be
"
{
expectedValue
}
"
after
{
aTestData
.
action
}
)
;
ok
(
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
beforeInputEvent
.
cancelable
true
{
aDescription
}
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
be
cancelable
)
;
is
(
beforeInputEvent
.
inputType
"
insertText
"
{
aDescription
}
inputType
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
be
"
insertText
"
)
;
is
(
beforeInputEvent
.
data
"
a
"
{
aDescription
}
data
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
be
"
a
"
)
;
is
(
beforeInputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
if
(
aTestData
.
cancelBeforeInput
)
{
ok
(
!
inputEvent
{
aDescription
}
"
input
"
event
shouldn
'
t
have
been
fired
at
{
aTestData
.
action
}
)
;
return
;
}
ok
(
inputEvent
{
aDescription
}
"
input
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
inputEvent
.
inputType
"
insertText
"
{
aDescription
}
inputType
of
"
input
"
event
by
{
aTestData
.
action
}
should
be
"
insertText
"
)
;
is
(
inputEvent
.
data
"
a
"
{
aDescription
}
data
of
"
input
"
event
by
{
aTestData
.
action
}
should
be
"
a
"
)
;
is
(
inputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
input
"
event
by
{
aTestData
.
action
}
should
be
null
)
;
is
(
inputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
input
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
}
test_typing_a_in_empty_editor
(
{
action
:
'
typing
"
a
"
and
canceling
beforeinput
'
cancelBeforeInput
:
true
}
)
;
test_typing_a_in_empty_editor
(
{
action
:
'
typing
"
a
"
'
cancelBeforeInput
:
false
}
)
;
function
test_typing_backspace_to_delete_last_character
(
aTestData
)
{
aElement
.
value
=
"
a
"
;
aElement
.
setSelectionStart
=
"
a
"
.
length
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
KEY_Backspace
"
)
;
let
expectedValue
=
aTestData
.
cancelBeforeInput
?
"
a
"
:
"
"
;
is
(
aElement
.
value
expectedValue
{
aDescription
}
the
value
should
be
"
{
expectedValue
}
"
after
{
aTestData
.
action
}
)
;
ok
(
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
beforeInputEvent
.
cancelable
true
{
aDescription
}
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
be
cancelable
)
;
is
(
beforeInputEvent
.
inputType
"
deleteContentBackward
"
{
aDescription
}
inputType
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
be
"
deleteContentBackward
"
)
;
is
(
beforeInputEvent
.
data
null
{
aDescription
}
data
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
if
(
aTestData
.
cancelBeforeInput
)
{
ok
(
!
inputEvent
{
aDescription
}
"
input
"
event
shouldn
'
t
have
been
fired
at
{
aTestData
.
action
}
)
;
return
;
}
ok
(
inputEvent
{
aDescription
}
"
input
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
inputEvent
.
inputType
"
deleteContentBackward
"
{
aDescription
}
inputType
of
"
input
"
event
by
{
aTestData
.
action
}
should
be
"
deleteContentBackward
"
)
;
is
(
inputEvent
.
data
null
{
aDescription
}
data
of
"
input
"
event
by
{
aTestData
.
action
}
should
be
null
)
;
is
(
inputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
input
"
event
by
{
aTestData
.
action
}
should
be
null
)
;
is
(
inputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
input
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
}
test_typing_backspace_to_delete_last_character
(
{
actin
:
'
typing
"
Backspace
"
to
delete
"
a
"
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_typing_backspace_to_delete_last_character
(
{
actin
:
'
typing
"
Backspace
"
to
delete
"
a
"
'
cancelBeforeInput
:
false
}
)
;
function
test_typing_enter_in_empty_editor
(
aTestData
)
{
aElement
.
value
=
"
"
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
KEY_Enter
"
)
;
if
(
aIsTextarea
)
{
let
expectedValue
=
aTestData
.
cancelBeforeInput
?
"
"
:
"
\
n
"
;
is
(
aElement
.
value
expectedValue
{
aDescription
}
the
value
should
be
"
{
expectedValue
}
"
after
{
aTestData
.
action
}
)
;
}
else
{
is
(
aElement
.
value
"
"
{
aDescription
}
the
value
should
be
"
"
after
{
aTestData
.
action
}
)
;
}
ok
(
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
beforeInputEvent
.
cancelable
true
{
aDescription
}
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
be
cancelable
)
;
is
(
beforeInputEvent
.
inputType
"
insertLineBreak
"
{
aDescription
}
inputType
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
be
"
insertLineBreak
"
)
;
is
(
beforeInputEvent
.
data
null
{
aDescription
}
data
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
if
(
aTestData
.
cancelBeforeInput
)
{
ok
(
!
inputEvent
{
aDescription
}
"
input
"
event
shouldn
'
t
have
been
fired
at
{
aTestData
.
action
}
)
;
return
;
}
if
(
aIsTextarea
)
{
ok
(
inputEvent
{
aDescription
}
"
input
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
inputEvent
.
inputType
"
insertLineBreak
"
{
aDescription
}
inputType
of
"
input
"
event
by
{
aTestData
.
action
}
should
be
"
insertLineBreak
"
)
;
is
(
inputEvent
.
data
null
{
aDescription
}
data
of
"
input
"
event
by
{
aTestData
.
action
}
should
be
null
)
;
is
(
inputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
input
"
event
by
{
aTestData
.
action
}
should
be
null
)
;
is
(
inputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
input
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
}
else
{
ok
(
!
inputEvent
{
aDescription
}
"
input
"
event
shouldn
'
t
have
been
fired
at
{
aTestData
.
action
}
since
it
'
s
a
single
line
editor
"
)
;
}
}
test_typing_enter_in_empty_editor
(
{
action
:
'
typing
"
Enter
"
in
empty
editor
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_typing_enter_in_empty_editor
(
{
action
:
'
typing
"
Enter
"
in
empty
editor
'
cancelBeforeInput
:
false
}
)
;
(
function
test_setting_value
(
)
{
cancelBeforeInput
=
false
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
aElement
.
value
=
"
foo
-
bar
"
;
action
=
"
setting
value
"
;
is
(
aElement
.
value
"
foo
-
bar
"
{
aDescription
}
value
should
'
ve
been
set
by
{
action
}
)
;
ok
(
!
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
shouldn
'
t
have
been
fired
by
{
action
}
)
;
ok
(
!
inputEvent
{
aDescription
}
"
input
"
event
shouldn
'
t
have
been
fired
by
{
action
}
)
;
}
)
(
)
;
(
function
test_setting_empty_value
(
)
{
cancelBeforeInput
=
false
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
aElement
.
value
=
"
"
;
action
=
"
setting
empty
value
"
;
is
(
aElement
.
value
"
"
aDescription
+
"
value
wasn
'
t
set
(
empty
)
"
)
;
is
(
aElement
.
value
"
"
{
aDescription
}
value
should
'
ve
been
set
to
empy
by
{
action
}
)
;
ok
(
!
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
shouldn
'
t
have
been
fired
by
{
action
}
)
;
ok
(
!
inputEvent
{
aDescription
}
"
input
"
event
shouldn
'
t
have
been
fired
by
{
action
}
)
;
}
)
(
)
;
(
function
test_typing_space_in_empty_editor
(
)
{
cancelBeforeInput
=
false
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
"
typing
a
space
"
;
sendString
(
"
"
)
;
is
(
aElement
.
value
"
"
{
aDescription
}
"
"
should
'
ve
been
inserted
by
{
action
}
)
;
ok
(
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
should
'
ve
been
fired
at
{
action
}
)
;
is
(
beforeInputEvent
.
cancelable
true
{
aDescription
}
"
beforeinput
"
event
by
{
action
}
should
be
cancelable
)
;
is
(
beforeInputEvent
.
inputType
"
insertText
"
{
aDescription
}
inputType
of
"
beforeinput
"
event
by
{
action
}
should
be
"
insertText
"
)
;
is
(
beforeInputEvent
.
data
"
"
{
aDescription
}
data
of
"
beforeinput
"
event
by
{
action
}
should
be
"
"
)
;
is
(
beforeInputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
beforeinput
"
event
by
{
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
beforeinput
"
event
by
{
action
}
should
return
empty
array
)
;
ok
(
inputEvent
{
aDescription
}
"
input
"
event
should
'
ve
been
fired
at
{
action
}
)
;
is
(
inputEvent
.
inputType
"
insertText
"
{
aDescription
}
inputType
of
"
input
"
event
by
{
action
}
should
be
"
insertText
"
)
;
is
(
inputEvent
.
data
"
"
{
aDescription
}
data
of
"
input
"
event
by
{
action
}
should
be
"
"
)
;
is
(
inputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
input
"
event
by
{
action
}
should
be
null
)
;
is
(
inputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
input
"
event
by
{
action
}
should
return
empty
array
)
;
}
)
(
)
;
(
function
test_typing_delete_at_end_of_editor
(
)
{
cancelBeforeInput
=
false
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
'
typing
"
Delete
"
at
end
'
;
synthesizeKey
(
"
KEY_Delete
"
)
;
is
(
aElement
.
value
"
"
{
aDescription
}
{
action
}
shouldn
'
t
remove
anything
since
no
removable
content
)
;
ok
(
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
should
'
ve
been
fired
at
{
action
}
)
;
is
(
beforeInputEvent
.
cancelable
true
{
aDescription
}
"
beforeinput
"
event
by
{
action
}
should
be
cancelable
)
;
is
(
beforeInputEvent
.
inputType
"
deleteContentForward
"
{
aDescription
}
inputType
of
"
beforeinput
"
event
by
{
action
}
should
be
"
deleteContentForward
"
)
;
is
(
beforeInputEvent
.
data
null
{
aDescription
}
data
of
"
beforeinput
"
event
by
{
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
beforeinput
"
event
by
{
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
beforeinput
"
event
by
{
action
}
should
return
empty
array
)
;
ok
(
!
inputEvent
{
aDescription
}
"
input
"
event
shouldn
'
t
have
been
fired
by
{
action
}
since
no
removable
content
)
;
}
)
(
)
;
(
function
test_typing_arrow_left_to_move_caret
(
)
{
cancelBeforeInput
=
false
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
'
typing
"
ArrowLeft
"
'
;
synthesizeKey
(
"
KEY_ArrowLeft
"
)
;
is
(
aElement
.
value
"
"
{
aDescription
}
{
action
}
shouldn
'
t
remove
anything
)
;
ok
(
!
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
shouldn
'
t
have
been
fired
by
{
action
}
)
;
ok
(
!
inputEvent
{
aDescription
}
"
input
"
event
shouldn
'
t
have
been
fired
by
{
action
}
)
;
}
)
(
)
;
function
test_typing_delete_to_delete_last_character
(
aTestData
)
{
aElement
.
value
=
"
"
;
aElement
.
selectionStart
=
0
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
KEY_Delete
"
)
;
let
expectedValue
=
aTestData
.
cancelBeforeInput
?
"
"
:
"
"
;
is
(
aElement
.
value
expectedValue
{
aDescription
}
the
value
should
be
"
{
expectedValue
}
"
after
{
aTestData
.
action
}
)
;
ok
(
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
beforeInputEvent
.
cancelable
true
{
aDescription
}
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
be
cancelable
)
;
is
(
beforeInputEvent
.
inputType
"
deleteContentForward
"
{
aDescription
}
inputType
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
be
"
deleteContentForward
"
)
;
is
(
beforeInputEvent
.
data
null
{
aDescription
}
data
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
if
(
aTestData
.
cancelBeforeInput
)
{
ok
(
!
inputEvent
{
aDescription
}
"
input
"
event
shouldn
'
t
have
been
fired
at
{
aTestData
.
action
}
)
;
return
;
}
ok
(
inputEvent
{
aDescription
}
"
input
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
inputEvent
.
inputType
"
deleteContentForward
"
{
aDescription
}
inputType
of
"
input
"
event
by
{
aTestData
.
action
}
should
be
"
deleteContentForward
"
)
;
is
(
inputEvent
.
data
null
{
aDescription
}
data
of
"
input
"
event
by
{
aTestData
.
action
}
should
be
null
)
;
is
(
inputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
input
"
event
by
{
aTestData
.
action
}
should
be
null
)
;
is
(
inputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
input
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
}
test_typing_delete_to_delete_last_character
(
{
action
:
'
typing
"
Delete
"
to
delete
space
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_typing_delete_to_delete_last_character
(
{
action
:
'
typing
"
Delete
"
to
delete
space
'
cancelBeforeInput
:
false
}
)
;
function
test_undoing_deleting_last_character
(
aTestData
)
{
initializing
=
true
;
aElement
.
value
=
"
a
"
;
aElement
.
selectionStart
=
0
;
synthesizeKey
(
"
KEY_Delete
"
)
;
initializing
=
false
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
z
"
{
accelKey
:
true
}
)
;
let
expectedValue
=
aTestData
.
cancelBeforeInput
?
"
"
:
"
a
"
;
is
(
aElement
.
value
expectedValue
{
aDescription
}
the
value
should
be
"
{
expectedValue
}
"
after
{
aTestData
.
action
}
)
;
ok
(
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
beforeInputEvent
.
cancelable
true
{
aDescription
}
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
cancelable
)
;
is
(
beforeInputEvent
.
inputType
"
historyUndo
"
{
aDescription
}
inputType
of
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
"
historyUndo
"
)
;
is
(
beforeInputEvent
.
data
null
{
aDescription
}
data
of
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
if
(
aTestData
.
cancelBeforeInput
)
{
ok
(
!
inputEvent
{
aDescription
}
"
input
"
event
shouldn
'
t
have
been
fired
at
{
aTestData
.
action
}
)
;
return
;
}
ok
(
inputEvent
{
aDescription
}
"
input
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
inputEvent
.
inputType
"
historyUndo
"
{
aDescription
}
inputType
of
"
input
"
event
for
{
aTestData
.
action
}
should
be
"
historyUndo
"
)
;
is
(
inputEvent
.
data
null
{
aDescription
}
data
of
"
input
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
inputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
input
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
inputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
input
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
}
test_undoing_deleting_last_character
(
{
action
:
'
undoing
deleting
last
character
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_undoing_deleting_last_character
(
{
action
:
"
undoing
deleting
last
character
"
cancelBeforeInput
:
false
}
)
;
(
function
test_undoing_without_undoable_transaction
(
)
{
cancelBeforeInput
=
false
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
'
doing
"
Undo
"
again
'
;
synthesizeKey
(
"
z
"
{
accelKey
:
true
}
)
;
is
(
aElement
.
value
"
a
"
{
aDescription
}
{
action
}
shouldn
'
t
modify
the
value
since
no
undo
transaction
)
;
ok
(
!
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
shouldn
'
t
have
been
fired
at
{
action
}
since
no
undo
transaction
)
;
ok
(
!
inputEvent
{
aDescription
}
"
input
"
event
shouldn
'
t
have
been
fired
at
{
action
}
since
no
undo
transaction
)
;
}
)
(
)
;
function
test_redoing_deleting_last_character
(
aTestData
)
{
initializing
=
true
;
aElement
.
value
=
"
a
"
;
aElement
.
selectionStart
=
0
;
synthesizeKey
(
"
KEY_Delete
"
)
;
synthesizeKey
(
"
z
"
{
accelKey
:
true
}
)
;
initializing
=
false
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
Z
"
{
accelKey
:
true
shiftKey
:
true
}
)
;
let
expectedValue
=
aTestData
.
cancelBeforeInput
?
"
a
"
:
"
"
;
is
(
aElement
.
value
expectedValue
{
aDescription
}
the
value
should
be
"
{
expectedValue
}
"
after
{
aTestData
.
action
}
)
;
ok
(
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
beforeInputEvent
.
cancelable
true
{
aDescription
}
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
cancelable
)
;
is
(
beforeInputEvent
.
inputType
"
historyRedo
"
{
aDescription
}
inputType
of
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
"
historyRedo
"
)
;
is
(
beforeInputEvent
.
data
null
{
aDescription
}
data
of
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
if
(
aTestData
.
cancelBeforeInput
)
{
ok
(
!
inputEvent
{
aDescription
}
"
input
"
event
shouldn
'
t
have
been
fired
at
{
aTestData
.
action
}
)
;
return
;
}
ok
(
inputEvent
{
aDescription
}
"
input
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
inputEvent
.
inputType
"
historyRedo
"
{
aDescription
}
inputType
of
"
input
"
event
for
{
aTestData
.
action
}
should
be
"
historyRedo
"
)
;
is
(
inputEvent
.
data
null
{
aDescription
}
data
of
"
input
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
inputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
input
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
inputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
input
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
}
test_redoing_deleting_last_character
(
{
action
:
'
redoing
deleting
last
character
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_redoing_deleting_last_character
(
{
action
:
"
redoing
deleting
last
character
"
cancelBeforeInput
:
false
}
)
;
(
function
test_redoing_without_redoable_transaction
(
)
{
cancelBeforeInput
=
false
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
'
doing
"
Redo
"
again
'
;
synthesizeKey
(
"
Z
"
{
accelKey
:
true
shiftKey
:
true
}
)
;
is
(
aElement
.
value
"
"
{
aDescription
}
{
action
}
shouldn
'
t
modify
the
value
since
no
redo
transaction
)
;
ok
(
!
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
shouldn
'
t
have
been
fired
at
{
action
}
since
no
redo
transaction
)
;
ok
(
!
inputEvent
{
aDescription
}
"
input
"
event
shouldn
'
t
have
been
fired
at
{
action
}
since
no
redo
transaction
)
;
}
)
(
)
;
function
test_typing_backspace_with_selecting_all_characters
(
aTestData
)
{
aElement
.
value
=
"
abc
"
;
aElement
.
focus
(
)
;
aElement
.
select
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
synthesizeKey
(
"
KEY_Backspace
"
)
;
let
expectedValue
=
aTestData
.
cancelBeforeInput
?
"
abc
"
:
"
"
;
is
(
aElement
.
value
expectedValue
{
aDescription
}
the
value
should
be
"
{
expectedValue
}
"
after
{
aTestData
.
action
}
)
;
ok
(
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
beforeInputEvent
.
cancelable
true
{
aDescription
}
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
cancelable
)
;
is
(
beforeInputEvent
.
inputType
"
deleteContentBackward
"
{
aDescription
}
inputType
of
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
"
deleteContentBackward
"
)
;
is
(
beforeInputEvent
.
data
null
{
aDescription
}
data
of
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
if
(
aTestData
.
cancelBeforeInput
)
{
ok
(
!
inputEvent
{
aDescription
}
"
input
"
event
shouldn
'
t
have
been
fired
at
{
aTestData
.
action
}
)
;
return
;
}
ok
(
inputEvent
{
aDescription
}
"
input
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
inputEvent
.
inputType
"
deleteContentBackward
"
{
aDescription
}
inputType
of
"
input
"
event
for
{
aTestData
.
action
}
should
be
"
deleteContentBackward
"
)
;
is
(
inputEvent
.
data
null
{
aDescription
}
data
of
"
input
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
inputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
input
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
inputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
input
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
}
test_typing_backspace_with_selecting_all_characters
(
{
action
:
'
typing
"
Backspace
"
to
delete
all
selected
characters
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_typing_backspace_with_selecting_all_characters
(
{
action
:
'
typing
"
Backspace
"
to
delete
all
selected
characters
'
cancelBeforeInput
:
false
}
)
;
function
test_typing_delete_with_selecting_all_characters
(
aTestData
)
{
aElement
.
value
=
"
abc
"
;
aElement
.
focus
(
)
;
aElement
.
select
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
KEY_Delete
"
)
;
let
expectedValue
=
aTestData
.
cancelBeforeInput
?
"
abc
"
:
"
"
;
is
(
aElement
.
value
expectedValue
{
aDescription
}
the
value
should
be
"
{
expectedValue
}
"
after
{
aTestData
.
action
}
)
;
ok
(
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
beforeInputEvent
.
cancelable
true
{
aDescription
}
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
cancelable
)
;
is
(
beforeInputEvent
.
inputType
"
deleteContentForward
"
{
aDescription
}
inputType
of
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
"
deleteContentForward
"
)
;
is
(
beforeInputEvent
.
data
null
{
aDescription
}
data
of
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
if
(
aTestData
.
cancelBeforeInput
)
{
ok
(
!
inputEvent
{
aDescription
}
"
input
"
event
shouldn
'
t
have
been
fired
at
{
aTestData
.
action
}
)
;
return
;
}
ok
(
inputEvent
{
aDescription
}
"
input
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
inputEvent
.
inputType
"
deleteContentForward
"
{
aDescription
}
inputType
of
"
input
"
event
for
{
aTestData
.
action
}
should
be
"
deleteContentForward
"
)
;
is
(
inputEvent
.
data
null
{
aDescription
}
data
of
"
input
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
inputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
input
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
inputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
input
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
}
test_typing_delete_with_selecting_all_characters
(
{
action
:
'
typing
"
Delete
"
to
delete
all
selected
characters
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_typing_delete_with_selecting_all_characters
(
{
action
:
'
typing
"
Delete
"
to
delete
all
selected
characters
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
false
}
)
;
function
test_deleting_word_backward_from_its_end
(
aTestData
)
{
aElement
.
value
=
"
abc
def
"
;
aElement
.
focus
(
)
;
document
.
documentElement
.
scrollTop
;
/
/
XXX
Needs
reflow
here
for
working
with
nsFrameSelection
must
be
a
bug
.
aElement
.
setSelectionRange
(
"
abc
def
"
.
length
"
abc
def
"
.
length
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
SpecialPowers
.
doCommand
(
window
"
cmd_deleteWordBackward
"
)
;
let
expectedValue
=
aTestData
.
cancelBeforeInput
?
"
abc
def
"
:
"
abc
"
;
is
(
aElement
.
value
expectedValue
{
aDescription
}
the
value
should
be
"
{
expectedValue
}
"
after
{
aTestData
.
action
}
)
;
ok
(
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
beforeInputEvent
.
cancelable
true
{
aDescription
}
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
cancelable
)
;
is
(
beforeInputEvent
.
inputType
"
deleteWordBackward
"
{
aDescription
}
inputType
of
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
"
deleteWordBackward
"
)
;
is
(
beforeInputEvent
.
data
null
{
aDescription
}
data
of
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
if
(
aTestData
.
cancelBeforeInput
)
{
ok
(
!
inputEvent
{
aDescription
}
"
input
"
event
shouldn
'
t
have
been
fired
at
{
aTestData
.
action
}
)
;
return
;
}
ok
(
inputEvent
{
aDescription
}
"
input
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
inputEvent
.
inputType
"
deleteWordBackward
"
{
aDescription
}
inputType
of
"
input
"
event
for
{
aTestData
.
action
}
should
be
"
deleteWordBackward
"
)
;
is
(
inputEvent
.
data
null
{
aDescription
}
data
of
"
input
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
inputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
input
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
inputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
input
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
}
test_deleting_word_backward_from_its_end
(
{
action
:
'
deleting
word
backward
from
its
end
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_deleting_word_backward_from_its_end
(
{
action
:
'
deleting
word
backward
from
its
end
'
cancelBeforeInput
:
false
}
)
;
function
test_deleting_word_forward_from_its_start
(
aTestData
)
{
aElement
.
value
=
"
abc
def
"
;
aElement
.
focus
(
)
;
document
.
documentElement
.
scrollTop
;
/
/
XXX
Needs
reflow
here
for
working
with
nsFrameSelection
must
be
a
bug
.
aElement
.
setSelectionRange
(
0
0
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
SpecialPowers
.
doCommand
(
window
"
cmd_deleteWordForward
"
)
;
let
expectedValue
;
if
(
aTestData
.
cancelBeforeInput
)
{
expectedValue
=
"
abc
def
"
;
}
else
{
expectedValue
=
kWordSelectEatSpaceToNextWord
?
"
def
"
:
"
def
"
;
}
is
(
aElement
.
value
expectedValue
{
aDescription
}
the
value
should
be
"
{
expectedValue
}
"
after
{
aTestData
.
action
}
)
;
ok
(
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
beforeInputEvent
.
cancelable
true
{
aDescription
}
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
cancelable
)
;
is
(
beforeInputEvent
.
inputType
"
deleteWordForward
"
{
aDescription
}
inputType
of
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
"
deleteWordForward
"
)
;
is
(
beforeInputEvent
.
data
null
{
aDescription
}
data
of
"
beforeinput
"
event
for
{
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
if
(
aTestData
.
cancelBeforeInput
)
{
ok
(
!
inputEvent
{
aDescription
}
"
input
"
event
shouldn
'
t
have
been
fired
at
{
aTestData
.
action
}
)
;
return
;
}
ok
(
inputEvent
{
aDescription
}
"
input
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
inputEvent
.
inputType
"
deleteWordForward
"
{
aDescription
}
inputType
of
"
input
"
event
for
{
aTestData
.
action
}
should
be
"
deleteWordForward
"
)
;
is
(
inputEvent
.
data
null
{
aDescription
}
data
of
"
input
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
inputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
input
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
inputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
input
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
}
test_deleting_word_forward_from_its_start
(
{
action
:
'
deleting
word
forward
from
its
start
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_deleting_word_forward_from_its_start
(
{
action
:
"
deleting
word
forward
from
its
start
"
cancelBeforeInput
:
false
}
)
;
(
function
test_deleting_word_backward_from_middle_of_second_word
(
)
{
aElement
.
value
=
"
abc
def
"
;
aElement
.
focus
(
)
;
document
.
documentElement
.
scrollTop
;
/
/
XXX
Needs
reflow
here
for
working
with
nsFrameSelection
must
be
a
bug
.
aElement
.
setSelectionRange
(
"
abc
d
"
.
length
"
abc
de
"
.
length
)
;
cancelBeforeInput
=
false
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
"
removing
characters
backward
from
middle
of
second
word
"
;
SpecialPowers
.
doCommand
(
window
"
cmd_deleteWordBackward
"
)
;
/
/
Only
on
Windows
we
collapse
selection
to
start
before
handling
this
command
.
let
expectedInputType
=
kIsWin
?
"
deleteWordBackward
"
:
"
deleteContentBackward
"
;
is
(
aElement
.
value
kIsWin
?
"
abc
ef
"
:
"
abc
df
"
{
aDescription
}
{
kIsWin
?
"
characters
between
current
word
start
and
selection
start
"
:
"
selected
characters
"
}
should
'
ve
been
removed
by
{
action
}
)
;
ok
(
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
should
'
ve
been
fired
at
{
action
}
)
;
is
(
beforeInputEvent
.
cancelable
true
{
aDescription
}
"
beforeinput
"
event
for
{
action
}
should
be
cancelable
)
;
is
(
beforeInputEvent
.
inputType
expectedInputType
{
aDescription
}
inputType
of
"
beforeinput
"
event
for
{
action
}
should
be
"
{
expectedInputType
}
"
)
;
is
(
beforeInputEvent
.
data
null
{
aDescription
}
data
of
"
beforeinput
"
event
for
{
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
beforeinput
"
event
for
{
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
beforeinput
"
event
by
{
action
}
should
return
empty
array
)
;
ok
(
inputEvent
{
aDescription
}
"
input
"
event
should
'
ve
been
fired
at
{
action
}
)
;
is
(
inputEvent
.
inputType
expectedInputType
{
aDescription
}
inputType
of
"
input
"
event
for
{
action
}
should
be
"
{
expectedInputType
}
"
)
;
is
(
inputEvent
.
data
null
{
aDescription
}
data
of
"
input
"
event
for
{
action
}
should
be
null
)
;
is
(
inputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
input
"
event
for
{
action
}
should
be
null
)
;
is
(
inputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
input
"
event
by
{
action
}
should
return
empty
array
)
;
}
)
(
)
;
(
function
test_deleting_word_forward_from_middle_of_first_word
(
)
{
aElement
.
value
=
"
abc
def
"
;
aElement
.
focus
(
)
;
document
.
documentElement
.
scrollTop
;
/
/
XXX
Needs
reflow
here
for
working
with
nsFrameSelection
must
be
a
bug
.
aElement
.
setSelectionRange
(
"
a
"
.
length
"
ab
"
.
length
)
;
cancelBeforeInput
=
false
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
"
removing
characters
forward
from
middle
of
first
word
"
;
SpecialPowers
.
doCommand
(
window
"
cmd_deleteWordForward
"
)
;
/
/
Only
on
Windows
we
collapse
selection
to
start
before
handling
this
command
.
let
expectedInputType
=
kIsWin
?
"
deleteWordForward
"
:
"
deleteContentForward
"
;
let
expectedValue
=
"
ac
def
"
;
if
(
kIsWin
)
{
expectedValue
=
kWordSelectEatSpaceToNextWord
?
"
adef
"
:
"
a
def
"
;
}
is
(
aElement
.
value
expectedValue
{
aDescription
}
{
kIsWin
?
"
characters
between
selection
start
and
next
word
start
"
:
"
selected
characters
"
}
should
'
ve
been
removed
by
{
action
}
)
;
ok
(
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
should
'
ve
been
fired
at
{
action
}
)
;
is
(
beforeInputEvent
.
cancelable
true
{
aDescription
}
"
beforeinput
"
event
for
{
action
}
should
be
cancelable
)
;
is
(
beforeInputEvent
.
inputType
expectedInputType
{
aDescription
}
inputType
of
"
beforeinput
"
event
for
{
action
}
should
be
"
{
expectedInputType
}
"
)
;
is
(
beforeInputEvent
.
data
null
{
aDescription
}
data
of
"
beforeinput
"
event
for
{
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
beforeinput
"
event
for
{
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
beforeinput
"
event
by
{
action
}
should
return
empty
array
)
;
ok
(
inputEvent
{
aDescription
}
"
input
"
event
should
'
ve
been
fired
at
{
action
}
)
;
is
(
inputEvent
.
inputType
expectedInputType
{
aDescription
}
inputType
of
"
input
"
event
for
{
action
}
should
be
"
{
expectedInputType
}
"
)
;
is
(
inputEvent
.
data
null
{
aDescription
}
data
of
"
input
"
event
for
{
action
}
should
be
null
)
;
is
(
inputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
input
"
event
for
{
action
}
should
be
null
)
;
is
(
inputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
input
"
event
by
{
action
}
should
return
empty
array
)
;
}
)
(
)
;
(
function
test_deleting_characters_backward_to_start_of_line
(
)
{
aElement
.
value
=
"
abc
def
"
;
aElement
.
focus
(
)
;
document
.
documentElement
.
scrollTop
;
/
/
XXX
Needs
reflow
here
for
working
with
nsFrameSelection
must
be
a
bug
.
aElement
.
setSelectionRange
(
"
abc
d
"
.
length
"
abc
d
"
.
length
)
;
cancelBeforeInput
=
false
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
"
removing
characters
backward
to
start
of
line
"
;
SpecialPowers
.
doCommand
(
window
"
cmd_deleteToBeginningOfLine
"
)
;
is
(
aElement
.
value
"
ef
"
{
aDescription
}
characters
between
start
of
line
and
caret
should
'
ve
been
removed
by
{
action
}
)
;
ok
(
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
should
'
ve
been
fired
at
{
action
}
)
;
is
(
beforeInputEvent
.
cancelable
true
{
aDescription
}
"
beforeinput
"
event
for
{
action
}
should
be
cancelable
)
;
is
(
beforeInputEvent
.
inputType
"
deleteSoftLineBackward
"
{
aDescription
}
inputType
of
"
beforeinput
"
event
for
{
action
}
should
be
"
deleteSoftLineBackward
"
)
;
is
(
beforeInputEvent
.
data
null
{
aDescription
}
data
of
"
beforeinput
"
event
for
{
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
beforeinput
"
event
for
{
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
beforeinput
"
event
by
{
action
}
should
return
empty
array
)
;
ok
(
inputEvent
{
aDescription
}
"
input
"
event
should
'
ve
been
fired
at
{
action
}
)
;
is
(
inputEvent
.
inputType
"
deleteSoftLineBackward
"
{
aDescription
}
inputType
of
"
input
"
event
for
{
action
}
should
be
"
deleteSoftLineBackward
"
)
;
is
(
inputEvent
.
data
null
{
aDescription
}
data
of
"
input
"
event
for
{
action
}
should
be
null
)
;
is
(
inputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
input
"
event
for
{
action
}
should
be
null
)
;
is
(
inputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
input
"
event
by
{
action
}
should
return
empty
array
)
;
}
)
(
)
;
(
function
test_deleting_characters_forward_to_end_of_line
(
)
{
aElement
.
value
=
"
abc
def
"
;
aElement
.
focus
(
)
;
document
.
documentElement
.
scrollTop
;
/
/
XXX
Needs
reflow
here
for
working
with
nsFrameSelection
must
be
a
bug
.
aElement
.
setSelectionRange
(
"
ab
"
.
length
"
ab
"
.
length
)
;
cancelBeforeInput
=
false
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
"
removing
characters
forward
to
end
of
line
"
;
SpecialPowers
.
doCommand
(
window
"
cmd_deleteToEndOfLine
"
)
;
is
(
aElement
.
value
"
ab
"
{
aDescription
}
characters
between
caret
and
end
of
line
should
'
ve
been
removed
by
{
action
}
)
;
ok
(
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
should
'
ve
been
fired
at
{
action
}
)
;
is
(
beforeInputEvent
.
cancelable
true
{
aDescription
}
"
beforeinput
"
event
for
{
action
}
should
be
cancelable
)
;
is
(
beforeInputEvent
.
inputType
"
deleteSoftLineForward
"
{
aDescription
}
inputType
of
"
beforeinput
"
event
for
{
action
}
should
be
"
deleteSoftLineForward
"
)
;
is
(
beforeInputEvent
.
data
null
{
aDescription
}
data
of
"
beforeinput
"
event
for
{
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
beforeinput
"
event
for
{
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
beforeinput
"
event
by
{
action
}
should
return
empty
array
)
;
ok
(
inputEvent
{
aDescription
}
"
input
"
event
should
'
ve
been
fired
at
{
action
}
)
;
is
(
inputEvent
.
inputType
"
deleteSoftLineForward
"
{
aDescription
}
inputType
of
"
input
"
event
for
{
action
}
should
be
"
deleteSoftLineForward
"
)
;
is
(
inputEvent
.
data
null
{
aDescription
}
data
of
"
input
"
event
for
{
action
}
should
be
null
)
;
is
(
inputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
input
"
event
for
{
action
}
should
be
null
)
;
is
(
inputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
input
"
event
by
{
action
}
should
return
empty
array
)
;
}
)
(
)
;
(
function
test_deleting_characters_backward_to_start_of_line_with_non_collapsed_selection
(
)
{
aElement
.
value
=
"
abc
def
"
;
aElement
.
focus
(
)
;
document
.
documentElement
.
scrollTop
;
/
/
XXX
Needs
reflow
here
for
working
with
nsFrameSelection
must
be
a
bug
.
aElement
.
setSelectionRange
(
"
abc
d
"
.
length
"
abc_de
"
.
length
)
;
cancelBeforeInput
=
false
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
"
removing
characters
backward
to
start
of
line
(
with
selection
in
second
word
)
"
;
SpecialPowers
.
doCommand
(
window
"
cmd_deleteToBeginningOfLine
"
)
;
/
/
Only
on
Windows
we
collapse
selection
to
start
before
handling
this
command
.
let
expectedInputType
=
kIsWin
?
"
deleteSoftLineBackward
"
:
"
deleteContentBackward
"
;
is
(
aElement
.
value
kIsWin
?
"
ef
"
:
"
abc
df
"
{
aDescription
}
{
kIsWin
?
"
characters
between
start
of
line
and
caret
"
:
"
selected
characters
"
}
should
'
ve
been
removed
by
{
action
}
)
;
ok
(
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
should
'
ve
been
fired
at
{
action
}
)
;
is
(
beforeInputEvent
.
cancelable
true
{
aDescription
}
"
beforeinput
"
event
for
{
action
}
should
be
cancelable
)
;
is
(
beforeInputEvent
.
inputType
expectedInputType
{
aDescription
}
inputType
of
"
beforeinput
"
event
for
{
action
}
should
be
"
{
expectedInputType
}
"
)
;
is
(
beforeInputEvent
.
data
null
{
aDescription
}
data
of
"
beforeinput
"
event
for
{
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
beforeinput
"
event
for
{
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
beforeinput
"
event
by
{
action
}
should
return
empty
array
)
;
ok
(
inputEvent
{
aDescription
}
"
input
"
event
should
'
ve
been
fired
at
{
action
}
)
;
is
(
inputEvent
.
inputType
expectedInputType
{
aDescription
}
inputType
of
"
input
"
event
for
{
action
}
should
be
"
{
expectedInputType
}
"
)
;
is
(
inputEvent
.
data
null
{
aDescription
}
data
of
"
input
"
event
for
{
action
}
should
be
null
)
;
is
(
inputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
input
"
event
for
{
action
}
should
be
null
)
;
is
(
inputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
input
"
event
by
{
action
}
should
return
empty
array
)
;
}
)
(
)
;
(
function
test_deleting_characters_forward_to_end_of_line_with_non_collapsed_selection
(
)
{
aElement
.
value
=
"
abc
def
"
;
aElement
.
focus
(
)
;
document
.
documentElement
.
scrollTop
;
/
/
XXX
Needs
reflow
here
for
working
with
nsFrameSelection
must
be
a
bug
.
aElement
.
setSelectionRange
(
"
a
"
.
length
"
ab
"
.
length
)
;
cancelBeforeInput
=
false
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
"
removing
characters
forward
to
end
of
line
(
with
selection
in
second
word
)
"
;
SpecialPowers
.
doCommand
(
window
"
cmd_deleteToEndOfLine
"
)
;
/
/
Only
on
Windows
we
collapse
selection
to
start
before
handling
this
command
.
let
expectedInputType
=
kIsWin
?
"
deleteSoftLineForward
"
:
"
deleteContentForward
"
;
is
(
aElement
.
value
kIsWin
?
"
a
"
:
"
ac
def
"
{
aDescription
}
{
kIsWin
?
"
characters
between
caret
anc
end
of
line
"
:
"
selected
characters
"
}
should
'
ve
been
removed
by
{
action
}
)
;
ok
(
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
should
'
ve
been
fired
at
{
action
}
)
;
is
(
beforeInputEvent
.
cancelable
true
{
aDescription
}
"
beforeinput
"
event
for
{
action
}
should
be
cancelable
)
;
is
(
beforeInputEvent
.
inputType
expectedInputType
{
aDescription
}
inputType
of
"
beforeinput
"
event
for
{
action
}
should
be
"
{
expectedInputType
}
"
)
;
is
(
beforeInputEvent
.
data
null
{
aDescription
}
data
of
"
beforeinput
"
event
for
{
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
beforeinput
"
event
for
{
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
beforeinput
"
event
by
{
action
}
should
return
empty
array
)
;
ok
(
inputEvent
{
aDescription
}
"
input
"
event
should
'
ve
been
fired
at
{
action
}
)
;
is
(
inputEvent
.
inputType
expectedInputType
{
aDescription
}
inputType
of
"
input
"
event
for
{
action
}
should
be
"
{
expectedInputType
}
"
)
;
is
(
inputEvent
.
data
null
{
aDescription
}
data
of
"
input
"
event
for
{
action
}
should
be
null
)
;
is
(
inputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
input
"
event
for
{
action
}
should
be
null
)
;
is
(
inputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
input
"
event
by
{
action
}
should
return
empty
array
)
;
}
)
(
)
;
function
test_switching_text_direction_from_default
(
aTestData
)
{
try
{
aElement
.
removeAttribute
(
"
dir
"
)
;
aElement
.
scrollTop
;
/
/
XXX
Update
the
root
frame
aElement
.
focus
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
SpecialPowers
.
doCommand
(
window
"
cmd_switchTextDirection
"
)
;
if
(
aTestData
.
cancelBeforeInput
)
{
is
(
aElement
.
getAttribute
(
"
dir
"
)
null
{
aDescription
}
dir
attribute
of
the
element
shouldn
'
t
have
been
set
by
{
aTestData
.
action
}
)
;
}
else
{
is
(
aElement
.
getAttribute
(
"
dir
"
)
"
rtl
"
{
aDescription
}
dir
attribute
of
the
element
should
'
ve
been
set
to
"
rtl
"
by
{
aTestData
.
action
}
)
;
}
ok
(
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
beforeInputEvent
.
cancelable
true
{
aDescription
}
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
cancelable
)
;
is
(
beforeInputEvent
.
inputType
"
formatSetBlockTextDirection
"
{
aDescription
}
inputType
of
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
"
formatSetBlockTextDirection
"
)
;
is
(
beforeInputEvent
.
data
"
rtl
"
{
aDescription
}
data
of
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
"
rtl
"
)
;
is
(
beforeInputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
if
(
aTestData
.
cancelBeforeInput
)
{
ok
(
!
inputEvent
{
aDescription
}
"
input
"
event
shouldn
'
t
have
been
fired
at
{
aTestData
.
action
}
)
;
return
;
}
ok
(
inputEvent
{
aDescription
}
"
input
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
inputEvent
.
inputType
"
formatSetBlockTextDirection
"
{
aDescription
}
inputType
of
"
input
"
event
for
{
aTestData
.
action
}
should
be
"
formatSetBlockTextDirection
"
)
;
is
(
inputEvent
.
data
"
rtl
"
{
aDescription
}
data
of
"
input
"
event
for
{
aTestData
.
action
}
should
be
"
rtl
"
)
;
is
(
inputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
input
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
inputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
input
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
}
finally
{
aElement
.
removeAttribute
(
"
dir
"
)
;
aElement
.
scrollTop
;
/
/
XXX
Update
the
root
frame
}
}
test_switching_text_direction_from_default
(
{
action
:
'
switching
text
direction
from
default
to
"
rtl
"
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_switching_text_direction_from_default
(
{
action
:
'
switching
text
direction
from
default
to
"
rtl
"
'
cancelBeforeInput
:
false
}
)
;
function
test_switching_text_direction_from_rtl_to_ltr
(
aTestData
)
{
try
{
aElement
.
setAttribute
(
"
dir
"
"
rtl
"
)
;
aElement
.
scrollTop
;
/
/
XXX
Update
the
root
frame
aElement
.
focus
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
beforeInputEvent
=
null
;
inputEvent
=
null
;
action
=
aTestData
.
action
;
SpecialPowers
.
doCommand
(
window
"
cmd_switchTextDirection
"
)
;
let
expectedDirValue
=
aTestData
.
cancelBeforeInput
?
"
rtl
"
:
"
ltr
"
;
is
(
aElement
.
getAttribute
(
"
dir
"
)
expectedDirValue
{
aDescription
}
dir
attribute
of
the
element
should
be
"
{
expectedDirValue
}
"
after
{
aTestData
.
action
}
)
;
ok
(
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
beforeInputEvent
.
cancelable
true
{
aDescription
}
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
cancelable
)
;
is
(
beforeInputEvent
.
inputType
"
formatSetBlockTextDirection
"
{
aDescription
}
inputType
of
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
"
formatSetBlockTextDirection
"
)
;
is
(
beforeInputEvent
.
data
"
ltr
"
{
aDescription
}
data
of
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
"
ltr
"
)
;
is
(
beforeInputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
beforeinput
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
beforeInputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
if
(
aTestData
.
cancelBeforeInput
)
{
ok
(
!
inputEvent
{
aDescription
}
"
input
"
event
shouldn
'
t
have
been
fired
at
{
aTestData
.
action
}
)
;
return
;
}
ok
(
inputEvent
{
aDescription
}
"
input
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
inputEvent
.
inputType
"
formatSetBlockTextDirection
"
{
aDescription
}
inputType
of
"
input
"
event
for
{
aTestData
.
action
}
should
be
"
formatSetBlockTextDirection
"
)
;
is
(
inputEvent
.
data
"
ltr
"
{
aDescription
}
data
of
"
input
"
event
for
{
aTestData
.
action
}
should
be
"
ltr
"
)
;
is
(
inputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
input
"
event
for
{
aTestData
.
action
}
should
be
null
)
;
is
(
inputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
input
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
}
finally
{
aElement
.
removeAttribute
(
"
dir
"
)
;
aElement
.
scrollTop
;
/
/
XXX
Update
the
root
frame
}
}
test_switching_text_direction_from_rtl_to_ltr
(
{
action
:
'
switching
text
direction
from
"
rtl
"
to
"
ltr
"
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_switching_text_direction_from_rtl_to_ltr
(
{
action
:
'
switching
text
direction
from
"
rtl
"
to
"
ltr
"
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
false
}
)
;
aElement
.
removeEventListener
(
"
beforeinput
"
beforeInputHandler
true
)
;
aElement
.
removeEventListener
(
"
input
"
inputHandler
true
)
;
}
doTests
(
document
.
getElementById
(
"
input
"
)
"
<
input
type
=
\
"
text
\
"
>
"
false
)
;
doTests
(
document
.
getElementById
(
"
textarea
"
)
"
<
textarea
>
"
true
)
;
SimpleTest
.
finish
(
)
;
}
<
/
script
>
<
/
body
>
<
/
html
>
