<
html
>
<
head
>
<
title
>
Test
for
input
event
of
text
editor
<
/
title
>
<
script
src
=
"
/
tests
/
SimpleTest
/
SimpleTest
.
js
"
>
<
/
script
>
<
script
src
=
"
/
tests
/
SimpleTest
/
EventUtils
.
js
"
>
<
/
script
>
<
link
rel
=
"
stylesheet
"
type
=
"
text
/
css
"
href
=
"
/
tests
/
SimpleTest
/
test
.
css
"
/
>
<
/
head
>
<
body
>
<
div
id
=
"
display
"
>
<
iframe
id
=
"
editor1
"
srcdoc
=
"
<
html
>
<
body
contenteditable
id
=
'
eventTarget
'
>
<
/
body
>
<
/
html
>
"
>
<
/
iframe
>
<
iframe
id
=
"
editor2
"
srcdoc
=
"
<
html
contenteditable
id
=
'
eventTarget
'
>
<
body
>
<
/
body
>
<
/
html
>
"
>
<
/
iframe
>
<
iframe
id
=
"
editor3
"
srcdoc
=
"
<
html
>
<
body
>
<
div
contenteditable
id
=
'
eventTarget
'
>
<
/
div
>
<
/
body
>
<
/
html
>
"
>
<
/
iframe
>
<
iframe
id
=
"
editor4
"
srcdoc
=
"
<
html
contenteditable
id
=
'
eventTarget
'
>
<
body
>
<
div
contenteditable
>
<
/
div
>
<
/
body
>
<
/
html
>
"
>
<
/
iframe
>
<
iframe
id
=
"
editor5
"
srcdoc
=
"
<
html
>
<
body
id
=
'
eventTarget
'
>
<
/
body
>
<
script
>
document
.
designMode
=
'
on
'
;
<
/
script
>
<
/
html
>
"
>
<
/
iframe
>
<
/
div
>
<
div
id
=
"
content
"
style
=
"
display
:
none
"
>
<
/
div
>
<
pre
id
=
"
test
"
>
<
/
pre
>
<
script
class
=
"
testbody
"
type
=
"
application
/
javascript
"
>
"
use
strict
"
;
SimpleTest
.
waitForExplicitFinish
(
)
;
SimpleTest
.
waitForFocus
(
runTests
window
)
;
const
kIsWin
=
navigator
.
platform
.
indexOf
(
"
Win
"
)
=
=
0
;
const
kIsMac
=
navigator
.
platform
.
indexOf
(
"
Mac
"
)
=
=
0
;
async
function
runTests
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
input_events
.
beforeinput
.
enabled
"
true
]
]
}
)
;
const
kWordSelectEatSpaceToNextWord
=
SpecialPowers
.
getBoolPref
(
"
layout
.
word_select
.
eat_space_to_next_word
"
)
;
const
kImgURL
=
"
data
:
image
/
png
;
base64
iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAYAAABytg0kAAAAEElEQVR42mNgaGD4D8YwBgAw9AX9Y9zBwwAAAABJRU5ErkJggg
=
=
"
;
/
/
eslint
-
disable
-
next
-
line
complexity
function
doTests
(
aDocument
aWindow
aDescription
)
{
aDescription
+
=
"
:
"
;
aWindow
.
focus
(
)
;
let
body
=
aDocument
.
body
;
let
selection
=
aWindow
.
getSelection
(
)
;
function
getHTMLEditor
(
)
{
let
editingSession
=
SpecialPowers
.
wrap
(
aWindow
)
.
docShell
.
editingSession
;
if
(
!
editingSession
)
{
return
null
;
}
let
editor
=
editingSession
.
getEditorForWindow
(
aWindow
)
;
if
(
!
editor
)
{
return
null
;
}
return
editor
.
QueryInterface
(
SpecialPowers
.
Ci
.
nsIHTMLEditor
)
;
}
let
htmlEditor
=
getHTMLEditor
(
)
;
let
eventTarget
=
aDocument
.
getElementById
(
"
eventTarget
"
)
;
/
/
The
event
target
must
be
focusable
because
it
'
s
the
editing
host
.
eventTarget
.
focus
(
)
;
let
editTarget
=
aDocument
.
getElementById
(
"
editTarget
"
)
;
if
(
!
editTarget
)
{
editTarget
=
eventTarget
;
}
/
/
Root
element
never
can
be
edit
target
.
If
the
editTarget
is
the
root
/
/
element
replace
with
its
body
.
let
isEditTargetIsDescendantOfEditingHost
=
false
;
if
(
editTarget
=
=
aDocument
.
documentElement
)
{
editTarget
=
body
;
isEditTargetIsDescendantOfEditingHost
=
true
;
}
editTarget
.
innerHTML
=
"
"
;
/
/
If
the
editTarget
isn
'
t
its
editing
host
move
caret
to
the
start
of
it
.
if
(
eventTarget
!
=
editTarget
)
{
aDocument
.
getSelection
(
)
.
collapse
(
editTarget
0
)
;
}
let
initializing
=
false
;
let
beforeInputEvent
=
null
;
let
inputEvent
=
null
;
let
selectionRanges
=
[
]
;
function
reset
(
)
{
beforeInputEvent
=
null
;
inputEvent
=
null
;
selectionRanges
=
[
]
;
}
let
cancelBeforeInput
=
false
;
let
action
=
"
"
;
let
beforeInputHandler
=
(
aEvent
)
=
>
{
if
(
initializing
)
{
return
;
}
if
(
cancelBeforeInput
)
{
aEvent
.
preventDefault
(
)
;
}
ok
(
!
beforeInputEvent
{
aDescription
}
Multiple
"
beforeinput
"
events
are
fired
at
{
action
}
(
inputType
:
"
{
aEvent
.
inputType
}
"
data
:
{
aEvent
.
data
}
)
)
;
ok
(
aEvent
.
isTrusted
{
aDescription
}
"
beforeinput
"
event
at
{
action
}
must
be
trusted
)
;
is
(
aEvent
.
target
eventTarget
{
aDescription
}
"
beforeinput
"
event
at
{
action
}
is
fired
on
unexpected
element
:
{
aEvent
.
target
.
tagName
}
)
;
ok
(
aEvent
instanceof
InputEvent
{
aDescription
}
"
beforeinput
"
event
at
{
action
}
should
be
dispatched
with
InputEvent
interface
)
;
ok
(
aEvent
.
bubbles
{
aDescription
}
"
beforeinput
"
event
at
{
action
}
must
be
bubbles
)
;
beforeInputEvent
=
aEvent
;
selectionRanges
=
[
]
;
for
(
let
i
=
0
;
i
<
selection
.
rangeCount
;
i
+
+
)
{
let
range
=
selection
.
getRangeAt
(
i
)
;
selectionRanges
.
push
(
{
startContainer
:
range
.
startContainer
startOffset
:
range
.
startOffset
endContainer
:
range
.
endContainer
endOffset
:
range
.
endOffset
}
)
;
}
}
;
let
inputHandler
=
(
aEvent
)
=
>
{
if
(
initializing
)
{
return
;
}
ok
(
!
inputEvent
{
aDescription
}
Multiple
"
input
"
events
are
fired
at
{
action
}
(
inputType
:
"
{
aEvent
.
inputType
}
"
data
:
{
aEvent
.
data
}
)
)
;
ok
(
aEvent
.
isTrusted
{
aDescription
}
"
input
"
event
at
{
action
}
must
be
trusted
)
;
is
(
aEvent
.
target
eventTarget
{
aDescription
}
"
input
"
event
at
{
action
}
is
fired
on
unexpected
element
:
{
aEvent
.
target
.
tagName
}
)
;
ok
(
aEvent
instanceof
InputEvent
{
aDescription
}
"
input
"
event
at
{
action
}
should
be
dispatched
with
InputEvent
interface
)
;
ok
(
!
aEvent
.
cancelable
{
aDescription
}
"
input
"
event
at
{
action
}
must
not
be
cancelable
)
;
ok
(
aEvent
.
bubbles
{
aDescription
}
"
input
"
event
at
{
action
}
must
be
bubbles
)
;
let
duration
=
Math
.
abs
(
window
.
performance
.
now
(
)
-
aEvent
.
timeStamp
)
;
ok
(
duration
<
30
*
1000
{
aDescription
}
perhaps
timestamp
wasn
'
t
set
correctly
:
{
aEvent
.
timeStamp
}
(
expected
it
to
be
within
30s
of
+
the
current
time
but
it
differed
by
{
duration
}
ms
)
)
;
inputEvent
=
aEvent
;
}
;
/
*
*
*
Helper
methods
to
very
editor
value
beforeinput
event
and
input
event
.
*
*
param
aTestData
The
test
data
to
verify
.
*
param
aExpectedInnerHTML
*
Set
string
value
if
the
test
needs
to
check
editTarget
.
innerHTML
.
*
Set
undefined
if
the
test
does
not
need
to
check
it
.
*
param
aExpectedBeforeInputEvent
*
Set
object
which
has
cancelable
inputType
data
and
*
targetRanges
if
a
"
beforeinput
"
event
should
be
fired
.
*
If
getTargetRanges
(
)
should
return
same
array
as
selection
when
*
the
beforeinput
event
is
dispatched
set
targetRanges
to
*
kSameAsSelection
.
*
Set
null
if
"
beforeinput
"
event
shouldn
'
t
be
fired
.
*
param
aExpectedInputEvent
*
Set
object
which
has
inputType
and
data
if
an
"
input
"
event
*
should
be
fired
if
aTestData
.
cancelBeforeInput
is
not
true
.
*
Set
null
if
"
input
"
event
shouldn
'
t
be
fired
.
*
Note
that
if
expected
"
beforeinput
"
event
is
cancelable
and
*
aTestData
.
cancelBeforeInput
is
true
this
is
ignored
.
*
/
const
kSameAsSelection
=
"
same
as
selection
"
;
function
verify
(
aTestData
aExpectedInnerHTML
aExpectedBeforeInputEvent
aExpectedInputEvent
)
{
try
{
function
checkTargetRanges
(
aEvent
aTargetRanges
)
{
let
targetRanges
=
aEvent
.
getTargetRanges
(
)
;
if
(
aTargetRanges
.
length
=
=
=
0
)
{
is
(
targetRanges
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
{
aEvent
.
type
}
"
event
for
{
aTestData
.
action
}
should
return
empty
array
)
;
return
;
}
is
(
targetRanges
.
length
aTargetRanges
.
length
{
aDescription
}
getTargetRanges
(
)
of
"
{
aEvent
.
type
}
"
event
for
{
aTestData
.
action
}
should
return
array
of
static
range
)
;
if
(
targetRanges
.
length
!
=
=
aTargetRanges
.
length
)
{
return
;
}
for
(
let
i
=
0
;
i
<
aTargetRanges
.
length
;
i
+
+
)
{
is
(
targetRanges
[
i
]
.
startContainer
aTargetRanges
[
i
]
.
startContainer
{
aDescription
}
startContainer
of
getTargetRanges
(
)
[
{
i
}
]
of
"
{
aEvent
.
type
}
"
event
for
{
aTestData
.
action
}
does
not
match
)
;
is
(
targetRanges
[
i
]
.
startOffset
aTargetRanges
[
i
]
.
startOffset
{
aDescription
}
startOffset
of
getTargetRanges
(
)
[
{
i
}
]
of
"
{
aEvent
.
type
}
"
event
for
{
aTestData
.
action
}
does
not
match
)
;
is
(
targetRanges
[
i
]
.
endContainer
aTargetRanges
[
i
]
.
endContainer
{
aDescription
}
endContainer
of
getTargetRanges
(
)
[
{
i
}
]
of
"
{
aEvent
.
type
}
"
event
for
{
aTestData
.
action
}
does
not
match
)
;
is
(
targetRanges
[
i
]
.
endOffset
aTargetRanges
[
i
]
.
endOffset
{
aDescription
}
endOffset
of
getTargetRanges
(
)
[
{
i
}
]
of
"
{
aEvent
.
type
}
"
event
for
{
aTestData
.
action
}
does
not
match
)
;
}
}
if
(
aExpectedInnerHTML
!
=
=
undefined
)
{
is
(
editTarget
.
innerHTML
aExpectedInnerHTML
{
aDescription
}
innerHTML
should
be
"
{
aExpectedInnerHTML
}
"
after
{
aTestData
.
action
}
)
;
}
if
(
aExpectedBeforeInputEvent
=
=
=
null
|
|
aExpectedBeforeInputEvent
=
=
=
undefined
)
{
ok
(
!
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
shouldn
'
t
have
been
fired
at
{
aTestData
.
action
}
)
;
}
else
{
ok
(
beforeInputEvent
{
aDescription
}
"
beforeinput
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
beforeInputEvent
.
cancelable
aExpectedBeforeInputEvent
.
cancelable
{
aDescription
}
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
be
{
aExpectedBeforeInputEvent
.
cancelable
?
"
cancelable
"
:
"
not
cancelable
"
}
)
;
is
(
beforeInputEvent
.
inputType
aExpectedBeforeInputEvent
.
inputType
{
aDescription
}
inputType
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
be
"
{
aExpectedBeforeInputEvent
.
inputType
}
"
)
;
is
(
beforeInputEvent
.
data
aExpectedBeforeInputEvent
.
data
{
aDescription
}
data
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
be
{
aExpectedBeforeInputEvent
.
data
=
=
=
null
?
"
null
"
:
"
{
aExpectedBeforeInputEvent
.
data
}
"
}
)
;
is
(
beforeInputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
beforeinput
"
event
by
{
aTestData
.
action
}
should
be
null
)
;
checkTargetRanges
(
beforeInputEvent
aExpectedBeforeInputEvent
.
targetRanges
=
=
=
kSameAsSelection
?
selectionRanges
:
aExpectedBeforeInputEvent
.
targetRanges
)
;
}
if
(
(
aTestData
.
cancelBeforeInput
=
=
=
true
&
&
aExpectedBeforeInputEvent
&
&
aExpectedBeforeInputEvent
.
cancelable
)
|
|
aExpectedInputEvent
=
=
=
null
|
|
aExpectedInputEvent
=
=
=
undefined
)
{
ok
(
!
inputEvent
{
aDescription
}
"
input
"
event
shouldn
'
t
have
been
fired
at
{
aTestData
.
action
}
)
;
}
else
{
ok
(
inputEvent
{
aDescription
}
"
input
"
event
should
'
ve
been
fired
at
{
aTestData
.
action
}
)
;
is
(
inputEvent
.
cancelable
false
{
aDescription
}
"
input
"
event
by
{
aTestData
.
action
}
should
be
not
be
cancelable
)
;
is
(
inputEvent
.
inputType
aExpectedInputEvent
.
inputType
{
aDescription
}
inputType
of
"
input
"
event
by
{
aTestData
.
action
}
should
be
"
{
aExpectedInputEvent
.
inputType
}
"
)
;
is
(
inputEvent
.
data
aExpectedInputEvent
.
data
{
aDescription
}
data
of
"
input
"
event
by
{
aTestData
.
action
}
should
be
{
aExpectedInputEvent
.
data
=
=
=
null
?
"
null
"
:
"
{
aExpectedInputEvent
.
data
}
"
}
)
;
is
(
inputEvent
.
dataTransfer
null
{
aDescription
}
dataTransfer
of
"
input
"
event
by
{
aTestData
.
action
}
should
be
null
)
;
is
(
inputEvent
.
getTargetRanges
(
)
.
length
0
{
aDescription
}
getTargetRanges
(
)
of
"
input
"
event
by
{
aTestData
.
action
}
should
return
empty
array
)
;
}
return
true
;
}
catch
(
ex
)
{
ok
(
false
{
aDescription
}
unexpected
exception
at
verifying
test
result
of
"
{
aTestData
.
action
}
"
:
{
ex
.
toString
(
)
}
)
;
return
false
;
}
}
aWindow
.
addEventListener
(
"
beforeinput
"
beforeInputHandler
true
)
;
aWindow
.
addEventListener
(
"
input
"
inputHandler
true
)
;
(
function
test_typing_a_in_empty_editor
(
aTestData
)
{
editTarget
.
innerHTML
=
"
"
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
a
"
{
}
aWindow
)
;
ok
(
!
aTestData
.
cancelBeforeInput
{
aDescription
}
cancelBeforeInput
must
not
be
true
for
{
aTestData
.
action
}
)
;
verify
(
aTestData
"
a
"
{
cancelable
:
true
inputType
:
"
insertText
"
data
:
"
a
"
targetRanges
:
kSameAsSelection
}
{
inputType
:
"
insertText
"
data
:
"
a
"
}
)
;
}
)
(
{
action
:
'
typing
"
a
"
in
empty
editor
'
}
)
;
function
test_typing_b_at_end_of_editor
(
aTestData
)
{
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
editTarget
.
innerHTML
=
"
a
"
;
selection
.
collapse
(
editTarget
.
firstChild
1
)
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
b
"
{
}
aWindow
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
"
a
"
:
"
ab
"
{
cancelable
:
true
inputType
:
"
insertText
"
data
:
"
b
"
targetRanges
:
kSameAsSelection
}
{
inputType
:
"
insertText
"
data
:
"
b
"
}
)
;
}
test_typing_b_at_end_of_editor
(
{
action
:
'
typing
"
b
"
after
"
a
"
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_typing_b_at_end_of_editor
(
{
action
:
'
typing
"
b
"
after
"
a
"
'
cancelBeforeInput
:
false
}
)
;
function
test_typing_backspace_to_delete_last_character
(
aTestData
)
{
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
editTarget
.
innerHTML
=
"
a
"
;
let
textNode
=
editTarget
.
firstChild
;
selection
.
collapse
(
textNode
1
)
;
synthesizeKey
(
"
KEY_Backspace
"
{
}
aWindow
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
"
a
"
:
"
<
br
>
"
{
cancelable
:
true
inputType
:
"
deleteContentBackward
"
data
:
null
targetRanges
:
[
{
startContainer
:
textNode
startOffset
:
0
endContainer
:
textNode
endOffset
:
1
}
]
}
{
inputType
:
"
deleteContentBackward
"
data
:
null
}
)
;
}
test_typing_backspace_to_delete_last_character
(
{
action
:
'
typing
"
Backspace
"
to
delete
the
last
character
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_typing_backspace_to_delete_last_character
(
{
action
:
'
typing
"
Backspace
"
to
delete
the
last
character
'
cancelBeforeInput
:
false
}
)
;
(
function
test_typing_backspace_in_empty_editor
(
aTestData
)
{
editTarget
.
innerHTML
=
"
"
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
KEY_Backspace
"
{
}
aWindow
)
;
ok
(
!
aTestData
.
cancelBeforeInput
{
aDescription
}
cancelBeforeInput
must
not
be
true
for
{
aTestData
.
action
}
)
;
verify
(
aTestData
editTarget
.
tagName
=
=
=
"
DIV
"
?
"
"
:
"
<
br
>
"
{
cancelable
:
true
inputType
:
"
deleteContentBackward
"
data
:
null
targetRanges
:
kSameAsSelection
}
null
)
;
}
)
(
{
action
:
'
typing
"
Backspace
"
in
empty
editor
'
}
)
;
function
test_typing_enter_at_end_of_editor
(
aTestData
)
{
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
editTarget
.
innerHTML
=
"
B
"
;
selection
.
collapse
(
editTarget
.
firstChild
1
)
;
synthesizeKey
(
"
KEY_Enter
"
{
}
aWindow
)
;
let
expectedValue
=
(
function
(
)
{
if
(
aTestData
.
cancelBeforeInput
)
{
return
"
B
"
;
}
/
/
XXX
Perhaps
this
is
a
bug
since
we
shouldn
'
t
change
behavior
when
contenteditable
element
is
<
html
>
or
<
body
>
.
return
!
isEditTargetIsDescendantOfEditingHost
?
"
<
div
>
B
<
/
div
>
<
div
>
<
br
>
<
/
div
>
"
:
"
B
<
br
>
<
br
>
"
;
}
)
(
)
;
verify
(
aTestData
expectedValue
{
cancelable
:
true
inputType
:
"
insertParagraph
"
data
:
null
targetRanges
:
kSameAsSelection
}
{
inputType
:
"
insertParagraph
"
data
:
null
}
)
;
}
test_typing_enter_at_end_of_editor
(
{
action
:
'
typing
"
Enter
"
at
end
of
editor
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_typing_enter_at_end_of_editor
(
{
action
:
'
typing
"
Enter
"
at
end
of
editor
'
cancelBeforeInput
:
false
}
)
;
function
test_typing_C_in_empty_last_line
(
aTestData
)
{
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
if
(
!
isEditTargetIsDescendantOfEditingHost
)
{
editTarget
.
innerHTML
=
"
<
div
>
B
<
/
div
>
<
div
>
<
br
>
<
/
div
>
"
;
selection
.
collapse
(
editTarget
.
querySelector
(
"
div
+
div
"
)
0
)
;
}
else
{
editTarget
.
innerHTML
=
"
B
<
br
>
<
br
>
"
;
selection
.
collapse
(
editTarget
2
)
;
}
synthesizeKey
(
"
C
"
{
shiftKey
:
true
}
aWindow
)
;
let
expectedValue
=
(
function
(
)
{
if
(
!
isEditTargetIsDescendantOfEditingHost
)
{
return
aTestData
.
cancelBeforeInput
?
"
<
div
>
B
<
/
div
>
<
div
>
<
br
>
<
/
div
>
"
:
"
<
div
>
B
<
/
div
>
<
div
>
C
<
br
>
<
/
div
>
"
;
}
return
aTestData
.
cancelBeforeInput
?
"
B
<
br
>
<
br
>
"
:
"
B
<
br
>
C
<
br
>
"
;
}
)
(
)
;
verify
(
aTestData
expectedValue
{
cancelable
:
true
inputType
:
"
insertText
"
data
:
"
C
"
targetRanges
:
kSameAsSelection
}
{
inputType
:
"
insertText
"
data
:
"
C
"
}
)
;
}
test_typing_C_in_empty_last_line
(
{
action
:
'
typing
"
C
"
in
empty
last
line
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_typing_C_in_empty_last_line
(
{
action
:
'
typing
"
C
"
in
empty
last
line
'
cancelBeforeInput
:
false
}
)
;
function
test_typing_enter_in_non_empty_last_line
(
aTestData
)
{
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
if
(
!
isEditTargetIsDescendantOfEditingHost
)
{
editTarget
.
innerHTML
=
"
<
div
>
B
<
/
div
>
<
div
>
C
<
br
>
<
/
div
>
"
;
selection
.
collapse
(
editTarget
.
querySelector
(
"
div
+
div
"
)
.
firstChild
1
)
;
}
else
{
editTarget
.
innerHTML
=
"
B
<
br
>
C
<
br
>
"
;
selection
.
collapse
(
editTarget
.
querySelector
(
"
br
"
)
.
nextSibling
1
)
;
}
synthesizeKey
(
"
KEY_Enter
"
{
}
aWindow
)
;
let
expectedValue
=
(
function
(
)
{
if
(
!
isEditTargetIsDescendantOfEditingHost
)
{
return
aTestData
.
cancelBeforeInput
?
"
<
div
>
B
<
/
div
>
<
div
>
C
<
br
>
<
/
div
>
"
:
"
<
div
>
B
<
/
div
>
<
div
>
C
<
/
div
>
<
div
>
<
br
>
<
/
div
>
"
;
}
return
aTestData
.
cancelBeforeInput
?
"
B
<
br
>
C
<
br
>
"
:
"
B
<
br
>
C
<
br
>
<
br
>
"
;
}
)
(
)
;
verify
(
aTestData
expectedValue
{
cancelable
:
true
inputType
:
"
insertParagraph
"
data
:
null
targetRanges
:
kSameAsSelection
}
{
inputType
:
"
insertParagraph
"
data
:
null
}
)
;
}
test_typing_enter_in_non_empty_last_line
(
{
action
:
'
typing
"
Enter
"
at
end
of
non
-
empty
line
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_typing_enter_in_non_empty_last_line
(
{
action
:
'
typing
"
Enter
"
at
end
of
non
-
empty
line
'
cancelBeforeInput
:
false
}
)
;
(
function
test_setting_innerHTML
(
aTestData
)
{
initializing
=
true
;
editTarget
.
innerHTML
=
"
"
;
initializing
=
false
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
reset
(
)
;
editTarget
.
innerHTML
=
"
foo
-
bar
"
;
verify
(
aTestData
"
foo
-
bar
"
null
null
)
;
}
)
(
{
action
:
"
setting
innerHTML
to
non
-
empty
value
"
}
)
;
(
function
test_setting_innerHTML_to_empty
(
aTestData
)
{
initializing
=
true
;
editTarget
.
innerHTML
=
"
foo
-
bar
"
;
initializing
=
false
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
reset
(
)
;
editTarget
.
innerHTML
=
"
"
;
verify
(
aTestData
editTarget
.
tagName
=
=
=
"
DIV
"
?
"
"
:
"
<
br
>
"
null
null
)
;
}
)
(
{
action
:
"
setting
innerHTML
to
empty
value
"
}
)
;
function
test_typing_white_space_in_empty_editor
(
aTestData
)
{
reset
(
)
;
editTarget
.
innerHTML
=
"
"
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
"
{
}
aWindow
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
"
"
:
"
&
nbsp
;
"
{
cancelable
:
true
inputType
:
"
insertText
"
data
:
"
"
targetRanges
:
kSameAsSelection
}
{
inputType
:
"
insertText
"
data
:
"
"
}
)
;
}
test_typing_white_space_in_empty_editor
(
{
action
:
'
typing
space
in
empty
editor
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_typing_white_space_in_empty_editor
(
{
action
:
"
typing
space
in
empty
editor
"
cancelBeforeInput
:
false
}
)
;
(
function
test_typing_delete_at_end_of_editor
(
aTestData
)
{
initializing
=
true
;
editTarget
.
innerHTML
=
"
&
nbsp
;
"
;
selection
.
collapse
(
editTarget
.
firstChild
1
)
;
initializing
=
false
;
reset
(
)
;
action
=
aTestData
.
action
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
synthesizeKey
(
"
KEY_Delete
"
{
}
aWindow
)
;
ok
(
!
aTestData
.
cancelBeforeInput
{
aDescription
}
cancelBeforeInput
must
not
be
true
for
{
aTestData
.
action
}
)
;
verify
(
aTestData
"
&
nbsp
;
"
{
cancelable
:
true
inputType
:
"
deleteContentForward
"
data
:
null
targetRanges
:
kSameAsSelection
}
null
)
;
}
)
(
{
action
:
'
typing
"
Delete
"
at
end
of
editor
'
}
)
;
(
function
test_typing_arrow_left_to_move_caret
(
aTestData
)
{
initializing
=
true
;
editTarget
.
innerHTML
=
"
&
nbsp
;
"
;
selection
.
collapse
(
editTarget
.
firstChild
1
)
;
initializing
=
false
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
KEY_ArrowLeft
"
{
}
aWindow
)
;
verify
(
aTestData
"
&
nbsp
;
"
null
null
)
;
}
)
(
{
action
:
'
typing
"
ArrowLeft
"
to
move
caret
'
}
)
;
function
test_typing_delete_to_delete_last_character
(
aTestData
)
{
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
editTarget
.
innerHTML
=
"
\
u00A0
"
;
let
textNode
=
editTarget
.
firstChild
;
selection
.
collapse
(
textNode
0
)
;
synthesizeKey
(
"
KEY_Delete
"
{
}
aWindow
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
"
&
nbsp
;
"
:
"
<
br
>
"
{
cancelable
:
true
inputType
:
"
deleteContentForward
"
data
:
null
targetRanges
:
[
{
startContainer
:
textNode
startOffset
:
0
endContainer
:
textNode
endOffset
:
1
}
]
}
{
inputType
:
"
deleteContentForward
"
data
:
null
}
)
;
}
test_typing_delete_to_delete_last_character
(
{
action
:
'
typing
"
Delete
"
to
delete
last
character
(
NBSP
)
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_typing_delete_to_delete_last_character
(
{
action
:
'
typing
"
Delete
"
to
delete
last
character
(
NBSP
)
'
cancelBeforeInput
:
false
}
)
;
function
test_undoing_deleting_last_character
(
aTestData
)
{
reset
(
)
;
initializing
=
true
;
editTarget
.
innerHTML
=
"
\
u00A0
"
;
selection
.
collapse
(
editTarget
.
firstChild
0
)
;
synthesizeKey
(
"
KEY_Delete
"
{
}
aWindow
)
;
initializing
=
false
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
z
"
{
accelKey
:
true
}
aWindow
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
"
<
br
>
"
:
"
&
nbsp
;
"
{
cancelable
:
true
inputType
:
"
historyUndo
"
data
:
null
targetRanges
:
[
]
}
{
inputType
:
"
historyUndo
"
data
:
null
}
)
;
}
test_undoing_deleting_last_character
(
{
action
:
'
undoing
deleting
last
character
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_undoing_deleting_last_character
(
{
action
:
'
undoing
deleting
last
character
'
cancelBeforeInput
:
false
}
)
;
(
function
test_undoing_without_undoable_transaction
(
aTestData
)
{
reset
(
)
;
initializing
=
true
;
htmlEditor
.
enableUndo
(
false
)
;
htmlEditor
.
enableUndo
(
true
)
;
editTarget
.
innerHTML
=
"
\
u00A0
"
;
selection
.
collapse
(
editTarget
.
firstChild
0
)
;
synthesizeKey
(
"
KEY_Delete
"
{
}
aWindow
)
;
synthesizeKey
(
"
z
"
{
accelKey
:
true
}
aWindow
)
;
initializing
=
false
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
z
"
{
accelKey
:
true
}
aWindow
)
;
verify
(
aTestData
"
&
nbsp
;
"
null
null
)
;
}
)
(
{
action
:
"
trying
to
undo
without
undoable
transaction
"
}
)
;
function
test_redoing_deleting_last_character
(
aTestData
)
{
reset
(
)
;
initializing
=
true
;
htmlEditor
.
enableUndo
(
false
)
;
htmlEditor
.
enableUndo
(
true
)
;
editTarget
.
innerHTML
=
"
\
u00A0
"
;
selection
.
collapse
(
editTarget
.
firstChild
0
)
;
synthesizeKey
(
"
KEY_Delete
"
{
}
aWindow
)
;
synthesizeKey
(
"
z
"
{
accelKey
:
true
}
aWindow
)
;
initializing
=
false
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
z
"
{
accelKey
:
true
shiftKey
:
true
}
aWindow
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
"
&
nbsp
;
"
:
"
<
br
>
"
{
cancelable
:
true
inputType
:
"
historyRedo
"
data
:
null
targetRanges
:
[
]
}
{
inputType
:
"
historyRedo
"
data
:
null
}
)
;
}
test_redoing_deleting_last_character
(
{
action
:
'
redoing
deleting
last
character
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_redoing_deleting_last_character
(
{
action
:
'
redoing
deleting
last
character
'
cancelBeforeInput
:
false
}
)
;
(
function
test_redoing_without_redoable_transaction
(
aTestData
)
{
reset
(
)
;
initializing
=
true
;
htmlEditor
.
enableUndo
(
false
)
;
htmlEditor
.
enableUndo
(
true
)
;
editTarget
.
innerHTML
=
"
\
u00A0
"
;
selection
.
collapse
(
editTarget
.
firstChild
0
)
;
synthesizeKey
(
"
KEY_Delete
"
{
}
aWindow
)
;
synthesizeKey
(
"
z
"
{
accelKey
:
true
}
aWindow
)
;
synthesizeKey
(
"
z
"
{
accelKey
:
true
shiftKey
:
true
}
aWindow
)
;
initializing
=
false
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
z
"
{
accelKey
:
true
shiftKey
:
true
}
aWindow
)
;
ok
(
!
aTestData
.
cancelBeforeInput
{
aDescription
}
cancelBeforeInput
must
not
be
true
for
{
aTestData
.
action
}
)
;
verify
(
aTestData
"
<
br
>
"
null
null
)
;
}
)
(
{
action
:
"
trying
to
redo
without
redoable
transaction
"
}
)
;
function
test_inserting_linebreak
(
aTestData
)
{
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
editTarget
.
innerHTML
=
"
<
br
>
"
;
selection
.
collapse
(
editTarget
0
)
;
synthesizeKey
(
"
KEY_Enter
"
{
shiftKey
:
true
}
aWindow
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
"
<
br
>
"
:
"
<
br
>
<
br
>
"
{
cancelable
:
true
inputType
:
"
insertLineBreak
"
data
:
null
targetRanges
:
kSameAsSelection
}
{
inputType
:
"
insertLineBreak
"
data
:
null
}
)
;
}
test_inserting_linebreak
(
{
action
:
'
inserting
a
linebreak
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_inserting_linebreak
(
{
action
:
"
inserting
a
linebreak
"
cancelBeforeInput
:
false
}
)
;
function
test_typing_backspace_to_delete_selected_characters
(
aTestData
)
{
editTarget
.
innerHTML
=
"
a
"
;
editTarget
.
focus
(
)
;
selection
.
selectAllChildren
(
editTarget
)
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
let
expectedTargetRanges
=
[
{
startContainer
:
editTarget
.
firstChild
startOffset
:
0
endContainer
:
editTarget
.
firstChild
endOffset
:
editTarget
.
firstChild
.
length
}
]
;
synthesizeKey
(
"
KEY_Backspace
"
{
}
aWindow
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
"
a
"
:
"
<
br
>
"
{
cancelable
:
true
inputType
:
"
deleteContentBackward
"
data
:
null
targetRanges
:
expectedTargetRanges
}
{
inputType
:
"
deleteContentBackward
"
data
:
null
}
)
;
}
test_typing_backspace_to_delete_selected_characters
(
{
action
:
'
typing
"
Backspace
"
to
delete
selected
characters
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_typing_backspace_to_delete_selected_characters
(
{
action
:
'
typing
"
Backspace
"
to
delete
selected
characters
'
cancelBeforeInput
:
false
}
)
;
function
test_typing_delete_to_delete_selected_characters
(
aTestData
)
{
editTarget
.
innerHTML
=
"
a
"
;
editTarget
.
focus
(
)
;
selection
.
selectAllChildren
(
editTarget
)
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
let
expectedTargetRanges
=
[
{
startContainer
:
editTarget
.
firstChild
startOffset
:
0
endContainer
:
editTarget
.
firstChild
endOffset
:
editTarget
.
firstChild
.
length
}
]
;
synthesizeKey
(
"
KEY_Delete
"
{
}
aWindow
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
"
a
"
:
"
<
br
>
"
{
cancelable
:
true
inputType
:
"
deleteContentForward
"
data
:
null
targetRanges
:
expectedTargetRanges
}
{
inputType
:
"
deleteContentForward
"
data
:
null
}
)
;
}
test_typing_delete_to_delete_selected_characters
(
{
action
:
'
typing
"
Delete
"
to
delete
selected
characters
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_typing_delete_to_delete_selected_characters
(
{
action
:
'
typing
"
Delete
"
to
delete
selected
characters
'
cancelBeforeInput
:
false
}
)
;
function
test_deleting_word_backward_from_its_end
(
aTestData
)
{
editTarget
.
innerHTML
=
"
abc
def
"
;
editTarget
.
focus
(
)
;
let
textNode
=
editTarget
.
firstChild
;
selection
.
collapse
(
textNode
"
abc
def
"
.
length
)
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
let
expectedTargetRanges
=
[
{
startContainer
:
textNode
startOffset
:
"
abc
"
.
length
endContainer
:
textNode
endOffset
:
textNode
.
length
}
]
;
SpecialPowers
.
doCommand
(
aWindow
"
cmd_deleteWordBackward
"
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
"
abc
def
"
:
"
abc
"
{
cancelable
:
true
inputType
:
"
deleteWordBackward
"
data
:
null
targetRanges
:
expectedTargetRanges
}
{
inputType
:
"
deleteWordBackward
"
data
:
null
}
)
;
}
test_deleting_word_backward_from_its_end
(
{
action
:
'
deleting
word
backward
from
its
end
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_deleting_word_backward_from_its_end
(
{
action
:
"
deleting
word
backward
from
its
end
"
cancelBeforeInput
:
false
}
)
;
function
test_deleting_word_forward_from_its_start
(
aTestData
)
{
editTarget
.
innerHTML
=
"
abc
def
"
;
editTarget
.
focus
(
)
;
let
textNode
=
editTarget
.
firstChild
;
selection
.
collapse
(
textNode
0
)
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
let
expectedTargetRanges
=
[
{
startContainer
:
textNode
startOffset
:
0
endContainer
:
textNode
endOffset
:
kWordSelectEatSpaceToNextWord
?
"
abc
"
.
length
:
"
abc
"
.
length
}
]
;
SpecialPowers
.
doCommand
(
aWindow
"
cmd_deleteWordForward
"
)
;
let
expectedValue
=
"
abc
def
"
;
if
(
!
aTestData
.
cancelBeforeInput
)
{
expectedValue
=
kWordSelectEatSpaceToNextWord
?
"
def
"
:
"
def
"
;
}
verify
(
aTestData
expectedValue
{
cancelable
:
true
inputType
:
"
deleteWordForward
"
data
:
null
targetRanges
:
expectedTargetRanges
}
{
inputType
:
"
deleteWordForward
"
data
:
null
}
)
;
}
test_deleting_word_forward_from_its_start
(
{
action
:
'
deleting
word
forward
from
its
start
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_deleting_word_forward_from_its_start
(
{
action
:
"
deleting
word
forward
from
its
start
"
cancelBeforeInput
:
false
}
)
;
(
function
test_deleting_word_backward_from_middle_of_second_word
(
aTestData
)
{
editTarget
.
innerHTML
=
"
abc
def
"
;
editTarget
.
focus
(
)
;
let
textNode
=
editTarget
.
firstChild
;
selection
.
setBaseAndExtent
(
textNode
"
abc
d
"
.
length
textNode
"
abc
de
"
.
length
)
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
let
expectedTargetRanges
=
[
{
startContainer
:
textNode
startOffset
:
kIsWin
?
"
abc
"
.
length
:
"
abc
d
"
.
length
endContainer
:
textNode
endOffset
:
kIsWin
?
"
abc
d
"
.
length
:
"
abc
de
"
.
length
}
]
;
SpecialPowers
.
doCommand
(
aWindow
"
cmd_deleteWordBackward
"
)
;
ok
(
!
aTestData
.
cancelBeforeInput
{
aDescription
}
cancelBeforeInput
must
not
be
true
for
{
aTestData
.
action
}
)
;
/
/
Only
on
Windows
we
collapse
selection
to
start
before
handling
this
command
.
verify
(
aTestData
kIsWin
?
"
abc
ef
"
:
"
abc
df
"
{
cancelable
:
true
inputType
:
kIsWin
?
"
deleteWordBackward
"
:
"
deleteContentBackward
"
data
:
null
targetRanges
:
expectedTargetRanges
}
{
inputType
:
kIsWin
?
"
deleteWordBackward
"
:
"
deleteContentBackward
"
data
:
null
}
)
;
}
)
(
{
action
:
"
removing
characters
backward
from
middle
of
second
word
"
}
)
;
(
function
test_deleting_word_forward_from_middle_of_first_word
(
aTestData
)
{
editTarget
.
innerHTML
=
"
abc
def
"
;
editTarget
.
focus
(
)
;
let
textNode
=
editTarget
.
firstChild
;
selection
.
setBaseAndExtent
(
textNode
"
a
"
.
length
textNode
"
ab
"
.
length
)
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
let
expectedTargetRanges
=
[
{
startContainer
:
textNode
startOffset
:
"
a
"
.
length
endContainer
:
textNode
endOffset
:
(
function
expectedEndOffset
(
)
{
if
(
!
kIsWin
)
{
return
"
ab
"
.
length
;
}
return
kWordSelectEatSpaceToNextWord
?
"
abc
"
.
length
:
"
abc
"
.
length
;
}
)
(
)
}
]
;
SpecialPowers
.
doCommand
(
aWindow
"
cmd_deleteWordForward
"
)
;
ok
(
!
aTestData
.
cancelBeforeInput
{
aDescription
}
cancelBeforeInput
must
not
be
true
for
{
aTestData
.
action
}
)
;
/
/
Only
on
Windows
we
collapse
selection
to
start
before
handling
this
command
.
verify
(
aTestData
(
function
expectedValue
(
)
{
if
(
!
kIsWin
)
{
return
"
ac
def
"
;
}
return
kWordSelectEatSpaceToNextWord
?
"
adef
"
:
"
a
def
"
;
}
)
(
)
{
cancelable
:
true
inputType
:
kIsWin
?
"
deleteWordForward
"
:
"
deleteContentForward
"
data
:
null
targetRanges
:
expectedTargetRanges
}
{
inputType
:
kIsWin
?
"
deleteWordForward
"
:
"
deleteContentForward
"
data
:
null
}
)
;
}
)
(
{
action
:
"
removing
characters
forward
from
middle
of
first
word
"
}
)
;
(
function
test_deleting_characters_backward_to_start_of_line
(
aTestData
)
{
editTarget
.
innerHTML
=
"
abc
def
"
;
editTarget
.
focus
(
)
;
let
textNode
=
editTarget
.
firstChild
;
selection
.
collapse
(
textNode
"
abc
d
"
.
length
)
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
let
expectedTargetRanges
=
[
{
startContainer
:
textNode
startOffset
:
0
endContainer
:
textNode
endOffset
:
"
abc
d
"
.
length
}
]
;
SpecialPowers
.
doCommand
(
aWindow
"
cmd_deleteToBeginningOfLine
"
)
;
ok
(
!
aTestData
.
cancelBeforeInput
{
aDescription
}
cancelBeforeInput
must
not
be
true
for
{
aTestData
.
action
}
)
;
verify
(
aTestData
"
ef
"
{
cancelable
:
true
inputType
:
"
deleteSoftLineBackward
"
data
:
null
targetRanges
:
expectedTargetRanges
}
{
inputType
:
"
deleteSoftLineBackward
"
data
:
null
}
)
;
}
)
(
{
action
:
"
removing
characters
backward
to
start
of
line
"
}
)
;
(
function
test_deleting_characters_forward_to_end_of_line
(
aTestData
)
{
editTarget
.
innerHTML
=
"
abc
def
"
;
editTarget
.
focus
(
)
;
let
textNode
=
editTarget
.
firstChild
;
selection
.
collapse
(
textNode
"
ab
"
.
length
)
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
let
expectedTargetRanges
=
[
{
startContainer
:
textNode
startOffset
:
"
ab
"
.
length
endContainer
:
textNode
endOffset
:
"
abc
def
"
.
length
}
]
;
SpecialPowers
.
doCommand
(
aWindow
"
cmd_deleteToEndOfLine
"
)
;
verify
(
aTestData
"
ab
"
{
cancelable
:
true
inputType
:
"
deleteSoftLineForward
"
data
:
null
targetRanges
:
expectedTargetRanges
}
{
inputType
:
"
deleteSoftLineForward
"
data
:
null
}
)
;
}
)
(
{
action
:
"
removing
characters
forward
to
end
of
line
"
}
)
;
(
function
test_deleting_characters_backward_to_start_of_line_with_non_collapsed_selection
(
aTestData
)
{
editTarget
.
innerHTML
=
"
abc
def
"
;
editTarget
.
focus
(
)
;
let
textNode
=
editTarget
.
firstChild
;
selection
.
setBaseAndExtent
(
textNode
"
abc
d
"
.
length
textNode
"
abc_de
"
.
length
)
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
let
expectedTargetRanges
=
[
{
startContainer
:
textNode
startOffset
:
kIsWin
?
0
:
"
abc
d
"
.
length
endContainer
:
textNode
endOffset
:
kIsWin
?
"
abc
d
"
.
length
:
"
abc
de
"
.
length
}
]
;
SpecialPowers
.
doCommand
(
aWindow
"
cmd_deleteToBeginningOfLine
"
)
;
ok
(
!
aTestData
.
cancelBeforeInput
{
aDescription
}
cancelBeforeInput
must
not
be
true
for
{
aTestData
.
action
}
)
;
/
/
Only
on
Windows
we
collapse
selection
to
start
before
handling
this
command
.
verify
(
aTestData
kIsWin
?
"
ef
"
:
"
abc
df
"
{
cancelable
:
true
inputType
:
kIsWin
?
"
deleteSoftLineBackward
"
:
"
deleteContentBackward
"
data
:
null
targetRanges
:
expectedTargetRanges
}
{
inputType
:
kIsWin
?
"
deleteSoftLineBackward
"
:
"
deleteContentBackward
"
data
:
null
}
)
;
}
)
(
{
action
:
"
removing
characters
backward
to
start
of
line
(
with
selection
in
second
word
)
"
}
)
;
(
function
test_deleting_characters_forward_to_end_of_line_with_non_collapsed_selection
(
aTestData
)
{
editTarget
.
innerHTML
=
"
abc
def
"
;
editTarget
.
focus
(
)
;
let
textNode
=
editTarget
.
firstChild
;
selection
.
setBaseAndExtent
(
textNode
"
a
"
.
length
textNode
"
ab
"
.
length
)
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
let
expectedTargetRanges
=
[
{
startContainer
:
textNode
startOffset
:
"
a
"
.
length
endContainer
:
textNode
endOffset
:
kIsWin
?
"
abc
def
"
.
length
:
"
ab
"
.
length
}
]
;
SpecialPowers
.
doCommand
(
aWindow
"
cmd_deleteToEndOfLine
"
)
;
ok
(
!
aTestData
.
cancelBeforeInput
{
aDescription
}
cancelBeforeInput
must
not
be
true
for
{
aTestData
.
action
}
)
;
/
/
Only
on
Windows
we
collapse
selection
to
start
before
handling
this
command
.
verify
(
aTestData
kIsWin
?
"
a
"
:
"
ac
def
"
{
cancelable
:
true
inputType
:
kIsWin
?
"
deleteSoftLineForward
"
:
"
deleteContentForward
"
data
:
null
targetRanges
:
expectedTargetRanges
}
{
inputType
:
kIsWin
?
"
deleteSoftLineForward
"
:
"
deleteContentForward
"
data
:
null
}
)
;
}
)
(
{
action
:
"
removing
characters
forward
to
end
of
line
(
with
selection
in
second
word
)
"
}
)
;
function
test_switching_text_direction_from_default
(
aTestData
)
{
try
{
body
.
removeAttribute
(
"
dir
"
)
;
htmlEditor
.
flags
&
=
~
SpecialPowers
.
Ci
.
nsIEditor
.
eEditorRightToLeft
;
htmlEditor
.
flags
|
=
SpecialPowers
.
Ci
.
nsIEditor
.
eEditorLeftToRight
;
/
/
XXX
flags
update
is
required
must
be
a
bug
.
aDocument
.
documentElement
.
scrollTop
;
/
/
XXX
Update
the
body
frame
editTarget
.
focus
(
)
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
SpecialPowers
.
doCommand
(
aWindow
"
cmd_switchTextDirection
"
)
;
/
/
XXX
If
editing
host
is
a
descendant
of
<
body
>
this
must
be
a
bug
.
if
(
aTestData
.
cancelBeforeInput
)
{
is
(
body
.
getAttribute
(
"
dir
"
)
null
{
aDescription
}
dir
attribute
of
the
element
shouldn
'
t
have
been
set
by
{
aTestData
.
action
}
)
;
}
else
{
is
(
body
.
getAttribute
(
"
dir
"
)
"
rtl
"
{
aDescription
}
dir
attribute
of
the
element
should
'
ve
been
set
to
"
rtl
"
by
{
aTestData
.
action
}
)
;
}
verify
(
aTestData
undefined
{
cancelable
:
true
inputType
:
"
formatSetBlockTextDirection
"
data
:
"
rtl
"
targetRanges
:
[
]
}
{
inputType
:
"
formatSetBlockTextDirection
"
data
:
"
rtl
"
}
)
;
}
finally
{
body
.
removeAttribute
(
"
dir
"
)
;
htmlEditor
.
flags
&
=
~
SpecialPowers
.
Ci
.
nsIEditor
.
eEditorRightToLeft
;
htmlEditor
.
flags
|
=
SpecialPowers
.
Ci
.
nsIEditor
.
eEditorLeftToRight
;
/
/
XXX
flags
update
is
required
must
be
a
bug
.
aDocument
.
documentElement
.
scrollTop
;
/
/
XXX
Update
the
body
frame
}
}
test_switching_text_direction_from_default
(
{
action
:
'
switching
text
direction
from
default
to
"
rtl
"
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_switching_text_direction_from_default
(
{
action
:
'
switching
text
direction
from
default
to
"
rtl
"
'
cancelBeforeInput
:
false
}
)
;
function
test_switching_text_direction_from_rtl_to_ltr
(
aTestData
)
{
try
{
body
.
setAttribute
(
"
dir
"
"
rtl
"
)
;
htmlEditor
.
flags
&
=
~
SpecialPowers
.
Ci
.
nsIEditor
.
eEditorLeftToRight
;
htmlEditor
.
flags
|
=
SpecialPowers
.
Ci
.
nsIEditor
.
eEditorRightToLeft
;
/
/
XXX
flags
update
is
required
must
be
a
bug
.
aDocument
.
documentElement
.
scrollTop
;
/
/
XXX
Update
the
body
frame
editTarget
.
focus
(
)
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
SpecialPowers
.
doCommand
(
aWindow
"
cmd_switchTextDirection
"
)
;
/
/
XXX
If
editing
host
is
a
descendant
of
<
body
>
this
must
be
a
bug
.
let
expectedDirValue
=
aTestData
.
cancelBeforeInput
?
"
rtl
"
:
"
ltr
"
;
is
(
body
.
getAttribute
(
"
dir
"
)
expectedDirValue
{
aDescription
}
dir
attribute
of
the
element
should
be
"
{
expectedDirValue
}
"
after
{
aTestData
.
action
}
)
;
verify
(
aTestData
undefined
{
cancelable
:
true
inputType
:
"
formatSetBlockTextDirection
"
data
:
"
ltr
"
targetRanges
:
[
]
}
{
inputType
:
"
formatSetBlockTextDirection
"
data
:
"
ltr
"
}
)
;
}
finally
{
body
.
removeAttribute
(
"
dir
"
)
;
htmlEditor
.
flags
&
=
~
SpecialPowers
.
Ci
.
nsIEditor
.
eEditorRightToLeft
;
htmlEditor
.
flags
|
=
SpecialPowers
.
Ci
.
nsIEditor
.
eEditorLeftToRight
;
/
/
XXX
flags
update
is
required
must
be
a
bug
.
aDocument
.
documentElement
.
scrollTop
;
/
/
XXX
Update
the
body
frame
}
}
test_switching_text_direction_from_rtl_to_ltr
(
{
action
:
'
switching
text
direction
from
"
rtl
"
to
"
ltr
"
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_switching_text_direction_from_rtl_to_ltr
(
{
action
:
'
switching
text
direction
from
"
rtl
"
to
"
ltr
"
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
false
}
)
;
function
test_inserting_link
(
aTestData
)
{
editTarget
.
innerHTML
=
"
link
"
;
editTarget
.
focus
(
)
;
selection
.
selectAllChildren
(
editTarget
)
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
SpecialPowers
.
doCommand
(
aWindow
"
cmd_insertLinkNoUI
"
"
https
:
/
/
example
.
com
/
foo
/
bar
.
html
"
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
"
link
"
:
'
<
a
href
=
"
https
:
/
/
example
.
com
/
foo
/
bar
.
html
"
>
link
<
/
a
>
'
{
cancelable
:
true
inputType
:
"
insertLink
"
data
:
"
https
:
/
/
example
.
com
/
foo
/
bar
.
html
"
targetRanges
:
kSameAsSelection
}
{
inputType
:
"
insertLink
"
data
:
"
https
:
/
/
example
.
com
/
foo
/
bar
.
html
"
}
)
;
}
test_inserting_link
(
{
action
:
'
setting
link
with
absolute
URL
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_inserting_link
(
{
action
:
"
setting
link
with
absolute
URL
"
cancelBeforeInput
:
false
}
)
;
(
function
test_inserting_link_with_relative_url
(
aTestData
)
{
editTarget
.
innerHTML
=
"
link
"
;
selection
.
selectAllChildren
(
editTarget
)
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
SpecialPowers
.
doCommand
(
aWindow
"
cmd_insertLinkNoUI
"
"
foo
/
bar
.
html
"
)
;
ok
(
!
aTestData
.
cancelBeforeInput
{
aDescription
}
cancelBeforeInput
must
not
be
true
for
{
aTestData
.
action
}
)
;
verify
(
aTestData
'
<
a
href
=
"
foo
/
bar
.
html
"
>
link
<
/
a
>
'
{
cancelable
:
true
inputType
:
"
insertLink
"
data
:
"
foo
/
bar
.
html
"
targetRanges
:
kSameAsSelection
}
{
inputType
:
"
insertLink
"
data
:
"
foo
/
bar
.
html
"
}
)
;
}
)
(
{
action
:
"
setting
link
with
relative
URL
"
}
)
;
(
function
test_format_commands
(
)
{
for
(
let
test
of
[
{
command
:
"
cmd_bold
"
tag
:
"
b
"
otherRemoveTags
:
[
"
strong
"
]
inputType
:
"
formatBold
"
}
{
command
:
"
cmd_italic
"
tag
:
"
i
"
otherRemoveTags
:
[
"
em
"
]
inputType
:
"
formatItalic
"
}
{
command
:
"
cmd_underline
"
tag
:
"
u
"
inputType
:
"
formatUnderline
"
}
{
command
:
"
cmd_strikethrough
"
tag
:
"
strike
"
otherRemoveTags
:
[
"
s
"
]
inputType
:
"
formatStrikeThrough
"
}
{
command
:
"
cmd_subscript
"
tag
:
"
sub
"
exclusiveTags
:
[
"
sup
"
]
inputType
:
"
formatSubscript
"
}
{
command
:
"
cmd_superscript
"
tag
:
"
sup
"
exclusiveTags
:
[
"
sub
"
]
inputType
:
"
formatSuperscript
"
}
]
)
{
function
test_formatting_text
(
aTestData
)
{
editTarget
.
innerHTML
=
"
format
"
;
editTarget
.
focus
(
)
;
selection
.
selectAllChildren
(
editTarget
)
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
SpecialPowers
.
doCommand
(
aWindow
test
.
command
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
"
format
"
:
<
{
test
.
tag
}
>
format
<
/
{
test
.
tag
}
>
{
cancelable
:
true
inputType
:
test
.
inputType
data
:
null
targetRanges
:
kSameAsSelection
}
{
inputType
:
test
.
inputType
data
:
null
}
)
;
}
test_formatting_text
(
{
action
:
formatting
with
"
{
test
.
command
}
"
and
canceling
"
beforeinput
"
cancelBeforeInput
:
true
}
)
;
test_formatting_text
(
{
action
:
formatting
with
"
{
test
.
command
}
"
and
canceling
"
beforeinput
"
cancelBeforeInput
:
false
}
)
;
function
test_removing_format_text
(
aTestData
)
{
editTarget
.
innerHTML
=
<
{
test
.
tag
}
>
format
<
/
{
test
.
tag
}
>
;
selection
.
selectAllChildren
(
editTarget
)
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
SpecialPowers
.
doCommand
(
aWindow
test
.
command
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
<
{
test
.
tag
}
>
format
<
/
{
test
.
tag
}
>
:
"
format
"
{
cancelable
:
true
inputType
:
test
.
inputType
data
:
null
targetRanges
:
kSameAsSelection
}
{
inputType
:
test
.
inputType
data
:
null
}
)
;
}
test_removing_format_text
(
{
action
:
removing
format
with
"
{
test
.
command
}
"
and
canceling
"
beforeinput
"
cancelBeforeInput
:
true
}
)
;
test_removing_format_text
(
{
action
:
removing
format
with
"
{
test
.
command
}
"
and
canceling
"
beforeinput
"
cancelBeforeInput
:
false
}
)
;
(
function
test_removing_format_styled_by_others
(
)
{
if
(
!
test
.
otherRemoveTags
)
{
return
;
}
for
(
let
anotherTag
of
test
.
otherRemoveTags
)
{
function
test_removing_format_styled_by_another_element
(
aTestData
)
{
editTarget
.
innerHTML
=
<
{
anotherTag
}
>
format
<
/
{
anotherTag
}
>
;
editTarget
.
focus
(
)
;
selection
.
selectAllChildren
(
editTarget
)
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
SpecialPowers
.
doCommand
(
aWindow
test
.
command
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
<
{
anotherTag
}
>
format
<
/
{
anotherTag
}
>
:
"
format
"
{
cancelable
:
true
inputType
:
test
.
inputType
data
:
null
targetRanges
:
kSameAsSelection
}
{
inputType
:
test
.
inputType
data
:
null
}
)
;
}
test_removing_format_styled_by_another_element
(
{
action
:
removing
<
{
anotherTag
}
>
element
with
"
{
test
.
command
}
"
and
canceling
"
beforeinput
"
cancelBeforeInput
:
true
}
)
;
test_removing_format_styled_by_another_element
(
{
action
:
removing
<
{
anotherTag
}
>
element
with
"
{
test
.
command
}
"
cancelBeforeInput
:
false
}
)
;
function
test_removing_format_styled_by_both_primary_one_and_another_one
(
aTestData
)
{
editTarget
.
innerHTML
=
<
{
test
.
tag
}
>
<
{
anotherTag
}
>
format
<
/
{
anotherTag
}
>
<
/
{
test
.
tag
}
>
;
editTarget
.
focus
(
)
;
selection
.
selectAllChildren
(
editTarget
)
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
SpecialPowers
.
doCommand
(
aWindow
test
.
command
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
<
{
test
.
tag
}
>
<
{
anotherTag
}
>
format
<
/
{
anotherTag
}
>
<
/
{
test
.
tag
}
>
:
"
format
"
{
cancelable
:
true
inputType
:
test
.
inputType
data
:
null
targetRanges
:
kSameAsSelection
}
{
inputType
:
test
.
inputType
data
:
null
}
)
;
}
test_removing_format_styled_by_both_primary_one_and_another_one
(
{
action
:
removing
both
<
{
test
.
tag
}
>
and
<
{
anotherTag
}
>
elements
with
"
{
test
.
command
}
"
and
canceling
"
beforeinput
"
cancelBeforeInput
:
true
}
)
;
test_removing_format_styled_by_both_primary_one_and_another_one
(
{
action
:
removing
both
<
{
test
.
tag
}
>
and
<
{
anotherTag
}
>
elements
with
"
{
test
.
command
}
"
cancelBeforeInput
:
false
}
)
;
}
}
)
(
)
;
(
function
test_formatting_text_styled_by_exclusive_elements
(
)
{
if
(
!
test
.
exclusiveTags
)
{
return
;
}
for
(
let
exclusiveTag
of
test
.
exclusiveTags
)
{
function
test_formatting_text_styled_by_exclusive_element
(
aTestData
)
{
editTarget
.
innerHTML
=
<
{
exclusiveTag
}
>
format
<
/
{
exclusiveTag
}
>
;
editTarget
.
focus
(
)
;
selection
.
selectAllChildren
(
editTarget
)
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
SpecialPowers
.
doCommand
(
aWindow
test
.
command
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
<
{
exclusiveTag
}
>
format
<
/
{
exclusiveTag
}
>
:
<
{
test
.
tag
}
>
format
<
/
{
test
.
tag
}
>
{
cancelable
:
true
inputType
:
test
.
inputType
data
:
null
targetRanges
:
kSameAsSelection
}
{
inputType
:
test
.
inputType
data
:
null
}
)
;
}
test_formatting_text_styled_by_exclusive_element
(
{
action
:
removing
<
{
exclusiveTag
}
>
element
with
formatting
with
"
{
test
.
command
}
"
and
canceling
"
beforeinput
"
cancelBeforeInput
:
true
}
)
;
test_formatting_text_styled_by_exclusive_element
(
{
action
:
removing
<
{
exclusiveTag
}
>
element
with
formatting
with
"
{
test
.
command
}
"
cancelBeforeInput
:
false
}
)
;
}
}
)
(
)
;
}
}
)
(
)
;
function
test_indenting_text
(
aTestData
)
{
editTarget
.
innerHTML
=
"
format
"
;
editTarget
.
focus
(
)
;
selection
.
selectAllChildren
(
editTarget
)
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
SpecialPowers
.
doCommand
(
aWindow
"
cmd_indent
"
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
"
format
"
:
"
<
blockquote
>
format
<
/
blockquote
>
"
{
cancelable
:
true
inputType
:
"
formatIndent
"
data
:
null
targetRanges
:
kSameAsSelection
}
{
inputType
:
"
formatIndent
"
data
:
null
}
)
;
}
test_indenting_text
(
{
action
:
'
indenting
text
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_indenting_text
(
{
action
:
'
indenting
text
'
cancelBeforeInput
:
false
}
)
;
function
test_outdenting_blockquote
(
aTestData
)
{
editTarget
.
innerHTML
=
"
<
blockquote
>
format
<
/
blockquote
>
"
;
selection
.
selectAllChildren
(
editTarget
.
firstChild
)
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
SpecialPowers
.
doCommand
(
aWindow
"
cmd_outdent
"
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
"
<
blockquote
>
format
<
/
blockquote
>
"
:
"
format
"
{
cancelable
:
true
inputType
:
"
formatOutdent
"
data
:
null
targetRanges
:
kSameAsSelection
}
{
inputType
:
"
formatOutdent
"
data
:
null
}
)
;
}
test_outdenting_blockquote
(
{
action
:
'
outdenting
blockquote
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_outdenting_blockquote
(
{
action
:
'
outdenting
blockquote
'
cancelBeforeInput
:
false
}
)
;
function
test_typing_delete_to_delete_img
(
aTestData
)
{
editTarget
.
innerHTML
=
<
img
src
=
"
{
kImgURL
}
"
>
;
editTarget
.
focus
(
)
;
selection
.
collapse
(
editTarget
0
)
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
KEY_Delete
"
{
}
aWindow
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
<
img
src
=
"
{
kImgURL
}
"
>
:
"
<
br
>
"
{
cancelable
:
true
inputType
:
"
deleteContentForward
"
data
:
null
targetRanges
:
[
{
startContainer
:
editTarget
startOffset
:
0
endContainer
:
editTarget
endOffset
:
1
}
]
}
{
inputType
:
"
deleteContentForward
"
data
:
null
}
)
;
}
test_typing_delete_to_delete_img
(
{
action
:
'
typing
"
Delete
"
to
delete
the
<
img
>
element
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_typing_delete_to_delete_img
(
{
action
:
'
typing
"
Delete
"
to
delete
the
<
img
>
element
'
cancelBeforeInput
:
false
}
)
;
function
test_typing_backspace_to_delete_img
(
aTestData
)
{
editTarget
.
innerHTML
=
<
img
src
=
"
{
kImgURL
}
"
>
;
editTarget
.
focus
(
)
;
selection
.
collapse
(
editTarget
1
)
;
reset
(
)
;
cancelBeforeInput
=
aTestData
.
cancelBeforeInput
;
action
=
aTestData
.
action
;
synthesizeKey
(
"
KEY_Backspace
"
{
}
aWindow
)
;
verify
(
aTestData
aTestData
.
cancelBeforeInput
?
<
img
src
=
"
{
kImgURL
}
"
>
:
"
<
br
>
"
{
cancelable
:
true
inputType
:
"
deleteContentBackward
"
data
:
null
targetRanges
:
[
{
startContainer
:
editTarget
startOffset
:
0
endContainer
:
editTarget
endOffset
:
1
}
]
}
{
inputType
:
"
deleteContentBackward
"
data
:
null
}
)
;
}
test_typing_backspace_to_delete_img
(
{
action
:
'
typing
"
Backspace
"
to
delete
the
<
img
>
element
and
canceling
"
beforeinput
"
'
cancelBeforeInput
:
true
}
)
;
test_typing_backspace_to_delete_img
(
{
action
:
'
typing
"
Backspace
"
to
delete
the
<
img
>
element
'
cancelBeforeInput
:
false
}
)
;
aWindow
.
removeEventListener
(
"
beforeinput
"
beforeInputHandler
true
)
;
aWindow
.
removeEventListener
(
"
input
"
inputHandler
true
)
;
}
doTests
(
document
.
getElementById
(
"
editor1
"
)
.
contentDocument
document
.
getElementById
(
"
editor1
"
)
.
contentWindow
"
Editor1
body
has
contenteditable
attribute
"
)
;
doTests
(
document
.
getElementById
(
"
editor2
"
)
.
contentDocument
document
.
getElementById
(
"
editor2
"
)
.
contentWindow
"
Editor2
html
has
contenteditable
attribute
"
)
;
doTests
(
document
.
getElementById
(
"
editor3
"
)
.
contentDocument
document
.
getElementById
(
"
editor3
"
)
.
contentWindow
"
Editor3
div
has
contenteditable
attribute
"
)
;
doTests
(
document
.
getElementById
(
"
editor4
"
)
.
contentDocument
document
.
getElementById
(
"
editor4
"
)
.
contentWindow
"
Editor4
html
and
div
have
contenteditable
attribute
"
)
;
doTests
(
document
.
getElementById
(
"
editor5
"
)
.
contentDocument
document
.
getElementById
(
"
editor5
"
)
.
contentWindow
"
Editor5
html
and
div
have
contenteditable
attribute
"
)
;
SimpleTest
.
finish
(
)
;
}
<
/
script
>
<
/
body
>
<
/
html
>
