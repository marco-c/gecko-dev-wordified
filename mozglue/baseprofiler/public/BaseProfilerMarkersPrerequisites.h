/
*
-
*
-
Mode
:
C
+
+
;
tab
-
width
:
2
;
indent
-
tabs
-
mode
:
nil
;
c
-
basic
-
offset
:
2
-
*
-
*
/
/
*
vim
:
set
ts
=
8
sts
=
2
et
sw
=
2
tw
=
80
:
*
/
/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
/
/
This
header
contains
basic
definitions
required
to
create
marker
types
and
/
/
to
add
markers
to
the
profiler
buffers
.
/
/
/
/
In
most
cases
#
include
"
mozilla
/
BaseProfilerMarkers
.
h
"
instead
or
/
/
#
include
"
mozilla
/
BaseProfilerMarkerTypes
.
h
"
for
common
marker
types
.
#
ifndef
BaseProfilerMarkersPrerequisites_h
#
define
BaseProfilerMarkersPrerequisites_h
#
ifdef
MOZ_GECKO_PROFILER
#
include
"
mozilla
/
ProfileChunkedBuffer
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
<
string_view
>
#
include
<
string
>
#
include
<
type_traits
>
#
include
<
utility
>
namespace
mozilla
:
:
baseprofiler
{
/
/
Implemented
in
platform
.
cpp
MFBT_API
int
profiler_current_thread_id
(
)
;
}
/
/
namespace
mozilla
:
:
baseprofiler
namespace
mozilla
{
/
/
Return
a
NotNull
<
const
CHAR
*
>
pointing
at
the
literal
empty
string
"
"
.
template
<
typename
CHAR
>
constexpr
const
CHAR
*
LiteralEmptyStringPointer
(
)
{
static_assert
(
std
:
:
is_same_v
<
CHAR
char
>
|
|
std
:
:
is_same_v
<
CHAR
char16_t
>
"
Only
char
and
char16_t
are
supported
in
Firefox
"
)
;
if
constexpr
(
std
:
:
is_same_v
<
CHAR
char
>
)
{
return
"
"
;
}
if
constexpr
(
std
:
:
is_same_v
<
CHAR
char16_t
>
)
{
return
u
"
"
;
}
}
/
/
Return
a
string_view
<
CHAR
>
pointing
at
the
literal
empty
string
.
template
<
typename
CHAR
>
constexpr
std
:
:
basic_string_view
<
CHAR
>
LiteralEmptyStringView
(
)
{
static_assert
(
std
:
:
is_same_v
<
CHAR
char
>
|
|
std
:
:
is_same_v
<
CHAR
char16_t
>
"
Only
char
and
char16_t
are
supported
in
Firefox
"
)
;
/
/
Use
operator
"
"
sv
(
)
from
<
string_view
>
.
using
namespace
std
:
:
literals
:
:
string_view_literals
;
if
constexpr
(
std
:
:
is_same_v
<
CHAR
char
>
)
{
return
"
"
sv
;
}
if
constexpr
(
std
:
:
is_same_v
<
CHAR
char16_t
>
)
{
return
u
"
"
sv
;
}
}
/
/
General
string
view
optimized
for
short
on
-
stack
life
before
serialization
/
/
and
between
deserialization
and
JSON
-
streaming
.
template
<
typename
CHAR
>
class
MOZ_STACK_CLASS
ProfilerStringView
{
public
:
/
/
Default
constructor
points
at
"
"
(
literal
empty
string
)
.
constexpr
ProfilerStringView
(
)
=
default
;
/
/
Don
'
t
allow
copy
.
ProfilerStringView
(
const
ProfilerStringView
&
)
=
delete
;
ProfilerStringView
&
operator
=
(
const
ProfilerStringView
&
)
=
delete
;
/
/
Allow
move
.
For
consistency
the
moved
-
from
string
is
always
reset
to
"
"
.
constexpr
ProfilerStringView
(
ProfilerStringView
&
&
aOther
)
:
mStringView
(
std
:
:
move
(
aOther
.
mStringView
)
)
mOwnership
(
aOther
.
mOwnership
)
{
if
(
mOwnership
=
=
Ownership
:
:
OwnedThroughStringView
)
{
/
/
We
now
own
the
buffer
make
the
other
point
at
the
literal
"
"
.
aOther
.
mStringView
=
LiteralEmptyStringView
<
CHAR
>
(
)
;
aOther
.
mOwnership
=
Ownership
:
:
Literal
;
}
}
constexpr
ProfilerStringView
&
operator
=
(
ProfilerStringView
&
&
aOther
)
{
mStringView
=
std
:
:
move
(
aOther
.
mStringView
)
;
mOwnership
=
aOther
.
mOwnership
;
if
(
mOwnership
=
=
Ownership
:
:
OwnedThroughStringView
)
{
/
/
We
now
own
the
buffer
make
the
other
point
at
the
literal
"
"
.
aOther
.
mStringView
=
LiteralEmptyStringView
<
CHAR
>
(
)
;
aOther
.
mOwnership
=
Ownership
:
:
Literal
;
}
return
*
this
;
}
~
ProfilerStringView
(
)
{
if
(
MOZ_UNLIKELY
(
mOwnership
=
=
Ownership
:
:
OwnedThroughStringView
)
)
{
/
/
We
own
the
buffer
pointed
at
by
mStringView
destroy
it
.
/
/
This
is
only
used
between
deserialization
and
streaming
.
delete
mStringView
.
data
(
)
;
}
}
/
/
Implicit
construction
from
nullptr
points
at
"
"
(
literal
empty
string
)
.
constexpr
MOZ_IMPLICIT
ProfilerStringView
(
decltype
(
nullptr
)
)
{
}
/
/
Implicit
constructor
from
a
literal
string
.
template
<
size_t
Np1
>
constexpr
MOZ_IMPLICIT
ProfilerStringView
(
const
CHAR
(
&
aLiteralString
)
[
Np1
]
)
:
ProfilerStringView
(
aLiteralString
Np1
-
1
Ownership
:
:
Literal
)
{
}
/
/
Constructor
from
a
non
-
literal
string
.
constexpr
ProfilerStringView
(
const
CHAR
*
aString
size_t
aLength
)
:
ProfilerStringView
(
aString
aLength
Ownership
:
:
Reference
)
{
}
/
/
Implicit
constructor
from
a
string_view
.
constexpr
MOZ_IMPLICIT
ProfilerStringView
(
const
std
:
:
basic_string_view
<
CHAR
>
&
aStringView
)
:
ProfilerStringView
(
aStringView
.
data
(
)
aStringView
.
length
(
)
Ownership
:
:
Reference
)
{
}
/
/
Implicit
constructor
from
an
expiring
string_view
.
We
assume
that
the
/
/
pointed
-
at
string
will
outlive
this
ProfilerStringView
.
constexpr
MOZ_IMPLICIT
ProfilerStringView
(
std
:
:
basic_string_view
<
CHAR
>
&
&
aStringView
)
:
ProfilerStringView
(
aStringView
.
data
(
)
aStringView
.
length
(
)
Ownership
:
:
Reference
)
{
}
/
/
Implicit
constructor
from
std
:
:
string
.
constexpr
MOZ_IMPLICIT
ProfilerStringView
(
const
std
:
:
string
&
aString
)
:
ProfilerStringView
(
aString
.
data
(
)
aString
.
length
(
)
Ownership
:
:
Reference
)
{
}
/
/
Construction
from
a
raw
pointer
to
a
null
-
terminated
string
.
/
/
This
is
a
named
class
-
static
function
to
make
it
more
obvious
where
work
is
/
/
being
done
(
to
determine
the
string
length
)
and
encourage
users
to
instead
/
/
provide
a
length
if
already
known
.
/
/
TODO
:
Find
callers
and
convert
them
to
constructor
instead
if
possible
.
static
constexpr
ProfilerStringView
WrapNullTerminatedString
(
const
CHAR
*
aString
)
{
return
ProfilerStringView
(
aString
aString
?
std
:
:
char_traits
<
char
>
:
:
length
(
aString
)
:
0
Ownership
:
:
Reference
)
;
}
/
/
Implicit
constructor
for
an
object
with
member
functions
Data
(
)
/
/
Length
(
)
and
IsLiteral
(
)
common
in
xpcom
strings
.
template
<
typename
String
typename
DataReturnType
=
decltype
(
std
:
:
declval
<
const
String
>
(
)
.
Data
(
)
)
typename
LengthReturnType
=
decltype
(
std
:
:
declval
<
const
String
>
(
)
.
Length
(
)
)
typename
IsLiteralReturnType
=
decltype
(
std
:
:
declval
<
const
String
>
(
)
.
IsLiteral
(
)
)
typename
=
std
:
:
enable_if_t
<
std
:
:
is_convertible_v
<
DataReturnType
const
CHAR
*
>
&
&
std
:
:
is_integral_v
<
LengthReturnType
>
&
&
std
:
:
is_same_v
<
IsLiteralReturnType
bool
>
>
>
constexpr
MOZ_IMPLICIT
ProfilerStringView
(
const
String
&
aString
)
:
ProfilerStringView
(
static_cast
<
const
CHAR
*
>
(
aString
.
Data
(
)
)
aString
.
Length
(
)
aString
.
IsLiteral
(
)
?
Ownership
:
:
Literal
:
Ownership
:
:
Reference
)
{
}
[
[
nodiscard
]
]
constexpr
const
std
:
:
basic_string_view
<
CHAR
>
&
StringView
(
)
const
{
return
mStringView
;
}
[
[
nodiscard
]
]
constexpr
const
CHAR
*
Data
(
)
const
{
return
mStringView
.
data
(
)
;
}
[
[
nodiscard
]
]
constexpr
size_t
Length
(
)
const
{
return
mStringView
.
length
(
)
;
}
[
[
nodiscard
]
]
constexpr
bool
IsLiteral
(
)
const
{
return
mOwnership
=
=
Ownership
:
:
Literal
;
}
[
[
nodiscard
]
]
constexpr
bool
IsReference
(
)
const
{
return
mOwnership
=
=
Ownership
:
:
Reference
;
}
/
/
No
IsOwned
.
.
.
(
)
because
it
'
s
a
secret
only
used
internally
!
[
[
nodiscard
]
]
std
:
:
basic_string
<
CHAR
>
String
(
)
const
{
return
std
:
:
basic_string
<
CHAR
>
(
mStringView
)
;
}
private
:
enum
class
Ownership
{
Literal
Reference
OwnedThroughStringView
}
;
/
/
Allow
deserializer
to
store
anything
here
.
friend
ProfileBufferEntryReader
:
:
Deserializer
<
ProfilerStringView
>
;
constexpr
ProfilerStringView
(
const
CHAR
*
aString
size_t
aLength
Ownership
aOwnership
)
:
mStringView
(
aString
?
std
:
:
basic_string_view
<
CHAR
>
(
aString
aLength
)
:
LiteralEmptyStringView
<
CHAR
>
(
)
)
mOwnership
(
aString
?
aOwnership
:
Ownership
:
:
Literal
)
{
}
/
/
String
view
to
an
outside
string
(
literal
or
reference
)
.
/
/
We
may
actually
own
the
pointed
-
at
buffer
but
it
is
only
used
internally
/
/
between
deserialization
and
JSON
streaming
.
std
:
:
basic_string_view
<
CHAR
>
mStringView
=
LiteralEmptyStringView
<
CHAR
>
(
)
;
Ownership
mOwnership
=
Ownership
:
:
Literal
;
}
;
using
ProfilerString8View
=
ProfilerStringView
<
char
>
;
using
ProfilerString16View
=
ProfilerStringView
<
char16_t
>
;
/
/
The
classes
below
are
all
embedded
in
a
MarkerOptions
object
.
class
MarkerOptions
;
/
/
This
compulsory
marker
option
contains
the
required
category
information
.
class
MarkerCategory
{
public
:
/
/
Constructor
from
category
pair
(
aka
sub
-
category
)
and
category
.
constexpr
MarkerCategory
(
baseprofiler
:
:
ProfilingCategoryPair
aCategoryPair
baseprofiler
:
:
ProfilingCategory
aCategory
)
:
mCategoryPair
(
aCategoryPair
)
mCategory
(
aCategory
)
{
}
constexpr
baseprofiler
:
:
ProfilingCategoryPair
CategoryPair
(
)
const
{
return
mCategoryPair
;
}
constexpr
baseprofiler
:
:
ProfilingCategory
Category
(
)
const
{
return
mCategory
;
}
private
:
/
/
The
default
constructor
is
only
used
during
deserialization
of
/
/
MarkerOptions
.
friend
MarkerOptions
;
constexpr
MarkerCategory
(
)
=
default
;
friend
ProfileBufferEntryReader
:
:
Deserializer
<
MarkerCategory
>
;
baseprofiler
:
:
ProfilingCategoryPair
mCategoryPair
=
baseprofiler
:
:
ProfilingCategoryPair
:
:
OTHER
;
baseprofiler
:
:
ProfilingCategory
mCategory
=
baseprofiler
:
:
ProfilingCategory
:
:
OTHER
;
}
;
namespace
baseprofiler
:
:
category
{
/
/
Each
category
-
pair
(
aka
subcategory
)
name
constructs
a
MarkerCategory
.
/
/
E
.
g
.
:
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER_Profiling
/
/
Profiler
macros
will
take
the
category
name
alone
.
/
/
E
.
g
.
:
PROFILER_MARKER_UNTYPED
(
"
name
"
OTHER_Profiling
)
#
define
CATEGORY_ENUM_BEGIN_CATEGORY
(
name
labelAsString
color
)
#
define
CATEGORY_ENUM_SUBCATEGORY
(
supercategory
name
labelAsString
)
\
static
constexpr
MarkerCategory
name
{
ProfilingCategoryPair
:
:
name
\
ProfilingCategory
:
:
supercategory
}
;
#
define
CATEGORY_ENUM_END_CATEGORY
MOZ_PROFILING_CATEGORY_LIST
(
CATEGORY_ENUM_BEGIN_CATEGORY
CATEGORY_ENUM_SUBCATEGORY
CATEGORY_ENUM_END_CATEGORY
)
#
undef
CATEGORY_ENUM_BEGIN_CATEGORY
#
undef
CATEGORY_ENUM_SUBCATEGORY
#
undef
CATEGORY_ENUM_END_CATEGORY
}
/
/
namespace
baseprofiler
:
:
category
/
/
This
marker
option
captures
a
given
thread
id
.
/
/
If
left
unspecified
(
by
default
construction
)
during
the
add
-
marker
call
the
/
/
current
thread
id
will
be
used
then
.
class
MarkerThreadId
{
public
:
/
/
Default
constructor
keeps
the
thread
id
unspecified
.
constexpr
MarkerThreadId
(
)
=
default
;
/
/
Constructor
from
a
given
thread
id
.
constexpr
explicit
MarkerThreadId
(
int
aThreadId
)
:
mThreadId
(
aThreadId
)
{
}
/
/
Use
the
current
thread
'
s
id
.
static
MarkerThreadId
CurrentThread
(
)
{
return
MarkerThreadId
(
baseprofiler
:
:
profiler_current_thread_id
(
)
)
;
}
[
[
nodiscard
]
]
constexpr
int
ThreadId
(
)
const
{
return
mThreadId
;
}
[
[
nodiscard
]
]
constexpr
bool
IsUnspecified
(
)
const
{
return
mThreadId
=
=
0
;
}
private
:
int
mThreadId
=
0
;
}
;
/
/
This
marker
option
contains
marker
timing
information
.
/
/
This
class
encapsulates
the
logic
for
correctly
storing
a
marker
based
on
its
/
/
Use
the
static
methods
to
create
the
MarkerTiming
.
This
is
a
transient
object
/
/
that
is
being
used
to
enforce
the
constraints
of
the
combinations
of
the
/
/
data
.
class
MarkerTiming
{
public
:
/
/
The
following
static
methods
are
used
to
create
the
MarkerTiming
based
on
/
/
the
type
that
it
is
.
static
MarkerTiming
InstantAt
(
const
TimeStamp
&
aTime
)
{
MOZ_ASSERT
(
!
aTime
.
IsNull
(
)
"
Time
is
null
for
an
instant
marker
.
"
)
;
return
MarkerTiming
{
aTime
TimeStamp
{
}
MarkerTiming
:
:
Phase
:
:
Instant
}
;
}
static
MarkerTiming
InstantNow
(
)
{
return
InstantAt
(
TimeStamp
:
:
NowUnfuzzed
(
)
)
;
}
static
MarkerTiming
Interval
(
const
TimeStamp
&
aStartTime
const
TimeStamp
&
aEndTime
)
{
MOZ_ASSERT
(
!
aStartTime
.
IsNull
(
)
"
Start
time
is
null
for
an
interval
marker
.
"
)
;
MOZ_ASSERT
(
!
aEndTime
.
IsNull
(
)
"
End
time
is
null
for
an
interval
marker
.
"
)
;
return
MarkerTiming
{
aStartTime
aEndTime
MarkerTiming
:
:
Phase
:
:
Interval
}
;
}
static
MarkerTiming
IntervalUntilNowFrom
(
const
TimeStamp
&
aStartTime
)
{
return
Interval
(
aStartTime
TimeStamp
:
:
NowUnfuzzed
(
)
)
;
}
static
MarkerTiming
IntervalStart
(
const
TimeStamp
&
aTime
=
TimeStamp
:
:
NowUnfuzzed
(
)
)
{
MOZ_ASSERT
(
!
aTime
.
IsNull
(
)
"
Time
is
null
for
an
interval
start
marker
.
"
)
;
return
MarkerTiming
{
aTime
TimeStamp
{
}
MarkerTiming
:
:
Phase
:
:
IntervalStart
}
;
}
static
MarkerTiming
IntervalEnd
(
const
TimeStamp
&
aTime
=
TimeStamp
:
:
NowUnfuzzed
(
)
)
{
MOZ_ASSERT
(
!
aTime
.
IsNull
(
)
"
Time
is
null
for
an
interval
end
marker
.
"
)
;
return
MarkerTiming
{
TimeStamp
{
}
aTime
MarkerTiming
:
:
Phase
:
:
IntervalEnd
}
;
}
[
[
nodiscard
]
]
const
TimeStamp
&
StartTime
(
)
const
{
return
mStartTime
;
}
[
[
nodiscard
]
]
const
TimeStamp
&
EndTime
(
)
const
{
return
mEndTime
;
}
enum
class
Phase
:
uint8_t
{
Instant
=
0
Interval
=
1
IntervalStart
=
2
IntervalEnd
=
3
}
;
[
[
nodiscard
]
]
Phase
MarkerPhase
(
)
const
{
MOZ_ASSERT
(
!
IsUnspecified
(
)
)
;
return
mPhase
;
}
/
/
The
following
getter
methods
are
used
to
put
the
value
into
the
buffer
for
/
/
storage
.
[
[
nodiscard
]
]
double
GetStartTime
(
)
const
{
MOZ_ASSERT
(
!
IsUnspecified
(
)
)
;
/
/
If
mStartTime
is
null
(
e
.
g
.
for
IntervalEnd
)
this
will
output
0
.
0
as
/
/
expected
.
return
MarkerTiming
:
:
timeStampToDouble
(
mStartTime
)
;
}
[
[
nodiscard
]
]
double
GetEndTime
(
)
const
{
MOZ_ASSERT
(
!
IsUnspecified
(
)
)
;
/
/
If
mEndTime
is
null
(
e
.
g
.
for
Instant
or
IntervalStart
)
this
will
/
/
output
0
.
0
as
expected
.
return
MarkerTiming
:
:
timeStampToDouble
(
mEndTime
)
;
}
[
[
nodiscard
]
]
uint8_t
GetPhase
(
)
const
{
MOZ_ASSERT
(
!
IsUnspecified
(
)
)
;
return
static_cast
<
uint8_t
>
(
mPhase
)
;
}
private
:
friend
ProfileBufferEntryWriter
:
:
Serializer
<
MarkerTiming
>
;
friend
ProfileBufferEntryReader
:
:
Deserializer
<
MarkerTiming
>
;
/
/
Default
timing
leaves
it
internally
"
unspecified
"
serialization
getters
/
/
and
add
-
marker
functions
will
default
to
InstantNow
(
)
.
constexpr
MarkerTiming
(
)
=
default
;
/
/
This
should
only
be
used
by
internal
profiler
code
.
[
[
nodiscard
]
]
bool
IsUnspecified
(
)
const
{
return
mStartTime
.
IsNull
(
)
&
&
mEndTime
.
IsNull
(
)
;
}
/
/
Full
constructor
used
by
static
factory
functions
.
constexpr
MarkerTiming
(
const
TimeStamp
&
aStartTime
const
TimeStamp
&
aEndTime
Phase
aPhase
)
:
mStartTime
(
aStartTime
)
mEndTime
(
aEndTime
)
mPhase
(
aPhase
)
{
}
static
double
timeStampToDouble
(
const
TimeStamp
&
time
)
{
if
(
time
.
IsNull
(
)
)
{
/
/
The
Phase
lets
us
know
not
to
use
this
value
.
return
0
;
}
return
(
time
-
TimeStamp
:
:
ProcessCreation
(
)
)
.
ToMilliseconds
(
)
;
}
TimeStamp
mStartTime
;
TimeStamp
mEndTime
;
Phase
mPhase
=
Phase
:
:
Instant
;
}
;
}
/
/
namespace
mozilla
#
endif
/
/
MOZ_GECKO_PROFILER
#
endif
/
/
BaseProfilerMarkersPrerequisites_h
