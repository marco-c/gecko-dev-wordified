#
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
#
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
#
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
#
This
script
generates
jit
/
MIROpsGenerated
.
h
(
list
of
MIR
instructions
)
#
from
MIROps
.
yaml
as
well
as
MIR
op
definitions
.
import
yaml
from
collections
import
OrderedDict
CPP_HEADER_TEMPLATE
=
"
"
"
\
/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
 
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
 
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
#
ifndef
{
includeguard
}
#
define
{
includeguard
}
/
*
This
file
is
generated
by
generate_profiling_categories
.
py
.
DO
NOT
EDIT
!
*
/
/
/
Profiler
sub
-
categories
are
applied
to
each
sampled
stack
to
describe
the
/
/
type
of
workload
that
the
CPU
is
busy
with
.
Only
one
sub
-
category
can
be
/
/
assigned
so
be
mindful
that
these
are
non
-
overlapping
.
The
active
category
is
/
/
set
by
pushing
a
label
to
the
profiling
stack
or
by
the
unwinder
in
cases
/
/
such
as
JITs
.
A
profile
sample
in
arbitrary
C
+
+
/
Rust
will
typically
be
/
/
categorized
based
on
the
top
of
the
label
stack
.
/
/
/
/
The
list
of
available
color
names
for
categories
is
:
/
/
transparent
/
/
blue
/
/
green
/
/
grey
/
/
lightblue
/
/
magenta
/
/
orange
/
/
purple
/
/
yellow
/
/
clang
-
format
off
{
contents
}
/
/
clang
-
format
on
#
endif
/
/
{
includeguard
}
"
"
"
CPP_MACRO_DEFINITION
=
"
"
"
\
#
define
MOZ_PROFILING_CATEGORY_LIST
(
BEGIN_CATEGORY
SUBCATEGORY
END_CATEGORY
)
\
\
"
"
"
def
generate_header
(
c_out
includeguard
contents
)
:
    
c_out
.
write
(
        
CPP_HEADER_TEMPLATE
.
format
(
includeguard
=
includeguard
contents
=
contents
)
    
)
def
load_yaml
(
yaml_path
)
:
    
#
Load
into
an
OrderedDict
to
ensure
order
is
preserved
.
Note
:
Python
3
.
7
+
    
#
also
preserves
ordering
for
normal
dictionaries
.
    
#
Code
based
on
https
:
/
/
stackoverflow
.
com
/
a
/
21912744
.
    
class
OrderedLoader
(
yaml
.
Loader
)
:
        
pass
    
def
construct_mapping
(
loader
node
)
:
        
loader
.
flatten_mapping
(
node
)
        
return
OrderedDict
(
loader
.
construct_pairs
(
node
)
)
    
tag
=
yaml
.
resolver
.
BaseResolver
.
DEFAULT_MAPPING_TAG
    
OrderedLoader
.
add_constructor
(
tag
construct_mapping
)
    
file_handler
=
open
(
yaml_path
)
    
return
yaml
.
load
(
file_handler
OrderedLoader
)
def
generate_category_macro
(
name
label
color
subcategories
)
:
    
contents
=
'
BEGIN_CATEGORY
(
{
name
}
"
{
label
}
"
"
{
color
}
"
)
\
\
\
n
'
.
format
(
        
name
=
name
label
=
label
color
=
color
    
)
    
subcategory_items
=
[
]
    
for
subcategory
in
subcategories
:
        
subcat_name
=
subcategory
[
"
name
"
]
        
assert
isinstance
(
subcat_name
str
)
        
subcat_label
=
subcategory
[
"
label
"
]
        
assert
isinstance
(
subcat_label
str
)
        
subcategory_items
.
append
(
            
'
SUBCATEGORY
(
{
parent_cat
}
{
name
}
"
{
label
}
"
)
\
\
\
n
'
.
format
(
                
parent_cat
=
name
name
=
subcat_name
label
=
subcat_label
            
)
        
)
    
contents
+
=
"
"
.
join
(
subcategory_items
)
    
contents
+
=
"
END_CATEGORY
"
    
return
contents
def
generate_macro_header
(
c_out
yaml_path
)
:
    
"
"
"
Generate
ProfilingCategoryList
.
h
from
profiling_categories
.
yaml
.
    
The
generated
file
has
a
macro
to
generate
the
profiling
category
enums
.
    
"
"
"
    
data
=
load_yaml
(
yaml_path
)
    
#
Stores
the
macro
definition
of
each
categories
.
    
category_items
=
[
]
    
for
category
in
data
:
        
name
=
category
[
"
name
"
]
        
assert
isinstance
(
name
str
)
        
label
=
category
[
"
label
"
]
        
assert
isinstance
(
label
str
)
        
color
=
category
[
"
color
"
]
        
assert
isinstance
(
color
str
)
        
subcategories
=
category
.
get
(
"
subcategories
"
None
)
        
assert
(
            
isinstance
(
subcategories
list
)
and
len
(
subcategories
)
>
0
        
)
"
At
least
one
subcategory
expected
as
default
in
{
}
.
"
.
format
(
name
)
        
category_items
.
append
(
            
generate_category_macro
(
name
label
color
subcategories
)
        
)
    
contents
=
CPP_MACRO_DEFINITION
    
contents
+
=
"
\
\
\
n
"
.
join
(
category_items
)
    
generate_header
(
c_out
"
baseprofiler_ProfilingCategoryList_h
"
contents
)
