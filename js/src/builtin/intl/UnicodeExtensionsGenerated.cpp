/
/
Generated
by
make_intl_data
.
py
.
DO
NOT
EDIT
.
/
/
Version
:
CLDR
-
35
.
1
/
/
URL
:
https
:
/
/
unicode
.
org
/
Public
/
cldr
/
35
.
1
/
core
.
zip
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
<
algorithm
>
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
"
builtin
/
intl
/
LanguageTag
.
h
"
using
namespace
js
:
:
intl
:
:
LanguageTagLimits
;
using
ConstCharRange
=
mozilla
:
:
Range
<
const
char
>
;
template
<
size_t
Length
>
static
inline
bool
IsUnicodeKey
(
const
ConstCharRange
&
key
const
char
(
&
str
)
[
Length
]
)
{
static_assert
(
Length
=
=
UnicodeKeyLength
+
1
"
Unicode
extension
key
is
two
characters
long
"
)
;
return
memcmp
(
key
.
begin
(
)
.
get
(
)
str
Length
-
1
)
=
=
0
;
}
template
<
size_t
Length
>
static
inline
bool
IsUnicodeType
(
const
ConstCharRange
&
type
const
char
(
&
str
)
[
Length
]
)
{
static_assert
(
Length
>
UnicodeKeyLength
+
1
"
Unicode
extension
type
contains
more
than
two
characters
"
)
;
return
type
.
length
(
)
=
=
(
Length
-
1
)
&
&
memcmp
(
type
.
begin
(
)
.
get
(
)
str
Length
-
1
)
=
=
0
;
}
static
int32_t
CompareUnicodeType
(
const
char
*
a
const
ConstCharRange
&
b
)
{
#
ifdef
DEBUG
auto
isNull
=
[
]
(
char
c
)
{
return
c
=
=
'
\
0
'
;
}
;
#
endif
MOZ_ASSERT
(
std
:
:
none_of
(
b
.
begin
(
)
.
get
(
)
b
.
end
(
)
.
get
(
)
isNull
)
"
unexpected
null
-
character
in
string
"
)
;
using
UnsignedChar
=
unsigned
char
;
for
(
size_t
i
=
0
;
i
<
b
.
length
(
)
;
i
+
+
)
{
/
/
|
a
|
is
zero
-
terminated
and
|
b
|
doesn
'
t
contain
a
null
-
terminator
.
So
if
/
/
we
'
ve
reached
the
end
of
|
a
|
the
below
if
-
statement
will
always
be
true
.
/
/
That
ensures
we
don
'
t
read
past
the
end
of
|
a
|
.
if
(
int32_t
r
=
UnsignedChar
(
a
[
i
]
)
-
UnsignedChar
(
b
[
i
]
)
)
{
return
r
;
}
}
/
/
Return
zero
if
both
strings
are
equal
or
a
negative
number
if
|
b
|
is
a
/
/
prefix
of
|
a
|
.
return
-
int32_t
(
UnsignedChar
(
a
[
b
.
length
(
)
]
)
)
;
}
;
template
<
size_t
Length
>
static
inline
const
char
*
SearchReplacement
(
const
char
*
(
&
types
)
[
Length
]
const
char
*
(
&
aliases
)
[
Length
]
const
ConstCharRange
&
type
)
{
auto
p
=
std
:
:
lower_bound
(
std
:
:
begin
(
types
)
std
:
:
end
(
types
)
type
[
]
(
const
auto
&
a
const
auto
&
b
)
{
return
CompareUnicodeType
(
a
b
)
<
0
;
}
)
;
if
(
p
!
=
std
:
:
end
(
types
)
&
&
CompareUnicodeType
(
*
p
type
)
=
=
0
)
{
return
aliases
[
std
:
:
distance
(
std
:
:
begin
(
types
)
p
)
]
;
}
return
nullptr
;
}
/
*
*
*
Mapping
from
deprecated
BCP
47
Unicode
extension
types
to
their
preferred
*
values
.
*
*
Spec
:
https
:
/
/
www
.
unicode
.
org
/
reports
/
tr35
/
#
Unicode_Locale_Extension_Data_Files
*
/
const
char
*
js
:
:
intl
:
:
LanguageTag
:
:
replaceUnicodeExtensionType
(
const
ConstCharRange
&
key
const
ConstCharRange
&
type
)
{
#
ifdef
DEBUG
static
auto
isAsciiLowercaseAlphanumeric
=
[
]
(
char
c
)
{
return
mozilla
:
:
IsAsciiLowercaseAlpha
(
c
)
|
|
mozilla
:
:
IsAsciiDigit
(
c
)
;
}
;
static
auto
isAsciiLowercaseAlphanumericOrDash
=
[
]
(
char
c
)
{
return
isAsciiLowercaseAlphanumeric
(
c
)
|
|
c
=
=
'
-
'
;
}
;
#
endif
MOZ_ASSERT
(
key
.
length
(
)
=
=
UnicodeKeyLength
)
;
MOZ_ASSERT
(
std
:
:
all_of
(
key
.
begin
(
)
.
get
(
)
key
.
end
(
)
.
get
(
)
isAsciiLowercaseAlphanumeric
)
)
;
MOZ_ASSERT
(
type
.
length
(
)
>
UnicodeKeyLength
)
;
MOZ_ASSERT
(
std
:
:
all_of
(
type
.
begin
(
)
.
get
(
)
type
.
end
(
)
.
get
(
)
isAsciiLowercaseAlphanumericOrDash
)
)
;
if
(
IsUnicodeKey
(
key
"
ca
"
)
)
{
if
(
IsUnicodeType
(
type
"
ethiopic
-
amete
-
alem
"
)
)
{
return
"
ethioaa
"
;
}
if
(
IsUnicodeType
(
type
"
islamicc
"
)
)
{
return
"
islamic
-
civil
"
;
}
}
else
if
(
IsUnicodeKey
(
key
"
kb
"
)
|
|
IsUnicodeKey
(
key
"
kc
"
)
|
|
IsUnicodeKey
(
key
"
kh
"
)
|
|
IsUnicodeKey
(
key
"
kk
"
)
|
|
IsUnicodeKey
(
key
"
kn
"
)
)
{
if
(
IsUnicodeType
(
type
"
yes
"
)
)
{
return
"
true
"
;
}
}
else
if
(
IsUnicodeKey
(
key
"
ks
"
)
)
{
if
(
IsUnicodeType
(
type
"
primary
"
)
)
{
return
"
level1
"
;
}
if
(
IsUnicodeType
(
type
"
tertiary
"
)
)
{
return
"
level3
"
;
}
}
else
if
(
IsUnicodeKey
(
key
"
ms
"
)
)
{
if
(
IsUnicodeType
(
type
"
imperial
"
)
)
{
return
"
uksystem
"
;
}
}
else
if
(
IsUnicodeKey
(
key
"
rg
"
)
|
|
IsUnicodeKey
(
key
"
sd
"
)
)
{
static
const
char
*
types
[
116
]
=
{
"
cn11
"
"
cn12
"
"
cn13
"
"
cn14
"
"
cn15
"
"
cn21
"
"
cn22
"
"
cn23
"
"
cn31
"
"
cn32
"
"
cn33
"
"
cn34
"
"
cn35
"
"
cn36
"
"
cn37
"
"
cn41
"
"
cn42
"
"
cn43
"
"
cn44
"
"
cn45
"
"
cn46
"
"
cn50
"
"
cn51
"
"
cn52
"
"
cn53
"
"
cn54
"
"
cn61
"
"
cn62
"
"
cn63
"
"
cn64
"
"
cn65
"
"
cz10a
"
"
cz10b
"
"
cz10c
"
"
cz10d
"
"
cz10e
"
"
cz10f
"
"
cz611
"
"
cz612
"
"
cz613
"
"
cz614
"
"
cz615
"
"
cz621
"
"
cz622
"
"
cz623
"
"
cz624
"
"
cz626
"
"
cz627
"
"
czjc
"
"
czjm
"
"
czka
"
"
czkr
"
"
czli
"
"
czmo
"
"
czol
"
"
czpa
"
"
czpl
"
"
czpr
"
"
czst
"
"
czus
"
"
czvy
"
"
czzl
"
"
fra
"
"
frb
"
"
frc
"
"
frd
"
"
fre
"
"
frf
"
"
frg
"
"
frh
"
"
fri
"
"
frj
"
"
frk
"
"
frl
"
"
frm
"
"
frn
"
"
fro
"
"
frp
"
"
frq
"
"
frr
"
"
frs
"
"
frt
"
"
fru
"
"
frv
"
"
laxn
"
"
lud
"
"
lug
"
"
lul
"
"
mrnkc
"
"
nzn
"
"
nzs
"
"
omba
"
"
omsh
"
"
plds
"
"
plkp
"
"
pllb
"
"
plld
"
"
pllu
"
"
plma
"
"
plmz
"
"
plop
"
"
plpd
"
"
plpk
"
"
plpm
"
"
plsk
"
"
plsl
"
"
plwn
"
"
plwp
"
"
plzp
"
"
tteto
"
"
ttrcm
"
"
ttwto
"
"
twkhq
"
"
twtnq
"
"
twtpq
"
"
twtxq
"
}
;
static
const
char
*
aliases
[
116
]
=
{
"
cnbj
"
"
cntj
"
"
cnhe
"
"
cnsx
"
"
cnmn
"
"
cnln
"
"
cnjl
"
"
cnhl
"
"
cnsh
"
"
cnjs
"
"
cnzj
"
"
cnah
"
"
cnfj
"
"
cnjx
"
"
cnsd
"
"
cnha
"
"
cnhb
"
"
cnhn
"
"
cngd
"
"
cngx
"
"
cnhi
"
"
cncq
"
"
cnsc
"
"
cngz
"
"
cnyn
"
"
cnxz
"
"
cnsn
"
"
cngs
"
"
cnqh
"
"
cnnx
"
"
cnxj
"
"
cz110
"
"
cz111
"
"
cz112
"
"
cz113
"
"
cz114
"
"
cz115
"
"
cz663
"
"
cz632
"
"
cz633
"
"
cz634
"
"
cz635
"
"
cz641
"
"
cz642
"
"
cz643
"
"
cz644
"
"
cz646
"
"
cz647
"
"
cz31
"
"
cz64
"
"
cz41
"
"
cz52
"
"
cz51
"
"
cz80
"
"
cz71
"
"
cz53
"
"
cz32
"
"
cz10
"
"
cz20
"
"
cz42
"
"
cz63
"
"
cz72
"
"
frges
"
"
frnaq
"
"
frara
"
"
frbfc
"
"
frbre
"
"
frcvl
"
"
frges
"
"
frcor
"
"
frbfc
"
"
fridf
"
"
frocc
"
"
frnaq
"
"
frges
"
"
frocc
"
"
frhdf
"
"
frnor
"
"
frnor
"
"
frpdl
"
"
frhdf
"
"
frnaq
"
"
frpac
"
"
frara
"
"
laxs
"
"
lucl
"
"
luec
"
"
luca
"
"
mr13
"
"
nzauk
"
"
nzcan
"
"
ombj
"
"
omsj
"
"
pl02
"
"
pl04
"
"
pl08
"
"
pl10
"
"
pl06
"
"
pl12
"
"
pl14
"
"
pl16
"
"
pl20
"
"
pl18
"
"
pl22
"
"
pl26
"
"
pl24
"
"
pl28
"
"
pl30
"
"
pl32
"
"
tttob
"
"
ttmrc
"
"
tttob
"
"
twkhh
"
"
twtnn
"
"
twnwt
"
"
twtxg
"
}
;
return
SearchReplacement
(
types
aliases
type
)
;
}
else
if
(
IsUnicodeKey
(
key
"
tz
"
)
)
{
static
const
char
*
types
[
28
]
=
{
"
aqams
"
"
cnckg
"
"
cnhrb
"
"
cnkhg
"
"
cuba
"
"
egypt
"
"
eire
"
"
est
"
"
gmt0
"
"
hongkong
"
"
hst
"
"
iceland
"
"
iran
"
"
israel
"
"
jamaica
"
"
japan
"
"
libya
"
"
mst
"
"
navajo
"
"
poland
"
"
portugal
"
"
prc
"
"
roc
"
"
rok
"
"
turkey
"
"
uct
"
"
usnavajo
"
"
zulu
"
}
;
static
const
char
*
aliases
[
28
]
=
{
"
nzakl
"
"
cnsha
"
"
cnsha
"
"
cnurc
"
"
cuhav
"
"
egcai
"
"
iedub
"
"
utcw05
"
"
gmt
"
"
hkhkg
"
"
utcw10
"
"
isrey
"
"
irthr
"
"
jeruslm
"
"
jmkin
"
"
jptyo
"
"
lytip
"
"
utcw07
"
"
usden
"
"
plwaw
"
"
ptlis
"
"
cnsha
"
"
twtpe
"
"
krsel
"
"
trist
"
"
utc
"
"
usden
"
"
utc
"
}
;
return
SearchReplacement
(
types
aliases
type
)
;
}
return
nullptr
;
}
