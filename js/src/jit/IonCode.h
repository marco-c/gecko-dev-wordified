/
*
-
*
-
Mode
:
C
+
+
;
tab
-
width
:
8
;
indent
-
tabs
-
mode
:
nil
;
c
-
basic
-
offset
:
2
-
*
-
*
vim
:
set
ts
=
8
sts
=
2
et
sw
=
2
tw
=
80
:
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
#
ifndef
jit_IonCode_h
#
define
jit_IonCode_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
jstypes
.
h
"
#
include
"
jit
/
ExecutableAllocator
.
h
"
#
include
"
jit
/
ICStubSpace
.
h
"
#
include
"
jit
/
IonOptimizationLevels
.
h
"
#
include
"
jit
/
IonTypes
.
h
"
#
include
"
js
/
UbiNode
.
h
"
#
include
"
util
/
TrailingArray
.
h
"
#
include
"
vm
/
TraceLogging
.
h
"
namespace
js
{
namespace
jit
{
class
IonBuilder
;
class
JitAllocPolicy
;
class
JitCode
;
class
MacroAssembler
;
using
ObjectVector
=
Vector
<
JSObject
*
4
JitAllocPolicy
>
;
using
TraceLoggerEventVector
=
Vector
<
TraceLoggerEvent
0
SystemAllocPolicy
>
;
/
/
Header
at
start
of
raw
code
buffer
struct
JitCodeHeader
{
/
/
Link
back
to
corresponding
gcthing
JitCode
*
jitCode_
;
/
/
!
!
!
NOTE
!
!
!
/
/
If
we
are
running
on
AMD
Bobcat
insert
a
NOP
-
slide
at
end
of
the
JitCode
/
/
header
so
we
can
try
to
recover
when
the
CPU
screws
up
the
branch
landing
/
/
site
.
See
Bug
1281759
.
void
*
nops_
;
void
init
(
JitCode
*
jitCode
)
;
static
JitCodeHeader
*
FromExecutable
(
uint8_t
*
buffer
)
{
return
(
JitCodeHeader
*
)
(
buffer
-
sizeof
(
JitCodeHeader
)
)
;
}
}
;
class
JitCode
:
public
gc
:
:
TenuredCell
{
protected
:
using
CellHeaderWithCodePtr
=
gc
:
:
CellHeaderWithNonGCPointer
<
uint8_t
>
;
CellHeaderWithCodePtr
cellHeaderAndCode_
;
ExecutablePool
*
pool_
;
uint32_t
bufferSize_
;
/
/
Total
buffer
size
.
Does
not
include
headerSize_
.
uint32_t
insnSize_
;
/
/
Instruction
stream
size
.
uint32_t
dataSize_
;
/
/
Size
of
the
read
-
only
data
area
.
uint32_t
jumpRelocTableBytes_
;
/
/
Size
of
the
jump
relocation
table
.
uint32_t
dataRelocTableBytes_
;
/
/
Size
of
the
data
relocation
table
.
uint8_t
headerSize_
:
5
;
/
/
Number
of
bytes
allocated
before
codeStart
.
uint8_t
kind_
:
3
;
/
/
jit
:
:
CodeKind
for
the
memory
reporters
.
bool
invalidated_
:
1
;
/
/
Whether
the
code
object
has
been
invalidated
.
/
/
This
is
necessary
to
prevent
GC
tracing
.
bool
hasBytecodeMap_
:
1
;
/
/
Whether
the
code
object
has
been
registered
with
/
/
native
=
>
bytecode
mapping
tables
.
JitCode
(
)
=
delete
;
JitCode
(
uint8_t
*
code
uint32_t
bufferSize
uint32_t
headerSize
ExecutablePool
*
pool
CodeKind
kind
)
:
cellHeaderAndCode_
(
code
)
pool_
(
pool
)
bufferSize_
(
bufferSize
)
insnSize_
(
0
)
dataSize_
(
0
)
jumpRelocTableBytes_
(
0
)
dataRelocTableBytes_
(
0
)
headerSize_
(
headerSize
)
kind_
(
uint8_t
(
kind
)
)
invalidated_
(
false
)
hasBytecodeMap_
(
false
)
{
MOZ_ASSERT
(
CodeKind
(
kind_
)
=
=
kind
)
;
MOZ_ASSERT
(
headerSize_
=
=
headerSize
)
;
}
uint32_t
dataOffset
(
)
const
{
return
insnSize_
;
}
uint32_t
jumpRelocTableOffset
(
)
const
{
return
dataOffset
(
)
+
dataSize_
;
}
uint32_t
dataRelocTableOffset
(
)
const
{
return
jumpRelocTableOffset
(
)
+
jumpRelocTableBytes_
;
}
public
:
uint8_t
*
raw
(
)
const
{
return
cellHeaderAndCode_
.
ptr
(
)
;
}
uint8_t
*
rawEnd
(
)
const
{
return
raw
(
)
+
insnSize_
;
}
bool
containsNativePC
(
const
void
*
addr
)
const
{
const
uint8_t
*
addr_u8
=
(
const
uint8_t
*
)
addr
;
return
raw
(
)
<
=
addr_u8
&
&
addr_u8
<
rawEnd
(
)
;
}
size_t
instructionsSize
(
)
const
{
return
insnSize_
;
}
size_t
bufferSize
(
)
const
{
return
bufferSize_
;
}
size_t
headerSize
(
)
const
{
return
headerSize_
;
}
void
traceChildren
(
JSTracer
*
trc
)
;
void
finalize
(
JSFreeOp
*
fop
)
;
void
setInvalidated
(
)
{
invalidated_
=
true
;
}
void
setHasBytecodeMap
(
)
{
hasBytecodeMap_
=
true
;
}
/
/
If
this
JitCode
object
has
been
effectively
corrupted
due
to
/
/
invalidation
patching
then
we
have
to
remember
this
so
we
don
'
t
try
and
/
/
trace
relocation
entries
that
may
now
be
corrupt
.
bool
invalidated
(
)
const
{
return
!
!
invalidated_
;
}
template
<
typename
T
>
T
as
(
)
const
{
return
JS_DATA_TO_FUNC_PTR
(
T
raw
(
)
)
;
}
void
copyFrom
(
MacroAssembler
&
masm
)
;
static
JitCode
*
FromExecutable
(
uint8_t
*
buffer
)
{
JitCode
*
code
=
JitCodeHeader
:
:
FromExecutable
(
buffer
)
-
>
jitCode_
;
MOZ_ASSERT
(
code
-
>
raw
(
)
=
=
buffer
)
;
return
code
;
}
static
size_t
offsetOfCode
(
)
{
return
offsetof
(
JitCode
cellHeaderAndCode_
)
+
CellHeaderWithCodePtr
:
:
offsetOfPtr
(
)
;
}
uint8_t
*
jumpRelocTable
(
)
{
return
raw
(
)
+
jumpRelocTableOffset
(
)
;
}
/
/
Allocates
a
new
JitCode
object
which
will
be
managed
by
the
GC
.
If
no
/
/
object
can
be
allocated
nullptr
is
returned
.
On
failure
|
pool
|
is
/
/
automatically
released
so
the
code
may
be
freed
.
template
<
AllowGC
allowGC
>
static
JitCode
*
New
(
JSContext
*
cx
uint8_t
*
code
uint32_t
totalSize
uint32_t
headerSize
ExecutablePool
*
pool
CodeKind
kind
)
;
public
:
static
const
JS
:
:
TraceKind
TraceKind
=
JS
:
:
TraceKind
:
:
JitCode
;
const
gc
:
:
CellHeader
&
cellHeader
(
)
const
{
return
cellHeaderAndCode_
;
}
}
;
class
SnapshotWriter
;
class
RecoverWriter
;
class
SafepointWriter
;
class
CodegenSafepointIndex
;
class
SafepointIndex
;
class
OsiIndex
;
class
IonIC
;
/
/
An
IonScript
attaches
Ion
-
generated
information
to
a
JSScript
.
The
header
/
/
structure
is
followed
by
several
arrays
of
data
.
These
trailing
arrays
have
a
/
/
layout
based
on
offsets
(
bytes
from
'
this
'
)
stored
in
the
IonScript
header
.
/
/
/
/
<
IonScript
itself
>
/
/
-
-
/
/
PreBarrieredValue
[
]
constantTable
(
)
/
/
uint8_t
[
]
runtimeData
(
)
/
/
OsiIndex
[
]
osiIndex
(
)
/
/
SafepointIndex
[
]
safepointIndex
(
)
/
/
SnapshotOffset
[
]
bailoutTable
(
)
/
/
uint32_t
[
]
icIndex
(
)
/
/
-
-
/
/
uint8_t
[
]
safepoints
(
)
/
/
uint8_t
[
]
snapshots
(
)
/
/
uint8_t
[
]
snapshotsRVATable
(
)
/
/
uint8_t
[
]
recovers
(
)
/
/
/
/
Note
:
These
are
arranged
in
order
of
descending
alignment
requirements
to
/
/
avoid
the
need
for
padding
.
The
runtimeData
uses
uint64_t
alignement
due
to
/
/
its
use
of
mozilla
:
:
AlignedStorage2
.
struct
alignas
(
8
)
IonScript
final
:
public
TrailingArray
{
private
:
/
/
Offset
(
in
bytes
)
from
this
to
the
start
of
each
trailing
array
.
Each
/
/
array
ends
where
following
one
begins
.
There
is
no
implicit
padding
(
except
/
/
possible
at
very
end
)
.
Offset
constantTableOffset_
=
0
;
/
/
JS
:
:
Value
aligned
Offset
runtimeDataOffset_
=
0
;
/
/
uint64_t
aligned
Offset
osiIndexOffset_
=
0
;
Offset
safepointIndexOffset_
=
0
;
Offset
bailoutTableOffset_
=
0
;
Offset
icIndexOffset_
=
0
;
Offset
safepointsOffset_
=
0
;
Offset
snapshotsOffset_
=
0
;
Offset
rvaTableOffset_
=
0
;
Offset
recoversOffset_
=
0
;
Offset
allocBytes_
=
0
;
/
/
Code
pointer
containing
the
actual
method
.
HeapPtrJitCode
method_
=
nullptr
;
/
/
Entrypoint
for
OSR
or
nullptr
.
jsbytecode
*
osrPc_
=
nullptr
;
/
/
Offset
to
OSR
entrypoint
from
method_
-
>
raw
(
)
or
0
.
uint32_t
osrEntryOffset_
=
0
;
/
/
Offset
to
entrypoint
skipping
type
arg
check
from
method_
-
>
raw
(
)
.
uint32_t
skipArgCheckEntryOffset_
=
0
;
/
/
Offset
of
the
invalidation
epilogue
(
which
pushes
this
IonScript
/
/
and
calls
the
invalidation
thunk
)
.
uint32_t
invalidateEpilogueOffset_
=
0
;
/
/
The
offset
immediately
after
the
IonScript
immediate
.
/
/
NOTE
:
technically
a
constant
delta
from
/
/
|
invalidateEpilogueOffset_
|
so
we
could
hard
-
code
this
/
/
per
-
platform
if
we
want
.
uint32_t
invalidateEpilogueDataOffset_
=
0
;
/
/
Number
of
times
this
script
bailed
out
without
invalidation
.
uint32_t
numBailouts_
=
0
;
/
/
Flag
set
if
IonScript
was
compiled
with
profiling
enabled
.
bool
hasProfilingInstrumentation_
=
false
;
/
/
Flag
for
if
this
script
is
getting
recompiled
.
uint32_t
recompiling_
=
0
;
/
/
Number
of
bytes
this
function
reserves
on
the
stack
.
uint32_t
frameSlots_
=
0
;
/
/
Number
of
bytes
used
passed
in
as
formal
arguments
or
|
this
|
.
uint32_t
argumentSlots_
=
0
;
/
/
Frame
size
is
the
value
that
can
be
added
to
the
StackPointer
along
/
/
with
the
frame
prefix
to
get
a
valid
JitFrameLayout
.
uint32_t
frameSize_
=
0
;
/
/
Number
of
references
from
invalidation
records
.
uint32_t
invalidationCount_
=
0
;
/
/
Identifier
of
the
compilation
which
produced
this
code
.
IonCompilationId
compilationId_
;
/
/
The
optimization
level
this
script
was
compiled
in
.
OptimizationLevel
optimizationLevel_
;
/
/
Number
of
times
we
tried
to
enter
this
script
via
OSR
but
failed
due
to
/
/
a
LOOPENTRY
pc
other
than
osrPc_
.
uint32_t
osrPcMismatchCounter_
=
0
;
/
/
TraceLogger
events
that
are
baked
into
the
IonScript
.
TraceLoggerEventVector
traceLoggerEvents_
;
/
/
End
of
fields
.
private
:
inline
uint8_t
*
bottomBuffer
(
)
{
return
reinterpret_cast
<
uint8_t
*
>
(
this
)
;
}
inline
const
uint8_t
*
bottomBuffer
(
)
const
{
return
reinterpret_cast
<
const
uint8_t
*
>
(
this
)
;
}
/
/
Layout
helpers
Offset
constantTableOffset
(
)
const
{
return
constantTableOffset_
;
}
Offset
runtimeDataOffset
(
)
const
{
return
runtimeDataOffset_
;
}
Offset
osiIndexOffset
(
)
const
{
return
osiIndexOffset_
;
}
Offset
safepointIndexOffset
(
)
const
{
return
safepointIndexOffset_
;
}
Offset
bailoutTableOffset
(
)
const
{
return
bailoutTableOffset_
;
}
Offset
icIndexOffset
(
)
const
{
return
icIndexOffset_
;
}
Offset
safepointsOffset
(
)
const
{
return
safepointsOffset_
;
}
Offset
snapshotsOffset
(
)
const
{
return
snapshotsOffset_
;
}
Offset
rvaTableOffset
(
)
const
{
return
rvaTableOffset_
;
}
Offset
recoversOffset
(
)
const
{
return
recoversOffset_
;
}
Offset
endOffset
(
)
const
{
return
allocBytes_
;
}
/
/
Hardcode
size
of
incomplete
types
.
These
are
verified
in
Ion
.
cpp
.
static
constexpr
size_t
SizeOf_OsiIndex
=
2
*
sizeof
(
uint32_t
)
;
static
constexpr
size_t
SizeOf_SafepointIndex
=
2
*
sizeof
(
uint32_t
)
;
static
constexpr
size_t
SizeOf_SnapshotOffset
=
sizeof
(
uint32_t
)
;
public
:
/
/
/
/
Table
of
constants
referenced
in
snapshots
.
(
JS
:
:
Value
alignment
)
/
/
PreBarrieredValue
*
constants
(
)
{
/
/
Nursery
constants
are
manually
barriered
in
CodeGenerator
:
:
link
(
)
so
a
/
/
post
barrier
is
not
required
.
.
return
offsetToPointer
<
PreBarrieredValue
>
(
constantTableOffset
(
)
)
;
}
size_t
numConstants
(
)
const
{
return
(
runtimeDataOffset
(
)
-
constantTableOffset
(
)
)
/
sizeof
(
PreBarrieredValue
)
;
}
/
/
/
/
IonIC
data
structures
.
(
uint64_t
alignment
)
/
/
uint8_t
*
runtimeData
(
)
{
return
offsetToPointer
<
uint8_t
>
(
runtimeDataOffset
(
)
)
;
}
size_t
runtimeSize
(
)
const
{
return
(
osiIndexOffset
(
)
-
runtimeDataOffset
(
)
)
/
sizeof
(
uint8_t
)
;
}
/
/
/
/
Map
OSI
-
point
displacement
to
snapshot
.
/
/
OsiIndex
*
osiIndices
(
)
{
return
offsetToPointer
<
OsiIndex
>
(
osiIndexOffset
(
)
)
;
}
const
OsiIndex
*
osiIndices
(
)
const
{
return
offsetToPointer
<
OsiIndex
>
(
osiIndexOffset
(
)
)
;
}
size_t
numOsiIndices
(
)
const
{
return
(
safepointIndexOffset
(
)
-
osiIndexOffset
(
)
)
/
SizeOf_OsiIndex
;
}
/
/
/
/
Map
code
displacement
to
safepoint
/
OSI
-
patch
-
delta
.
/
/
SafepointIndex
*
safepointIndices
(
)
{
return
offsetToPointer
<
SafepointIndex
>
(
safepointIndexOffset
(
)
)
;
}
const
SafepointIndex
*
safepointIndices
(
)
const
{
return
offsetToPointer
<
SafepointIndex
>
(
safepointIndexOffset
(
)
)
;
}
size_t
numSafepointIndices
(
)
const
{
return
(
bailoutTableOffset
(
)
-
safepointIndexOffset
(
)
)
/
SizeOf_SafepointIndex
;
}
/
/
/
/
Table
mapping
bailout
IDs
to
snapshot
offsets
.
/
/
SnapshotOffset
*
bailoutTable
(
)
{
return
offsetToPointer
<
SnapshotOffset
>
(
bailoutTableOffset
(
)
)
;
}
size_t
numBailoutEntries
(
)
const
{
return
(
icIndexOffset
(
)
-
bailoutTableOffset
(
)
)
/
SizeOf_SnapshotOffset
;
}
/
/
/
/
Offset
into
runtimeData
for
each
(
variable
-
length
)
IonIC
.
/
/
uint32_t
*
icIndex
(
)
{
return
offsetToPointer
<
uint32_t
>
(
icIndexOffset
(
)
)
;
}
size_t
numICs
(
)
const
{
return
(
safepointsOffset
(
)
-
icIndexOffset
(
)
)
/
sizeof
(
uint32_t
)
;
}
/
/
/
/
Safepoint
table
as
a
CompactBuffer
.
/
/
const
uint8_t
*
safepoints
(
)
const
{
return
offsetToPointer
<
uint8_t
>
(
safepointsOffset
(
)
)
;
}
size_t
safepointsSize
(
)
const
{
return
(
snapshotsOffset
(
)
-
safepointsOffset
(
)
)
/
sizeof
(
uint8_t
)
;
}
/
/
/
/
Snapshot
and
RValueAllocation
tables
as
CompactBuffers
.
/
/
const
uint8_t
*
snapshots
(
)
const
{
return
offsetToPointer
<
uint8_t
>
(
snapshotsOffset
(
)
)
;
}
size_t
snapshotsListSize
(
)
const
{
return
(
rvaTableOffset
(
)
-
snapshotsOffset
(
)
)
/
sizeof
(
uint8_t
)
;
}
size_t
snapshotsRVATableSize
(
)
const
{
return
(
recoversOffset
(
)
-
rvaTableOffset
(
)
)
/
sizeof
(
uint8_t
)
;
}
/
/
/
/
Recover
instruction
table
as
a
CompactBuffer
.
/
/
const
uint8_t
*
recovers
(
)
const
{
return
offsetToPointer
<
uint8_t
>
(
recoversOffset
(
)
)
;
}
size_t
recoversSize
(
)
const
{
return
(
endOffset
(
)
-
recoversOffset
(
)
)
/
sizeof
(
uint8_t
)
;
}
private
:
IonScript
(
IonCompilationId
compilationId
uint32_t
frameSlots
uint32_t
argumentSlots
uint32_t
frameSize
OptimizationLevel
optimizationLevel
)
;
public
:
static
IonScript
*
New
(
JSContext
*
cx
IonCompilationId
compilationId
uint32_t
frameSlots
uint32_t
argumentSlots
uint32_t
frameSize
size_t
snapshotsListSize
size_t
snapshotsRVATableSize
size_t
recoversSize
size_t
bailoutEntries
size_t
constants
size_t
safepointIndexEntries
size_t
osiIndexEntries
size_t
icEntries
size_t
runtimeSize
size_t
safepointsSize
OptimizationLevel
optimizationLevel
)
;
static
void
Destroy
(
JSFreeOp
*
fop
IonScript
*
script
)
;
void
trace
(
JSTracer
*
trc
)
;
static
inline
size_t
offsetOfMethod
(
)
{
return
offsetof
(
IonScript
method_
)
;
}
static
inline
size_t
offsetOfOsrEntryOffset
(
)
{
return
offsetof
(
IonScript
osrEntryOffset_
)
;
}
static
inline
size_t
offsetOfSkipArgCheckEntryOffset
(
)
{
return
offsetof
(
IonScript
skipArgCheckEntryOffset_
)
;
}
static
inline
size_t
offsetOfInvalidationCount
(
)
{
return
offsetof
(
IonScript
invalidationCount_
)
;
}
static
inline
size_t
offsetOfRecompiling
(
)
{
return
offsetof
(
IonScript
recompiling_
)
;
}
public
:
JitCode
*
method
(
)
const
{
return
method_
;
}
void
setMethod
(
JitCode
*
code
)
{
MOZ_ASSERT
(
!
invalidated
(
)
)
;
method_
=
code
;
}
void
setOsrPc
(
jsbytecode
*
osrPc
)
{
osrPc_
=
osrPc
;
}
jsbytecode
*
osrPc
(
)
const
{
return
osrPc_
;
}
void
setOsrEntryOffset
(
uint32_t
offset
)
{
MOZ_ASSERT
(
!
osrEntryOffset_
)
;
osrEntryOffset_
=
offset
;
}
uint32_t
osrEntryOffset
(
)
const
{
return
osrEntryOffset_
;
}
void
setSkipArgCheckEntryOffset
(
uint32_t
offset
)
{
MOZ_ASSERT
(
!
skipArgCheckEntryOffset_
)
;
skipArgCheckEntryOffset_
=
offset
;
}
uint32_t
getSkipArgCheckEntryOffset
(
)
const
{
return
skipArgCheckEntryOffset_
;
}
bool
containsCodeAddress
(
uint8_t
*
addr
)
const
{
return
method
(
)
-
>
raw
(
)
<
=
addr
&
&
addr
<
=
method
(
)
-
>
raw
(
)
+
method
(
)
-
>
instructionsSize
(
)
;
}
bool
containsReturnAddress
(
uint8_t
*
addr
)
const
{
/
/
This
accounts
for
an
off
by
one
error
caused
by
the
return
address
of
a
/
/
bailout
sitting
outside
the
range
of
the
containing
function
.
return
method
(
)
-
>
raw
(
)
<
=
addr
&
&
addr
<
=
method
(
)
-
>
raw
(
)
+
method
(
)
-
>
instructionsSize
(
)
;
}
void
setInvalidationEpilogueOffset
(
uint32_t
offset
)
{
MOZ_ASSERT
(
!
invalidateEpilogueOffset_
)
;
invalidateEpilogueOffset_
=
offset
;
}
uint32_t
invalidateEpilogueOffset
(
)
const
{
MOZ_ASSERT
(
invalidateEpilogueOffset_
)
;
return
invalidateEpilogueOffset_
;
}
void
setInvalidationEpilogueDataOffset
(
uint32_t
offset
)
{
MOZ_ASSERT
(
!
invalidateEpilogueDataOffset_
)
;
invalidateEpilogueDataOffset_
=
offset
;
}
uint32_t
invalidateEpilogueDataOffset
(
)
const
{
MOZ_ASSERT
(
invalidateEpilogueDataOffset_
)
;
return
invalidateEpilogueDataOffset_
;
}
void
incNumBailouts
(
)
{
numBailouts_
+
+
;
}
bool
bailoutExpected
(
)
const
{
return
numBailouts_
>
=
JitOptions
.
frequentBailoutThreshold
;
}
void
setHasProfilingInstrumentation
(
)
{
hasProfilingInstrumentation_
=
true
;
}
void
clearHasProfilingInstrumentation
(
)
{
hasProfilingInstrumentation_
=
false
;
}
bool
hasProfilingInstrumentation
(
)
const
{
return
hasProfilingInstrumentation_
;
}
MOZ_MUST_USE
bool
addTraceLoggerEvent
(
TraceLoggerEvent
&
event
)
{
MOZ_ASSERT
(
event
.
hasTextId
(
)
)
;
return
traceLoggerEvents_
.
append
(
std
:
:
move
(
event
)
)
;
}
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
this
)
;
}
PreBarrieredValue
&
getConstant
(
size_t
index
)
{
MOZ_ASSERT
(
index
<
numConstants
(
)
)
;
return
constants
(
)
[
index
]
;
}
uint32_t
frameSlots
(
)
const
{
return
frameSlots_
;
}
uint32_t
argumentSlots
(
)
const
{
return
argumentSlots_
;
}
uint32_t
frameSize
(
)
const
{
return
frameSize_
;
}
SnapshotOffset
bailoutToSnapshot
(
uint32_t
bailoutId
)
{
MOZ_ASSERT
(
bailoutId
<
numBailoutEntries
(
)
)
;
return
bailoutTable
(
)
[
bailoutId
]
;
}
const
SafepointIndex
*
getSafepointIndex
(
uint32_t
disp
)
const
;
const
SafepointIndex
*
getSafepointIndex
(
uint8_t
*
retAddr
)
const
{
MOZ_ASSERT
(
containsCodeAddress
(
retAddr
)
)
;
return
getSafepointIndex
(
retAddr
-
method
(
)
-
>
raw
(
)
)
;
}
const
OsiIndex
*
getOsiIndex
(
uint32_t
disp
)
const
;
const
OsiIndex
*
getOsiIndex
(
uint8_t
*
retAddr
)
const
;
IonIC
&
getICFromIndex
(
uint32_t
index
)
{
MOZ_ASSERT
(
index
<
numICs
(
)
)
;
uint32_t
offset
=
icIndex
(
)
[
index
]
;
return
getIC
(
offset
)
;
}
inline
IonIC
&
getIC
(
uint32_t
offset
)
{
MOZ_ASSERT
(
offset
<
runtimeSize
(
)
)
;
return
*
reinterpret_cast
<
IonIC
*
>
(
runtimeData
(
)
+
offset
)
;
}
void
purgeICs
(
Zone
*
zone
)
;
void
copySnapshots
(
const
SnapshotWriter
*
writer
)
;
void
copyRecovers
(
const
RecoverWriter
*
writer
)
;
void
copyBailoutTable
(
const
SnapshotOffset
*
table
)
;
void
copyConstants
(
const
Value
*
vp
)
;
void
copySafepointIndices
(
const
CodegenSafepointIndex
*
firstSafepointIndex
)
;
void
copyOsiIndices
(
const
OsiIndex
*
firstOsiIndex
)
;
void
copyRuntimeData
(
const
uint8_t
*
data
)
;
void
copyICEntries
(
const
uint32_t
*
caches
)
;
void
copySafepoints
(
const
SafepointWriter
*
writer
)
;
bool
invalidated
(
)
const
{
return
invalidationCount_
!
=
0
;
}
/
/
Invalidate
the
current
compilation
.
void
invalidate
(
JSContext
*
cx
JSScript
*
script
bool
resetUses
const
char
*
reason
)
;
size_t
invalidationCount
(
)
const
{
return
invalidationCount_
;
}
void
incrementInvalidationCount
(
)
{
invalidationCount_
+
+
;
}
void
decrementInvalidationCount
(
JSFreeOp
*
fop
)
{
MOZ_ASSERT
(
invalidationCount_
)
;
invalidationCount_
-
-
;
if
(
!
invalidationCount_
)
{
Destroy
(
fop
this
)
;
}
}
IonCompilationId
compilationId
(
)
const
{
return
compilationId_
;
}
OptimizationLevel
optimizationLevel
(
)
const
{
return
optimizationLevel_
;
}
uint32_t
incrOsrPcMismatchCounter
(
)
{
return
+
+
osrPcMismatchCounter_
;
}
void
resetOsrPcMismatchCounter
(
)
{
osrPcMismatchCounter_
=
0
;
}
void
setRecompiling
(
)
{
recompiling_
=
true
;
}
bool
isRecompiling
(
)
const
{
return
recompiling_
;
}
void
clearRecompiling
(
)
{
recompiling_
=
false
;
}
size_t
allocBytes
(
)
const
{
return
allocBytes_
;
}
enum
ShouldIncreaseAge
{
IncreaseAge
=
true
KeepAge
=
false
}
;
static
void
writeBarrierPre
(
Zone
*
zone
IonScript
*
ionScript
)
;
}
;
/
/
Execution
information
for
a
basic
block
which
may
persist
after
the
/
/
accompanying
IonScript
is
destroyed
for
use
during
profiling
.
struct
IonBlockCounts
{
private
:
uint32_t
id_
;
/
/
Approximate
bytecode
in
the
outer
(
not
inlined
)
script
this
block
/
/
was
generated
from
.
uint32_t
offset_
;
/
/
File
and
line
of
the
inner
script
this
block
was
generated
from
.
char
*
description_
;
/
/
ids
for
successors
of
this
block
.
uint32_t
numSuccessors_
;
uint32_t
*
successors_
;
/
/
Hit
count
for
this
block
.
uint64_t
hitCount_
;
/
/
Text
information
about
the
code
generated
for
this
block
.
char
*
code_
;
public
:
MOZ_MUST_USE
bool
init
(
uint32_t
id
uint32_t
offset
char
*
description
uint32_t
numSuccessors
)
{
id_
=
id
;
offset_
=
offset
;
description_
=
description
;
numSuccessors_
=
numSuccessors
;
if
(
numSuccessors
)
{
successors_
=
js_pod_calloc
<
uint32_t
>
(
numSuccessors
)
;
if
(
!
successors_
)
{
return
false
;
}
}
return
true
;
}
void
destroy
(
)
{
js_free
(
description_
)
;
js_free
(
successors_
)
;
js_free
(
code_
)
;
}
uint32_t
id
(
)
const
{
return
id_
;
}
uint32_t
offset
(
)
const
{
return
offset_
;
}
const
char
*
description
(
)
const
{
return
description_
;
}
size_t
numSuccessors
(
)
const
{
return
numSuccessors_
;
}
void
setSuccessor
(
size_t
i
uint32_t
id
)
{
MOZ_ASSERT
(
i
<
numSuccessors_
)
;
successors_
[
i
]
=
id
;
}
uint32_t
successor
(
size_t
i
)
const
{
MOZ_ASSERT
(
i
<
numSuccessors_
)
;
return
successors_
[
i
]
;
}
uint64_t
*
addressOfHitCount
(
)
{
return
&
hitCount_
;
}
uint64_t
hitCount
(
)
const
{
return
hitCount_
;
}
void
setCode
(
const
char
*
code
)
{
char
*
ncode
=
js_pod_malloc
<
char
>
(
strlen
(
code
)
+
1
)
;
if
(
ncode
)
{
strcpy
(
ncode
code
)
;
code_
=
ncode
;
}
}
const
char
*
code
(
)
const
{
return
code_
;
}
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
return
mallocSizeOf
(
description_
)
+
mallocSizeOf
(
successors_
)
+
mallocSizeOf
(
code_
)
;
}
}
;
/
/
Execution
information
for
a
compiled
script
which
may
persist
after
the
/
/
IonScript
is
destroyed
for
use
during
profiling
.
struct
IonScriptCounts
{
private
:
/
/
Any
previous
invalidated
compilation
(
s
)
for
the
script
.
IonScriptCounts
*
previous_
=
nullptr
;
/
/
Information
about
basic
blocks
in
this
script
.
size_t
numBlocks_
=
0
;
IonBlockCounts
*
blocks_
=
nullptr
;
public
:
IonScriptCounts
(
)
=
default
;
~
IonScriptCounts
(
)
{
for
(
size_t
i
=
0
;
i
<
numBlocks_
;
i
+
+
)
{
blocks_
[
i
]
.
destroy
(
)
;
}
js_free
(
blocks_
)
;
/
/
The
list
can
be
long
in
some
corner
cases
(
bug
1140084
)
so
/
/
unroll
the
recursion
.
IonScriptCounts
*
victims
=
previous_
;
while
(
victims
)
{
IonScriptCounts
*
victim
=
victims
;
victims
=
victim
-
>
previous_
;
victim
-
>
previous_
=
nullptr
;
js_delete
(
victim
)
;
}
}
MOZ_MUST_USE
bool
init
(
size_t
numBlocks
)
{
blocks_
=
js_pod_calloc
<
IonBlockCounts
>
(
numBlocks
)
;
if
(
!
blocks_
)
{
return
false
;
}
numBlocks_
=
numBlocks
;
return
true
;
}
size_t
numBlocks
(
)
const
{
return
numBlocks_
;
}
IonBlockCounts
&
block
(
size_t
i
)
{
MOZ_ASSERT
(
i
<
numBlocks_
)
;
return
blocks_
[
i
]
;
}
void
setPrevious
(
IonScriptCounts
*
previous
)
{
previous_
=
previous
;
}
IonScriptCounts
*
previous
(
)
const
{
return
previous_
;
}
size_t
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
size_t
size
=
0
;
auto
currCounts
=
this
;
do
{
size
+
=
currCounts
-
>
sizeOfOneIncludingThis
(
mallocSizeOf
)
;
currCounts
=
currCounts
-
>
previous_
;
}
while
(
currCounts
)
;
return
size
;
}
size_t
sizeOfOneIncludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
{
size_t
size
=
mallocSizeOf
(
this
)
+
mallocSizeOf
(
blocks_
)
;
for
(
size_t
i
=
0
;
i
<
numBlocks_
;
i
+
+
)
{
blocks_
[
i
]
.
sizeOfExcludingThis
(
mallocSizeOf
)
;
}
return
size
;
}
}
;
struct
VMFunction
;
}
/
/
namespace
jit
namespace
gc
{
inline
bool
IsMarked
(
JSRuntime
*
rt
const
jit
:
:
VMFunction
*
)
{
/
/
VMFunction
are
only
static
objects
which
are
used
by
WeakMaps
as
keys
.
/
/
It
is
considered
as
a
root
object
which
is
always
marked
.
return
true
;
}
}
/
/
namespace
gc
}
/
/
namespace
js
/
/
JS
:
:
ubi
:
:
Nodes
can
point
to
js
:
:
jit
:
:
JitCode
instances
;
they
'
re
js
:
:
gc
:
:
Cell
/
/
instances
with
no
associated
compartment
.
namespace
JS
{
namespace
ubi
{
template
<
>
class
Concrete
<
js
:
:
jit
:
:
JitCode
>
:
TracerConcrete
<
js
:
:
jit
:
:
JitCode
>
{
protected
:
explicit
Concrete
(
js
:
:
jit
:
:
JitCode
*
ptr
)
:
TracerConcrete
<
js
:
:
jit
:
:
JitCode
>
(
ptr
)
{
}
public
:
static
void
construct
(
void
*
storage
js
:
:
jit
:
:
JitCode
*
ptr
)
{
new
(
storage
)
Concrete
(
ptr
)
;
}
CoarseType
coarseType
(
)
const
final
{
return
CoarseType
:
:
Script
;
}
Size
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
override
{
Size
size
=
js
:
:
gc
:
:
Arena
:
:
thingSize
(
get
(
)
.
asTenured
(
)
.
getAllocKind
(
)
)
;
size
+
=
get
(
)
.
bufferSize
(
)
;
size
+
=
get
(
)
.
headerSize
(
)
;
return
size
;
}
const
char16_t
*
typeName
(
)
const
override
{
return
concreteTypeName
;
}
static
const
char16_t
concreteTypeName
[
]
;
}
;
}
/
/
namespace
ubi
template
<
>
struct
DeletePolicy
<
js
:
:
jit
:
:
IonScript
>
{
explicit
DeletePolicy
(
JSRuntime
*
rt
)
:
rt_
(
rt
)
{
}
void
operator
(
)
(
const
js
:
:
jit
:
:
IonScript
*
script
)
;
private
:
JSRuntime
*
rt_
;
}
;
}
/
/
namespace
JS
#
endif
/
*
jit_IonCode_h
*
/
