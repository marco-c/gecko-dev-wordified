/
*
-
*
-
Mode
:
C
+
+
;
tab
-
width
:
8
;
indent
-
tabs
-
mode
:
nil
;
c
-
basic
-
offset
:
2
-
*
-
*
vim
:
set
ts
=
8
sts
=
2
et
sw
=
2
tw
=
80
:
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
#
include
"
jit
/
WarpBuilder
.
h
"
#
include
"
jit
/
MIR
.
h
"
#
include
"
jit
/
MIRGenerator
.
h
"
#
include
"
jit
/
MIRGraph
.
h
"
#
include
"
jit
/
WarpOracle
.
h
"
#
include
"
jit
/
JitScript
-
inl
.
h
"
#
include
"
vm
/
BytecodeIterator
-
inl
.
h
"
#
include
"
vm
/
BytecodeLocation
-
inl
.
h
"
using
namespace
js
;
using
namespace
js
:
:
jit
;
WarpBuilder
:
:
WarpBuilder
(
WarpSnapshot
&
snapshot
MIRGenerator
&
mirGen
)
:
snapshot_
(
snapshot
)
mirGen_
(
mirGen
)
graph_
(
mirGen
.
graph
(
)
)
alloc_
(
mirGen
.
alloc
(
)
)
info_
(
mirGen
.
outerInfo
(
)
)
script_
(
snapshot
.
script
(
)
-
>
script
(
)
)
loopStack_
(
alloc_
)
{
opSnapshotIter_
=
snapshot
.
script
(
)
-
>
opSnapshots
(
)
.
getFirst
(
)
;
}
MConstant
*
WarpBuilder
:
:
constant
(
const
Value
&
v
)
{
MOZ_ASSERT_IF
(
v
.
isString
(
)
v
.
toString
(
)
-
>
isAtom
(
)
)
;
MOZ_ASSERT_IF
(
v
.
isGCThing
(
)
!
IsInsideNursery
(
v
.
toGCThing
(
)
)
)
;
MConstant
*
c
=
MConstant
:
:
New
(
alloc
(
)
v
)
;
current
-
>
add
(
c
)
;
return
c
;
}
void
WarpBuilder
:
:
pushConstant
(
const
Value
&
v
)
{
MConstant
*
c
=
constant
(
v
)
;
current
-
>
push
(
c
)
;
}
BytecodeSite
*
WarpBuilder
:
:
newBytecodeSite
(
BytecodeLocation
loc
)
{
jsbytecode
*
pc
=
loc
.
toRawBytecode
(
)
;
MOZ_ASSERT
(
info
(
)
.
inlineScriptTree
(
)
-
>
script
(
)
-
>
containsPC
(
pc
)
)
;
return
new
(
alloc
(
)
)
BytecodeSite
(
info
(
)
.
inlineScriptTree
(
)
pc
)
;
}
const
WarpOpSnapshot
*
WarpBuilder
:
:
getOpSnapshotImpl
(
BytecodeLocation
loc
)
{
uint32_t
offset
=
loc
.
bytecodeToOffset
(
script_
)
;
/
/
Skip
snapshots
until
we
get
to
a
snapshot
with
offset
>
=
offset
.
This
is
/
/
a
loop
because
WarpBuilder
can
skip
unreachable
bytecode
ops
.
while
(
opSnapshotIter_
&
&
opSnapshotIter_
-
>
offset
(
)
<
offset
)
{
opSnapshotIter_
=
opSnapshotIter_
-
>
getNext
(
)
;
}
if
(
!
opSnapshotIter_
|
|
opSnapshotIter_
-
>
offset
(
)
!
=
offset
)
{
return
nullptr
;
}
return
opSnapshotIter_
;
}
void
WarpBuilder
:
:
initBlock
(
MBasicBlock
*
block
)
{
graph
(
)
.
addBlock
(
block
)
;
/
/
TODO
:
set
block
hit
count
(
for
branch
pruning
pass
)
block
-
>
setLoopDepth
(
loopDepth_
)
;
current
=
block
;
}
bool
WarpBuilder
:
:
startNewBlock
(
MBasicBlock
*
predecessor
BytecodeLocation
loc
size_t
numToPop
)
{
MBasicBlock
*
block
=
MBasicBlock
:
:
NewPopN
(
graph
(
)
info
(
)
predecessor
newBytecodeSite
(
loc
)
MBasicBlock
:
:
NORMAL
numToPop
)
;
if
(
!
block
)
{
return
false
;
}
initBlock
(
block
)
;
return
true
;
}
bool
WarpBuilder
:
:
startNewEntryBlock
(
size_t
stackDepth
BytecodeLocation
loc
)
{
MBasicBlock
*
block
=
MBasicBlock
:
:
New
(
graph
(
)
stackDepth
info
(
)
/
*
maybePred
=
*
/
nullptr
newBytecodeSite
(
loc
)
MBasicBlock
:
:
NORMAL
)
;
if
(
!
block
)
{
return
false
;
}
initBlock
(
block
)
;
return
true
;
}
bool
WarpBuilder
:
:
startNewLoopHeaderBlock
(
MBasicBlock
*
predecessor
BytecodeLocation
loc
)
{
MBasicBlock
*
header
=
MBasicBlock
:
:
NewPendingLoopHeader
(
graph
(
)
info
(
)
predecessor
newBytecodeSite
(
loc
)
)
;
if
(
!
header
)
{
return
false
;
}
initBlock
(
header
)
;
return
loopStack_
.
emplaceBack
(
header
)
;
}
bool
WarpBuilder
:
:
addPendingEdge
(
const
PendingEdge
&
edge
BytecodeLocation
target
)
{
jsbytecode
*
targetPC
=
target
.
toRawBytecode
(
)
;
PendingEdgesMap
:
:
AddPtr
p
=
pendingEdges_
.
lookupForAdd
(
targetPC
)
;
if
(
p
)
{
return
p
-
>
value
(
)
.
append
(
edge
)
;
}
PendingEdges
edges
;
static_assert
(
PendingEdges
:
:
InlineLength
>
=
1
"
Appending
one
element
should
be
infallible
"
)
;
MOZ_ALWAYS_TRUE
(
edges
.
append
(
edge
)
)
;
return
pendingEdges_
.
add
(
p
targetPC
std
:
:
move
(
edges
)
)
;
}
bool
WarpBuilder
:
:
resumeAfter
(
MInstruction
*
ins
BytecodeLocation
loc
)
{
MOZ_ASSERT
(
ins
-
>
isEffectful
(
)
)
;
MResumePoint
*
resumePoint
=
MResumePoint
:
:
New
(
alloc
(
)
ins
-
>
block
(
)
loc
.
toRawBytecode
(
)
MResumePoint
:
:
ResumeAfter
)
;
if
(
!
resumePoint
)
{
return
false
;
}
ins
-
>
setResumePoint
(
resumePoint
)
;
return
true
;
}
bool
WarpBuilder
:
:
build
(
)
{
if
(
!
buildPrologue
(
)
)
{
return
false
;
}
if
(
!
buildBody
(
)
)
{
return
false
;
}
if
(
!
buildEpilogue
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
loopStack_
.
empty
(
)
)
;
MOZ_ASSERT
(
loopDepth_
=
=
0
)
;
return
true
;
}
MInstruction
*
WarpBuilder
:
:
buildNamedLambdaEnv
(
MDefinition
*
callee
MDefinition
*
env
LexicalEnvironmentObject
*
templateObj
)
{
MOZ_ASSERT
(
!
templateObj
-
>
hasDynamicSlots
(
)
)
;
MInstruction
*
namedLambda
=
MNewNamedLambdaObject
:
:
New
(
alloc
(
)
templateObj
)
;
current
-
>
add
(
namedLambda
)
;
/
/
Initialize
the
object
'
s
reserved
slots
.
No
post
barrier
is
needed
here
:
/
/
the
object
will
be
allocated
in
the
nursery
if
possible
and
if
the
/
/
tenured
heap
is
used
instead
a
minor
collection
will
have
been
performed
/
/
that
moved
env
/
callee
to
the
tenured
heap
.
size_t
enclosingSlot
=
NamedLambdaObject
:
:
enclosingEnvironmentSlot
(
)
;
size_t
lambdaSlot
=
NamedLambdaObject
:
:
lambdaSlot
(
)
;
current
-
>
add
(
MStoreFixedSlot
:
:
New
(
alloc
(
)
namedLambda
enclosingSlot
env
)
)
;
current
-
>
add
(
MStoreFixedSlot
:
:
New
(
alloc
(
)
namedLambda
lambdaSlot
callee
)
)
;
return
namedLambda
;
}
MInstruction
*
WarpBuilder
:
:
buildCallObject
(
MDefinition
*
callee
MDefinition
*
env
CallObject
*
templateObj
)
{
MConstant
*
templateCst
=
constant
(
ObjectValue
(
*
templateObj
)
)
;
MNewCallObject
*
callObj
=
MNewCallObject
:
:
New
(
alloc
(
)
templateCst
)
;
current
-
>
add
(
callObj
)
;
/
/
Initialize
the
object
'
s
reserved
slots
.
No
post
barrier
is
needed
here
/
/
for
the
same
reason
as
in
buildNamedLambdaEnv
.
size_t
enclosingSlot
=
CallObject
:
:
enclosingEnvironmentSlot
(
)
;
size_t
calleeSlot
=
CallObject
:
:
calleeSlot
(
)
;
current
-
>
add
(
MStoreFixedSlot
:
:
New
(
alloc
(
)
callObj
enclosingSlot
env
)
)
;
current
-
>
add
(
MStoreFixedSlot
:
:
New
(
alloc
(
)
callObj
calleeSlot
callee
)
)
;
/
/
Copy
closed
-
over
argument
slots
if
there
aren
'
t
parameter
expressions
.
MSlots
*
slots
=
nullptr
;
for
(
PositionalFormalParameterIter
fi
(
script_
)
;
fi
;
fi
+
+
)
{
if
(
!
fi
.
closedOver
(
)
)
{
continue
;
}
if
(
!
alloc
(
)
.
ensureBallast
(
)
)
{
return
nullptr
;
}
uint32_t
slot
=
fi
.
location
(
)
.
slot
(
)
;
uint32_t
formal
=
fi
.
argumentSlot
(
)
;
uint32_t
numFixedSlots
=
templateObj
-
>
numFixedSlots
(
)
;
MDefinition
*
param
;
if
(
script_
-
>
functionHasParameterExprs
(
)
)
{
param
=
constant
(
MagicValue
(
JS_UNINITIALIZED_LEXICAL
)
)
;
}
else
{
param
=
current
-
>
getSlot
(
info
(
)
.
argSlotUnchecked
(
formal
)
)
;
}
if
(
slot
>
=
numFixedSlots
)
{
if
(
!
slots
)
{
slots
=
MSlots
:
:
New
(
alloc
(
)
callObj
)
;
current
-
>
add
(
slots
)
;
}
uint32_t
dynamicSlot
=
slot
-
numFixedSlots
;
current
-
>
add
(
MStoreSlot
:
:
New
(
alloc
(
)
slots
dynamicSlot
param
)
)
;
}
else
{
current
-
>
add
(
MStoreFixedSlot
:
:
New
(
alloc
(
)
callObj
slot
param
)
)
;
}
}
return
callObj
;
}
bool
WarpBuilder
:
:
buildEnvironmentChain
(
)
{
const
WarpEnvironment
&
env
=
snapshot_
.
script
(
)
-
>
environment
(
)
;
MInstruction
*
envDef
=
nullptr
;
switch
(
env
.
kind
(
)
)
{
case
WarpEnvironment
:
:
Kind
:
:
None
:
/
/
Leave
the
slot
|
undefined
|
nothing
to
do
.
return
true
;
case
WarpEnvironment
:
:
Kind
:
:
ConstantObject
:
envDef
=
constant
(
ObjectValue
(
*
env
.
constantObject
(
)
)
)
;
break
;
case
WarpEnvironment
:
:
Kind
:
:
Function
:
{
/
/
TODO
:
fix
this
for
inlining
.
MCallee
*
callee
=
MCallee
:
:
New
(
alloc
(
)
)
;
current
-
>
add
(
callee
)
;
envDef
=
MFunctionEnvironment
:
:
New
(
alloc
(
)
callee
)
;
current
-
>
add
(
envDef
)
;
if
(
LexicalEnvironmentObject
*
obj
=
env
.
maybeNamedLambdaTemplate
(
)
)
{
envDef
=
buildNamedLambdaEnv
(
callee
envDef
obj
)
;
}
if
(
CallObject
*
obj
=
env
.
maybeCallObjectTemplate
(
)
)
{
envDef
=
buildCallObject
(
callee
envDef
obj
)
;
if
(
!
envDef
)
{
return
false
;
}
}
break
;
}
}
/
/
Update
the
environment
slot
from
UndefinedValue
only
after
the
initial
/
/
environment
is
created
so
that
bailout
doesn
'
t
see
a
partial
environment
.
/
/
See
:
|
InitFromBailout
|
current
-
>
setEnvironmentChain
(
envDef
)
;
return
true
;
}
bool
WarpBuilder
:
:
buildPrologue
(
)
{
BytecodeLocation
startLoc
(
script_
script_
-
>
code
(
)
)
;
if
(
!
startNewEntryBlock
(
info
(
)
.
firstStackSlot
(
)
startLoc
)
)
{
return
false
;
}
if
(
info
(
)
.
funMaybeLazy
(
)
)
{
/
/
Initialize
|
this
|
.
MParameter
*
param
=
MParameter
:
:
New
(
alloc
(
)
MParameter
:
:
THIS_SLOT
nullptr
)
;
current
-
>
add
(
param
)
;
current
-
>
initSlot
(
info
(
)
.
thisSlot
(
)
param
)
;
/
/
Initialize
arguments
.
for
(
uint32_t
i
=
0
;
i
<
info
(
)
.
nargs
(
)
;
i
+
+
)
{
MParameter
*
param
=
MParameter
:
:
New
(
alloc
(
)
.
fallible
(
)
i
nullptr
)
;
if
(
!
param
)
{
return
false
;
}
current
-
>
add
(
param
)
;
current
-
>
initSlot
(
info
(
)
.
argSlotUnchecked
(
i
)
param
)
;
}
}
MConstant
*
undef
=
constant
(
UndefinedValue
(
)
)
;
/
/
Initialize
local
slots
.
for
(
uint32_t
i
=
0
;
i
<
info
(
)
.
nlocals
(
)
;
i
+
+
)
{
current
-
>
initSlot
(
info
(
)
.
localSlot
(
i
)
undef
)
;
}
/
/
Initialize
the
environment
chain
return
value
and
arguments
object
slots
.
current
-
>
initSlot
(
info
(
)
.
environmentChainSlot
(
)
undef
)
;
current
-
>
initSlot
(
info
(
)
.
returnValueSlot
(
)
undef
)
;
if
(
info
(
)
.
hasArguments
(
)
)
{
current
-
>
initSlot
(
info
(
)
.
argsObjSlot
(
)
undef
)
;
}
current
-
>
add
(
MStart
:
:
New
(
alloc
(
)
)
)
;
/
/
Guard
against
over
-
recursion
.
MCheckOverRecursed
*
check
=
MCheckOverRecursed
:
:
New
(
alloc
(
)
)
;
current
-
>
add
(
check
)
;
if
(
!
buildEnvironmentChain
(
)
)
{
return
false
;
}
return
true
;
}
bool
WarpBuilder
:
:
buildBody
(
)
{
for
(
BytecodeLocation
loc
:
AllBytecodesIterable
(
script_
)
)
{
if
(
mirGen_
.
shouldCancel
(
"
WarpBuilder
(
opcode
loop
)
"
)
)
{
return
false
;
}
/
/
Skip
unreachable
ops
(
for
example
code
after
a
'
return
'
or
'
throw
'
)
until
/
/
we
get
to
the
next
jump
target
.
if
(
hasTerminatedBlock
(
)
)
{
/
/
Finish
any
"
broken
"
loops
with
an
unreachable
backedge
.
For
example
:
/
/
/
/
do
{
/
/
.
.
.
/
/
return
;
/
/
.
.
.
/
/
}
while
(
x
)
;
/
/
/
/
This
loop
never
actually
loops
.
if
(
loc
.
isBackedge
(
)
&
&
!
loopStack_
.
empty
(
)
)
{
BytecodeLocation
loopHead
(
script_
loopStack_
.
back
(
)
.
header
(
)
-
>
pc
(
)
)
;
if
(
loc
.
isBackedgeForLoophead
(
loopHead
)
)
{
MOZ_ASSERT
(
loopDepth_
>
0
)
;
loopDepth_
-
-
;
loopStack_
.
popBack
(
)
;
}
}
if
(
!
loc
.
isJumpTarget
(
)
)
{
continue
;
}
}
if
(
!
alloc
(
)
.
ensureBallast
(
)
)
{
return
false
;
}
/
/
TODO
:
port
PoppedValueUseChecker
from
IonBuilder
JSOp
op
=
loc
.
getOp
(
)
;
#
define
BUILD_OP
(
OP
)
\
case
JSOp
:
:
OP
:
\
if
(
MOZ_UNLIKELY
(
!
this
-
>
build_
#
#
OP
(
loc
)
)
)
{
\
return
false
;
\
}
\
break
;
switch
(
op
)
{
WARP_OPCODE_LIST
(
BUILD_OP
)
default
:
/
/
WarpOracle
should
have
aborted
compilation
.
MOZ_CRASH
(
"
Unexpected
op
"
)
;
}
#
undef
BUILD_OP
}
return
true
;
}
bool
WarpBuilder
:
:
buildEpilogue
(
)
{
return
true
;
}
bool
WarpBuilder
:
:
build_Nop
(
BytecodeLocation
)
{
return
true
;
}
bool
WarpBuilder
:
:
build_NopDestructuring
(
BytecodeLocation
)
{
return
true
;
}
bool
WarpBuilder
:
:
build_TryDestructuring
(
BytecodeLocation
)
{
return
true
;
}
bool
WarpBuilder
:
:
build_Lineno
(
BytecodeLocation
)
{
return
true
;
}
bool
WarpBuilder
:
:
build_DebugLeaveLexicalEnv
(
BytecodeLocation
)
{
return
true
;
}
bool
WarpBuilder
:
:
build_Undefined
(
BytecodeLocation
)
{
pushConstant
(
UndefinedValue
(
)
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_Void
(
BytecodeLocation
)
{
current
-
>
pop
(
)
;
pushConstant
(
UndefinedValue
(
)
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_Null
(
BytecodeLocation
)
{
pushConstant
(
NullValue
(
)
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_Hole
(
BytecodeLocation
)
{
pushConstant
(
MagicValue
(
JS_ELEMENTS_HOLE
)
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_Uninitialized
(
BytecodeLocation
)
{
pushConstant
(
MagicValue
(
JS_UNINITIALIZED_LEXICAL
)
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_IsConstructing
(
BytecodeLocation
)
{
pushConstant
(
MagicValue
(
JS_IS_CONSTRUCTING
)
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_False
(
BytecodeLocation
)
{
pushConstant
(
BooleanValue
(
false
)
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_True
(
BytecodeLocation
)
{
pushConstant
(
BooleanValue
(
true
)
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_Pop
(
BytecodeLocation
)
{
current
-
>
pop
(
)
;
/
/
TODO
:
IonBuilder
inserts
a
resume
point
in
loops
re
-
evaluate
this
.
return
true
;
}
bool
WarpBuilder
:
:
build_PopN
(
BytecodeLocation
loc
)
{
for
(
uint32_t
i
=
0
n
=
loc
.
getPopCount
(
)
;
i
<
n
;
i
+
+
)
{
current
-
>
pop
(
)
;
}
return
true
;
}
bool
WarpBuilder
:
:
build_Dup
(
BytecodeLocation
)
{
current
-
>
pushSlot
(
current
-
>
stackDepth
(
)
-
1
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_Dup2
(
BytecodeLocation
)
{
uint32_t
lhsSlot
=
current
-
>
stackDepth
(
)
-
2
;
uint32_t
rhsSlot
=
current
-
>
stackDepth
(
)
-
1
;
current
-
>
pushSlot
(
lhsSlot
)
;
current
-
>
pushSlot
(
rhsSlot
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_DupAt
(
BytecodeLocation
loc
)
{
current
-
>
pushSlot
(
current
-
>
stackDepth
(
)
-
1
-
loc
.
getDupAtIndex
(
)
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_Swap
(
BytecodeLocation
)
{
current
-
>
swapAt
(
-
1
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_Pick
(
BytecodeLocation
loc
)
{
int32_t
depth
=
-
int32_t
(
loc
.
getPickDepth
(
)
)
;
current
-
>
pick
(
depth
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_Unpick
(
BytecodeLocation
loc
)
{
int32_t
depth
=
-
int32_t
(
loc
.
getUnpickDepth
(
)
)
;
current
-
>
unpick
(
depth
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_Zero
(
BytecodeLocation
)
{
pushConstant
(
Int32Value
(
0
)
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_One
(
BytecodeLocation
)
{
pushConstant
(
Int32Value
(
1
)
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_Int8
(
BytecodeLocation
loc
)
{
pushConstant
(
Int32Value
(
loc
.
getInt8
(
)
)
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_Uint16
(
BytecodeLocation
loc
)
{
pushConstant
(
Int32Value
(
loc
.
getUint16
(
)
)
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_Uint24
(
BytecodeLocation
loc
)
{
pushConstant
(
Int32Value
(
loc
.
getUint24
(
)
)
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_Int32
(
BytecodeLocation
loc
)
{
pushConstant
(
Int32Value
(
loc
.
getInt32
(
)
)
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_Double
(
BytecodeLocation
loc
)
{
pushConstant
(
loc
.
getInlineValue
(
)
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_ResumeIndex
(
BytecodeLocation
loc
)
{
pushConstant
(
Int32Value
(
loc
.
getResumeIndex
(
)
)
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_BigInt
(
BytecodeLocation
loc
)
{
BigInt
*
bi
=
loc
.
getBigInt
(
script_
)
;
pushConstant
(
BigIntValue
(
bi
)
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_String
(
BytecodeLocation
loc
)
{
JSAtom
*
atom
=
loc
.
getAtom
(
script_
)
;
pushConstant
(
StringValue
(
atom
)
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_Symbol
(
BytecodeLocation
loc
)
{
uint32_t
which
=
loc
.
getSymbolIndex
(
)
;
JS
:
:
Symbol
*
sym
=
mirGen_
.
runtime
-
>
wellKnownSymbols
(
)
.
get
(
which
)
;
pushConstant
(
SymbolValue
(
sym
)
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_RegExp
(
BytecodeLocation
loc
)
{
RegExpObject
*
reObj
=
loc
.
getRegExp
(
script_
)
;
auto
*
snapshot
=
getOpSnapshot
<
WarpRegExp
>
(
loc
)
;
MRegExp
*
regexp
=
MRegExp
:
:
New
(
alloc
(
)
/
*
constraints
=
*
/
nullptr
reObj
snapshot
-
>
hasShared
(
)
)
;
current
-
>
add
(
regexp
)
;
current
-
>
push
(
regexp
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_Return
(
BytecodeLocation
)
{
MDefinition
*
def
=
current
-
>
pop
(
)
;
MReturn
*
ret
=
MReturn
:
:
New
(
alloc
(
)
def
)
;
current
-
>
end
(
ret
)
;
setTerminatedBlock
(
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_RetRval
(
BytecodeLocation
)
{
MDefinition
*
rval
;
if
(
script_
-
>
noScriptRval
(
)
)
{
rval
=
constant
(
UndefinedValue
(
)
)
;
}
else
{
rval
=
current
-
>
getSlot
(
info
(
)
.
returnValueSlot
(
)
)
;
}
MReturn
*
ret
=
MReturn
:
:
New
(
alloc
(
)
rval
)
;
current
-
>
end
(
ret
)
;
setTerminatedBlock
(
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_SetRval
(
BytecodeLocation
)
{
MOZ_ASSERT
(
!
script_
-
>
noScriptRval
(
)
)
;
MDefinition
*
rval
=
current
-
>
pop
(
)
;
current
-
>
setSlot
(
info
(
)
.
returnValueSlot
(
)
rval
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_GetLocal
(
BytecodeLocation
loc
)
{
current
-
>
pushLocal
(
loc
.
local
(
)
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_SetLocal
(
BytecodeLocation
loc
)
{
current
-
>
setLocal
(
loc
.
local
(
)
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_InitLexical
(
BytecodeLocation
loc
)
{
current
-
>
setLocal
(
loc
.
local
(
)
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_GetArg
(
BytecodeLocation
loc
)
{
uint32_t
arg
=
loc
.
arg
(
)
;
if
(
info
(
)
.
argsObjAliasesFormals
(
)
)
{
MDefinition
*
argsObj
=
current
-
>
argumentsObject
(
)
;
auto
*
getArg
=
MGetArgumentsObjectArg
:
:
New
(
alloc
(
)
argsObj
arg
)
;
current
-
>
add
(
getArg
)
;
current
-
>
push
(
getArg
)
;
}
else
{
current
-
>
pushArg
(
arg
)
;
}
return
true
;
}
bool
WarpBuilder
:
:
build_SetArg
(
BytecodeLocation
loc
)
{
MOZ_ASSERT
(
script_
-
>
jitScript
(
)
-
>
modifiesArguments
(
)
)
;
uint32_t
arg
=
loc
.
arg
(
)
;
MDefinition
*
val
=
current
-
>
peek
(
-
1
)
;
if
(
!
info
(
)
.
argumentsAliasesFormals
(
)
)
{
MOZ_ASSERT
(
!
info
(
)
.
argsObjAliasesFormals
(
)
)
;
/
/
|
arguments
|
is
never
referenced
within
this
function
.
No
arguments
object
/
/
is
created
in
this
case
so
we
don
'
t
need
to
worry
about
synchronizing
/
/
the
argument
values
when
writing
to
them
.
MOZ_ASSERT_IF
(
!
info
(
)
.
hasArguments
(
)
!
info
(
)
.
needsArgsObj
(
)
)
;
/
/
The
arguments
object
doesn
'
t
map
to
the
actual
argument
values
so
we
/
/
also
don
'
t
need
to
worry
about
synchronizing
them
.
/
/
Directly
writing
to
a
positional
formal
parameter
is
only
possible
when
/
/
the
|
arguments
|
contents
are
never
observed
otherwise
we
can
'
t
/
/
reconstruct
the
original
parameter
values
when
we
access
them
through
/
/
|
arguments
[
i
]
|
.
AnalyzeArgumentsUsage
ensures
this
is
handled
correctly
.
MOZ_ASSERT_IF
(
info
(
)
.
hasArguments
(
)
!
info
(
)
.
hasMappedArgsObj
(
)
)
;
current
-
>
setArg
(
arg
)
;
return
true
;
}
MOZ_ASSERT
(
info
(
)
.
hasArguments
(
)
&
&
info
(
)
.
hasMappedArgsObj
(
)
"
arguments
aliases
formals
when
an
arguments
binding
is
present
"
"
and
the
arguments
object
is
mapped
"
)
;
/
/
TODO
:
double
check
corresponding
IonBuilder
code
when
supporting
the
/
/
arguments
analysis
in
WarpBuilder
.
MOZ_ASSERT
(
info
(
)
.
needsArgsObj
(
)
"
unexpected
JSOp
:
:
SetArg
with
lazy
arguments
"
)
;
MOZ_ASSERT
(
info
(
)
.
argsObjAliasesFormals
(
)
"
argsObjAliasesFormals
(
)
is
true
iff
a
mapped
arguments
object
is
used
"
)
;
/
/
If
an
arguments
object
is
in
use
and
it
aliases
formals
then
all
SetArgs
/
/
must
go
through
the
arguments
object
.
MDefinition
*
argsObj
=
current
-
>
argumentsObject
(
)
;
current
-
>
add
(
MPostWriteBarrier
:
:
New
(
alloc
(
)
argsObj
val
)
)
;
auto
*
ins
=
MSetArgumentsObjectArg
:
:
New
(
alloc
(
)
argsObj
arg
val
)
;
current
-
>
add
(
ins
)
;
return
resumeAfter
(
ins
loc
)
;
}
bool
WarpBuilder
:
:
build_ToNumeric
(
BytecodeLocation
loc
)
{
MDefinition
*
value
=
current
-
>
pop
(
)
;
MToNumeric
*
ins
=
MToNumeric
:
:
New
(
alloc
(
)
value
/
*
types
=
*
/
nullptr
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
loc
)
;
}
bool
WarpBuilder
:
:
buildUnaryOp
(
BytecodeLocation
loc
)
{
MDefinition
*
value
=
current
-
>
pop
(
)
;
MInstruction
*
ins
=
MUnaryCache
:
:
New
(
alloc
(
)
value
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
loc
)
;
}
bool
WarpBuilder
:
:
build_Inc
(
BytecodeLocation
loc
)
{
return
buildUnaryOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_Dec
(
BytecodeLocation
loc
)
{
return
buildUnaryOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_Neg
(
BytecodeLocation
loc
)
{
return
buildUnaryOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_BitNot
(
BytecodeLocation
loc
)
{
return
buildUnaryOp
(
loc
)
;
}
bool
WarpBuilder
:
:
buildBinaryOp
(
BytecodeLocation
loc
)
{
MDefinition
*
right
=
current
-
>
pop
(
)
;
MDefinition
*
left
=
current
-
>
pop
(
)
;
MInstruction
*
ins
=
MBinaryCache
:
:
New
(
alloc
(
)
left
right
MIRType
:
:
Value
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
loc
)
;
}
bool
WarpBuilder
:
:
build_Add
(
BytecodeLocation
loc
)
{
return
buildBinaryOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_Sub
(
BytecodeLocation
loc
)
{
return
buildBinaryOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_Mul
(
BytecodeLocation
loc
)
{
return
buildBinaryOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_Div
(
BytecodeLocation
loc
)
{
return
buildBinaryOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_Mod
(
BytecodeLocation
loc
)
{
return
buildBinaryOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_Pow
(
BytecodeLocation
loc
)
{
return
buildBinaryOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_BitAnd
(
BytecodeLocation
loc
)
{
return
buildBinaryOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_BitOr
(
BytecodeLocation
loc
)
{
return
buildBinaryOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_BitXor
(
BytecodeLocation
loc
)
{
return
buildBinaryOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_Lsh
(
BytecodeLocation
loc
)
{
return
buildBinaryOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_Rsh
(
BytecodeLocation
loc
)
{
return
buildBinaryOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_Ursh
(
BytecodeLocation
loc
)
{
return
buildBinaryOp
(
loc
)
;
}
bool
WarpBuilder
:
:
buildCompareOp
(
BytecodeLocation
loc
)
{
MDefinition
*
right
=
current
-
>
pop
(
)
;
MDefinition
*
left
=
current
-
>
pop
(
)
;
MInstruction
*
ins
=
MBinaryCache
:
:
New
(
alloc
(
)
left
right
MIRType
:
:
Boolean
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
loc
)
;
}
bool
WarpBuilder
:
:
build_Eq
(
BytecodeLocation
loc
)
{
return
buildCompareOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_Ne
(
BytecodeLocation
loc
)
{
return
buildCompareOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_Lt
(
BytecodeLocation
loc
)
{
return
buildCompareOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_Le
(
BytecodeLocation
loc
)
{
return
buildCompareOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_Gt
(
BytecodeLocation
loc
)
{
return
buildCompareOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_Ge
(
BytecodeLocation
loc
)
{
return
buildCompareOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_StrictEq
(
BytecodeLocation
loc
)
{
return
buildCompareOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_StrictNe
(
BytecodeLocation
loc
)
{
return
buildCompareOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_JumpTarget
(
BytecodeLocation
loc
)
{
PendingEdgesMap
:
:
Ptr
p
=
pendingEdges_
.
lookup
(
loc
.
toRawBytecode
(
)
)
;
if
(
!
p
)
{
/
/
No
(
reachable
)
jumps
so
this
is
just
a
no
-
op
.
return
true
;
}
PendingEdges
edges
(
std
:
:
move
(
p
-
>
value
(
)
)
)
;
pendingEdges_
.
remove
(
p
)
;
MOZ_ASSERT
(
!
edges
.
empty
(
)
)
;
MBasicBlock
*
joinBlock
=
nullptr
;
/
/
Create
join
block
if
there
'
s
fall
-
through
from
the
previous
bytecode
op
.
if
(
!
hasTerminatedBlock
(
)
)
{
MBasicBlock
*
pred
=
current
;
if
(
!
startNewBlock
(
pred
loc
)
)
{
return
false
;
}
pred
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
current
)
)
;
joinBlock
=
current
;
setTerminatedBlock
(
)
;
}
auto
addEdge
=
[
&
]
(
MBasicBlock
*
pred
size_t
numToPop
)
-
>
bool
{
if
(
joinBlock
)
{
MOZ_ASSERT
(
pred
-
>
stackDepth
(
)
-
numToPop
=
=
joinBlock
-
>
stackDepth
(
)
)
;
return
joinBlock
-
>
addPredecessorPopN
(
alloc
(
)
pred
numToPop
)
;
}
if
(
!
startNewBlock
(
pred
loc
numToPop
)
)
{
return
false
;
}
joinBlock
=
current
;
setTerminatedBlock
(
)
;
return
true
;
}
;
/
/
When
a
block
is
terminated
with
an
MTest
instruction
we
can
end
up
with
the
/
/
following
triangle
structure
:
/
/
/
/
testBlock
/
/
/
|
/
/
block
|
/
/
\
|
/
/
joinBlock
/
/
/
/
Although
this
is
fine
for
correctness
the
FoldTests
pass
is
unable
to
/
/
optimize
this
pattern
.
This
matters
for
short
-
circuit
operations
/
/
(
JSOp
:
:
And
JSOp
:
:
Coalesce
etc
)
.
/
/
/
/
To
fix
these
issues
we
create
an
empty
block
to
get
a
diamond
structure
:
/
/
/
/
testBlock
/
/
/
|
/
/
block
emptyBlock
/
/
\
|
/
/
joinBlock
/
/
/
/
TODO
:
re
-
evaluate
this
.
It
would
probably
be
better
to
fix
FoldTests
to
/
/
support
the
triangle
pattern
so
that
we
can
remove
this
.
IonBuilder
had
/
/
other
concerns
that
don
'
t
apply
to
WarpBuilder
.
auto
createEmptyBlockForTest
=
[
&
]
(
MBasicBlock
*
pred
size_t
successor
size_t
numToPop
)
-
>
MBasicBlock
*
{
MOZ_ASSERT
(
joinBlock
)
;
if
(
!
startNewBlock
(
pred
loc
numToPop
)
)
{
return
nullptr
;
}
MBasicBlock
*
emptyBlock
=
current
;
MOZ_ASSERT
(
emptyBlock
-
>
stackDepth
(
)
=
=
joinBlock
-
>
stackDepth
(
)
)
;
MTest
*
test
=
pred
-
>
lastIns
(
)
-
>
toTest
(
)
;
test
-
>
initSuccessor
(
successor
emptyBlock
)
;
emptyBlock
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
joinBlock
)
)
;
setTerminatedBlock
(
)
;
return
emptyBlock
;
}
;
for
(
const
PendingEdge
&
edge
:
edges
)
{
MBasicBlock
*
source
=
edge
.
block
(
)
;
MControlInstruction
*
lastIns
=
source
-
>
lastIns
(
)
;
switch
(
edge
.
kind
(
)
)
{
case
PendingEdge
:
:
Kind
:
:
TestTrue
:
{
/
/
JSOp
:
:
Case
must
pop
the
value
when
branching
to
the
true
-
target
.
/
/
If
we
create
an
empty
block
we
have
to
pop
the
value
there
instead
/
/
of
as
part
of
the
emptyBlock
-
>
joinBlock
edge
so
stack
depths
match
/
/
the
current
depth
.
const
size_t
numToPop
=
(
edge
.
testOp
(
)
=
=
JSOp
:
:
Case
)
?
1
:
0
;
const
size_t
successor
=
0
;
/
/
true
-
branch
if
(
joinBlock
&
&
TestTrueTargetIsJoinPoint
(
edge
.
testOp
(
)
)
)
{
MBasicBlock
*
pred
=
createEmptyBlockForTest
(
source
successor
numToPop
)
;
if
(
!
pred
|
|
!
addEdge
(
pred
/
*
numToPop
=
*
/
0
)
)
{
return
false
;
}
}
else
{
if
(
!
addEdge
(
source
numToPop
)
)
{
return
false
;
}
lastIns
-
>
toTest
(
)
-
>
initSuccessor
(
successor
joinBlock
)
;
}
continue
;
}
case
PendingEdge
:
:
Kind
:
:
TestFalse
:
{
const
size_t
numToPop
=
0
;
const
size_t
successor
=
1
;
/
/
false
-
branch
if
(
joinBlock
&
&
!
TestTrueTargetIsJoinPoint
(
edge
.
testOp
(
)
)
)
{
MBasicBlock
*
pred
=
createEmptyBlockForTest
(
source
successor
numToPop
)
;
if
(
!
pred
|
|
!
addEdge
(
pred
/
*
numToPop
=
*
/
0
)
)
{
return
false
;
}
}
else
{
if
(
!
addEdge
(
source
numToPop
)
)
{
return
false
;
}
lastIns
-
>
toTest
(
)
-
>
initSuccessor
(
successor
joinBlock
)
;
}
continue
;
}
case
PendingEdge
:
:
Kind
:
:
Goto
:
if
(
!
addEdge
(
source
/
*
numToPop
=
*
/
0
)
)
{
return
false
;
}
lastIns
-
>
toGoto
(
)
-
>
initSuccessor
(
0
joinBlock
)
;
continue
;
case
PendingEdge
:
:
Kind
:
:
GotoWithFake
:
if
(
!
addEdge
(
source
/
*
numToPop
=
*
/
0
)
)
{
return
false
;
}
lastIns
-
>
toGotoWithFake
(
)
-
>
initSuccessor
(
1
joinBlock
)
;
continue
;
}
MOZ_CRASH
(
"
Invalid
kind
"
)
;
}
/
/
Start
traversing
the
join
block
.
Make
sure
it
comes
after
predecessor
/
/
blocks
created
by
createEmptyBlockForTest
.
MOZ_ASSERT
(
hasTerminatedBlock
(
)
)
;
MOZ_ASSERT
(
joinBlock
)
;
graph
(
)
.
moveBlockToEnd
(
joinBlock
)
;
current
=
joinBlock
;
return
true
;
}
bool
WarpBuilder
:
:
build_LoopHead
(
BytecodeLocation
loc
)
{
/
/
All
loops
have
the
following
bytecode
structure
:
/
/
/
/
LoopHead
/
/
.
.
.
/
/
IfNe
/
Goto
to
LoopHead
if
(
hasTerminatedBlock
(
)
)
{
/
/
The
whole
loop
is
unreachable
.
return
true
;
}
/
/
TODO
:
support
OSR
loopDepth_
+
+
;
MBasicBlock
*
pred
=
current
;
if
(
!
startNewLoopHeaderBlock
(
pred
loc
)
)
{
return
false
;
}
pred
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
current
)
)
;
/
/
TODO
:
handle
destructuring
special
case
(
IonBuilder
:
:
newPendingLoopHeader
)
MInterruptCheck
*
check
=
MInterruptCheck
:
:
New
(
alloc
(
)
)
;
current
-
>
add
(
check
)
;
/
/
TODO
:
recompile
check
return
true
;
}
bool
WarpBuilder
:
:
buildTestOp
(
BytecodeLocation
loc
)
{
if
(
loc
.
isBackedge
(
)
)
{
return
buildTestBackedge
(
loc
)
;
}
JSOp
op
=
loc
.
getOp
(
)
;
BytecodeLocation
target1
=
loc
.
next
(
)
;
BytecodeLocation
target2
=
loc
.
getJumpTarget
(
)
;
if
(
TestTrueTargetIsJoinPoint
(
op
)
)
{
std
:
:
swap
(
target1
target2
)
;
}
/
/
JSOp
:
:
And
and
JSOp
:
:
Or
inspect
the
top
stack
value
but
don
'
t
pop
it
.
/
/
Also
note
that
JSOp
:
:
Case
must
pop
a
second
value
on
the
true
-
branch
(
the
/
/
input
to
the
switch
-
statement
)
.
This
conditional
pop
happens
in
/
/
build_JumpTarget
.
bool
mustKeepCondition
=
(
op
=
=
JSOp
:
:
And
|
|
op
=
=
JSOp
:
:
Or
)
;
MDefinition
*
value
=
mustKeepCondition
?
current
-
>
peek
(
-
1
)
:
current
-
>
pop
(
)
;
/
/
If
this
op
always
branches
to
the
same
location
we
treat
this
as
a
/
/
JSOp
:
:
Goto
.
if
(
target1
=
=
target2
)
{
value
-
>
setImplicitlyUsedUnchecked
(
)
;
return
buildForwardGoto
(
target1
)
;
}
MTest
*
test
=
MTest
:
:
New
(
alloc
(
)
value
/
*
ifTrue
=
*
/
nullptr
/
*
ifFalse
=
*
/
nullptr
)
;
current
-
>
end
(
test
)
;
if
(
!
addPendingEdge
(
PendingEdge
:
:
NewTestTrue
(
current
op
)
target1
)
)
{
return
false
;
}
if
(
!
addPendingEdge
(
PendingEdge
:
:
NewTestFalse
(
current
op
)
target2
)
)
{
return
false
;
}
setTerminatedBlock
(
)
;
return
true
;
}
bool
WarpBuilder
:
:
buildTestBackedge
(
BytecodeLocation
loc
)
{
JSOp
op
=
loc
.
getOp
(
)
;
MOZ_ASSERT
(
op
=
=
JSOp
:
:
IfNe
)
;
MOZ_ASSERT
(
loopDepth_
>
0
)
;
MDefinition
*
value
=
current
-
>
pop
(
)
;
BytecodeLocation
loopHead
=
loc
.
getJumpTarget
(
)
;
MOZ_ASSERT
(
loopHead
.
is
(
JSOp
:
:
LoopHead
)
)
;
BytecodeLocation
successor
=
loc
.
next
(
)
;
/
/
We
can
finish
the
loop
now
.
Use
the
loophead
pc
instead
of
the
current
pc
/
/
because
the
stack
depth
at
the
start
of
that
op
matches
the
current
stack
/
/
depth
(
after
popping
our
operand
)
.
MBasicBlock
*
pred
=
current
;
if
(
!
startNewBlock
(
current
loopHead
)
)
{
return
false
;
}
pred
-
>
end
(
MTest
:
:
New
(
alloc
(
)
value
/
*
ifTrue
=
*
/
current
/
*
ifFalse
=
*
/
nullptr
)
)
;
if
(
!
addPendingEdge
(
PendingEdge
:
:
NewTestFalse
(
pred
op
)
successor
)
)
{
return
false
;
}
return
buildBackedge
(
)
;
}
bool
WarpBuilder
:
:
build_IfEq
(
BytecodeLocation
loc
)
{
return
buildTestOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_IfNe
(
BytecodeLocation
loc
)
{
return
buildTestOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_And
(
BytecodeLocation
loc
)
{
return
buildTestOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_Or
(
BytecodeLocation
loc
)
{
return
buildTestOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_Case
(
BytecodeLocation
loc
)
{
return
buildTestOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_Default
(
BytecodeLocation
loc
)
{
current
-
>
pop
(
)
;
return
buildForwardGoto
(
loc
.
getJumpTarget
(
)
)
;
}
bool
WarpBuilder
:
:
build_Coalesce
(
BytecodeLocation
loc
)
{
BytecodeLocation
target1
=
loc
.
next
(
)
;
BytecodeLocation
target2
=
loc
.
getJumpTarget
(
)
;
MOZ_ASSERT
(
target2
>
target1
)
;
MDefinition
*
value
=
current
-
>
peek
(
-
1
)
;
MInstruction
*
isNullOrUndefined
=
MIsNullOrUndefined
:
:
New
(
alloc
(
)
value
)
;
current
-
>
add
(
isNullOrUndefined
)
;
current
-
>
end
(
MTest
:
:
New
(
alloc
(
)
isNullOrUndefined
/
*
ifTrue
=
*
/
nullptr
/
*
ifFalse
=
*
/
nullptr
)
)
;
if
(
!
addPendingEdge
(
PendingEdge
:
:
NewTestTrue
(
current
JSOp
:
:
Coalesce
)
target1
)
)
{
return
false
;
}
if
(
!
addPendingEdge
(
PendingEdge
:
:
NewTestFalse
(
current
JSOp
:
:
Coalesce
)
target2
)
)
{
return
false
;
}
setTerminatedBlock
(
)
;
return
true
;
}
bool
WarpBuilder
:
:
buildBackedge
(
)
{
MOZ_ASSERT
(
loopDepth_
>
0
)
;
loopDepth_
-
-
;
MBasicBlock
*
header
=
loopStack_
.
popCopy
(
)
.
header
(
)
;
current
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
header
)
)
;
AbortReason
r
=
header
-
>
setBackedge
(
alloc
(
)
current
)
;
if
(
r
=
=
AbortReason
:
:
NoAbort
)
{
setTerminatedBlock
(
)
;
return
true
;
}
MOZ_ASSERT
(
r
=
=
AbortReason
:
:
Alloc
)
;
return
false
;
}
bool
WarpBuilder
:
:
buildForwardGoto
(
BytecodeLocation
target
)
{
current
-
>
end
(
MGoto
:
:
New
(
alloc
(
)
nullptr
)
)
;
if
(
!
addPendingEdge
(
PendingEdge
:
:
NewGoto
(
current
)
target
)
)
{
return
false
;
}
setTerminatedBlock
(
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_Goto
(
BytecodeLocation
loc
)
{
if
(
loc
.
isBackedge
(
)
)
{
return
buildBackedge
(
)
;
}
return
buildForwardGoto
(
loc
.
getJumpTarget
(
)
)
;
}
bool
WarpBuilder
:
:
build_DebugCheckSelfHosted
(
BytecodeLocation
loc
)
{
#
ifdef
DEBUG
MDefinition
*
val
=
current
-
>
pop
(
)
;
MDebugCheckSelfHosted
*
check
=
MDebugCheckSelfHosted
:
:
New
(
alloc
(
)
val
)
;
current
-
>
add
(
check
)
;
current
-
>
push
(
check
)
;
if
(
!
resumeAfter
(
check
loc
)
)
{
return
false
;
}
#
endif
return
true
;
}
bool
WarpBuilder
:
:
build_DynamicImport
(
BytecodeLocation
loc
)
{
MDefinition
*
specifier
=
current
-
>
pop
(
)
;
MDynamicImport
*
ins
=
MDynamicImport
:
:
New
(
alloc
(
)
specifier
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
loc
)
;
}
bool
WarpBuilder
:
:
build_Not
(
BytecodeLocation
loc
)
{
MDefinition
*
value
=
current
-
>
pop
(
)
;
MNot
*
ins
=
MNot
:
:
New
(
alloc
(
)
value
/
*
constraints
=
*
/
nullptr
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_ToString
(
BytecodeLocation
loc
)
{
MDefinition
*
value
=
current
-
>
pop
(
)
;
MToString
*
ins
=
MToString
:
:
New
(
alloc
(
)
value
MToString
:
:
SideEffectHandling
:
:
Supported
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
MOZ_ASSERT
(
ins
-
>
isEffectful
(
)
)
;
return
resumeAfter
(
ins
loc
)
;
}
bool
WarpBuilder
:
:
usesEnvironmentChain
(
)
const
{
return
script_
-
>
jitScript
(
)
-
>
usesEnvironmentChain
(
)
;
}
bool
WarpBuilder
:
:
build_DefVar
(
BytecodeLocation
loc
)
{
MOZ_ASSERT
(
usesEnvironmentChain
(
)
)
;
MDefinition
*
env
=
current
-
>
environmentChain
(
)
;
MDefVar
*
defvar
=
MDefVar
:
:
New
(
alloc
(
)
env
)
;
current
-
>
add
(
defvar
)
;
return
resumeAfter
(
defvar
loc
)
;
}
bool
WarpBuilder
:
:
buildDefLexicalOp
(
BytecodeLocation
loc
)
{
MOZ_ASSERT
(
usesEnvironmentChain
(
)
)
;
MDefinition
*
env
=
current
-
>
environmentChain
(
)
;
MDefLexical
*
defLexical
=
MDefLexical
:
:
New
(
alloc
(
)
env
)
;
current
-
>
add
(
defLexical
)
;
return
resumeAfter
(
defLexical
loc
)
;
}
bool
WarpBuilder
:
:
build_DefLet
(
BytecodeLocation
loc
)
{
return
buildDefLexicalOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_DefConst
(
BytecodeLocation
loc
)
{
return
buildDefLexicalOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_DefFun
(
BytecodeLocation
loc
)
{
MOZ_ASSERT
(
usesEnvironmentChain
(
)
)
;
MDefinition
*
fun
=
current
-
>
pop
(
)
;
MDefinition
*
env
=
current
-
>
environmentChain
(
)
;
MDefFun
*
deffun
=
MDefFun
:
:
New
(
alloc
(
)
fun
env
)
;
current
-
>
add
(
deffun
)
;
return
resumeAfter
(
deffun
loc
)
;
}
bool
WarpBuilder
:
:
build_BindVar
(
BytecodeLocation
)
{
MOZ_ASSERT
(
usesEnvironmentChain
(
)
)
;
MDefinition
*
env
=
current
-
>
environmentChain
(
)
;
MCallBindVar
*
ins
=
MCallBindVar
:
:
New
(
alloc
(
)
env
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_MutateProto
(
BytecodeLocation
loc
)
{
MDefinition
*
value
=
current
-
>
pop
(
)
;
MDefinition
*
obj
=
current
-
>
peek
(
-
1
)
;
MMutateProto
*
mutate
=
MMutateProto
:
:
New
(
alloc
(
)
obj
value
)
;
current
-
>
add
(
mutate
)
;
return
resumeAfter
(
mutate
loc
)
;
}
bool
WarpBuilder
:
:
build_Callee
(
BytecodeLocation
)
{
/
/
TODO
:
handle
inlined
callees
when
we
implement
inlining
.
MInstruction
*
callee
=
MCallee
:
:
New
(
alloc
(
)
)
;
current
-
>
add
(
callee
)
;
current
-
>
push
(
callee
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_ClassConstructor
(
BytecodeLocation
loc
)
{
jsbytecode
*
pc
=
loc
.
toRawBytecode
(
)
;
auto
*
constructor
=
MClassConstructor
:
:
New
(
alloc
(
)
pc
)
;
current
-
>
add
(
constructor
)
;
current
-
>
push
(
constructor
)
;
return
resumeAfter
(
constructor
loc
)
;
}
bool
WarpBuilder
:
:
build_DerivedConstructor
(
BytecodeLocation
loc
)
{
jsbytecode
*
pc
=
loc
.
toRawBytecode
(
)
;
MDefinition
*
prototype
=
current
-
>
pop
(
)
;
auto
*
constructor
=
MDerivedClassConstructor
:
:
New
(
alloc
(
)
prototype
pc
)
;
current
-
>
add
(
constructor
)
;
current
-
>
push
(
constructor
)
;
return
resumeAfter
(
constructor
loc
)
;
}
bool
WarpBuilder
:
:
build_ToAsyncIter
(
BytecodeLocation
loc
)
{
MDefinition
*
nextMethod
=
current
-
>
pop
(
)
;
MDefinition
*
iterator
=
current
-
>
pop
(
)
;
MToAsyncIter
*
ins
=
MToAsyncIter
:
:
New
(
alloc
(
)
iterator
nextMethod
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
loc
)
;
}
bool
WarpBuilder
:
:
build_ToId
(
BytecodeLocation
loc
)
{
MDefinition
*
index
=
current
-
>
pop
(
)
;
MToId
*
ins
=
MToId
:
:
New
(
alloc
(
)
index
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
loc
)
;
}
bool
WarpBuilder
:
:
build_Typeof
(
BytecodeLocation
)
{
/
/
TODO
:
remove
MTypeOf
:
:
inputType_
and
unbox
in
foldsTo
instead
.
MDefinition
*
input
=
current
-
>
pop
(
)
;
MTypeOf
*
ins
=
MTypeOf
:
:
New
(
alloc
(
)
input
MIRType
:
:
Value
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_TypeofExpr
(
BytecodeLocation
loc
)
{
return
build_Typeof
(
loc
)
;
}
bool
WarpBuilder
:
:
build_Arguments
(
BytecodeLocation
loc
)
{
auto
*
snapshot
=
getOpSnapshot
<
WarpArguments
>
(
loc
)
;
MOZ_ASSERT
(
info
(
)
.
needsArgsObj
(
)
=
=
!
!
snapshot
)
;
if
(
!
snapshot
)
{
pushConstant
(
MagicValue
(
JS_OPTIMIZED_ARGUMENTS
)
)
;
return
true
;
}
ArgumentsObject
*
templateObj
=
snapshot
-
>
templateObj
(
)
;
MDefinition
*
env
=
current
-
>
environmentChain
(
)
;
auto
*
argsObj
=
MCreateArgumentsObject
:
:
New
(
alloc
(
)
env
templateObj
)
;
current
-
>
add
(
argsObj
)
;
current
-
>
setArgumentsObject
(
argsObj
)
;
current
-
>
push
(
argsObj
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_ObjWithProto
(
BytecodeLocation
loc
)
{
MDefinition
*
proto
=
current
-
>
pop
(
)
;
MInstruction
*
ins
=
MObjectWithProto
:
:
New
(
alloc
(
)
proto
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
loc
)
;
}
MDefinition
*
WarpBuilder
:
:
walkEnvironmentChain
(
uint32_t
numHops
)
{
MDefinition
*
env
=
current
-
>
environmentChain
(
)
;
for
(
uint32_t
i
=
0
;
i
<
numHops
;
i
+
+
)
{
MInstruction
*
ins
=
MEnclosingEnvironment
:
:
New
(
alloc
(
)
env
)
;
current
-
>
add
(
ins
)
;
env
=
ins
;
}
return
env
;
}
bool
WarpBuilder
:
:
build_GetAliasedVar
(
BytecodeLocation
loc
)
{
EnvironmentCoordinate
ec
=
loc
.
getEnvironmentCoordinate
(
)
;
MDefinition
*
obj
=
walkEnvironmentChain
(
ec
.
hops
(
)
)
;
MInstruction
*
load
;
if
(
EnvironmentObject
:
:
nonExtensibleIsFixedSlot
(
ec
)
)
{
load
=
MLoadFixedSlot
:
:
New
(
alloc
(
)
obj
ec
.
slot
(
)
)
;
}
else
{
MInstruction
*
slots
=
MSlots
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
slots
)
;
uint32_t
slot
=
EnvironmentObject
:
:
nonExtensibleDynamicSlotIndex
(
ec
)
;
load
=
MLoadSlot
:
:
New
(
alloc
(
)
slots
slot
)
;
}
current
-
>
add
(
load
)
;
current
-
>
push
(
load
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_SetAliasedVar
(
BytecodeLocation
loc
)
{
EnvironmentCoordinate
ec
=
loc
.
getEnvironmentCoordinate
(
)
;
MDefinition
*
val
=
current
-
>
peek
(
-
1
)
;
MDefinition
*
obj
=
walkEnvironmentChain
(
ec
.
hops
(
)
)
;
current
-
>
add
(
MPostWriteBarrier
:
:
New
(
alloc
(
)
obj
val
)
)
;
MInstruction
*
store
;
if
(
EnvironmentObject
:
:
nonExtensibleIsFixedSlot
(
ec
)
)
{
store
=
MStoreFixedSlot
:
:
NewBarriered
(
alloc
(
)
obj
ec
.
slot
(
)
val
)
;
}
else
{
MInstruction
*
slots
=
MSlots
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
slots
)
;
uint32_t
slot
=
EnvironmentObject
:
:
nonExtensibleDynamicSlotIndex
(
ec
)
;
store
=
MStoreSlot
:
:
NewBarriered
(
alloc
(
)
slots
slot
val
)
;
}
current
-
>
add
(
store
)
;
return
resumeAfter
(
store
loc
)
;
}
bool
WarpBuilder
:
:
build_EnvCallee
(
BytecodeLocation
loc
)
{
uint32_t
numHops
=
loc
.
getEnvCalleeNumHops
(
)
;
MDefinition
*
env
=
walkEnvironmentChain
(
numHops
)
;
auto
*
callee
=
MLoadFixedSlot
:
:
New
(
alloc
(
)
env
CallObject
:
:
calleeSlot
(
)
)
;
current
-
>
add
(
callee
)
;
current
-
>
push
(
callee
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_Iter
(
BytecodeLocation
loc
)
{
MDefinition
*
obj
=
current
-
>
pop
(
)
;
MInstruction
*
ins
=
MGetIteratorCache
:
:
New
(
alloc
(
)
obj
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
loc
)
;
}
bool
WarpBuilder
:
:
build_IterNext
(
BytecodeLocation
)
{
/
/
TODO
:
IterNext
was
added
as
hint
to
prevent
IonBuilder
/
TI
loop
restarts
.
/
/
Once
IonBuilder
is
gone
this
op
should
probably
just
be
removed
.
MDefinition
*
def
=
current
-
>
pop
(
)
;
MInstruction
*
unbox
=
MUnbox
:
:
New
(
alloc
(
)
def
MIRType
:
:
String
MUnbox
:
:
Infallible
)
;
current
-
>
add
(
unbox
)
;
current
-
>
push
(
unbox
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_MoreIter
(
BytecodeLocation
loc
)
{
MDefinition
*
iter
=
current
-
>
peek
(
-
1
)
;
MInstruction
*
ins
=
MIteratorMore
:
:
New
(
alloc
(
)
iter
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
loc
)
;
}
bool
WarpBuilder
:
:
build_EndIter
(
BytecodeLocation
loc
)
{
current
-
>
pop
(
)
;
/
/
Iterator
value
is
not
used
.
MDefinition
*
iter
=
current
-
>
pop
(
)
;
MInstruction
*
ins
=
MIteratorEnd
:
:
New
(
alloc
(
)
iter
)
;
current
-
>
add
(
ins
)
;
return
resumeAfter
(
ins
loc
)
;
}
bool
WarpBuilder
:
:
build_IsNoIter
(
BytecodeLocation
)
{
MDefinition
*
def
=
current
-
>
peek
(
-
1
)
;
MOZ_ASSERT
(
def
-
>
isIteratorMore
(
)
)
;
MInstruction
*
ins
=
MIsNoIter
:
:
New
(
alloc
(
)
def
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
true
;
}
bool
WarpBuilder
:
:
buildCallOp
(
BytecodeLocation
loc
)
{
uint32_t
argc
=
loc
.
getCallArgc
(
)
;
JSOp
op
=
loc
.
getOp
(
)
;
bool
constructing
=
IsConstructOp
(
op
)
;
bool
ignoresReturnValue
=
(
op
=
=
JSOp
:
:
CallIgnoresRv
)
;
CallInfo
callInfo
(
alloc
(
)
loc
.
toRawBytecode
(
)
constructing
ignoresReturnValue
)
;
if
(
!
callInfo
.
init
(
current
argc
)
)
{
return
false
;
}
/
/
TODO
:
consider
adding
a
Call
IC
like
Baseline
has
.
bool
needsThisCheck
=
false
;
if
(
callInfo
.
constructing
(
)
)
{
/
/
Inline
the
this
-
object
allocation
on
the
caller
-
side
.
MDefinition
*
callee
=
callInfo
.
fun
(
)
;
MDefinition
*
newTarget
=
callInfo
.
getNewTarget
(
)
;
MCreateThis
*
createThis
=
MCreateThis
:
:
New
(
alloc
(
)
callee
newTarget
)
;
current
-
>
add
(
createThis
)
;
callInfo
.
setThis
(
createThis
)
;
needsThisCheck
=
true
;
}
/
/
TODO
:
specialize
for
known
target
.
Pad
missing
arguments
.
Set
MCall
flags
/
/
based
on
this
known
target
.
JSFunction
*
target
=
nullptr
;
uint32_t
targetArgs
=
callInfo
.
argc
(
)
;
bool
isDOMCall
=
false
;
DOMObjectKind
objKind
=
DOMObjectKind
:
:
Unknown
;
MCall
*
call
=
MCall
:
:
New
(
alloc
(
)
target
targetArgs
+
1
+
callInfo
.
constructing
(
)
callInfo
.
argc
(
)
callInfo
.
constructing
(
)
callInfo
.
ignoresReturnValue
(
)
isDOMCall
objKind
)
;
if
(
!
call
)
{
return
false
;
}
if
(
callInfo
.
constructing
(
)
)
{
if
(
needsThisCheck
)
{
call
-
>
setNeedsThisCheck
(
)
;
}
call
-
>
addArg
(
targetArgs
+
1
callInfo
.
getNewTarget
(
)
)
;
}
/
/
Add
explicit
arguments
.
/
/
Skip
addArg
(
0
)
because
it
is
reserved
for
|
this
|
.
for
(
int32_t
i
=
callInfo
.
argc
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
call
-
>
addArg
(
i
+
1
callInfo
.
getArg
(
i
)
)
;
}
/
/
Pass
|
this
|
and
function
.
call
-
>
addArg
(
0
callInfo
.
thisArg
(
)
)
;
call
-
>
initFunction
(
callInfo
.
fun
(
)
)
;
current
-
>
add
(
call
)
;
current
-
>
push
(
call
)
;
return
resumeAfter
(
call
loc
)
;
}
bool
WarpBuilder
:
:
build_Call
(
BytecodeLocation
loc
)
{
return
buildCallOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_CallIgnoresRv
(
BytecodeLocation
loc
)
{
return
buildCallOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_CallIter
(
BytecodeLocation
loc
)
{
return
buildCallOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_New
(
BytecodeLocation
loc
)
{
return
buildCallOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_SuperCall
(
BytecodeLocation
loc
)
{
return
buildCallOp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_FunctionThis
(
BytecodeLocation
loc
)
{
MOZ_ASSERT
(
info
(
)
.
funMaybeLazy
(
)
)
;
if
(
script_
-
>
strict
(
)
)
{
/
/
No
need
to
wrap
primitive
|
this
|
in
strict
mode
.
current
-
>
pushSlot
(
info
(
)
.
thisSlot
(
)
)
;
return
true
;
}
MOZ_ASSERT
(
!
script_
-
>
hasNonSyntacticScope
(
)
"
WarpOracle
should
have
aborted
compilation
"
)
;
/
/
TODO
:
Add
fast
path
to
MComputeThis
for
null
/
undefined
=
>
globalThis
.
MDefinition
*
def
=
current
-
>
getSlot
(
info
(
)
.
thisSlot
(
)
)
;
MComputeThis
*
thisObj
=
MComputeThis
:
:
New
(
alloc
(
)
def
)
;
current
-
>
add
(
thisObj
)
;
current
-
>
push
(
thisObj
)
;
return
resumeAfter
(
thisObj
loc
)
;
}
bool
WarpBuilder
:
:
build_GlobalThis
(
BytecodeLocation
loc
)
{
MOZ_ASSERT
(
!
script_
-
>
hasNonSyntacticScope
(
)
"
WarpOracle
should
have
aborted
compilation
"
)
;
Value
v
=
snapshot_
.
globalLexicalEnvThis
(
)
;
pushConstant
(
v
)
;
return
true
;
}
MConstant
*
WarpBuilder
:
:
globalLexicalEnvConstant
(
)
{
JSObject
*
globalLexical
=
snapshot_
.
globalLexicalEnv
(
)
;
return
constant
(
ObjectValue
(
*
globalLexical
)
)
;
}
bool
WarpBuilder
:
:
buildGetNameOp
(
BytecodeLocation
loc
MDefinition
*
env
)
{
MGetNameCache
*
ins
=
MGetNameCache
:
:
New
(
alloc
(
)
env
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
loc
)
;
}
bool
WarpBuilder
:
:
build_GetName
(
BytecodeLocation
loc
)
{
return
buildGetNameOp
(
loc
current
-
>
environmentChain
(
)
)
;
}
bool
WarpBuilder
:
:
build_GetGName
(
BytecodeLocation
loc
)
{
if
(
script_
-
>
hasNonSyntacticScope
(
)
)
{
return
build_GetName
(
loc
)
;
}
/
/
Try
to
optimize
undefined
/
NaN
/
Infinity
.
PropertyName
*
name
=
loc
.
getPropertyName
(
script_
)
;
const
JSAtomState
&
names
=
mirGen_
.
runtime
-
>
names
(
)
;
if
(
name
=
=
names
.
undefined
)
{
pushConstant
(
UndefinedValue
(
)
)
;
return
true
;
}
if
(
name
=
=
names
.
NaN
)
{
pushConstant
(
JS
:
:
NaNValue
(
)
)
;
return
true
;
}
if
(
name
=
=
names
.
Infinity
)
{
pushConstant
(
JS
:
:
InfinityValue
(
)
)
;
return
true
;
}
return
buildGetNameOp
(
loc
globalLexicalEnvConstant
(
)
)
;
}
bool
WarpBuilder
:
:
buildBindNameOp
(
BytecodeLocation
loc
MDefinition
*
env
)
{
MBindNameCache
*
ins
=
MBindNameCache
:
:
New
(
alloc
(
)
env
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
loc
)
;
}
bool
WarpBuilder
:
:
build_BindName
(
BytecodeLocation
loc
)
{
return
buildBindNameOp
(
loc
current
-
>
environmentChain
(
)
)
;
}
bool
WarpBuilder
:
:
build_BindGName
(
BytecodeLocation
loc
)
{
if
(
script_
-
>
hasNonSyntacticScope
(
)
)
{
return
build_BindName
(
loc
)
;
}
return
buildBindNameOp
(
loc
globalLexicalEnvConstant
(
)
)
;
}
bool
WarpBuilder
:
:
buildGetPropOp
(
BytecodeLocation
loc
MDefinition
*
val
MDefinition
*
id
)
{
/
/
For
now
pass
monitoredResult
=
true
to
get
the
behavior
we
want
(
no
/
/
TI
-
related
restrictions
apply
similar
to
the
Baseline
IC
)
.
/
/
See
also
IonGetPropertyICFlags
.
bool
monitoredResult
=
true
;
auto
*
ins
=
MGetPropertyCache
:
:
New
(
alloc
(
)
val
id
monitoredResult
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
loc
)
;
}
bool
WarpBuilder
:
:
build_GetProp
(
BytecodeLocation
loc
)
{
PropertyName
*
name
=
loc
.
getPropertyName
(
script_
)
;
MDefinition
*
val
=
current
-
>
pop
(
)
;
MConstant
*
id
=
constant
(
StringValue
(
name
)
)
;
return
buildGetPropOp
(
loc
val
id
)
;
}
bool
WarpBuilder
:
:
build_CallProp
(
BytecodeLocation
loc
)
{
return
build_GetProp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_Length
(
BytecodeLocation
loc
)
{
return
build_GetProp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_GetElem
(
BytecodeLocation
loc
)
{
MDefinition
*
id
=
current
-
>
pop
(
)
;
MDefinition
*
val
=
current
-
>
pop
(
)
;
return
buildGetPropOp
(
loc
val
id
)
;
}
bool
WarpBuilder
:
:
build_CallElem
(
BytecodeLocation
loc
)
{
return
build_GetElem
(
loc
)
;
}
bool
WarpBuilder
:
:
buildSetPropOp
(
BytecodeLocation
loc
MDefinition
*
obj
MDefinition
*
id
MDefinition
*
val
)
{
/
/
We
need
a
GC
post
barrier
and
we
don
'
t
know
whether
the
prototype
has
/
/
indexed
properties
so
we
need
to
check
for
holes
.
We
don
'
t
need
a
TI
/
/
barrier
.
bool
strict
=
loc
.
isStrictSetOp
(
)
;
bool
needsPostBarrier
=
true
;
bool
needsTypeBarrier
=
false
;
bool
guardHoles
=
true
;
auto
*
ins
=
MSetPropertyCache
:
:
New
(
alloc
(
)
obj
id
val
strict
needsPostBarrier
needsTypeBarrier
guardHoles
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
val
)
;
return
resumeAfter
(
ins
loc
)
;
}
bool
WarpBuilder
:
:
build_SetProp
(
BytecodeLocation
loc
)
{
PropertyName
*
name
=
loc
.
getPropertyName
(
script_
)
;
MDefinition
*
val
=
current
-
>
pop
(
)
;
MDefinition
*
obj
=
current
-
>
pop
(
)
;
MConstant
*
id
=
constant
(
StringValue
(
name
)
)
;
return
buildSetPropOp
(
loc
obj
id
val
)
;
}
bool
WarpBuilder
:
:
build_StrictSetProp
(
BytecodeLocation
loc
)
{
return
build_SetProp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_SetName
(
BytecodeLocation
loc
)
{
return
build_SetProp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_StrictSetName
(
BytecodeLocation
loc
)
{
return
build_SetProp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_SetElem
(
BytecodeLocation
loc
)
{
MDefinition
*
val
=
current
-
>
pop
(
)
;
MDefinition
*
id
=
current
-
>
pop
(
)
;
MDefinition
*
obj
=
current
-
>
pop
(
)
;
return
buildSetPropOp
(
loc
obj
id
val
)
;
}
bool
WarpBuilder
:
:
build_StrictSetElem
(
BytecodeLocation
loc
)
{
return
build_SetElem
(
loc
)
;
}
bool
WarpBuilder
:
:
build_DelProp
(
BytecodeLocation
loc
)
{
PropertyName
*
name
=
loc
.
getPropertyName
(
script_
)
;
MDefinition
*
obj
=
current
-
>
pop
(
)
;
bool
strict
=
loc
.
getOp
(
)
=
=
JSOp
:
:
StrictDelProp
;
MInstruction
*
ins
=
MDeleteProperty
:
:
New
(
alloc
(
)
obj
name
strict
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
loc
)
;
}
bool
WarpBuilder
:
:
build_StrictDelProp
(
BytecodeLocation
loc
)
{
return
build_DelProp
(
loc
)
;
}
bool
WarpBuilder
:
:
build_DelElem
(
BytecodeLocation
loc
)
{
MDefinition
*
id
=
current
-
>
pop
(
)
;
MDefinition
*
obj
=
current
-
>
pop
(
)
;
bool
strict
=
loc
.
getOp
(
)
=
=
JSOp
:
:
StrictDelElem
;
MInstruction
*
ins
=
MDeleteElement
:
:
New
(
alloc
(
)
obj
id
strict
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
loc
)
;
}
bool
WarpBuilder
:
:
build_StrictDelElem
(
BytecodeLocation
loc
)
{
return
build_DelElem
(
loc
)
;
}
bool
WarpBuilder
:
:
build_SetFunName
(
BytecodeLocation
loc
)
{
FunctionPrefixKind
prefixKind
=
loc
.
getFunctionPrefixKind
(
)
;
MDefinition
*
name
=
current
-
>
pop
(
)
;
MDefinition
*
fun
=
current
-
>
pop
(
)
;
MSetFunName
*
ins
=
MSetFunName
:
:
New
(
alloc
(
)
fun
name
uint8_t
(
prefixKind
)
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
fun
)
;
return
resumeAfter
(
ins
loc
)
;
}
bool
WarpBuilder
:
:
build_PushLexicalEnv
(
BytecodeLocation
loc
)
{
MOZ_ASSERT
(
usesEnvironmentChain
(
)
)
;
LexicalScope
*
scope
=
&
loc
.
getScope
(
script_
)
-
>
as
<
LexicalScope
>
(
)
;
MDefinition
*
env
=
current
-
>
environmentChain
(
)
;
auto
*
ins
=
MNewLexicalEnvironmentObject
:
:
New
(
alloc
(
)
env
scope
)
;
current
-
>
add
(
ins
)
;
current
-
>
setEnvironmentChain
(
ins
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_PopLexicalEnv
(
BytecodeLocation
)
{
MDefinition
*
enclosingEnv
=
walkEnvironmentChain
(
1
)
;
current
-
>
setEnvironmentChain
(
enclosingEnv
)
;
return
true
;
}
void
WarpBuilder
:
:
buildCopyLexicalEnvOp
(
bool
copySlots
)
{
MOZ_ASSERT
(
usesEnvironmentChain
(
)
)
;
MDefinition
*
env
=
current
-
>
environmentChain
(
)
;
auto
*
ins
=
MCopyLexicalEnvironmentObject
:
:
New
(
alloc
(
)
env
copySlots
)
;
current
-
>
add
(
ins
)
;
current
-
>
setEnvironmentChain
(
ins
)
;
}
bool
WarpBuilder
:
:
build_FreshenLexicalEnv
(
BytecodeLocation
)
{
buildCopyLexicalEnvOp
(
/
*
copySlots
=
*
/
true
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_RecreateLexicalEnv
(
BytecodeLocation
)
{
buildCopyLexicalEnvOp
(
/
*
copySlots
=
*
/
false
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_ImplicitThis
(
BytecodeLocation
loc
)
{
MOZ_ASSERT
(
usesEnvironmentChain
(
)
)
;
PropertyName
*
name
=
loc
.
getPropertyName
(
script_
)
;
MDefinition
*
env
=
current
-
>
environmentChain
(
)
;
auto
*
ins
=
MImplicitThis
:
:
New
(
alloc
(
)
env
name
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
loc
)
;
}
bool
WarpBuilder
:
:
build_GImplicitThis
(
BytecodeLocation
loc
)
{
if
(
script_
-
>
hasNonSyntacticScope
(
)
)
{
return
build_ImplicitThis
(
loc
)
;
}
return
build_Undefined
(
loc
)
;
}
bool
WarpBuilder
:
:
build_CheckClassHeritage
(
BytecodeLocation
loc
)
{
MDefinition
*
def
=
current
-
>
pop
(
)
;
auto
*
ins
=
MCheckClassHeritage
:
:
New
(
alloc
(
)
def
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
resumeAfter
(
ins
loc
)
;
}
bool
WarpBuilder
:
:
build_CheckThis
(
BytecodeLocation
)
{
MDefinition
*
def
=
current
-
>
pop
(
)
;
auto
*
ins
=
MCheckThis
:
:
New
(
alloc
(
)
def
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_CheckThisReinit
(
BytecodeLocation
)
{
MDefinition
*
def
=
current
-
>
pop
(
)
;
auto
*
ins
=
MCheckThisReinit
:
:
New
(
alloc
(
)
def
)
;
current
-
>
add
(
ins
)
;
current
-
>
push
(
ins
)
;
return
true
;
}
bool
WarpBuilder
:
:
build_CheckReturn
(
BytecodeLocation
)
{
MOZ_ASSERT
(
!
script_
-
>
noScriptRval
(
)
)
;
MDefinition
*
returnValue
=
current
-
>
getSlot
(
info
(
)
.
returnValueSlot
(
)
)
;
MDefinition
*
thisValue
=
current
-
>
pop
(
)
;
auto
*
ins
=
MCheckReturn
:
:
New
(
alloc
(
)
returnValue
thisValue
)
;
current
-
>
add
(
ins
)
;
current
-
>
setSlot
(
info
(
)
.
returnValueSlot
(
)
ins
)
;
return
true
;
}
