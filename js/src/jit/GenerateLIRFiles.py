#
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
#
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
#
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
#
This
script
generates
jit
/
LIROpsGenerated
.
h
(
list
of
LIR
instructions
)
#
from
LIROps
.
yaml
.
import
buildconfig
import
yaml
import
six
from
collections
import
OrderedDict
from
mozbuild
.
preprocessor
import
Preprocessor
HEADER_TEMPLATE
=
"
"
"
\
/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
 
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
 
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
#
ifndef
%
(
includeguard
)
s
#
define
%
(
includeguard
)
s
/
*
This
file
is
generated
by
jit
/
GenerateLIRFiles
.
py
.
Do
not
edit
!
*
/
%
(
contents
)
s
#
endif
/
/
%
(
includeguard
)
s
"
"
"
def
load_yaml
(
yaml_path
)
:
    
#
First
invoke
preprocessor
.
py
so
that
we
can
use
#
ifdef
JS_SIMULATOR
in
    
#
the
YAML
file
.
    
pp
=
Preprocessor
(
)
    
pp
.
context
.
update
(
buildconfig
.
defines
[
"
ALLDEFINES
"
]
)
    
pp
.
out
=
six
.
StringIO
(
)
    
pp
.
do_filter
(
"
substitution
"
)
    
pp
.
do_include
(
yaml_path
)
    
contents
=
pp
.
out
.
getvalue
(
)
    
#
Load
into
an
OrderedDict
to
ensure
order
is
preserved
.
Note
:
Python
3
.
7
    
#
also
preserves
ordering
for
normal
dictionaries
.
    
#
Code
based
on
https
:
/
/
stackoverflow
.
com
/
a
/
21912744
.
    
class
OrderedLoader
(
yaml
.
Loader
)
:
        
pass
    
def
construct_mapping
(
loader
node
)
:
        
loader
.
flatten_mapping
(
node
)
        
return
OrderedDict
(
loader
.
construct_pairs
(
node
)
)
    
tag
=
yaml
.
resolver
.
BaseResolver
.
DEFAULT_MAPPING_TAG
    
OrderedLoader
.
add_constructor
(
tag
construct_mapping
)
    
return
yaml
.
load
(
contents
OrderedLoader
)
def
generate_header
(
c_out
includeguard
contents
)
:
    
c_out
.
write
(
        
HEADER_TEMPLATE
        
%
{
            
"
includeguard
"
:
includeguard
            
"
contents
"
:
contents
        
}
    
)
def
gen_lir_class
(
name
mir_op
)
:
    
"
"
"
Generates
class
definition
for
a
single
LIR
opcode
.
"
"
"
    
class_name
=
"
L
"
+
name
    
code
=
"
class
{
}
:
public
LInstructionHelper
<
0
0
0
>
{
{
"
.
format
(
class_name
)
    
code
+
=
"
\
\
\
n
public
:
\
\
\
n
LIR_HEADER
(
{
}
)
\
\
\
n
"
.
format
(
name
)
    
code
+
=
"
{
}
(
)
:
LInstructionHelper
(
classOpcode
)
{
{
}
}
\
\
\
n
"
.
format
(
class_name
)
    
if
mir_op
:
        
if
mir_op
is
True
:
            
code
+
=
"
M
{
}
*
mir
(
)
const
{
{
return
mir_
-
>
to
{
}
(
)
;
}
}
;
\
\
\
n
"
.
format
(
                
name
name
            
)
        
else
:
            
code
+
=
"
M
{
}
*
mir
(
)
const
{
{
return
mir_
-
>
to
{
}
(
)
;
}
}
;
\
\
\
n
"
.
format
(
                
mir_op
mir_op
            
)
    
code
+
=
"
}
;
\
\
\
n
"
    
return
code
def
generate_lir_header
(
c_out
yaml_path
)
:
    
data
=
load_yaml
(
yaml_path
)
    
#
LIR_OPCODE_LIST
opcode
.
    
ops
=
[
]
    
#
Generated
LIR
op
class
definitions
.
    
lir_op_classes
=
[
]
    
for
op
in
data
:
        
name
=
op
[
"
name
"
]
        
gen_boilerplate
=
op
.
get
(
"
gen_boilerplate
"
True
)
        
assert
isinstance
(
gen_boilerplate
bool
)
        
if
gen_boilerplate
:
            
gen_boilerplate
=
op
.
get
(
"
gen_boilerplate
"
True
)
            
assert
isinstance
(
gen_boilerplate
bool
)
            
mir_op
=
op
.
get
(
"
mir_op
"
None
)
            
assert
mir_op
is
None
or
True
or
str
            
lir_op_classes
.
append
(
gen_lir_class
(
name
mir_op
)
)
        
ops
.
append
(
"
_
(
{
}
)
"
.
format
(
name
)
)
    
contents
=
"
#
define
LIR_OPCODE_LIST
(
_
)
\
\
\
n
"
    
contents
+
=
"
\
\
\
n
"
.
join
(
ops
)
    
contents
+
=
"
\
n
\
n
"
    
contents
+
=
"
#
define
LIR_OPCODE_CLASS_GENERATED
\
\
\
n
"
    
contents
+
=
"
\
\
\
n
"
.
join
(
lir_op_classes
)
    
contents
+
=
"
\
n
\
n
"
    
generate_header
(
c_out
"
jit_LIROpsGenerated_h
"
contents
)
