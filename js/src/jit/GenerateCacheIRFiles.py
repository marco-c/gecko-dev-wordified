#
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
#
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
#
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
#
This
script
generates
jit
/
CacheIROpsGenerated
.
h
from
CacheIROps
.
yaml
import
buildconfig
import
yaml
import
six
from
collections
import
OrderedDict
from
mozbuild
.
preprocessor
import
Preprocessor
HEADER_TEMPLATE
=
"
"
"
\
/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
 
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
 
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
#
ifndef
%
(
includeguard
)
s
#
define
%
(
includeguard
)
s
/
*
This
file
is
generated
by
jit
/
GenerateCacheIRFiles
.
py
.
Do
not
edit
!
*
/
%
(
contents
)
s
#
endif
/
/
%
(
includeguard
)
s
"
"
"
def
generate_header
(
c_out
includeguard
contents
)
:
    
c_out
.
write
(
HEADER_TEMPLATE
%
{
        
'
includeguard
'
:
includeguard
        
'
contents
'
:
contents
    
}
)
def
load_yaml
(
yaml_path
)
:
    
#
First
invoke
preprocessor
.
py
so
that
we
can
use
#
ifdef
JS_SIMULATOR
in
    
#
the
YAML
file
.
    
pp
=
Preprocessor
(
)
    
pp
.
context
.
update
(
buildconfig
.
defines
[
'
ALLDEFINES
'
]
)
    
pp
.
out
=
six
.
StringIO
(
)
    
pp
.
do_filter
(
'
substitution
'
)
    
pp
.
do_include
(
yaml_path
)
    
contents
=
pp
.
out
.
getvalue
(
)
    
#
Load
into
an
OrderedDict
to
ensure
order
is
preserved
.
Note
:
Python
3
.
7
+
    
#
also
preserves
ordering
for
normal
dictionaries
.
    
#
Code
based
on
https
:
/
/
stackoverflow
.
com
/
a
/
21912744
.
    
class
OrderedLoader
(
yaml
.
Loader
)
:
        
pass
    
def
construct_mapping
(
loader
node
)
:
        
loader
.
flatten_mapping
(
node
)
        
return
OrderedDict
(
loader
.
construct_pairs
(
node
)
)
    
tag
=
yaml
.
resolver
.
BaseResolver
.
DEFAULT_MAPPING_TAG
    
OrderedLoader
.
add_constructor
(
tag
construct_mapping
)
    
return
yaml
.
load
(
contents
OrderedLoader
)
#
Information
for
generating
CacheIRWriter
code
for
a
single
operand
.
Tuple
#
stores
the
C
+
+
argument
type
and
the
CacheIRWriter
method
to
call
.
operand_writer_info
=
{
    
'
ValId
'
:
(
'
ValOperandId
'
'
writeOperandId
'
)
    
'
ObjId
'
:
(
'
ObjOperandId
'
'
writeOperandId
'
)
    
'
StrId
'
:
(
'
StringOperandId
'
'
writeOperandId
'
)
    
'
SymId
'
:
(
'
SymbolOperandId
'
'
writeOperandId
'
)
    
'
Int32Id
'
:
(
'
Int32OperandId
'
'
writeOperandId
'
)
    
'
ShapeField
'
:
(
'
Shape
*
'
'
writeShapeField
'
)
    
'
GroupField
'
:
(
'
ObjectGroup
*
'
'
writeGroupField
'
)
    
'
ObjectField
'
:
(
'
JSObject
*
'
'
writeObjectField
'
)
    
'
StringField
'
:
(
'
JSString
*
'
'
writeStringField
'
)
    
'
PropertyNameField
'
:
(
'
PropertyName
*
'
'
writeStringField
'
)
    
'
SymbolField
'
:
(
'
JS
:
:
Symbol
*
'
'
writeSymbolField
'
)
    
'
RawWordField
'
:
(
'
uintptr_t
'
'
writeRawWordField
'
)
    
'
RawPointerField
'
:
(
'
const
void
*
'
'
writeRawPointerField
'
)
    
'
IdField
'
:
(
'
jsid
'
'
writeIdField
'
)
    
'
JSOpImm
'
:
(
'
JSOp
'
'
writeJSOpImm
'
)
    
'
BoolImm
'
:
(
'
bool
'
'
writeBoolImm
'
)
    
'
GuardClassKindImm
'
:
(
'
GuardClassKind
'
'
writeGuardClassKindImm
'
)
    
'
JSWhyMagicImm
'
:
(
'
JSWhyMagic
'
'
writeJSWhyMagicImm
'
)
    
'
CallFlagsImm
'
:
(
'
CallFlags
'
'
writeCallFlagsImm
'
)
    
'
TypedThingLayoutImm
'
:
(
'
TypedThingLayout
'
'
writeTypedThingLayoutImm
'
)
    
'
ReferenceTypeImm
'
:
(
'
ReferenceType
'
'
writeReferenceTypeImm
'
)
    
'
ScalarTypeImm
'
:
(
'
Scalar
:
:
Type
'
'
writeScalarTypeImm
'
)
    
'
Int32Imm
'
:
(
'
int32_t
'
'
writeInt32Imm
'
)
    
'
JSNativeImm
'
:
(
'
JSNative
'
'
writeJSNativeImm
'
)
}
def
gen_writer_method
(
name
operands
)
:
    
"
"
"
Generates
a
CacheIRWRiter
method
for
a
single
opcode
.
"
"
"
    
#
Generate
a
single
method
that
writes
the
opcode
and
each
operand
.
    
#
For
example
:
    
#
    
#
void
guardShape
(
ObjOperandId
obj
Shape
*
shape
)
{
    
#
writeOp
(
CacheOp
:
:
GuardShape
)
;
    
#
writeOperandId
(
obj
)
;
    
#
writeShapeField
(
shape
)
;
    
#
}
    
#
Method
names
start
with
a
lowercase
letter
.
    
method_name
=
name
[
0
]
.
lower
(
)
+
name
[
1
:
]
    
args_sig
=
[
]
    
operands_code
=
'
'
    
if
operands
:
        
for
opnd_name
opnd_type
in
six
.
iteritems
(
operands
)
:
            
argtype
write_method
=
operand_writer_info
[
opnd_type
]
            
args_sig
.
append
(
'
{
}
{
}
'
.
format
(
argtype
opnd_name
)
)
            
operands_code
+
=
'
{
}
(
{
}
)
;
\
\
\
n
'
.
format
(
write_method
opnd_name
)
    
code
=
'
void
{
}
(
{
}
)
{
{
\
\
\
n
'
.
format
(
method_name
'
'
.
join
(
args_sig
)
)
    
code
+
=
'
writeOp
(
CacheOp
:
:
{
}
)
;
\
\
\
n
'
.
format
(
name
)
    
code
+
=
operands_code
    
code
+
=
'
}
'
    
return
code
#
Information
for
generating
CacheIRCompiler
code
for
a
single
operand
.
Tuple
#
stores
the
C
+
+
type
the
suffix
used
for
arguments
/
variables
of
this
type
and
#
the
expression
to
read
this
type
from
CacheIRReader
.
operand_compiler_info
=
{
    
'
ValId
'
:
(
'
ValOperandId
'
'
Id
'
'
reader
.
valOperandId
(
)
'
)
    
'
ObjId
'
:
(
'
ObjOperandId
'
'
Id
'
'
reader
.
objOperandId
(
)
'
)
    
'
StrId
'
:
(
'
StringOperandId
'
'
Id
'
'
reader
.
stringOperandId
(
)
'
)
    
'
SymId
'
:
(
'
SymbolOperandId
'
'
Id
'
'
reader
.
symbolOperandId
(
)
'
)
    
'
Int32Id
'
:
(
'
Int32OperandId
'
'
Id
'
'
reader
.
int32OperandId
(
)
'
)
    
'
ShapeField
'
:
(
'
uint32_t
'
'
Offset
'
'
reader
.
stubOffset
(
)
'
)
    
'
GroupField
'
:
(
'
uint32_t
'
'
Offset
'
'
reader
.
stubOffset
(
)
'
)
    
'
ObjectField
'
:
(
'
uint32_t
'
'
Offset
'
'
reader
.
stubOffset
(
)
'
)
    
'
StringField
'
:
(
'
uint32_t
'
'
Offset
'
'
reader
.
stubOffset
(
)
'
)
    
'
PropertyNameField
'
:
(
'
uint32_t
'
'
Offset
'
'
reader
.
stubOffset
(
)
'
)
    
'
SymbolField
'
:
(
'
uint32_t
'
'
Offset
'
'
reader
.
stubOffset
(
)
'
)
    
'
RawWordField
'
:
(
'
uint32_t
'
'
Offset
'
'
reader
.
stubOffset
(
)
'
)
    
'
RawPointerField
'
:
(
'
uint32_t
'
'
Offset
'
'
reader
.
stubOffset
(
)
'
)
    
'
IdField
'
:
(
'
uint32_t
'
'
Offset
'
'
reader
.
stubOffset
(
)
'
)
    
'
JSOpImm
'
:
(
'
JSOp
'
'
'
'
reader
.
jsop
(
)
'
)
    
'
BoolImm
'
:
(
'
bool
'
'
'
'
reader
.
readBool
(
)
'
)
    
'
GuardClassKindImm
'
:
(
'
GuardClassKind
'
'
'
'
reader
.
guardClassKind
(
)
'
)
    
'
JSWhyMagicImm
'
:
(
'
JSWhyMagic
'
'
'
'
reader
.
whyMagic
(
)
'
)
    
'
CallFlagsImm
'
:
(
'
CallFlags
'
'
'
'
reader
.
callFlags
(
)
'
)
    
'
TypedThingLayoutImm
'
:
(
'
TypedThingLayout
'
'
'
'
reader
.
typedThingLayout
(
)
'
)
    
'
ReferenceTypeImm
'
:
(
'
ReferenceType
'
'
'
'
reader
.
referenceTypeDescrType
(
)
'
)
    
'
ScalarTypeImm
'
:
(
'
Scalar
:
:
Type
'
'
'
'
reader
.
scalarType
(
)
'
)
    
'
Int32Imm
'
:
(
'
int32_t
'
'
'
'
reader
.
int32Immediate
(
)
'
)
    
'
JSNativeImm
'
:
(
'
JSNative
'
'
'
'
reinterpret_cast
<
JSNative
>
(
reader
.
pointer
(
)
)
'
)
}
def
gen_compiler_method
(
name
operands
)
:
    
"
"
"
Generates
CacheIRCompiler
header
code
for
a
single
opcode
.
"
"
"
    
method_name
=
'
emit
'
+
name
    
#
If
there
are
no
operands
just
generate
a
bool
emitFoo
(
)
;
signature
.
    
if
not
operands
:
        
return
'
MOZ_MUST_USE
bool
{
}
(
)
;
\
\
\
n
'
.
format
(
method_name
)
    
#
If
there
are
operands
we
generate
the
signature
of
the
method
that
needs
    
#
to
be
implemented
and
a
separate
function
forwarding
to
it
.
For
example
:
    
#
    
#
MOZ_MUST_USE
bool
emitGuardShape
(
ObjOperandId
objId
uint32_t
shapeOffset
)
;
    
#
MOZ_MUST_USE
bool
emitGuardShape
(
)
{
    
#
ObjOperandId
objId
=
reader
.
objOperandId
(
)
;
    
#
uint32_t
shapeOffset
=
reader
.
stubOffset
(
)
;
    
#
return
emitGuardShape
(
objId
shapeOffset
)
;
    
#
}
    
args_names
=
[
]
    
args_sig
=
[
]
    
operands_code
=
'
'
    
for
opnd_name
opnd_type
in
six
.
iteritems
(
operands
)
:
        
vartype
suffix
readexpr
=
operand_compiler_info
[
opnd_type
]
        
varname
=
opnd_name
+
suffix
        
args_names
.
append
(
varname
)
        
args_sig
.
append
(
'
{
}
{
}
'
.
format
(
vartype
varname
)
)
        
operands_code
+
=
'
{
}
{
}
=
{
}
;
\
\
\
n
'
.
format
(
vartype
varname
readexpr
)
    
#
Generate
signature
.
    
code
=
'
MOZ_MUST_USE
bool
{
}
(
{
}
)
;
\
\
\
n
'
.
format
(
method_name
'
'
.
join
(
args_sig
)
)
    
#
Generate
the
method
forwarding
to
it
.
    
code
+
=
'
MOZ_MUST_USE
bool
{
}
(
)
{
{
\
\
\
n
'
.
format
(
method_name
)
    
code
+
=
operands_code
    
code
+
=
'
return
{
}
(
{
}
)
;
\
\
\
n
'
.
format
(
method_name
'
'
.
join
(
args_names
)
)
    
code
+
=
'
}
\
\
\
n
'
    
return
code
def
generate_cacheirops_header
(
c_out
yaml_path
)
:
    
"
"
"
Generate
CacheIROpsGenerated
.
h
from
CacheIROps
.
yaml
.
The
generated
file
    
contains
:
    
*
A
list
of
all
CacheIR
ops
:
        
#
define
CACHE_IR_OPS
(
_
)
\
        
_
(
GuardToObject
Id
)
\
        
_
(
CompareObjectUndefinedNullResult
Id
Byte
)
\
        
.
.
.
    
*
Lists
of
shared
and
unshared
ops
for
the
CacheIRCompiler
classes
.
See
the
    
'
shared
'
attribute
in
the
YAML
file
.
    
*
Generated
source
code
for
CacheIRWriter
and
CacheIRCompiler
.
    
"
"
"
    
data
=
load_yaml
(
yaml_path
)
    
#
Mapping
from
operand
types
to
the
less
precise
types
expected
by
current
    
#
C
+
+
code
.
    
mapping
=
{
        
'
ValId
'
:
'
Id
'
        
'
ObjId
'
:
'
Id
'
        
'
StrId
'
:
'
Id
'
        
'
SymId
'
:
'
Id
'
        
'
Int32Id
'
:
'
Id
'
        
'
NumId
'
:
'
Id
'
        
'
BigIntId
'
:
'
Id
'
        
'
ValTagId
'
:
'
Id
'
        
'
AnyId
'
:
'
Id
'
        
'
ShapeField
'
:
'
Field
'
        
'
GroupField
'
:
'
Field
'
        
'
ObjectField
'
:
'
Field
'
        
'
StringField
'
:
'
Field
'
        
'
PropertyNameField
'
:
'
Field
'
        
'
SymbolField
'
:
'
Field
'
        
'
RawWordField
'
:
'
Field
'
        
'
RawPointerField
'
:
'
Field
'
        
'
DOMExpandoGenerationField
'
:
'
Field
'
        
'
IdField
'
:
'
Field
'
        
'
ValueField
'
:
'
Field
'
        
'
FieldOffset
'
:
'
Field
'
        
'
ByteImm
'
:
'
Byte
'
        
'
BoolImm
'
:
'
Byte
'
        
'
CallFlagsImm
'
:
'
Byte
'
        
'
TypedThingLayoutImm
'
:
'
Byte
'
        
'
ReferenceTypeImm
'
:
'
Byte
'
        
'
ScalarTypeImm
'
:
'
Byte
'
        
'
MetaTwoByteKindImm
'
:
'
Byte
'
        
'
JSOpImm
'
:
'
Byte
'
        
'
ValueTypeImm
'
:
'
Byte
'
        
'
GuardClassKindImm
'
:
'
Byte
'
        
'
JSWhyMagicImm
'
:
'
Byte
'
        
'
Int32Imm
'
:
'
Int32
'
        
'
UInt32Imm
'
:
'
UInt32
'
        
'
JSNativeImm
'
:
'
Word
'
        
'
StaticStringImm
'
:
'
Word
'
    
}
    
#
CACHE_IR_OPS
items
.
    
ops_items
=
[
]
    
#
CACHE_IR_SHARED_OPS
and
CACHE_IR_UNSHARED_OPS
items
.
These
will
go
away
    
#
when
all
ops
have
generated
boilerplate
.
    
ops_shared
=
[
]
    
ops_unshared
=
[
]
    
#
Generated
CacheIRWriter
methods
.
    
writer_methods
=
[
]
    
#
Generated
CacheIRCompiler
methods
.
    
compiler_shared_methods
=
[
]
    
compiler_unshared_methods
=
[
]
    
for
op
in
data
:
        
name
=
op
[
'
name
'
]
        
operands
=
op
[
'
operands
'
]
        
assert
operands
is
None
or
isinstance
(
operands
OrderedDict
)
        
shared
=
op
[
'
shared
'
]
        
assert
isinstance
(
shared
bool
)
        
gen_boilerplate
=
op
.
get
(
'
gen_boilerplate
'
False
)
        
if
operands
:
            
operands_str
=
'
'
.
join
(
[
mapping
[
v
]
for
v
in
operands
.
values
(
)
]
)
        
else
:
            
operands_str
=
'
None
'
        
ops_items
.
append
(
'
_
(
{
}
{
}
)
'
.
format
(
name
operands_str
)
)
        
if
gen_boilerplate
:
            
writer_methods
.
append
(
gen_writer_method
(
name
operands
)
)
            
if
shared
:
                
compiler_shared_methods
.
append
(
gen_compiler_method
(
name
operands
)
)
            
else
:
                
compiler_unshared_methods
.
append
(
gen_compiler_method
(
name
operands
)
)
        
else
:
            
if
shared
:
                
ops_shared
.
append
(
'
_
(
{
}
)
'
.
format
(
name
)
)
            
else
:
                
ops_unshared
.
append
(
'
_
(
{
}
)
'
.
format
(
name
)
)
    
contents
=
'
#
define
CACHE_IR_OPS
(
_
)
\
\
\
n
'
    
contents
+
=
'
\
\
\
n
'
.
join
(
ops_items
)
    
contents
+
=
'
\
n
\
n
'
    
contents
+
=
'
#
define
CACHE_IR_SHARED_OPS
(
_
)
\
\
\
n
'
    
contents
+
=
'
\
\
\
n
'
.
join
(
ops_shared
)
    
contents
+
=
'
\
n
\
n
'
    
contents
+
=
'
#
define
CACHE_IR_UNSHARED_OPS
(
_
)
\
\
\
n
'
    
contents
+
=
'
\
\
\
n
'
.
join
(
ops_unshared
)
    
contents
+
=
'
\
n
\
n
'
    
contents
+
=
'
#
define
CACHE_IR_WRITER_GENERATED
\
\
\
n
'
    
contents
+
=
'
\
\
\
n
'
.
join
(
writer_methods
)
    
contents
+
=
'
\
n
\
n
'
    
contents
+
=
'
#
define
CACHE_IR_COMPILER_SHARED_GENERATED
\
\
\
n
'
    
contents
+
=
'
\
\
\
n
'
.
join
(
compiler_shared_methods
)
    
contents
+
=
'
\
n
\
n
'
    
contents
+
=
'
#
define
CACHE_IR_COMPILER_UNSHARED_GENERATED
\
\
\
n
'
    
contents
+
=
'
\
\
\
n
'
.
join
(
compiler_unshared_methods
)
    
contents
+
=
'
\
n
\
n
'
    
generate_header
(
c_out
'
jit_CacheIROpsGenerated_h
'
contents
)
