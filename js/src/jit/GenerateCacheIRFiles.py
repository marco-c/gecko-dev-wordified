#
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
#
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
#
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
#
This
script
generates
jit
/
CacheIROpsGenerated
.
h
from
CacheIROps
.
yaml
import
buildconfig
import
yaml
from
collections
import
OrderedDict
from
six
import
StringIO
from
mozbuild
.
preprocessor
import
Preprocessor
HEADER_TEMPLATE
=
"
"
"
\
/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
 
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
 
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
#
ifndef
%
(
includeguard
)
s
#
define
%
(
includeguard
)
s
/
*
This
file
is
generated
by
jit
/
GenerateCacheIRFiles
.
py
.
Do
not
edit
!
*
/
%
(
contents
)
s
#
endif
/
/
%
(
includeguard
)
s
"
"
"
def
generate_header
(
c_out
includeguard
contents
)
:
    
c_out
.
write
(
HEADER_TEMPLATE
%
{
        
'
includeguard
'
:
includeguard
        
'
contents
'
:
contents
    
}
)
def
load_yaml
(
yaml_path
)
:
    
#
First
invoke
preprocessor
.
py
so
that
we
can
use
#
ifdef
JS_SIMULATOR
in
    
#
the
YAML
file
.
    
pp
=
Preprocessor
(
)
    
pp
.
context
.
update
(
buildconfig
.
defines
[
'
ALLDEFINES
'
]
)
    
pp
.
out
=
StringIO
(
)
    
pp
.
do_filter
(
'
substitution
'
)
    
pp
.
do_include
(
yaml_path
)
    
contents
=
pp
.
out
.
getvalue
(
)
    
#
Load
into
an
OrderedDict
to
ensure
order
is
preserved
.
Note
:
Python
3
.
7
+
    
#
also
preserves
ordering
for
normal
dictionaries
.
    
#
Code
based
on
https
:
/
/
stackoverflow
.
com
/
a
/
21912744
.
    
class
OrderedLoader
(
yaml
.
Loader
)
:
        
pass
    
def
construct_mapping
(
loader
node
)
:
        
loader
.
flatten_mapping
(
node
)
        
return
OrderedDict
(
loader
.
construct_pairs
(
node
)
)
    
tag
=
yaml
.
resolver
.
BaseResolver
.
DEFAULT_MAPPING_TAG
    
OrderedLoader
.
add_constructor
(
tag
construct_mapping
)
    
return
yaml
.
load
(
contents
OrderedLoader
)
def
generate_cacheirops_header
(
c_out
yaml_path
)
:
    
"
"
"
Generate
CacheIROpsGenerated
.
h
from
CacheIROps
.
yaml
.
The
generated
file
    
has
a
list
of
CacheIR
ops
like
this
:
        
#
define
CACHE_IR_OPS
(
_
)
\
        
_
(
GuardToObject
Id
)
\
        
_
(
CompareObjectUndefinedNullResult
Id
Byte
)
\
        
.
.
.
    
It
also
contains
lists
of
shared
and
unshared
ops
.
See
the
'
shared
'
    
attribute
in
the
YAML
file
.
    
"
"
"
    
data
=
load_yaml
(
yaml_path
)
    
#
Mapping
from
operand
types
to
the
less
precise
types
expected
by
current
    
#
C
+
+
code
.
    
mapping
=
{
        
'
ValId
'
:
'
Id
'
        
'
ObjId
'
:
'
Id
'
        
'
StrId
'
:
'
Id
'
        
'
SymId
'
:
'
Id
'
        
'
Int32Id
'
:
'
Id
'
        
'
NumId
'
:
'
Id
'
        
'
BigIntId
'
:
'
Id
'
        
'
ValTagId
'
:
'
Id
'
        
'
AnyId
'
:
'
Id
'
        
'
ShapeField
'
:
'
Field
'
        
'
GroupField
'
:
'
Field
'
        
'
ObjectField
'
:
'
Field
'
        
'
StringField
'
:
'
Field
'
        
'
SymbolField
'
:
'
Field
'
        
'
RawWordField
'
:
'
Field
'
        
'
DOMExpandoGenerationField
'
:
'
Field
'
        
'
IdField
'
:
'
Field
'
        
'
ValueField
'
:
'
Field
'
        
'
FieldOffset
'
:
'
Field
'
        
'
ByteImm
'
:
'
Byte
'
        
'
BoolImm
'
:
'
Byte
'
        
'
CallFlagsImm
'
:
'
Byte
'
        
'
TypedThingLayoutImm
'
:
'
Byte
'
        
'
ReferenceTypeImm
'
:
'
Byte
'
        
'
ScalarTypeImm
'
:
'
Byte
'
        
'
MetaTwoByteKindImm
'
:
'
Byte
'
        
'
JSOpImm
'
:
'
Byte
'
        
'
ValueTypeImm
'
:
'
Byte
'
        
'
GuardClassKindImm
'
:
'
Byte
'
        
'
JSWhyMagicImm
'
:
'
Byte
'
        
'
Int32Imm
'
:
'
Int32
'
        
'
UInt32Imm
'
:
'
UInt32
'
        
'
JSNativeImm
'
:
'
Word
'
        
'
StaticStringImm
'
:
'
Word
'
    
}
    
ops_items
=
[
]
    
ops_shared
=
[
]
    
ops_unshared
=
[
]
    
for
op
in
data
:
        
name
=
op
[
'
name
'
]
        
operands
=
op
[
'
operands
'
]
        
assert
operands
is
None
or
isinstance
(
operands
OrderedDict
)
        
shared
=
op
[
'
shared
'
]
        
assert
isinstance
(
shared
bool
)
        
if
operands
:
            
operands_str
=
'
'
.
join
(
[
mapping
[
v
]
for
v
in
operands
.
values
(
)
]
)
        
else
:
            
operands_str
=
'
None
'
        
ops_items
.
append
(
'
_
(
{
}
{
}
)
'
.
format
(
name
operands_str
)
)
        
if
shared
:
            
ops_shared
.
append
(
'
_
(
{
}
)
'
.
format
(
name
)
)
        
else
:
            
ops_unshared
.
append
(
'
_
(
{
}
)
'
.
format
(
name
)
)
    
contents
=
'
#
define
CACHE_IR_OPS
(
_
)
\
\
\
n
'
    
contents
+
=
'
\
\
\
n
'
.
join
(
ops_items
)
    
contents
+
=
'
\
n
\
n
'
    
contents
+
=
'
#
define
CACHE_IR_SHARED_OPS
(
_
)
\
\
\
n
'
    
contents
+
=
'
\
\
\
n
'
.
join
(
ops_shared
)
    
contents
+
=
'
\
n
\
n
'
    
contents
+
=
'
#
define
CACHE_IR_UNSHARED_OPS
(
_
)
\
\
\
n
'
    
contents
+
=
'
\
\
\
n
'
.
join
(
ops_unshared
)
    
contents
+
=
'
\
n
\
n
'
    
generate_header
(
c_out
'
jit_CacheIROpsGenerated_h
'
contents
)
