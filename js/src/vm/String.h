/
*
-
*
-
Mode
:
C
+
+
;
tab
-
width
:
8
;
indent
-
tabs
-
mode
:
nil
;
c
-
basic
-
offset
:
4
-
*
-
*
vim
:
set
ts
=
8
sts
=
4
et
sw
=
4
tw
=
99
:
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
#
ifndef
vm_String_h
#
define
vm_String_h
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
jsstr
.
h
"
#
include
"
gc
/
Barrier
.
h
"
#
include
"
gc
/
Heap
.
h
"
#
include
"
gc
/
Marking
.
h
"
#
include
"
gc
/
Rooting
.
h
"
#
include
"
js
/
CharacterEncoding
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
class
JSDependentString
;
class
JSExtensibleString
;
class
JSExternalString
;
class
JSInlineString
;
class
JSRope
;
namespace
js
{
class
StaticStrings
;
class
PropertyName
;
/
*
The
buffer
length
required
to
contain
any
unsigned
32
-
bit
integer
.
*
/
static
const
size_t
UINT32_CHAR_BUFFER_LENGTH
=
sizeof
(
"
4294967295
"
)
-
1
;
}
/
*
namespace
js
*
/
/
*
*
JavaScript
strings
*
*
Conceptually
a
JS
string
is
just
an
array
of
chars
and
a
length
.
This
array
*
of
chars
may
or
may
not
be
null
-
terminated
and
if
it
is
the
null
character
*
is
not
included
in
the
length
.
*
*
To
improve
performance
of
common
operations
the
following
optimizations
are
*
made
which
affect
the
engine
'
s
representation
of
strings
:
*
*
-
The
plain
vanilla
representation
is
a
"
flat
"
string
which
consists
of
a
*
string
header
in
the
GC
heap
and
a
malloc
'
d
null
terminated
char
array
.
*
*
-
To
avoid
copying
a
substring
of
an
existing
"
base
"
string
a
"
dependent
"
*
string
(
JSDependentString
)
can
be
created
which
points
into
the
base
*
string
'
s
char
array
.
*
*
-
To
avoid
O
(
n
^
2
)
char
buffer
copying
a
"
rope
"
node
(
JSRope
)
can
be
created
*
to
represent
a
delayed
string
concatenation
.
Concatenation
(
called
*
flattening
)
is
performed
if
and
when
a
linear
char
array
is
requested
.
In
*
general
ropes
form
a
binary
dag
whose
internal
nodes
are
JSRope
string
*
headers
with
no
associated
char
array
and
whose
leaf
nodes
are
either
flat
*
or
dependent
strings
.
*
*
-
To
avoid
copying
the
left
-
hand
side
when
flattening
the
left
-
hand
side
'
s
*
buffer
may
be
grown
to
make
space
for
a
copy
of
the
right
-
hand
side
(
see
*
comment
in
JSString
:
:
flatten
)
.
This
optimization
requires
that
there
are
*
no
external
pointers
into
the
char
array
.
We
conservatively
maintain
this
*
property
via
a
flat
string
'
s
"
extensible
"
property
.
*
*
-
To
avoid
allocating
small
char
arrays
short
strings
can
be
stored
inline
*
in
the
string
header
(
JSInlineString
)
.
To
increase
the
max
size
of
such
*
inline
strings
larger
string
headers
can
be
used
(
JSFatInlineString
)
.
*
*
-
To
avoid
comparing
O
(
n
)
string
equality
comparison
strings
can
be
*
canonicalized
to
"
atoms
"
(
JSAtom
)
such
that
there
is
a
single
atom
with
a
*
given
(
length
chars
)
.
*
*
-
To
avoid
copying
all
strings
created
through
the
JSAPI
an
"
external
"
*
string
(
JSExternalString
)
can
be
created
whose
chars
are
managed
by
the
*
JSAPI
client
.
*
*
-
To
avoid
using
two
bytes
per
character
for
every
string
string
characters
*
are
stored
as
Latin1
instead
of
TwoByte
if
all
characters
are
representable
*
in
Latin1
.
Note
that
Latin1
strings
are
not
yet
enabled
by
default
see
*
bug
998392
.
*
*
Although
all
strings
share
the
same
basic
memory
layout
we
can
conceptually
*
arrange
them
into
a
hierarchy
of
operations
/
invariants
and
represent
this
*
hierarchy
in
C
+
+
with
classes
:
*
*
C
+
+
type
operations
+
fields
/
invariants
+
properties
*
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
*
JSString
(
abstract
)
get
(
Latin1
|
TwoByte
)
CharsZ
get
(
Latin1
|
TwoByte
)
Chars
length
/
-
*
|
\
*
|
JSRope
leftChild
rightChild
/
-
*
|
*
JSLinearString
(
abstract
)
latin1Chars
twoByteChars
/
might
be
null
-
terminated
*
|
\
*
|
JSDependentString
base
/
-
*
|
*
JSFlatString
-
/
null
terminated
*
|
|
*
|
+
-
-
JSExternalString
-
/
char
array
memory
managed
by
embedding
*
|
|
*
|
+
-
-
JSExtensibleString
capacity
/
no
external
pointers
into
char
array
*
|
|
*
|
+
-
-
JSUndependedString
original
dependent
base
/
-
*
|
|
*
|
+
-
-
JSInlineString
-
/
chars
stored
in
header
*
|
\
*
|
JSFatInlineString
-
/
header
is
fat
*
|
*
JSAtom
-
/
string
equality
=
=
=
pointer
equality
*
|
*
js
:
:
PropertyName
-
/
chars
don
'
t
contain
an
index
(
uint32_t
)
*
*
Classes
marked
with
(
abstract
)
above
are
not
literally
C
+
+
Abstract
Base
*
Classes
(
since
there
are
no
virtual
functions
pure
or
not
in
this
*
hierarchy
)
but
have
the
same
meaning
:
there
are
no
strings
with
this
type
as
*
its
most
-
derived
type
.
*
*
Atoms
can
additionally
be
permanent
i
.
e
.
unable
to
be
collected
and
can
*
be
combined
with
other
string
types
to
create
additional
most
-
derived
types
*
that
satisfy
the
invariants
of
more
than
one
of
the
abovementioned
*
most
-
derived
types
:
*
-
InlineAtom
=
JSInlineString
+
JSAtom
(
atom
with
inline
chars
)
*
-
FatInlineAtom
=
JSFatInlineString
+
JSAtom
(
atom
with
(
more
)
inline
chars
)
*
*
Derived
string
types
can
be
queried
from
ancestor
types
via
isX
(
)
and
*
retrieved
with
asX
(
)
debug
-
only
-
checked
casts
.
*
*
The
ensureX
(
)
operations
mutate
'
this
'
in
place
to
effectively
the
type
to
be
*
at
least
X
(
e
.
g
.
ensureLinear
will
change
a
JSRope
to
be
a
JSFlatString
)
.
*
/
class
JSString
:
public
js
:
:
gc
:
:
BarrieredCell
<
JSString
>
{
protected
:
static
const
size_t
NUM_INLINE_CHARS_LATIN1
=
2
*
sizeof
(
void
*
)
/
sizeof
(
char
)
;
static
const
size_t
NUM_INLINE_CHARS_TWO_BYTE
=
2
*
sizeof
(
void
*
)
/
sizeof
(
jschar
)
;
/
*
Fields
only
apply
to
string
types
commented
on
the
right
.
*
/
struct
Data
{
union
{
struct
{
uint32_t
flags
;
/
*
JSString
*
/
uint32_t
length
;
/
*
JSString
*
/
}
;
uintptr_t
flattenData
;
/
*
JSRope
(
temporary
while
flattening
)
*
/
}
u1
;
union
{
union
{
/
*
JS
(
Fat
)
InlineString
*
/
char
inlineStorageLatin1
[
NUM_INLINE_CHARS_LATIN1
]
;
jschar
inlineStorageTwoByte
[
NUM_INLINE_CHARS_TWO_BYTE
]
;
}
;
struct
{
union
{
const
char
*
nonInlineCharsLatin1
;
/
*
JSLinearString
except
JS
(
Fat
)
InlineString
*
/
const
jschar
*
nonInlineCharsTwoByte
;
/
*
JSLinearString
except
JS
(
Fat
)
InlineString
*
/
JSString
*
left
;
/
*
JSRope
*
/
}
u2
;
union
{
JSLinearString
*
base
;
/
*
JS
(
Dependent
|
Undepended
)
String
*
/
JSString
*
right
;
/
*
JSRope
*
/
size_t
capacity
;
/
*
JSFlatString
(
extensible
)
*
/
const
JSStringFinalizer
*
externalFinalizer
;
/
*
JSExternalString
*
/
}
u3
;
}
s
;
}
;
}
d
;
public
:
/
*
Flags
exposed
only
for
jits
*
/
/
*
*
The
Flags
Word
*
*
The
flags
word
stores
both
the
string
'
s
type
and
its
character
encoding
.
*
*
If
LATIN1_CHARS_BIT
is
set
the
string
'
s
characters
are
stored
as
Latin1
*
instead
of
TwoByte
.
This
flag
can
also
be
set
for
ropes
if
both
the
*
left
and
right
nodes
are
Latin1
.
Flattening
will
result
in
a
Latin1
*
string
in
this
case
.
*
*
The
other
flags
store
the
string
'
s
type
.
Instead
of
using
a
dense
index
*
to
represent
the
most
-
derived
type
string
types
are
encoded
to
allow
*
single
-
op
tests
for
hot
queries
(
isRope
isDependent
isFlat
isAtom
)
*
which
in
view
of
subtyping
would
require
slower
*
(
isX
(
)
|
|
isY
(
)
|
|
isZ
(
)
)
.
*
*
The
string
type
encoding
can
be
summarized
as
follows
.
The
"
instance
*
encoding
"
entry
for
a
type
specifies
the
flag
bits
used
to
create
a
*
string
instance
of
that
type
.
Abstract
types
have
no
instances
and
thus
*
have
no
such
entry
.
The
"
subtype
predicate
"
entry
for
a
type
specifies
*
the
predicate
used
to
query
whether
a
JSString
instance
is
subtype
*
(
reflexively
)
of
that
type
.
*
*
String
Instance
Subtype
*
type
encoding
predicate
*
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
*
Rope
000000
000000
*
Linear
-
!
000000
*
HasBase
-
xxxx1x
*
Dependent
000010
000010
*
Flat
-
xxxxx1
*
Undepended
000011
000011
*
Extensible
010001
010001
*
Inline
000101
xxx1xx
*
FatInline
010101
x1x1xx
*
External
100001
100001
*
Atom
001001
xx1xxx
*
PermanentAtom
101001
1x1xxx
*
InlineAtom
-
xx11xx
*
FatInlineAtom
-
x111xx
*
*
Note
that
the
first
4
flag
bits
(
from
right
to
left
in
the
previous
table
)
*
have
the
following
meaning
and
can
be
used
for
some
hot
queries
:
*
*
Bit
0
:
IsFlat
*
Bit
1
:
HasBase
(
Dependent
Undepended
)
*
Bit
2
:
IsInline
(
Inline
FatInline
)
*
Bit
3
:
IsAtom
(
Atom
PermanentAtom
)
*
*
"
HasBase
"
here
refers
to
the
two
string
types
that
have
a
'
base
'
field
:
*
JSDependentString
and
JSUndependedString
.
*
A
JSUndependedString
is
a
JSDependentString
which
has
been
'
fixed
'
(
by
ensureFixed
)
*
to
be
null
-
terminated
.
In
such
cases
the
string
must
keep
marking
its
base
since
*
there
may
be
any
number
of
*
other
*
JSDependentStrings
transitively
depending
on
it
.
*
*
/
static
const
uint32_t
FLAT_BIT
=
JS_BIT
(
0
)
;
static
const
uint32_t
HAS_BASE_BIT
=
JS_BIT
(
1
)
;
static
const
uint32_t
INLINE_CHARS_BIT
=
JS_BIT
(
2
)
;
static
const
uint32_t
ATOM_BIT
=
JS_BIT
(
3
)
;
static
const
uint32_t
ROPE_FLAGS
=
0
;
static
const
uint32_t
DEPENDENT_FLAGS
=
HAS_BASE_BIT
;
static
const
uint32_t
UNDEPENDED_FLAGS
=
FLAT_BIT
|
HAS_BASE_BIT
;
static
const
uint32_t
EXTENSIBLE_FLAGS
=
FLAT_BIT
|
JS_BIT
(
4
)
;
static
const
uint32_t
EXTERNAL_FLAGS
=
FLAT_BIT
|
JS_BIT
(
5
)
;
static
const
uint32_t
FAT_INLINE_MASK
=
INLINE_CHARS_BIT
|
JS_BIT
(
4
)
;
static
const
uint32_t
PERMANENT_ATOM_MASK
=
ATOM_BIT
|
JS_BIT
(
5
)
;
/
*
Initial
flags
for
inline
and
fat
inline
strings
.
*
/
static
const
uint32_t
INIT_INLINE_FLAGS
=
FLAT_BIT
|
INLINE_CHARS_BIT
;
static
const
uint32_t
INIT_FAT_INLINE_FLAGS
=
FLAT_BIT
|
FAT_INLINE_MASK
;
static
const
uint32_t
TYPE_FLAGS_MASK
=
JS_BIT
(
6
)
-
1
;
static
const
uint32_t
LATIN1_CHARS_BIT
=
JS_BIT
(
6
)
;
static
const
uint32_t
MAX_LENGTH
=
JS_BIT
(
28
)
-
1
;
/
*
*
Helper
function
to
validate
that
a
string
of
a
given
length
is
*
representable
by
a
JSString
.
An
allocation
overflow
is
reported
if
false
*
is
returned
.
*
/
static
inline
bool
validateLength
(
js
:
:
ThreadSafeContext
*
maybecx
size_t
length
)
;
static
void
staticAsserts
(
)
{
static_assert
(
JSString
:
:
MAX_LENGTH
<
UINT32_MAX
"
Length
must
fit
in
32
bits
"
)
;
static_assert
(
sizeof
(
JSString
)
=
=
(
offsetof
(
JSString
d
.
inlineStorageLatin1
)
+
NUM_INLINE_CHARS_LATIN1
*
sizeof
(
char
)
)
"
Inline
chars
must
fit
in
a
JSString
"
)
;
static_assert
(
sizeof
(
JSString
)
=
=
(
offsetof
(
JSString
d
.
inlineStorageTwoByte
)
+
NUM_INLINE_CHARS_TWO_BYTE
*
sizeof
(
jschar
)
)
"
Inline
chars
must
fit
in
a
JSString
"
)
;
/
*
Ensure
js
:
:
shadow
:
:
Atom
has
the
same
layout
.
*
/
using
js
:
:
shadow
:
:
Atom
;
static_assert
(
offsetof
(
JSString
d
.
u1
.
length
)
=
=
offsetof
(
Atom
length
)
"
shadow
:
:
Atom
length
offset
must
match
JSString
"
)
;
static_assert
(
offsetof
(
JSString
d
.
u1
.
flags
)
=
=
offsetof
(
Atom
flags
)
"
shadow
:
:
Atom
flags
offset
must
match
JSString
"
)
;
static_assert
(
offsetof
(
JSString
d
.
s
.
u2
.
nonInlineCharsLatin1
)
=
=
offsetof
(
Atom
nonInlineCharsLatin1
)
"
shadow
:
:
Atom
nonInlineChars
offset
must
match
JSString
"
)
;
static_assert
(
offsetof
(
JSString
d
.
s
.
u2
.
nonInlineCharsTwoByte
)
=
=
offsetof
(
Atom
nonInlineCharsTwoByte
)
"
shadow
:
:
Atom
nonInlineChars
offset
must
match
JSString
"
)
;
static_assert
(
offsetof
(
JSString
d
.
inlineStorageLatin1
)
=
=
offsetof
(
Atom
inlineStorageLatin1
)
"
shadow
:
:
Atom
inlineStorage
offset
must
match
JSString
"
)
;
static_assert
(
offsetof
(
JSString
d
.
inlineStorageTwoByte
)
=
=
offsetof
(
Atom
inlineStorageTwoByte
)
"
shadow
:
:
Atom
inlineStorage
offset
must
match
JSString
"
)
;
static_assert
(
INLINE_CHARS_BIT
=
=
Atom
:
:
INLINE_CHARS_BIT
"
shadow
:
:
Atom
:
:
INLINE_CHARS_BIT
must
match
JSString
:
:
INLINE_CHARS_BIT
"
)
;
static_assert
(
LATIN1_CHARS_BIT
=
=
Atom
:
:
LATIN1_CHARS_BIT
"
shadow
:
:
Atom
:
:
LATIN1_CHARS_BIT
must
match
JSString
:
:
LATIN1_CHARS_BIT
"
)
;
}
/
*
Avoid
lame
compile
errors
in
JSRope
:
:
flatten
*
/
friend
class
JSRope
;
public
:
/
*
All
strings
have
length
.
*
/
MOZ_ALWAYS_INLINE
size_t
length
(
)
const
{
return
d
.
u1
.
length
;
}
MOZ_ALWAYS_INLINE
bool
empty
(
)
const
{
return
d
.
u1
.
length
=
=
0
;
}
/
*
*
All
strings
have
a
fallible
operation
to
get
an
array
of
chars
.
*
getCharsZ
additionally
ensures
the
array
is
null
terminated
.
*
/
inline
const
jschar
*
getChars
(
js
:
:
ExclusiveContext
*
cx
)
;
inline
const
jschar
*
getCharsZ
(
js
:
:
ExclusiveContext
*
cx
)
;
inline
bool
getChar
(
js
:
:
ExclusiveContext
*
cx
size_t
index
jschar
*
code
)
;
/
*
*
A
string
has
"
pure
"
chars
if
it
can
return
a
pointer
to
its
chars
*
infallibly
without
mutating
anything
so
they
are
safe
to
be
from
off
the
*
main
thread
.
If
a
string
does
not
have
pure
chars
the
caller
can
call
*
copyNonPureChars
to
allocate
a
copy
of
the
chars
which
is
also
a
*
non
-
mutating
threadsafe
operation
.
Beware
this
is
an
O
(
n
)
operation
*
(
involving
a
DAG
traversal
for
ropes
)
.
*
/
bool
hasPureChars
(
)
const
{
return
isLinear
(
)
;
}
bool
hasPureCharsZ
(
)
const
{
return
isFlat
(
)
;
}
inline
const
jschar
*
pureChars
(
)
const
;
inline
const
jschar
*
pureCharsZ
(
)
const
;
inline
bool
copyNonPureChars
(
js
:
:
ThreadSafeContext
*
cx
js
:
:
ScopedJSFreePtr
<
jschar
>
&
out
)
const
;
inline
bool
copyNonPureCharsZ
(
js
:
:
ThreadSafeContext
*
cx
js
:
:
ScopedJSFreePtr
<
jschar
>
&
out
)
const
;
/
*
Strings
have
either
Latin1
or
TwoByte
chars
.
*
/
bool
hasLatin1Chars
(
)
const
{
return
d
.
u1
.
flags
&
LATIN1_CHARS_BIT
;
}
bool
hasTwoByteChars
(
)
const
{
return
!
(
d
.
u1
.
flags
&
LATIN1_CHARS_BIT
)
;
}
/
*
Fallible
conversions
to
more
-
derived
string
types
.
*
/
inline
JSLinearString
*
ensureLinear
(
js
:
:
ExclusiveContext
*
cx
)
;
inline
JSFlatString
*
ensureFlat
(
js
:
:
ExclusiveContext
*
cx
)
;
static
bool
ensureLinear
(
js
:
:
ExclusiveContext
*
cx
JSString
*
str
)
{
return
str
-
>
ensureLinear
(
cx
)
!
=
nullptr
;
}
/
*
Type
query
and
debug
-
checked
casts
*
/
MOZ_ALWAYS_INLINE
bool
isRope
(
)
const
{
return
(
d
.
u1
.
flags
&
TYPE_FLAGS_MASK
)
=
=
ROPE_FLAGS
;
}
MOZ_ALWAYS_INLINE
JSRope
&
asRope
(
)
const
{
JS_ASSERT
(
isRope
(
)
)
;
return
*
(
JSRope
*
)
this
;
}
MOZ_ALWAYS_INLINE
bool
isLinear
(
)
const
{
return
!
isRope
(
)
;
}
MOZ_ALWAYS_INLINE
JSLinearString
&
asLinear
(
)
const
{
JS_ASSERT
(
JSString
:
:
isLinear
(
)
)
;
return
*
(
JSLinearString
*
)
this
;
}
MOZ_ALWAYS_INLINE
bool
isDependent
(
)
const
{
return
(
d
.
u1
.
flags
&
TYPE_FLAGS_MASK
)
=
=
DEPENDENT_FLAGS
;
}
MOZ_ALWAYS_INLINE
JSDependentString
&
asDependent
(
)
const
{
JS_ASSERT
(
isDependent
(
)
)
;
return
*
(
JSDependentString
*
)
this
;
}
MOZ_ALWAYS_INLINE
bool
isFlat
(
)
const
{
return
d
.
u1
.
flags
&
FLAT_BIT
;
}
MOZ_ALWAYS_INLINE
JSFlatString
&
asFlat
(
)
const
{
JS_ASSERT
(
isFlat
(
)
)
;
return
*
(
JSFlatString
*
)
this
;
}
MOZ_ALWAYS_INLINE
bool
isExtensible
(
)
const
{
return
(
d
.
u1
.
flags
&
TYPE_FLAGS_MASK
)
=
=
EXTENSIBLE_FLAGS
;
}
MOZ_ALWAYS_INLINE
JSExtensibleString
&
asExtensible
(
)
const
{
JS_ASSERT
(
isExtensible
(
)
)
;
return
*
(
JSExtensibleString
*
)
this
;
}
MOZ_ALWAYS_INLINE
bool
isInline
(
)
const
{
return
d
.
u1
.
flags
&
INLINE_CHARS_BIT
;
}
MOZ_ALWAYS_INLINE
JSInlineString
&
asInline
(
)
const
{
JS_ASSERT
(
isInline
(
)
)
;
return
*
(
JSInlineString
*
)
this
;
}
MOZ_ALWAYS_INLINE
bool
isFatInline
(
)
const
{
return
(
d
.
u1
.
flags
&
FAT_INLINE_MASK
)
=
=
FAT_INLINE_MASK
;
}
/
*
For
hot
code
prefer
other
type
queries
.
*
/
bool
isExternal
(
)
const
{
return
(
d
.
u1
.
flags
&
TYPE_FLAGS_MASK
)
=
=
EXTERNAL_FLAGS
;
}
MOZ_ALWAYS_INLINE
JSExternalString
&
asExternal
(
)
const
{
JS_ASSERT
(
isExternal
(
)
)
;
return
*
(
JSExternalString
*
)
this
;
}
MOZ_ALWAYS_INLINE
bool
isUndepended
(
)
const
{
return
(
d
.
u1
.
flags
&
TYPE_FLAGS_MASK
)
=
=
UNDEPENDED_FLAGS
;
}
MOZ_ALWAYS_INLINE
bool
isAtom
(
)
const
{
return
d
.
u1
.
flags
&
ATOM_BIT
;
}
MOZ_ALWAYS_INLINE
bool
isPermanentAtom
(
)
const
{
return
(
d
.
u1
.
flags
&
PERMANENT_ATOM_MASK
)
=
=
PERMANENT_ATOM_MASK
;
}
MOZ_ALWAYS_INLINE
JSAtom
&
asAtom
(
)
const
{
JS_ASSERT
(
isAtom
(
)
)
;
return
*
(
JSAtom
*
)
this
;
}
/
*
Only
called
by
the
GC
for
dependent
or
undepended
strings
.
*
/
inline
bool
hasBase
(
)
const
{
return
d
.
u1
.
flags
&
HAS_BASE_BIT
;
}
inline
JSLinearString
*
base
(
)
const
;
inline
void
markBase
(
JSTracer
*
trc
)
;
/
*
Only
called
by
the
GC
for
strings
with
the
FINALIZE_STRING
kind
.
*
/
inline
void
finalize
(
js
:
:
FreeOp
*
fop
)
;
/
*
Gets
the
number
of
bytes
that
the
chars
take
on
the
heap
.
*
/
size_t
sizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
;
/
*
Offsets
for
direct
field
from
jit
code
.
*
/
static
size_t
offsetOfLength
(
)
{
return
offsetof
(
JSString
d
.
u1
.
length
)
;
}
static
size_t
offsetOfFlags
(
)
{
return
offsetof
(
JSString
d
.
u1
.
flags
)
;
}
static
size_t
offsetOfNonInlineChars
(
)
{
return
offsetof
(
JSString
d
.
s
.
u2
.
nonInlineCharsTwoByte
)
;
}
js
:
:
gc
:
:
AllocKind
getAllocKind
(
)
const
{
return
tenuredGetAllocKind
(
)
;
}
static
inline
js
:
:
ThingRootKind
rootKind
(
)
{
return
js
:
:
THING_ROOT_STRING
;
}
#
ifdef
DEBUG
void
dump
(
)
;
static
void
dumpChars
(
const
jschar
*
s
size_t
len
)
;
bool
equals
(
const
char
*
s
)
;
#
endif
static
MOZ_ALWAYS_INLINE
void
readBarrier
(
JSString
*
thing
)
{
#
ifdef
JSGC_INCREMENTAL
if
(
thing
-
>
isPermanentAtom
(
)
)
return
;
js
:
:
gc
:
:
BarrieredCell
<
JSString
>
:
:
readBarrier
(
thing
)
;
#
endif
}
static
MOZ_ALWAYS_INLINE
void
writeBarrierPre
(
JSString
*
thing
)
{
#
ifdef
JSGC_INCREMENTAL
if
(
isNullLike
(
thing
)
|
|
thing
-
>
isPermanentAtom
(
)
)
return
;
js
:
:
gc
:
:
BarrieredCell
<
JSString
>
:
:
writeBarrierPre
(
thing
)
;
#
endif
}
private
:
JSString
(
)
MOZ_DELETE
;
JSString
(
const
JSString
&
other
)
MOZ_DELETE
;
void
operator
=
(
const
JSString
&
other
)
MOZ_DELETE
;
}
;
class
JSRope
:
public
JSString
{
bool
copyNonPureCharsInternal
(
js
:
:
ThreadSafeContext
*
cx
js
:
:
ScopedJSFreePtr
<
jschar
>
&
out
bool
nullTerminate
)
const
;
bool
copyNonPureChars
(
js
:
:
ThreadSafeContext
*
cx
js
:
:
ScopedJSFreePtr
<
jschar
>
&
out
)
const
;
bool
copyNonPureCharsZ
(
js
:
:
ThreadSafeContext
*
cx
js
:
:
ScopedJSFreePtr
<
jschar
>
&
out
)
const
;
enum
UsingBarrier
{
WithIncrementalBarrier
NoBarrier
}
;
template
<
UsingBarrier
b
>
JSFlatString
*
flattenInternal
(
js
:
:
ExclusiveContext
*
cx
)
;
friend
class
JSString
;
JSFlatString
*
flatten
(
js
:
:
ExclusiveContext
*
cx
)
;
void
init
(
js
:
:
ThreadSafeContext
*
cx
JSString
*
left
JSString
*
right
size_t
length
)
;
public
:
template
<
js
:
:
AllowGC
allowGC
>
static
inline
JSRope
*
new_
(
js
:
:
ThreadSafeContext
*
cx
typename
js
:
:
MaybeRooted
<
JSString
*
allowGC
>
:
:
HandleType
left
typename
js
:
:
MaybeRooted
<
JSString
*
allowGC
>
:
:
HandleType
right
size_t
length
)
;
inline
JSString
*
leftChild
(
)
const
{
JS_ASSERT
(
isRope
(
)
)
;
return
d
.
s
.
u2
.
left
;
}
inline
JSString
*
rightChild
(
)
const
{
JS_ASSERT
(
isRope
(
)
)
;
return
d
.
s
.
u3
.
right
;
}
inline
void
markChildren
(
JSTracer
*
trc
)
;
inline
static
size_t
offsetOfLeft
(
)
{
return
offsetof
(
JSRope
d
.
s
.
u2
.
left
)
;
}
inline
static
size_t
offsetOfRight
(
)
{
return
offsetof
(
JSRope
d
.
s
.
u3
.
right
)
;
}
}
;
JS_STATIC_ASSERT
(
sizeof
(
JSRope
)
=
=
sizeof
(
JSString
)
)
;
class
JSLinearString
:
public
JSString
{
friend
class
JSString
;
/
*
Vacuous
and
therefore
unimplemented
.
*
/
JSLinearString
*
ensureLinear
(
JSContext
*
cx
)
MOZ_DELETE
;
bool
isLinear
(
)
const
MOZ_DELETE
;
JSLinearString
&
asLinear
(
)
const
MOZ_DELETE
;
public
:
MOZ_ALWAYS_INLINE
const
jschar
*
nonInlineChars
(
)
const
{
JS_ASSERT
(
!
isInline
(
)
)
;
JS_ASSERT
(
hasTwoByteChars
(
)
)
;
return
d
.
s
.
u2
.
nonInlineCharsTwoByte
;
}
MOZ_ALWAYS_INLINE
const
char
*
nonInlineLatin1Chars
(
const
JS
:
:
AutoCheckCannotGC
&
nogc
)
const
{
JS_ASSERT
(
!
isInline
(
)
)
;
JS_ASSERT
(
hasLatin1Chars
(
)
)
;
return
d
.
s
.
u2
.
nonInlineCharsLatin1
;
}
MOZ_ALWAYS_INLINE
const
jschar
*
nonInlineTwoByteChars
(
const
JS
:
:
AutoCheckCannotGC
&
nogc
)
const
{
JS_ASSERT
(
!
isInline
(
)
)
;
JS_ASSERT
(
hasTwoByteChars
(
)
)
;
return
d
.
s
.
u2
.
nonInlineCharsTwoByte
;
}
MOZ_ALWAYS_INLINE
const
jschar
*
chars
(
)
const
;
MOZ_ALWAYS_INLINE
const
char
*
latin1Chars
(
const
JS
:
:
AutoCheckCannotGC
&
nogc
)
const
;
MOZ_ALWAYS_INLINE
const
jschar
*
twoByteChars
(
const
JS
:
:
AutoCheckCannotGC
&
nogc
)
const
;
JS
:
:
TwoByteChars
range
(
)
const
{
JS_ASSERT
(
JSString
:
:
isLinear
(
)
)
;
return
JS
:
:
TwoByteChars
(
chars
(
)
length
(
)
)
;
}
/
*
Temporary
unsafe
helper
function
for
bug
998392
.
Don
'
t
use
for
anything
else
.
*
/
void
debugUnsafeConvertToLatin1
(
)
;
}
;
JS_STATIC_ASSERT
(
sizeof
(
JSLinearString
)
=
=
sizeof
(
JSString
)
)
;
class
JSDependentString
:
public
JSLinearString
{
bool
copyNonPureCharsZ
(
js
:
:
ThreadSafeContext
*
cx
js
:
:
ScopedJSFreePtr
<
jschar
>
&
out
)
const
;
friend
class
JSString
;
JSFlatString
*
undepend
(
js
:
:
ExclusiveContext
*
cx
)
;
void
init
(
js
:
:
ThreadSafeContext
*
cx
JSLinearString
*
base
const
jschar
*
chars
size_t
length
)
;
/
*
Vacuous
and
therefore
unimplemented
.
*
/
bool
isDependent
(
)
const
MOZ_DELETE
;
JSDependentString
&
asDependent
(
)
const
MOZ_DELETE
;
/
*
Hide
chars
(
)
nonInlineChars
(
)
is
more
efficient
.
*
/
const
jschar
*
chars
(
)
const
MOZ_DELETE
;
public
:
static
inline
JSLinearString
*
new_
(
js
:
:
ExclusiveContext
*
cx
JSLinearString
*
base
const
jschar
*
chars
size_t
length
)
;
}
;
JS_STATIC_ASSERT
(
sizeof
(
JSDependentString
)
=
=
sizeof
(
JSString
)
)
;
class
JSFlatString
:
public
JSLinearString
{
/
*
Vacuous
and
therefore
unimplemented
.
*
/
JSFlatString
*
ensureFlat
(
JSContext
*
cx
)
MOZ_DELETE
;
bool
isFlat
(
)
const
MOZ_DELETE
;
JSFlatString
&
asFlat
(
)
const
MOZ_DELETE
;
bool
isIndexSlow
(
uint32_t
*
indexp
)
const
;
void
init
(
const
jschar
*
chars
size_t
length
)
;
public
:
template
<
js
:
:
AllowGC
allowGC
>
static
inline
JSFlatString
*
new_
(
js
:
:
ThreadSafeContext
*
cx
const
jschar
*
chars
size_t
length
)
;
MOZ_ALWAYS_INLINE
const
jschar
*
charsZ
(
)
const
{
JS_ASSERT
(
JSString
:
:
isFlat
(
)
)
;
return
chars
(
)
;
}
/
*
*
Returns
true
if
this
string
'
s
characters
store
an
unsigned
32
-
bit
*
integer
value
initializing
*
indexp
to
that
value
if
so
.
(
Thus
if
*
calling
isIndex
returns
true
js
:
:
IndexToString
(
cx
*
indexp
)
will
be
a
*
string
equal
to
this
string
.
)
*
/
inline
bool
isIndex
(
uint32_t
*
indexp
)
const
{
const
jschar
*
s
=
chars
(
)
;
return
JS7_ISDEC
(
*
s
)
&
&
isIndexSlow
(
indexp
)
;
}
/
*
*
Returns
a
property
name
represented
by
this
string
or
null
on
failure
.
*
You
must
verify
that
this
is
not
an
index
per
isIndex
before
calling
*
this
method
.
*
/
inline
js
:
:
PropertyName
*
toPropertyName
(
JSContext
*
cx
)
;
/
*
*
Once
a
JSFlatString
sub
-
class
has
been
added
to
the
atom
state
this
*
operation
changes
the
string
to
the
JSAtom
type
in
place
.
*
/
MOZ_ALWAYS_INLINE
JSAtom
*
morphAtomizedStringIntoAtom
(
)
{
d
.
u1
.
flags
|
=
ATOM_BIT
;
return
&
asAtom
(
)
;
}
MOZ_ALWAYS_INLINE
JSAtom
*
morphAtomizedStringIntoPermanentAtom
(
)
{
d
.
u1
.
flags
|
=
PERMANENT_ATOM_MASK
;
return
&
asAtom
(
)
;
}
inline
void
finalize
(
js
:
:
FreeOp
*
fop
)
;
}
;
JS_STATIC_ASSERT
(
sizeof
(
JSFlatString
)
=
=
sizeof
(
JSString
)
)
;
class
JSExtensibleString
:
public
JSFlatString
{
/
*
Vacuous
and
therefore
unimplemented
.
*
/
bool
isExtensible
(
)
const
MOZ_DELETE
;
JSExtensibleString
&
asExtensible
(
)
const
MOZ_DELETE
;
/
*
Hide
chars
(
)
nonInlineChars
(
)
is
more
efficient
.
*
/
const
jschar
*
chars
(
)
const
MOZ_DELETE
;
public
:
MOZ_ALWAYS_INLINE
size_t
capacity
(
)
const
{
JS_ASSERT
(
JSString
:
:
isExtensible
(
)
)
;
return
d
.
s
.
u3
.
capacity
;
}
}
;
JS_STATIC_ASSERT
(
sizeof
(
JSExtensibleString
)
=
=
sizeof
(
JSString
)
)
;
/
*
*
On
32
-
bit
platforms
JSInlineString
can
store
7
Latin1
characters
or
*
3
TwoByte
characters
(
excluding
null
terminator
)
inline
.
On
64
-
bit
*
platforms
these
numbers
are
15
and
7
respectively
.
*
/
class
JSInlineString
:
public
JSFlatString
{
static
const
size_t
MAX_LENGTH_LATIN1
=
NUM_INLINE_CHARS_LATIN1
-
1
;
static
const
size_t
MAX_LENGTH_TWO_BYTE
=
NUM_INLINE_CHARS_TWO_BYTE
-
1
;
public
:
template
<
js
:
:
AllowGC
allowGC
>
static
inline
JSInlineString
*
new_
(
js
:
:
ThreadSafeContext
*
cx
)
;
inline
jschar
*
init
(
size_t
length
)
;
inline
void
resetLength
(
size_t
length
)
;
MOZ_ALWAYS_INLINE
const
jschar
*
chars
(
)
const
{
JS_ASSERT
(
JSString
:
:
isInline
(
)
)
;
JS_ASSERT
(
hasTwoByteChars
(
)
)
;
return
d
.
inlineStorageTwoByte
;
}
MOZ_ALWAYS_INLINE
const
char
*
latin1Chars
(
const
JS
:
:
AutoCheckCannotGC
&
nogc
)
const
{
JS_ASSERT
(
JSString
:
:
isInline
(
)
)
;
JS_ASSERT
(
hasLatin1Chars
(
)
)
;
return
d
.
inlineStorageLatin1
;
}
MOZ_ALWAYS_INLINE
const
jschar
*
twoByteChars
(
const
JS
:
:
AutoCheckCannotGC
&
nogc
)
const
{
JS_ASSERT
(
JSString
:
:
isInline
(
)
)
;
JS_ASSERT
(
hasTwoByteChars
(
)
)
;
return
d
.
inlineStorageTwoByte
;
}
static
bool
latin1LengthFits
(
size_t
length
)
{
return
length
<
=
MAX_LENGTH_LATIN1
;
}
static
bool
twoByteLengthFits
(
size_t
length
)
{
return
length
<
=
MAX_LENGTH_TWO_BYTE
;
}
static
size_t
offsetOfInlineStorage
(
)
{
return
offsetof
(
JSInlineString
d
.
inlineStorageTwoByte
)
;
}
}
;
JS_STATIC_ASSERT
(
sizeof
(
JSInlineString
)
=
=
sizeof
(
JSString
)
)
;
/
*
*
On
both
32
-
bit
and
64
-
bit
platforms
MAX_LENGTH_TWO_BYTE
is
11
and
*
MAX_LENGTH_LATIN1
is
23
(
excluding
null
terminator
)
.
This
is
deliberate
*
in
order
to
minimize
potential
performance
differences
between
32
-
bit
and
*
64
-
bit
platforms
.
*
*
There
are
still
some
differences
due
to
NUM_INLINE_CHARS_
*
being
different
.
*
E
.
g
.
TwoByte
strings
of
length
4
-
-
7
will
be
JSFatInlineStrings
on
32
-
bit
*
platforms
and
JSInlineStrings
on
64
-
bit
platforms
.
But
the
more
significant
*
transition
from
inline
strings
to
non
-
inline
strings
occurs
at
length
11
(
for
*
TwoByte
strings
)
and
23
(
Latin1
strings
)
on
both
32
-
bit
and
64
-
bit
platforms
.
*
/
class
JSFatInlineString
:
public
JSInlineString
{
static
const
size_t
INLINE_EXTENSION_CHARS_LATIN1
=
24
-
NUM_INLINE_CHARS_LATIN1
;
static
const
size_t
INLINE_EXTENSION_CHARS_TWO_BYTE
=
12
-
NUM_INLINE_CHARS_TWO_BYTE
;
static
void
staticAsserts
(
)
{
JS_STATIC_ASSERT
(
(
INLINE_EXTENSION_CHARS_LATIN1
*
sizeof
(
char
)
)
%
js
:
:
gc
:
:
CellSize
=
=
0
)
;
JS_STATIC_ASSERT
(
(
INLINE_EXTENSION_CHARS_TWO_BYTE
*
sizeof
(
jschar
)
)
%
js
:
:
gc
:
:
CellSize
=
=
0
)
;
JS_STATIC_ASSERT
(
MAX_LENGTH_TWO_BYTE
+
1
=
=
(
sizeof
(
JSFatInlineString
)
-
offsetof
(
JSFatInlineString
d
.
inlineStorageTwoByte
)
)
/
sizeof
(
jschar
)
)
;
JS_STATIC_ASSERT
(
MAX_LENGTH_LATIN1
+
1
=
=
(
sizeof
(
JSFatInlineString
)
-
offsetof
(
JSFatInlineString
d
.
inlineStorageLatin1
)
)
/
sizeof
(
char
)
)
;
}
/
*
Hide
chars
(
)
inlineChars
(
)
is
more
efficient
.
*
/
const
jschar
*
chars
(
)
const
MOZ_DELETE
;
protected
:
/
*
to
fool
clang
into
not
warning
this
is
unused
*
/
union
{
char
inlineStorageExtensionLatin1
[
INLINE_EXTENSION_CHARS_LATIN1
]
;
jschar
inlineStorageExtensionTwoByte
[
INLINE_EXTENSION_CHARS_TWO_BYTE
]
;
}
;
public
:
template
<
js
:
:
AllowGC
allowGC
>
static
inline
JSFatInlineString
*
new_
(
js
:
:
ThreadSafeContext
*
cx
)
;
static
const
size_t
MAX_LENGTH_LATIN1
=
JSString
:
:
NUM_INLINE_CHARS_LATIN1
+
INLINE_EXTENSION_CHARS_LATIN1
-
1
/
*
null
terminator
*
/
;
static
const
size_t
MAX_LENGTH_TWO_BYTE
=
JSString
:
:
NUM_INLINE_CHARS_TWO_BYTE
+
INLINE_EXTENSION_CHARS_TWO_BYTE
-
1
/
*
null
terminator
*
/
;
inline
jschar
*
init
(
size_t
length
)
;
static
bool
latin1LengthFits
(
size_t
length
)
{
return
length
<
=
MAX_LENGTH_LATIN1
;
}
static
bool
twoByteLengthFits
(
size_t
length
)
{
return
length
<
=
MAX_LENGTH_TWO_BYTE
;
}
/
*
Only
called
by
the
GC
for
strings
with
the
FINALIZE_FAT_INLINE_STRING
kind
.
*
/
MOZ_ALWAYS_INLINE
void
finalize
(
js
:
:
FreeOp
*
fop
)
;
}
;
JS_STATIC_ASSERT
(
sizeof
(
JSFatInlineString
)
%
js
:
:
gc
:
:
CellSize
=
=
0
)
;
class
JSExternalString
:
public
JSFlatString
{
void
init
(
const
jschar
*
chars
size_t
length
const
JSStringFinalizer
*
fin
)
;
/
*
Vacuous
and
therefore
unimplemented
.
*
/
bool
isExternal
(
)
const
MOZ_DELETE
;
JSExternalString
&
asExternal
(
)
const
MOZ_DELETE
;
/
*
Hide
chars
(
)
nonInlineChars
(
)
is
more
efficient
.
*
/
const
jschar
*
chars
(
)
const
MOZ_DELETE
;
public
:
static
inline
JSExternalString
*
new_
(
JSContext
*
cx
const
jschar
*
chars
size_t
length
const
JSStringFinalizer
*
fin
)
;
const
JSStringFinalizer
*
externalFinalizer
(
)
const
{
JS_ASSERT
(
JSString
:
:
isExternal
(
)
)
;
return
d
.
s
.
u3
.
externalFinalizer
;
}
/
*
Only
called
by
the
GC
for
strings
with
the
FINALIZE_EXTERNAL_STRING
kind
.
*
/
inline
void
finalize
(
js
:
:
FreeOp
*
fop
)
;
}
;
JS_STATIC_ASSERT
(
sizeof
(
JSExternalString
)
=
=
sizeof
(
JSString
)
)
;
class
JSUndependedString
:
public
JSFlatString
{
/
*
*
JSUndependedString
is
not
explicitly
used
and
is
only
present
for
*
consistency
.
See
JSDependentString
:
:
undepend
for
how
a
JSDependentString
*
gets
morphed
into
a
JSUndependedString
.
*
/
}
;
JS_STATIC_ASSERT
(
sizeof
(
JSUndependedString
)
=
=
sizeof
(
JSString
)
)
;
class
JSAtom
:
public
JSFlatString
{
/
*
Vacuous
and
therefore
unimplemented
.
*
/
bool
isAtom
(
)
const
MOZ_DELETE
;
JSAtom
&
asAtom
(
)
const
MOZ_DELETE
;
public
:
/
*
Returns
the
PropertyName
for
this
.
isIndex
(
)
must
be
false
.
*
/
inline
js
:
:
PropertyName
*
asPropertyName
(
)
;
inline
void
finalize
(
js
:
:
FreeOp
*
fop
)
;
MOZ_ALWAYS_INLINE
bool
isPermanent
(
)
const
{
return
JSString
:
:
isPermanentAtom
(
)
;
}
/
/
Transform
this
atom
into
a
permanent
atom
.
This
is
only
done
during
/
/
initialization
of
the
runtime
.
MOZ_ALWAYS_INLINE
void
morphIntoPermanentAtom
(
)
{
d
.
u1
.
flags
|
=
PERMANENT_ATOM_MASK
;
}
#
ifdef
DEBUG
void
dump
(
)
;
#
endif
}
;
JS_STATIC_ASSERT
(
sizeof
(
JSAtom
)
=
=
sizeof
(
JSString
)
)
;
namespace
js
{
/
*
*
Thread
safe
RAII
wrapper
for
inspecting
the
contents
of
JSStrings
.
The
*
thread
safe
operations
such
as
|
getCharsNonDestructive
|
require
allocation
*
of
a
char
array
.
This
allocation
is
not
always
required
such
as
when
the
*
string
is
already
linear
.
This
wrapper
makes
dealing
with
this
detail
more
*
convenient
by
encapsulating
the
allocation
logic
.
*
*
As
the
name
suggests
this
class
is
scoped
.
Return
values
from
chars
(
)
and
*
range
(
)
may
not
be
valid
after
the
inspector
goes
out
of
scope
.
*
/
class
ScopedThreadSafeStringInspector
{
private
:
JSString
*
str_
;
ScopedJSFreePtr
<
jschar
>
scopedChars_
;
const
jschar
*
chars_
;
public
:
explicit
ScopedThreadSafeStringInspector
(
JSString
*
str
)
:
str_
(
str
)
chars_
(
nullptr
)
{
}
bool
ensureChars
(
ThreadSafeContext
*
cx
)
;
const
jschar
*
chars
(
)
{
JS_ASSERT
(
chars_
)
;
return
chars_
;
}
JS
:
:
TwoByteChars
range
(
)
{
JS_ASSERT
(
chars_
)
;
return
JS
:
:
TwoByteChars
(
chars_
str_
-
>
length
(
)
)
;
}
}
;
class
StaticStrings
{
private
:
/
*
Bigger
chars
cannot
be
in
a
length
-
2
string
.
*
/
static
const
size_t
SMALL_CHAR_LIMIT
=
128U
;
static
const
size_t
NUM_SMALL_CHARS
=
64U
;
JSAtom
*
length2StaticTable
[
NUM_SMALL_CHARS
*
NUM_SMALL_CHARS
]
;
public
:
/
*
We
keep
these
public
for
the
JITs
.
*
/
static
const
size_t
UNIT_STATIC_LIMIT
=
256U
;
JSAtom
*
unitStaticTable
[
UNIT_STATIC_LIMIT
]
;
static
const
size_t
INT_STATIC_LIMIT
=
256U
;
JSAtom
*
intStaticTable
[
INT_STATIC_LIMIT
]
;
StaticStrings
(
)
{
mozilla
:
:
PodZero
(
this
)
;
}
bool
init
(
JSContext
*
cx
)
;
void
trace
(
JSTracer
*
trc
)
;
static
bool
hasUint
(
uint32_t
u
)
{
return
u
<
INT_STATIC_LIMIT
;
}
JSAtom
*
getUint
(
uint32_t
u
)
{
JS_ASSERT
(
hasUint
(
u
)
)
;
return
intStaticTable
[
u
]
;
}
static
bool
hasInt
(
int32_t
i
)
{
return
uint32_t
(
i
)
<
INT_STATIC_LIMIT
;
}
JSAtom
*
getInt
(
int32_t
i
)
{
JS_ASSERT
(
hasInt
(
i
)
)
;
return
getUint
(
uint32_t
(
i
)
)
;
}
static
bool
hasUnit
(
jschar
c
)
{
return
c
<
UNIT_STATIC_LIMIT
;
}
JSAtom
*
getUnit
(
jschar
c
)
{
JS_ASSERT
(
hasUnit
(
c
)
)
;
return
unitStaticTable
[
c
]
;
}
/
*
May
not
return
atom
returns
null
on
(
reported
)
failure
.
*
/
inline
JSLinearString
*
getUnitStringForElement
(
JSContext
*
cx
JSString
*
str
size_t
index
)
;
static
bool
isStatic
(
JSAtom
*
atom
)
;
/
*
Return
null
if
no
static
atom
exists
for
the
given
(
chars
length
)
.
*
/
JSAtom
*
lookup
(
const
jschar
*
chars
size_t
length
)
{
switch
(
length
)
{
case
1
:
if
(
chars
[
0
]
<
UNIT_STATIC_LIMIT
)
return
getUnit
(
chars
[
0
]
)
;
return
nullptr
;
case
2
:
if
(
fitsInSmallChar
(
chars
[
0
]
)
&
&
fitsInSmallChar
(
chars
[
1
]
)
)
return
getLength2
(
chars
[
0
]
chars
[
1
]
)
;
return
nullptr
;
case
3
:
/
*
*
Here
we
know
that
JSString
:
:
intStringTable
covers
only
256
(
or
at
least
*
not
1000
or
more
)
chars
.
We
rely
on
order
here
to
resolve
the
unit
vs
.
*
int
string
/
length
-
2
string
atom
identity
issue
by
giving
priority
to
unit
*
strings
for
"
0
"
through
"
9
"
and
length
-
2
strings
for
"
10
"
through
"
99
"
.
*
/
JS_STATIC_ASSERT
(
INT_STATIC_LIMIT
<
=
999
)
;
if
(
'
1
'
<
=
chars
[
0
]
&
&
chars
[
0
]
<
=
'
9
'
&
&
'
0
'
<
=
chars
[
1
]
&
&
chars
[
1
]
<
=
'
9
'
&
&
'
0
'
<
=
chars
[
2
]
&
&
chars
[
2
]
<
=
'
9
'
)
{
int
i
=
(
chars
[
0
]
-
'
0
'
)
*
100
+
(
chars
[
1
]
-
'
0
'
)
*
10
+
(
chars
[
2
]
-
'
0
'
)
;
if
(
unsigned
(
i
)
<
INT_STATIC_LIMIT
)
return
getInt
(
i
)
;
}
return
nullptr
;
}
return
nullptr
;
}
private
:
typedef
uint8_t
SmallChar
;
static
const
SmallChar
INVALID_SMALL_CHAR
=
-
1
;
static
bool
fitsInSmallChar
(
jschar
c
)
{
return
c
<
SMALL_CHAR_LIMIT
&
&
toSmallChar
[
c
]
!
=
INVALID_SMALL_CHAR
;
}
static
const
SmallChar
toSmallChar
[
]
;
JSAtom
*
getLength2
(
jschar
c1
jschar
c2
)
;
JSAtom
*
getLength2
(
uint32_t
u
)
{
JS_ASSERT
(
u
<
100
)
;
return
getLength2
(
'
0
'
+
u
/
10
'
0
'
+
u
%
10
)
;
}
}
;
/
*
*
Represents
an
atomized
string
which
does
not
contain
an
index
(
that
is
an
*
unsigned
32
-
bit
value
)
.
Thus
for
any
PropertyName
propname
*
ToString
(
ToUint32
(
propname
)
)
never
equals
propname
.
*
*
To
more
concretely
illustrate
the
utility
of
PropertyName
consider
that
it
*
is
used
to
partition
in
a
type
-
safe
manner
the
ways
to
refer
to
a
*
property
as
follows
:
*
*
-
uint32_t
indexes
*
-
PropertyName
strings
which
don
'
t
encode
uint32_t
indexes
and
*
-
jsspecial
special
properties
(
non
-
ES5
properties
like
object
-
valued
*
jsids
JSID_EMPTY
JSID_VOID
and
maybe
in
the
future
Harmony
-
proposed
*
private
names
)
.
*
/
class
PropertyName
:
public
JSAtom
{
}
;
JS_STATIC_ASSERT
(
sizeof
(
PropertyName
)
=
=
sizeof
(
JSString
)
)
;
static
MOZ_ALWAYS_INLINE
jsid
NameToId
(
PropertyName
*
name
)
{
return
NON_INTEGER_ATOM_TO_JSID
(
name
)
;
}
class
AutoNameVector
:
public
AutoVectorRooter
<
PropertyName
*
>
{
typedef
AutoVectorRooter
<
PropertyName
*
>
BaseType
;
public
:
explicit
AutoNameVector
(
JSContext
*
cx
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
AutoVectorRooter
<
PropertyName
*
>
(
cx
NAMEVECTOR
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
HandlePropertyName
operator
[
]
(
size_t
i
)
const
{
return
HandlePropertyName
:
:
fromMarkedLocation
(
&
begin
(
)
[
i
]
)
;
}
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
}
/
*
namespace
js
*
/
/
*
Avoid
requiring
vm
/
String
-
inl
.
h
just
to
call
getChars
.
*
/
MOZ_ALWAYS_INLINE
const
jschar
*
JSString
:
:
getChars
(
js
:
:
ExclusiveContext
*
cx
)
{
if
(
JSLinearString
*
str
=
ensureLinear
(
cx
)
)
return
str
-
>
chars
(
)
;
return
nullptr
;
}
MOZ_ALWAYS_INLINE
bool
JSString
:
:
getChar
(
js
:
:
ExclusiveContext
*
cx
size_t
index
jschar
*
code
)
{
JS_ASSERT
(
index
<
length
(
)
)
;
/
*
*
Optimization
for
one
level
deep
ropes
.
*
This
is
common
for
the
following
pattern
:
*
*
while
(
)
{
*
text
=
text
.
substr
(
0
x
)
+
"
bla
"
+
text
.
substr
(
x
)
*
test
.
charCodeAt
(
x
+
1
)
*
}
*
/
const
jschar
*
chars
;
if
(
isRope
(
)
)
{
JSRope
*
rope
=
&
asRope
(
)
;
if
(
uint32_t
(
index
)
<
rope
-
>
leftChild
(
)
-
>
length
(
)
)
{
chars
=
rope
-
>
leftChild
(
)
-
>
getChars
(
cx
)
;
}
else
{
chars
=
rope
-
>
rightChild
(
)
-
>
getChars
(
cx
)
;
index
-
=
rope
-
>
leftChild
(
)
-
>
length
(
)
;
}
}
else
{
chars
=
getChars
(
cx
)
;
}
if
(
!
chars
)
return
false
;
*
code
=
chars
[
index
]
;
return
true
;
}
MOZ_ALWAYS_INLINE
const
jschar
*
JSString
:
:
getCharsZ
(
js
:
:
ExclusiveContext
*
cx
)
{
if
(
JSFlatString
*
str
=
ensureFlat
(
cx
)
)
return
str
-
>
chars
(
)
;
return
nullptr
;
}
MOZ_ALWAYS_INLINE
const
jschar
*
JSString
:
:
pureChars
(
)
const
{
JS_ASSERT
(
hasPureChars
(
)
)
;
return
asLinear
(
)
.
chars
(
)
;
}
MOZ_ALWAYS_INLINE
const
jschar
*
JSString
:
:
pureCharsZ
(
)
const
{
JS_ASSERT
(
hasPureCharsZ
(
)
)
;
return
asFlat
(
)
.
charsZ
(
)
;
}
MOZ_ALWAYS_INLINE
bool
JSString
:
:
copyNonPureChars
(
js
:
:
ThreadSafeContext
*
cx
js
:
:
ScopedJSFreePtr
<
jschar
>
&
out
)
const
{
JS_ASSERT
(
!
hasPureChars
(
)
)
;
return
asRope
(
)
.
copyNonPureChars
(
cx
out
)
;
}
MOZ_ALWAYS_INLINE
bool
JSString
:
:
copyNonPureCharsZ
(
js
:
:
ThreadSafeContext
*
cx
js
:
:
ScopedJSFreePtr
<
jschar
>
&
out
)
const
{
JS_ASSERT
(
!
hasPureChars
(
)
)
;
if
(
isDependent
(
)
)
return
asDependent
(
)
.
copyNonPureCharsZ
(
cx
out
)
;
return
asRope
(
)
.
copyNonPureCharsZ
(
cx
out
)
;
}
MOZ_ALWAYS_INLINE
JSLinearString
*
JSString
:
:
ensureLinear
(
js
:
:
ExclusiveContext
*
cx
)
{
return
isLinear
(
)
?
&
asLinear
(
)
:
asRope
(
)
.
flatten
(
cx
)
;
}
MOZ_ALWAYS_INLINE
JSFlatString
*
JSString
:
:
ensureFlat
(
js
:
:
ExclusiveContext
*
cx
)
{
return
isFlat
(
)
?
&
asFlat
(
)
:
isDependent
(
)
?
asDependent
(
)
.
undepend
(
cx
)
:
asRope
(
)
.
flatten
(
cx
)
;
}
inline
JSLinearString
*
JSString
:
:
base
(
)
const
{
JS_ASSERT
(
hasBase
(
)
)
;
JS_ASSERT
(
!
d
.
s
.
u3
.
base
-
>
isInline
(
)
)
;
return
d
.
s
.
u3
.
base
;
}
MOZ_ALWAYS_INLINE
const
jschar
*
JSLinearString
:
:
chars
(
)
const
{
JS_ASSERT
(
JSString
:
:
isLinear
(
)
)
;
JS_ASSERT
(
hasTwoByteChars
(
)
)
;
return
isInline
(
)
?
asInline
(
)
.
chars
(
)
:
nonInlineChars
(
)
;
}
MOZ_ALWAYS_INLINE
const
char
*
JSLinearString
:
:
latin1Chars
(
const
JS
:
:
AutoCheckCannotGC
&
nogc
)
const
{
JS_ASSERT
(
JSString
:
:
isLinear
(
)
)
;
JS_ASSERT
(
hasLatin1Chars
(
)
)
;
return
isInline
(
)
?
asInline
(
)
.
latin1Chars
(
nogc
)
:
nonInlineLatin1Chars
(
nogc
)
;
}
MOZ_ALWAYS_INLINE
const
jschar
*
JSLinearString
:
:
twoByteChars
(
const
JS
:
:
AutoCheckCannotGC
&
nogc
)
const
{
JS_ASSERT
(
JSString
:
:
isLinear
(
)
)
;
JS_ASSERT
(
hasTwoByteChars
(
)
)
;
return
isInline
(
)
?
asInline
(
)
.
twoByteChars
(
nogc
)
:
nonInlineTwoByteChars
(
nogc
)
;
}
inline
js
:
:
PropertyName
*
JSAtom
:
:
asPropertyName
(
)
{
#
ifdef
DEBUG
uint32_t
dummy
;
JS_ASSERT
(
!
isIndex
(
&
dummy
)
)
;
#
endif
return
static_cast
<
js
:
:
PropertyName
*
>
(
this
)
;
}
#
endif
/
*
vm_String_h
*
/
