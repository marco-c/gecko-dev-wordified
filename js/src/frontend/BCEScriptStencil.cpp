/
*
-
*
-
Mode
:
C
+
+
;
tab
-
width
:
8
;
indent
-
tabs
-
mode
:
nil
;
c
-
basic
-
offset
:
2
-
*
-
*
vim
:
set
ts
=
8
sts
=
2
et
sw
=
2
tw
=
80
:
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
#
include
"
frontend
/
BCEScriptStencil
.
h
"
#
include
"
frontend
/
AbstractScopePtr
.
h
"
/
/
AbstractScope
#
include
"
frontend
/
BytecodeEmitter
.
h
"
/
/
BytecodeEmitter
#
include
"
frontend
/
BytecodeSection
.
h
"
/
/
BytecodeSection
PerScriptData
#
include
"
vm
/
SharedStencil
.
h
"
using
namespace
js
;
using
namespace
js
:
:
frontend
;
BCEScriptStencil
:
:
BCEScriptStencil
(
BytecodeEmitter
&
bce
UniquePtr
<
ImmutableScriptData
>
immutableData
)
:
ScriptStencil
(
bce
.
cx
)
bce_
(
bce
)
{
init
(
bce
std
:
:
move
(
immutableData
)
)
;
}
void
BCEScriptStencil
:
:
init
(
BytecodeEmitter
&
bce
UniquePtr
<
ImmutableScriptData
>
immutableData
)
{
natoms
=
bce
.
perScriptData
(
)
.
atomIndices
(
)
-
>
count
(
)
;
immutableFlags
=
bce
.
sc
-
>
immutableFlags
(
)
;
/
/
Update
the
flags
generated
by
BCE
.
immutableFlags
.
setFlag
(
ImmutableFlags
:
:
Strict
bce
.
sc
-
>
strict
(
)
)
;
immutableFlags
.
setFlag
(
ImmutableFlags
:
:
NeedsFunctionEnvironmentObjects
getNeedsFunctionEnvironmentObjects
(
bce
)
)
;
immutableFlags
.
setFlag
(
ImmutableFlags
:
:
HasNonSyntacticScope
bce
.
outermostScope
(
)
.
hasOnChain
(
ScopeKind
:
:
NonSyntactic
)
)
;
gcThings
=
bce
.
perScriptData
(
)
.
gcThingList
(
)
.
stealGCThings
(
)
;
/
/
Hand
over
the
ImmutableScriptData
instance
generated
by
BCE
.
immutableScriptData
=
std
:
:
move
(
immutableData
)
;
/
/
Update
flags
specific
to
functions
.
if
(
isFunction
(
)
)
{
FunctionBox
*
funbox
=
bce
.
sc
-
>
asFunctionBox
(
)
;
functionIndex
.
emplace
(
funbox
-
>
index
(
)
)
;
fieldInitializers
=
funbox
-
>
fieldInitializers
;
/
/
Set
flags
that
don
'
t
have
direct
flag
representation
within
the
/
/
FunctionBox
.
immutableFlags
.
setFlag
(
ImmutableFlags
:
:
HasMappedArgsObj
funbox
-
>
hasMappedArgsObj
(
)
)
;
}
/
*
isFunctionBox
*
/
}
bool
BCEScriptStencil
:
:
getNeedsFunctionEnvironmentObjects
(
BytecodeEmitter
&
bce
)
const
{
/
/
See
JSFunction
:
:
needsCallObject
(
)
js
:
:
AbstractScopePtr
bodyScope
=
bce
.
bodyScope
(
)
;
if
(
bodyScope
.
kind
(
)
=
=
js
:
:
ScopeKind
:
:
Function
)
{
if
(
bodyScope
.
hasEnvironment
(
)
)
{
return
true
;
}
}
/
/
See
JSScript
:
:
maybeNamedLambdaScope
(
)
js
:
:
AbstractScopePtr
outerScope
=
bce
.
outermostScope
(
)
;
if
(
outerScope
.
kind
(
)
=
=
js
:
:
ScopeKind
:
:
NamedLambda
|
|
outerScope
.
kind
(
)
=
=
js
:
:
ScopeKind
:
:
StrictNamedLambda
)
{
MOZ_ASSERT
(
bce
.
sc
-
>
asFunctionBox
(
)
-
>
isNamedLambda
(
)
)
;
if
(
outerScope
.
hasEnvironment
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
BCEScriptStencil
:
:
finishGCThings
(
JSContext
*
cx
mozilla
:
:
Span
<
JS
:
:
GCCellPtr
>
output
)
const
{
return
EmitScriptThingsVector
(
cx
bce_
.
compilationInfo
gcThings
output
)
;
}
void
BCEScriptStencil
:
:
initAtomMap
(
GCPtrAtom
*
atoms
)
const
{
const
AtomIndexMap
&
indices
=
*
bce_
.
perScriptData
(
)
.
atomIndices
(
)
;
for
(
AtomIndexMap
:
:
Range
r
=
indices
.
all
(
)
;
!
r
.
empty
(
)
;
r
.
popFront
(
)
)
{
JSAtom
*
atom
=
r
.
front
(
)
.
key
(
)
;
uint32_t
index
=
r
.
front
(
)
.
value
(
)
;
MOZ_ASSERT
(
index
<
indices
.
count
(
)
)
;
atoms
[
index
]
.
init
(
atom
)
;
}
}
void
BCEScriptStencil
:
:
finishInnerFunctions
(
)
const
{
bce_
.
perScriptData
(
)
.
gcThingList
(
)
.
finishInnerFunctions
(
)
;
}
