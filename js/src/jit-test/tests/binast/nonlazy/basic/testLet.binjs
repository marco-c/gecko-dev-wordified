BINJS
[
GRAMMAR
]
identity
;
'
F
(
IdentifierExpression
.
LiteralStringExpression
CallExpression
&
ExpressionStatement0LiteralNumericExpression
"
BindingIdentifier
BinaryExpression0LiteralBooleanExpression
(
AssertedDeclaredName
&
VariableDeclaration
VariableDeclarator
ArrayExpression
DataProperty
&
LiteralPropertyName
ObjectExpression
AssertedBlockScope
Block
>
AssertedPositionalParameterName
StaticMemberExpression
(
AssignmentExpression4AssignmentTargetIdentifier
AssertedParameterScope
AssertedVarScope0EagerFunctionDeclaration
FormalParameters0FunctionOrMethodContents
NewExpression
"
AssertedBoundName
.
AssertedBoundNamesScope
CatchClause
IfStatement
"
TryCatchStatement2AssertedScriptGlobalScope
Script
[
STRINGS
]
identity
;
w
^
m
test
isReferenceError
var
str
caught
isParseError
ponies
e
got
assertEq
expect
arg
+
undefined
instanceof
Function
code
fun
p
print
result
x
c
&
isRuntimeParseError
otherGlobal
toSource
|
|
EXPECT
:
SyntaxError
TypeError
a
b8if
(
x
)
{
let
y
=
x
;
return
x
;
}
p1p2
unicorns
!
=
=
}
)
}
)
x
"
use
strict
"
;
if
(
x
)
{
let
y
=
1
;
return
eval
(
"
let
y
=
x
;
y
;
"
)
;
}
v
"
use
strict
"
;
if
(
x
)
{
let
y
=
x
;
eval
(
"
let
y
=
2
"
)
;
return
y
;
}
v
"
use
strict
"
;
if
(
x
)
{
let
y
=
x
;
eval
(
"
var
y
=
2
"
)
;
return
y
;
}
(
function
(
x
)
{
4
(
function
anonymous
(
x
)
{
n
(
function
(
)
{
let
x
=
(
function
(
)
{
return
x
}
(
)
)
;
}
(
)
)
-
00011011
GOT
:
GOT
:
ReferenceError
Reflect
a
:
for
(
let
i
in
x
)
{
for
(
let
j
in
x
)
{
break
a
;
}
}
return
eval
(
"
x
"
)
;
ra
:
for
(
let
i
in
x
)
{
for
(
let
j
in
x
)
{
break
a
;
}
}
return
x
;
arguments
clone
eval
evaluate
for
(
(
let
(
x
=
{
y
:
true
}
)
x
)
.
y
in
eval
(
"
x
"
)
)
{
return
eval
(
"
x
"
)
;
}
(
for
(
;
;
)
{
return
x
;
}
bfor
(
let
[
[
a
[
b
c
]
]
]
=
[
[
x
[
]
]
]
;
;
)
{
return
a
;
}
ffor
(
let
[
a
b
]
=
x
;
;
)
{
let
c
=
x
d
=
x
;
return
c
;
}
Lfor
(
let
[
a
]
=
(
1
[
x
]
)
;
;
)
{
return
a
;
}
Tfor
(
let
[
a
]
=
(
1
x
1
x
)
;
;
)
{
return
a
;
}
for
(
let
[
x
[
y
[
x
]
]
]
=
a
;
;
)
{
}
>
for
(
let
[
x
[
y
[
x
]
]
]
in
o
)
{
}
0for
(
let
[
x
x
]
in
o
)
{
}
8for
(
let
[
x
y
x
]
=
a
;
;
)
{
}
6for
(
let
[
x
y
x
]
in
o
)
{
}
Hfor
(
let
[
x
y
]
=
a
{
a
:
x
}
=
b
;
;
)
{
}
\
for
(
let
a
=
x
;
;
)
{
let
c
=
x
d
=
x
;
return
c
;
}
Tfor
(
let
i
in
x
)
{
break
;
}
return
eval
(
"
x
"
)
;
Dfor
(
let
i
in
x
)
{
break
;
}
return
x
;
Lfor
(
let
i
in
x
)
{
let
i
=
x
;
return
i
;
}
Dfor
(
let
i
in
x
)
{
let
y
;
return
x
;
}
8for
(
let
i
in
x
)
{
return
x
;
}
6for
(
let
x
=
1
x
=
2
;
;
)
{
}
Dfor
(
let
x
=
eval
(
"
throw
x
"
)
;
;
)
{
}
Tfor
(
let
x
=
x
+
"
s
"
;
eval
(
"
throw
x
"
)
;
)
{
}
Bfor
(
let
x
in
eval
(
"
throw
x
"
)
)
{
}
Xfor
(
let
x
in
eval
(
"
x
"
)
)
{
return
eval
(
"
x
"
)
;
}
Hfor
(
let
x
in
eval
(
"
x
"
)
)
{
return
x
;
}
Tfor
(
let
x
in
x
)
{
break
;
}
return
eval
(
"
x
"
)
;
Dfor
(
let
x
in
x
)
{
break
;
}
return
x
;
Hfor
(
let
x
in
x
)
{
return
eval
(
"
x
"
)
;
}
Bfor
(
let
y
=
1
;
+
+
y
;
)
{
return
x
;
}
Bfor
(
let
y
=
1
;
;
+
+
y
)
{
return
x
;
}
:
for
(
let
y
=
1
;
;
)
{
return
x
;
}
Ffor
(
let
y
=
x
;
;
)
{
let
x
;
return
y
;
}
Ffor
(
let
y
=
x
;
;
)
{
let
y
;
return
x
;
}
>
for
(
let
y
;
;
)
{
let
y
;
return
x
;
}
|
for
(
var
X
=
1
[
y
z
]
=
x
a
=
x
;
z
<
4
;
+
+
z
)
{
return
X
+
y
;
}
Bfor
(
var
y
=
1
;
+
+
y
;
)
{
return
x
;
}
Bfor
(
var
y
=
1
;
;
+
+
y
)
{
return
x
;
}
:
for
(
var
y
=
1
;
;
)
{
return
x
;
}
zif
(
x
)
{
let
X
=
x
+
1
[
]
=
X
[
[
]
]
=
X
y
=
x
;
return
y
;
}
Nif
(
x
)
{
let
X
=
x
+
1
y
=
x
;
return
y
;
}
Jif
(
x
)
{
let
[
]
=
x
;
return
x
;
}
>
if
(
x
)
{
let
[
]
=
x
;
return
x
;
}
^
if
(
x
)
{
let
[
X
[
y
z
]
]
=
[
x
x
+
1
]
;
return
X
;
}
xif
(
x
)
{
let
[
X
y
z
]
=
[
x
x
+
1
x
+
2
]
;
return
X
+
y
+
z
;
}
\
if
(
x
)
{
let
[
X
y
]
=
[
x
x
+
1
]
;
return
X
+
y
;
}
Tif
(
x
)
{
let
[
X
y
]
=
[
x
x
+
1
]
;
return
X
;
}
if
(
x
)
{
let
[
X
]
=
[
x
]
;
return
X
;
}
Hif
(
x
)
{
let
[
[
X
]
]
=
[
[
x
]
]
;
return
X
;
}
if
(
x
)
{
let
[
[
a
[
b
c
]
]
]
=
[
[
x
[
]
]
]
;
return
a
;
}
:
if
(
x
)
{
let
[
]
=
x
;
return
x
;
}
Jif
(
x
)
{
let
[
a
]
=
(
1
[
x
]
)
;
return
a
;
}
Rif
(
x
)
{
let
[
a
]
=
(
1
x
1
x
)
;
return
a
;
}
if
(
x
)
{
let
[
y
]
=
[
x
]
;
return
y
;
}
if
(
x
)
{
let
[
{
a
:
X
}
]
=
x
[
{
b
:
Y
}
]
=
x
;
var
XX
=
X
+
1
YY
=
Y
+
2
;
return
XX
+
YY
;
}
|
if
(
x
)
{
let
[
{
x
:
[
X
]
}
{
y1
:
y
z1
:
z
}
]
=
[
x
x
+
1
]
;
return
X
;
}
:
if
(
x
)
{
let
x
;
return
"
"
+
x
;
}
\
if
(
x
)
{
let
y
=
x
;
eval
(
"
var
y
=
2
"
)
;
return
y
;
}
xif
(
x
)
{
let
y
=
x
;
return
function
(
)
{
return
eval
(
"
y
"
)
;
}
(
)
;
}
if
(
x
)
{
let
y
=
x
;
try
{
let
x
=
1
;
throw
2
;
}
catch
(
e
)
{
return
y
;
}
}
0if
(
x
)
{
let
y
;
return
x
;
}
8if
(
x
)
{
var
y
=
x
;
return
x
;
}
^
if
(
x
)
{
var
z
=
y
;
var
[
y
]
=
x
;
z
+
=
y
;
}
return
z
;
Dif
(
x
)
{
y
=
x
;
var
y
=
y
;
return
y
;
}
Rinner
(
)
;
function
inner
(
)
{
x
+
+
;
}
let
x
;
inner
(
)
;
let
x
;
function
inner
(
)
{
function
innerer
(
)
{
x
+
+
;
}
innerer
(
)
;
}
Rinner
(
)
;
let
x
;
function
inner
(
)
{
x
+
+
;
}
length
let
[
x
]
=
[
x
]
;
let
a
;
function
a
(
)
{
}
Vlet
x
=
function
(
)
{
}
?
x
(
)
:
function
(
)
{
}
let
x
=
x
;
plet
x
;
var
inner
=
function
(
)
{
y
+
+
;
}
;
inner
(
)
;
let
y
;
let
{
x
}
=
{
x
:
x
}
;
newGlobal
parse8return
eval
(
"
let
y
=
x
;
y
"
)
;
switch
(
x
)
{
case
3
:
let
x
;
break
;
default
:
if
(
x
=
=
=
undefined
)
{
return
"
ponies
"
;
}
}
switch
(
x
)
{
case
3
:
let
y
;
return
3
;
case
4
:
let
y
;
return
4
;
default
:
;
}
switch
(
x
)
{
case
3
:
let
y
;
return
3
;
case
4
:
let
z
;
return
4
;
default
:
return
x
;
}
hthis
.
y
=
x
;
if
(
x
)
{
let
y
=
1
;
return
this
.
eval
(
"
y
"
)
;
}
\
try
{
let
x
=
1
;
throw
2
;
}
catch
(
e
)
{
return
x
;
}
undefined
-
hvar
X
=
x
+
1
[
]
=
X
[
[
]
]
=
X
y
=
x
;
return
y
;
<
var
X
=
x
+
1
y
=
x
;
return
y
;
8var
[
]
=
x
;
return
x
;
var
[
]
=
x
;
return
x
;
Nvar
[
[
a
[
b
c
]
]
]
=
[
[
x
[
]
]
]
;
return
a
;
6var
[
[
x
]
]
=
[
[
x
]
]
;
return
x
;
(
var
[
]
=
x
;
return
x
;
8var
[
a
]
=
(
1
[
x
]
)
;
return
a
;
var
[
a
]
=
(
1
x
1
x
)
;
return
a
;
Lvar
[
x
[
y
z
]
]
=
[
x
x
+
1
]
;
return
x
;
fvar
[
x
y
z
]
=
[
x
x
+
1
x
+
2
]
;
return
x
+
y
+
z
;
Jvar
[
x
y
]
=
[
x
x
+
1
]
;
return
x
+
y
;
Bvar
[
x
y
]
=
[
x
x
+
1
]
;
return
x
;
.
var
[
x
]
=
[
x
]
;
return
x
;
.
var
[
y
]
=
[
x
]
;
return
y
;
var
[
{
a
:
X
}
]
=
x
[
{
b
:
y
}
]
=
x
;
var
X
=
X
+
1
y
=
y
+
2
;
return
X
+
y
;
jvar
[
{
x
:
[
x
]
}
{
y1
:
y
z1
:
z
}
]
=
[
x
x
+
1
]
;
return
x
;
\
var
j
;
for
(
let
i
in
x
)
{
j
=
i
;
break
;
}
return
j
;
nvar
res
=
"
"
;
for
(
let
i
in
x
)
{
res
+
=
x
[
i
]
;
}
return
res
;
nvar
res
=
"
"
;
for
(
var
i
in
x
)
{
res
+
=
x
[
i
]
;
}
return
res
;
var
s
=
"
"
;
for
(
let
a
in
x
)
{
for
(
let
b
in
x
)
{
s
+
=
a
+
b
;
}
}
return
s
;
var
sum
=
0
;
for
(
let
x
=
1
;
eval
(
"
x
"
)
<
4
;
+
+
x
)
{
sum
+
=
eval
(
"
x
"
)
;
}
return
sum
;
var
sum
=
0
;
for
(
let
x
=
eval
(
"
x
"
)
;
eval
(
"
x
"
)
<
4
;
+
+
x
)
{
sum
+
=
eval
(
"
x
"
)
;
}
return
sum
;
var
sum
=
0
;
for
(
let
x
=
eval
(
"
x
"
)
;
x
<
4
;
+
+
x
)
{
sum
+
=
x
;
}
return
sum
;
var
sum
=
0
;
for
(
let
x
=
x
y
=
10
;
x
<
4
;
+
+
x
)
{
sum
+
=
x
;
}
return
sum
;
var
sum
=
0
;
for
(
let
x
=
x
;
eval
(
"
x
"
)
<
4
;
+
+
x
)
{
sum
+
=
eval
(
"
x
"
)
;
}
return
sum
;
xvar
sum
=
0
;
for
(
let
x
=
x
;
x
<
4
;
+
+
x
)
{
sum
+
=
x
;
}
return
x
;
|
var
sum
=
0
;
for
(
let
y
=
x
;
y
<
4
;
+
+
y
)
{
sum
+
=
y
;
}
return
sum
;
var
sum
=
0
;
for
(
var
X
=
eval
(
"
x
"
)
;
X
<
4
;
+
+
X
)
{
sum
+
=
X
;
}
return
sum
;
var
sum
=
0
;
for
(
var
X
=
eval
(
"
x
"
)
;
eval
(
"
X
"
)
<
4
;
+
+
X
)
{
sum
+
=
eval
(
"
X
"
)
;
}
return
sum
;
var
sum
=
0
;
for
(
var
X
=
x
y
=
10
;
X
<
4
;
+
+
X
)
{
sum
+
=
X
;
}
return
sum
;
xvar
sum
=
0
;
for
(
var
X
=
x
;
X
<
4
;
+
+
X
)
{
sum
+
=
X
;
}
return
x
;
var
sum
=
0
;
for
(
var
X
=
x
;
eval
(
"
X
"
)
<
4
;
+
+
X
)
{
sum
+
=
eval
(
"
X
"
)
;
}
return
sum
;
|
var
sum
=
0
;
for
(
var
y
=
x
;
y
<
4
;
+
+
y
)
{
sum
+
=
y
;
}
return
sum
;
6var
x
=
eval
(
"
x
"
)
;
return
x
;
&
var
x
=
x
;
return
x
;
var
y
=
3
;
switch
(
function
(
)
{
return
eval
(
"
y
"
)
;
}
(
)
)
{
case
3
:
let
y
;
return
x
;
default
:
;
}
&
var
y
=
x
;
return
x
;
0var
y
=
y
;
return
"
"
+
y
;
var
y
;
return
x
;
x
+
1
;
let
x
=
42
;
x
=
42
;
let
x
;
Px
.
foo
;
if
(
x
)
{
x
.
bar
;
let
y
=
x
;
return
y
;
}
6x
.
foo
;
{
let
y
=
x
;
return
y
;
}
<
[
TREE
]
identity
;
DB
.
0
0
0
4
(
2
(
"
.
"
(
*
4
>
k
&
h
(
*
(
"
"
6
*
&
"
2
T
H
>
F
&
^
&
6
"
&
b
R
J
j
&
0n
&
2
&
l
2
"
(
>
F
&
\
&
6
"
0
4
2
"
.
6
<
:
8
4
:
8
(
*
0
.
4
2
"
.
6
*
<
:
8
4
:
8
(
*
0
4
2
"
.
6
<
:
8
(
*
a
]
Y
_
D
W
1
<
>
B
-
/
!
#
)
?
'
?
+
%
3
*
X
D
<
>
B
?
?
*
i
g
.
P
N
L
r
t
I
?
=
?
U
?
O
?
Q
?
?
K
?
S
?
M
?
v
x
z
|
;
?
Z
7
9
p
f
d
5
~
[
c
e
V
C
G
A
E
?
