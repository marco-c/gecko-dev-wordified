BINJS
[
GRAMMAR
]
identity
;
#
^
.
LiteralStringExpression
(
IdentifierExpression
BinaryExpression0LiteralNumericExpression
DataProperty
&
LiteralPropertyName
StaticMemberExpression
ReturnStatement
SwitchCase
&
ExpressionStatement
CallExpression
(
AssignmentExpression
"
BindingIdentifier
(
AssertedDeclaredName8StaticMemberAssignmentTarget
&
VariableDeclaration
VariableDeclarator
ObjectExpression4AssignmentTargetIdentifier
ThisExpression
AssertedParameterScope
AssertedVarScope
FormalParameters4FunctionExpressionContents
LazyFunctionExpression
*
LiteralNullExpression
AssertedBlockScope
Block
>
AssertedPositionalParameterName0ComputedMemberExpression8CompoundAssignmentExpression
IfStatement0LiteralBooleanExpression
UpdateExpression
<
ComputedMemberAssignmentTarget
*
ConditionalExpression
ArrayExpression
ForStatement
.
LiteralRegExpExpression
NewExpression
SwitchDefault4SwitchStatementWithDefault
UnaryExpression2AssertedScriptGlobalScope
Script
WhileStatement
[
STRINGS
]
identity
;
:
9
+
var
Date
g
s
c
format
i
ch
currentGroup
special
code
String
day
prototype
-
character
funcName
+
=
<
=
=
]
10
)
;
date
daysInMonth
func
obj
result
year
+
+
escape
formatFunctions
length
parseFunctions
regex
%
&
&
(
\
d
{
1
2
}
)
count
getDate
getDay
leftPad
num
regexNum
ret
then
0
dateFormat
getMonth
"
getTimezoneOffset
input
isLeapYear
jan1
longFormat
now
parseRegexes
replace
shortFormat
size
string
val
'
'
+
(
\
d
{
2
}
)
)
A
D
F
G
H
L
M
May
O
S
T
W
Y
Y
-
m
-
d
Z
\
a
charAt
createNewFormat
createParser
d
dayNames
eval
"
formatCodeToRegex
getDayOfYear
getFormatCode
getFullYear
h0if
(
h
=
=
12
)
{
h
=
0
;
}
if
(
results
[
j
join
l
"
l
F
d
Y
g
:
i
:
s
A
mNm
=
parseInt
(
Date
.
monthNumbers
[
results
[
monthNames
n
t
w
y
z
|
D
}
else
{
if
(
h
<
12
)
{
h
+
=
12
;
}
}
!
/
*
=
function
(
)
{
return
(
=
function
(
input
)
{
1
1
2
3
(
X
(
'
'
+
this
.
getFullYear
(
)
)
.
substring
(
2
4
)
+
(
'
|
\
\
)
l
(
(
this
.
getHours
(
)
%
12
)
?
this
.
getHours
(
)
%
12
:
12
)
+
(
?
:
(
?
:
1
|
0
)
>
(
?
:
Sun
|
Mon
|
Tue
|
Wed
|
Thu
|
Fri
|
Sat
)
(
?
:
\
d
{
1
3
}
)
(
?
:
\
d
{
2
}
)
(
?
:
st
|
nd
|
rd
|
th
)
(
AM
|
PM
)
b
(
Jan
|
Feb
|
Mar
|
Apr
|
May
|
Jun
|
Jul
|
Aug
|
Sep
|
Oct
|
Nov
|
Dec
)
(
\
d
{
4
}
)
(
am
|
pm
)
N
(
this
.
getHours
(
)
<
12
?
'
AM
'
:
'
PM
'
)
+
N
(
this
.
getHours
(
)
<
12
?
'
am
'
:
'
pm
'
)
+
0
(
this
.
getMonth
(
)
+
1
)
+
F
(
this
.
getTimezoneOffset
(
)
*
-
60
)
+
<
(
this
.
isLeapYear
(
)
?
1
:
0
)
+
1
/
1
/
2007
1
:
11
:
11
;
}
Apr
April
Aug
August
Date
.
>
Date
.
dayNames
[
this
.
getDay
(
)
]
+
^
Date
.
dayNames
[
this
.
getDay
(
)
]
.
substring
(
0
3
)
+
FDate
.
monthNames
[
this
.
getMonth
(
)
]
+
fDate
.
monthNames
[
this
.
getMonth
(
)
]
.
substring
(
0
3
)
+
Date
.
prototype
.
Dec
December
F
d
F
Y
Feb
February
Friday
&
FullDateTimePattern
ISO8601LongPattern
&
ISO8601ShortPattern
Jan
January
Jul
July
Jun
June
LongDatePattern
LongTimePattern
Mar
March
Math
Monday
MonthDayPattern
Nov
November
Oct
October
RegExp
Saturday
Sep
September
ShortDatePattern
ShortTimePattern
.
SortableDateTimePattern
String
.
leftPad
(
(
this
.
getHours
(
)
%
12
)
?
this
.
getHours
(
)
%
12
:
12
2
'
0
'
)
+
RString
.
leftPad
(
this
.
getDate
(
)
2
'
0
'
)
+
TString
.
leftPad
(
this
.
getHours
(
)
2
'
0
'
)
+
XString
.
leftPad
(
this
.
getMinutes
(
)
2
'
0
'
)
+
\
String
.
leftPad
(
this
.
getMonth
(
)
+
1
2
'
0
'
)
+
XString
.
leftPad
(
this
.
getSeconds
(
)
2
'
0
'
)
+
Sunday
Thursday
Tuesday
UniversalSortableDateTimePattern
Wednesday
Y
-
m
-
d
H
:
i
:
s
Y
-
m
-
d
H
:
i
:
sO
Y
-
m
-
d
\
TH
:
i
:
s
YearMonthPattern
[
+
-
]
\
d
{
1
5
}
[
+
-
]
\
d
{
4
}
[
A
-
Z
]
{
3
}
\
1
\
d
\
d
{
1
2
}
]
=
=
'
AM
'
)
{
]
=
=
'
am
'
)
{
]
)
;
]
10
)
-
1
;
2
]
.
substring
(
0
3
)
]
10
)
;
]
]
10
)
;
^
6
^
.
*
?
(
[
A
-
Z
]
{
3
}
)
[
0
-
9
]
{
4
}
.
*
d
^
.
*
?
\
(
(
[
A
-
Z
]
)
[
a
-
z
]
+
(
[
A
-
Z
]
)
[
a
-
z
]
+
(
[
A
-
Z
]
)
[
a
-
z
]
+
\
)
d
^
2017
-
09
-
05Tuesday
September
05
2017
[
0
-
9
:
]
*
AM
assertEq
"
d
=
d
.
getDate
(
)
;
*
d
=
parseInt
(
results
[
documentnelse
if
(
y
>
0
&
&
m
>
=
0
&
&
d
>
0
&
&
h
>
=
0
&
&
i
>
=
0
)
Zelse
if
(
y
>
0
&
&
m
>
=
0
&
&
d
>
0
&
&
h
>
=
0
)
Felse
if
(
y
>
0
&
&
m
>
=
0
&
&
d
>
0
)
4else
if
(
y
>
0
&
&
m
>
=
0
)
else
if
(
y
>
0
)
exec
floor
g
:
i
A
g
:
i
:
s
A
getDaysInMonth
getFirstDayOfMonth
getGMTOffset
"
getLastDayOfMonth
getSuffix
getTime
getTimezone
getWeekOfYear
*
h
=
parseInt
(
results
[
*
i
=
parseInt
(
results
[
Hif
(
results
&
&
results
.
length
>
0
)
{
xif
(
y
>
0
&
&
m
>
=
0
&
&
d
>
0
&
&
h
>
=
0
&
&
i
>
=
0
&
&
s
>
=
0
)
l
F
d
Y
m
=
d
.
getMonth
(
)
;
*
m
=
parseInt
(
results
[
monthNumbers
n
/
j
/
Y
nd
parse
parseDate
patterns
rd
*
s
=
parseInt
(
results
[
setTime
st
substring
th
"
this
.
getDate
(
)
+
this
.
getDay
(
)
+
this
.
getDayOfYear
(
)
+
0this
.
getDaysInMonth
(
)
+
*
this
.
getFullYear
(
)
+
this
.
getGMTOffset
(
)
+
this
.
getHours
(
)
+
&
this
.
getSuffix
(
)
+
*
this
.
getTimezone
(
)
+
.
this
.
getWeekOfYear
(
)
+
toString
(
var
d
=
new
Date
(
)
;
Xvar
results
=
input
.
match
(
Date
.
parseRegexes
[
4var
ty
=
parseInt
(
results
[
hvar
y
=
-
1
m
=
-
1
d
=
-
1
h
=
-
1
i
=
-
1
s
=
-
1
;
write
*
y
=
d
.
getFullYear
(
)
;
*
y
=
parseInt
(
results
[
^
y
=
ty
>
Date
.
y2kYear
?
1900
+
ty
:
2000
+
ty
;
y2kYear
{
return
new
Date
(
y
)
;
}
2
{
return
new
Date
(
y
m
)
;
}
8
{
return
new
Date
(
y
m
d
)
;
}
>
{
return
new
Date
(
y
m
d
h
)
;
}
D
{
return
new
Date
(
y
m
d
h
i
)
;
}
J
{
return
new
Date
(
y
m
d
h
i
s
)
;
}
}
return
null
;
}
!
=
&
>
|
|
[
TREE
]
identity
;
%
>
ZX
.
j
X
r
<
B
L
nJ
>
L
^
2
0
*
:
.
2
(
<
>
486
"
2
<
>
<
(
2
2
0
*
:
.
"
"
"
D
:
>
L
F
>
"
"
'
"
"
B
"
*
L
"
&
D
:
&
86
&
HV
(
86
&
B
86
&
B
>
&
z
<
|
86
>
&
2
0
*
:
.
T
6
o
!
#
u
%
m
q
s
w
R
z
<
|
2
0
*
:
d
:
.
d
2
(
<
B
486
"
2
<
B
<
2
d
2
0
*
:
.
"
D
V
"
"
D
:
BL
"
V
n
"
?
F
B
"
"
"
V
"
D
*
"
B
"
*
L
"
&
D
:
&
86
&
HV
(
86
&
B
86
&
B
>
&
D
<
86
&
4
>
&
4
>
&
D
4
H
4
4
86
>
&
4
>
&
-
+
)
'
%
#
/
F
n
VP
_
D
2
0
*
:
:
.
T
6
4
?
J
4
4
4
4
4
?
?
?
J
4
4
?
?
J
?
?
?
J
?
~
?
~
4
4
4
R
4
<
2
R0
*
.
(
p
N
*
p
N
*
2
0
*
.
H
5
(
b
R
Q
(
b
N
\
R
F
(
b
N
\
2
#
0
*
.
T
"
T
F
0
?
H
(
f
=
<
L
"
&
(
D
:
&
86
>
&
T
<
0
T
(
N
?
2
g
0
*
.
h
l
Z
"
l
(
(
P
"
hP
(
?
"
Z
hP
Z
R
l
Z
?
\
f2
0
*
.
8
"
8
(
H
(
3
8
7
F
8
Y
H
(
F
8
y
8
2
0
*
.
"
F
(
P
(
N
?
H
&
2
0
*
.
"
F
(
P
<
0
(
(
N
H
&
2
0
*
.
F
0
?
H
(
f
=
<
<
0
(
2
0
*
.
T
(
N
?
5
?
6
7
R
<
2
B0
*
:
v
.
v
vp
N
R2
0
*
:
x
:
t
:
.
x
t
6
"
6P
x
(
486
&
\
&
6
t86
&
6
6
6
0J
?
<
?
>
?
>
?
?
>
?
>
?
J
?
3
O
G
C
e
]
Y
+
J
y
S
}
{
5
a
!
I
=
1
?
M
E
A
c
[
"
W
)
&
9
;
g
I
7
U
-
i
K
k
/
"
.
P
"
X
L
&
&
D
:
&
86
"
r
.
^
"
j
.
^
&
X
r
j
.
.
0
?
A
1
N
*
X4B
