BINJS
[
GRAMMAR
]
identity
;
F
(
IdentifierExpression
CallExpression
&
ExpressionStatement
.
LiteralStringExpression
"
BindingIdentifier
StaticMemberExpression
(
AssertedDeclaredName
BinaryExpression
&
VariableDeclaration
VariableDeclarator0LiteralNumericExpression
4AssignmentTargetIdentifier
AssertedParameterScope
>
AssertedPositionalParameterName
AssertedVarScope
FormalParameters0LiteralBooleanExpression8CompoundAssignmentExpression0FunctionOrMethodContents
.
LazyFunctionDeclaration
UpdateExpression2AssertedScriptGlobalScope
(
AssignmentExpression
DataProperty
ForStatement4FunctionExpressionContents
LazyFunctionExpression
*
LiteralNullExpression
&
LiteralPropertyName
NewExpression
ObjectExpression
Script8StaticMemberAssignmentTarget
UnaryExpression
[
STRINGS
]
identity
;
i
j
var
test2
code
test1
env
g
i
manyNames
X
assertEq
hits
+
dbg
frame
eval
print
replace
!
=
=
+
+
+
=
P
{
let
=
0
;
h
(
)
;
}
d
{
for
(
let
=
0
;
X
<
1
;
X
+
+
)
h
(
)
;
}
{
let
=
0
;
{
let
y
=
0
;
h
(
)
;
}
}
:
many
:
one4
(
function
X
(
)
{
h
(
)
;
}
)
(
)
;
P
(
function
X
(
a
b
c
)
{
h
(
)
;
}
)
(
1
2
3
)
;
Debugger
declarative
environment
findpfunction
f
(
)
{
for
(
let
=
0
;
X
<
1
;
X
+
+
)
h
(
)
;
}
f
(
)
;
lfunction
f
(
)
{
let
=
0
;
{
let
y
=
0
;
h
(
)
;
}
}
f
(
)
;
:
function
f
(
)
{
h
(
)
;
}
f
(
)
;
<
function
f
(
)
{
h
(
)
;
}
f
(
1
)
;
rfunction
f
(
)
{
return
function
g
(
)
{
h
(
X
)
;
}
;
}
f
(
)
(
)
;
tfunction
f
(
)
{
return
function
g
(
)
{
h
(
X
)
;
}
;
}
f
(
1
)
(
)
;
jfunction
f
(
a
b
c
)
{
let
=
0
;
h
(
)
;
}
f
(
1
2
3
)
;
4function
h
(
)
{
debugger
;
}
indexOf
names
newCompartment
newGlobal
older
&
onDebuggerStatement
parent
type
x
-
<
[
TREE
]
identity
;
(
Z
>
0
:
X
"
R
<
<
(
k
&
.
B
^
6
4
\
B
V
T
Df
?
"
b
>
8
"
*
&
?
*
2
h
*
&
(
d
:
(
(
&
4
"
2
"
J
H
N
L
P
0
F
.
D
6
8
