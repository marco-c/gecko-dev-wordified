BINJS
[
GRAMMAR
]
identity
;
J
(
IdentifierExpression
&
ExpressionStatement
.
LiteralStringExpression
CallExpression
BinaryExpression
StaticMemberExpression
"
BindingIdentifier
(
AssignmentExpression
8StaticMemberAssignmentTarget
(
AssertedDeclaredName0LiteralNumericExpression
VariableDeclarator4AssignmentTargetIdentifier
&
VariableDeclaration
AssertedParameterScope
AssertedVarScope0ComputedMemberExpression
FormalParameters8CompoundAssignmentExpression
DataProperty4FunctionExpressionContents
LazyFunctionExpression
&
LiteralPropertyName
ObjectExpression
UpdateExpression
AssertedBlockScope
>
AssertedPositionalParameterName
Block
ForStatement2AssertedScriptGlobalScope0FunctionOrMethodContents
.
LazyFunctionDeclaration0LiteralBooleanExpression
*
LiteralNullExpression
.
LiteralRegExpExpression
Script
[
STRINGS
]
identity
;
t
var
g
i
s
+
offs
test
lineno
log
assertEq
length
where
count
dbg
frame
+
+
+
=
getLineOffsets
"
getOffsetLocation
hit
line0
lineNumber
setBreakpoint
switch
(
i
)
{
-
<
0
-
-
i
;
}
log
+
=
'
!
'
;
Z
case
'
0
'
:
case
'
1
'
:
log
+
=
'
!
'
;
break
;
}
h
case
'
ok
'
+
i
:
case
i
-
i
:
log
+
=
'
!
'
;
break
;
}
R
case
0
:
case
1
:
log
+
=
'
!
'
;
break
;
}
0
if
(
i
=
=
=
2
)
break
;
<
if
(
i
=
=
=
70
)
log
+
=
'
X
'
;
B
log
+
=
'
!
'
;
else
log
+
=
'
X
'
;
B
log
+
=
'
X
'
;
else
log
+
=
'
!
'
;
<
log
+
=
'
X
'
;
}
log
+
=
'
!
'
;
A
AB
!
CD
B
C
Debugger
\
n
charAt
debugger
;
eval
if
(
i
=
=
=
0
)
if
(
i
=
=
=
2
)
8line0
=
Error
(
)
.
lineNumber
;
log
+
=
'
D
'
;
newCompartment
newGlobal
&
onDebuggerStatement
script
split
switch
(
'
'
+
i
)
{
while
(
1
)
{
while
(
i
>
0
)
{
[
TREE
]
identity
;
I
H
<
"
f
0
(
.
dB
*
D
R
h
g
*
6
j
*
:
4
2
84
&
"
.
"
0
(
.
(
.
*
&
N
2
:
4
2
84
&
"
.
"
0
(
.
(
.
*
&
P
&
J
>
6
V
2
?
6
2
l
FT
"
?
"
?
Z
X
b
L
\
D
^
F
p
H
r
B
8
0
>
n
:
0
<
