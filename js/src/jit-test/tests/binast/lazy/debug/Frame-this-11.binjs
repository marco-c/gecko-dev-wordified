BINJS
[
GRAMMAR
]
identity
;
B
(
IdentifierExpression
CallExpression
&
ExpressionStatement
StaticMemberExpression
.
LiteralStringExpression
"
BindingIdentifier
(
AssertedDeclaredName
BinaryExpression
&
VariableDeclaration
VariableDeclarator
(
AssignmentExpression8StaticMemberAssignmentTarget
IfStatement0LiteralNumericExpression
AssertedParameterScope
>
AssertedPositionalParameterName2AssertedScriptGlobalScope
AssertedVarScope4AssignmentTargetIdentifier
DataProperty
FormalParameters4FunctionExpressionContents
LazyFunctionExpression0LiteralBooleanExpression
*
LiteralNullExpression
&
LiteralPropertyName
NewExpression
ObjectExpression
ReturnStatement
Script
UnaryExpression
UpdateExpression
[
STRINGS
]
identity
;
}
N
g
eval
frameThis
var
frame
hits
assertEq
dbg
this
gotThis
return
=
=
=
DebuggerPfunction
nonstrictfun
(
)
{
return
this
;
}
function
nonstrictfunNoThis
(
)
{
}
ffunction
strictfun
(
)
{
'
use
strict
'
;
return
this
;
}
Xfunction
strictfunNoThis
(
)
{
'
use
strict
'
;
}
newCompartment
newGlobalbnonstrictfun
.
call
(
)
;
assertEq
(
gotThis
this
)
;
bnonstrictfun
.
call
(
Math
)
;
assertEq
(
gotThis
Math
)
;
bnonstrictfun
.
call
(
null
)
;
assertEq
(
gotThis
this
)
;
nnonstrictfunNoThis
.
call
(
)
;
assertEq
(
gotThis
this
)
;
nnonstrictfunNoThis
.
call
(
Math
)
;
assertEq
(
gotThis
Math
)
;
nnonstrictfunNoThis
.
call
(
null
)
;
assertEq
(
gotThis
this
)
;
object
onEnterFramefstrictfun
.
call
(
)
;
assertEq
(
gotThis
undefined
)
;
\
strictfun
.
call
(
Math
)
;
assertEq
(
gotThis
Math
)
;
\
strictfun
.
call
(
true
)
;
assertEq
(
gotThis
true
)
;
hstrictfunNoThis
.
call
(
Math
)
;
assertEq
(
gotThis
Math
)
;
hstrictfunNoThis
.
call
(
null
)
;
assertEq
(
gotThis
null
)
;
hstrictfunNoThis
.
call
(
true
)
;
assertEq
(
gotThis
true
)
;
type
"
unsafeDereference
!
=
=
&
&
+
+
typeof
[
TREE
]
identity
;
<
"
*
8
(
4
"
0
6
4
.
*
B
:
J
&
H
F
2
>
L
2
D
8
:
6
<
>
(
*
&
.
0
(
