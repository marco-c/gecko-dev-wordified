BINJS
[
GRAMMAR
]
identity
;
.
LiteralStringExpression
(
IdentifierExpression
CallExpression
&
ExpressionStatement
BinaryExpression2AssertedScriptGlobalScope
Script
[
STRINGS
]
identity
;
h
&
assertOffsetColumns
+
dvar
obj
=
{
base
:
{
a
(
)
{
return
{
b
(
)
{
}
}
;
}
}
}
;
var
args
=
[
]
;
0
2
1
3z
^
^
^
^
^
^
^
^
^
^
b
^
^
^
^
H
^
^
^
^
D
^
^
^
^
^
8
^
^
^
^
^
^
^
^
^
^
^
^
d
^
^
^
t
^
^
^
^
^
^
^
^
T
^
^
^
^
N
^
^
^
P
^
^
^
X
^
^
^
^
^
^
^
^
t
^
^
^
^
n
^
^
^
^
R
^
^
^
^
d
^
^
^
^
^
0
1
2
4
3
5B0
1
3
.
2
1
3
.
2
1
3
.
2
1
4
!
5
0
1
3
2
4
0
2
1
3
40assert
-
offset
-
columns
.
jsdfunction
f
(
)
{
1
&
&
ppppp
(
ppppp
(
)
)
&
&
new
Error
(
)
}
^
function
f
(
n
)
{
(
0
obj
)
.
base
.
a
(
)
.
b
(
.
.
.
args
)
;
}
nfunction
f
(
n
)
{
do
{
print
(
n
)
;
break
;
}
while
(
false
)
;
}
tfunction
f
(
n
)
{
do
{
print
(
n
)
;
continue
;
}
while
(
false
)
;
}
function
f
(
n
)
{
do
{
print
(
n
)
;
}
while
(
false
)
;
}
function
f
(
n
)
{
for
(
var
i
=
0
;
i
<
n
;
+
+
i
)
hits
.
push
(
'
.
'
)
;
hits
.
push
(
'
!
'
)
;
}
tfunction
f
(
n
)
{
if
(
n
=
=
2
)
;
else
if
(
n
=
=
=
3
)
print
(
n
)
;
}
Nfunction
f
(
n
)
{
if
(
n
=
=
3
)
print
(
n
)
;
}
Tfunction
f
(
n
)
{
obj
.
base
.
a
(
)
.
b
(
.
.
.
args
)
;
}
function
f
(
n
)
{
obj
.
base
[
'
a
'
]
(
)
[
'
b
'
]
(
.
.
.
args
)
;
}
Xfunction
f
(
n
)
{
obj
.
base
[
a
]
(
)
[
b
]
(
.
.
.
args
)
;
}
dfunction
f
(
n
)
{
switch
(
n
)
{
default
:
print
(
n
)
;
}
}
Pfunction
f
(
n
)
{
with
(
{
}
)
{
print
(
n
)
;
}
}
Rfunction
f
(
n
)
{
print
(
n
)
print
(
n
)
print
(
n
)
}
8function
f
(
n
)
{
var
a
=
[
1
2
n
]
}
Dfunction
f
(
n
)
{
var
o
=
{
a
:
1
b
:
2
c
:
3
}
}
Hfunction
f
(
n
)
{
var
w0
x1
=
3
y2
=
4
z3
=
9
}
>
function
ppppp
(
)
{
return
1
;
}
libdir
loadBvar
args
=
[
]
a
=
'
a
'
b
=
'
b
'
;
xvar
f
=
function
(
)
{
this
.
base
.
a
(
)
.
b
(
.
.
.
args
)
;
}
.
bind
(
obj
)
;
var
f
=
{
__proto__
:
obj
f
(
n
)
{
super
.
base
.
a
(
)
.
b
(
.
.
.
args
)
;
}
}
.
f
;
[
TREE
]
identity
;
(
^
8
D
2
Z
T
X
V
\
:
.
6
P
>
*
(
R
"
H
F
B
&
J
d
f
<
0
L
b
N
4
