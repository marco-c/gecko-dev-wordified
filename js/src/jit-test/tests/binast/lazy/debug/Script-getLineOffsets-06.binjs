BINJS
[
GRAMMAR
]
identity
;
L
BinaryExpression
.
LiteralStringExpression
(
IdentifierExpression
CallExpression
&
ExpressionStatement
"
BindingIdentifier
StaticMemberExpression
(
AssertedDeclaredName
&
VariableDeclaration
VariableDeclarator
0LiteralNumericExpression
(
AssignmentExpression8StaticMemberAssignmentTarget
AssertedParameterScope
>
AssertedPositionalParameterName
AssertedVarScope
FormalParameters4AssignmentTargetIdentifier8CompoundAssignmentExpression0ComputedMemberExpression
DataProperty4FunctionExpressionContents0FunctionOrMethodContents
.
LazyFunctionDeclaration
LazyFunctionExpression0LiteralBooleanExpression
&
LiteralPropertyName
ObjectExpression
AssertedBlockScope2AssertedScriptGlobalScope
Block
ForStatement
*
LiteralNullExpression
.
LiteralRegExpExpression
ReturnStatement
Script
UpdateExpression
[
STRINGS
]
identity
;
+
var
s
test
g
long_throw_stmt
i
offs
frame
switch
(
i
)
{
default
:
lineno
log
long_expr
where
assertEq
count
dbg
length
repeat
}
"
i
+
+
;
break
;
}
"
if
(
i
=
=
=
0
)
case
i
+
1
-
i
:
"
default
:
i
+
+
;
}
;
line0
+
=
break
;
continue
;
i
=
0
;
i
=
1
;
throw
case
'
0
'
:
i
+
+
;
}
case
'
1
'
:
case
'
1
'
:
case
'
2
'
:
case
'
3
'
:
case
0
:
i
+
+
;
}
case
1
:
4
case
1
:
case
2
:
case
3
:
case
i
+
i
:
+
i
log
+
=
'
C
'
;
A
ABC
Array
B
Debugger
\
n
charAt
debugger
;
do
{
eval
for
(
;
;
)
{
getLineOffsets
"
getOffsetLocation
hit
if
(
i
=
=
=
2
)
{
join8line0
=
Error
(
)
.
lineNumber
;
lineNumber
newCompartment
newGlobal
&
onDebuggerStatement
script
setBreakpoint
split
switch
(
'
'
+
i
)
{
throw
try
{
}
catch
(
exc
)
{
}
finally
{
}
while
(
i
!
=
=
0
)
;
!
=
=
+
+
-
<
<
<
[
TREE
]
identity
;
5
H
<
(
&
8
*
6
~
4
8B
b
2
"
8
p
&
J
>
:
r
(
|
(
8
*
6t2
:
"
&
:
&
:
Z0
!
.
"
"
f
&
?
<
4
"
Dd
&
?
"
l
z
h
X
\
0
(
z
.
"
F
^
?
?
x
(
V
6
n
0
>
*
j
0
v
*
B
F
6
D
*
P
N
R
4
J
H
L
4
2
T
.
2
.
