/
/
Check
JS
:
:
ubi
:
:
Node
:
:
size
results
for
strings
.
/
/
We
actually
hard
-
code
specific
sizes
into
this
test
even
though
they
'
re
/
/
implementation
details
because
in
practice
there
are
only
two
architecture
/
/
variants
to
consider
(
32
-
bit
and
64
-
bit
)
and
if
these
sizes
change
that
'
s
/
/
something
SpiderMonkey
hackers
really
want
to
know
;
they
'
re
supposed
to
be
/
/
stable
.
/
/
Run
this
test
only
if
we
'
re
using
jemalloc
.
Other
malloc
implementations
/
/
exhibit
surprising
behaviors
.
For
example
32
-
bit
Fedora
builds
have
/
/
non
-
deterministic
allocation
sizes
.
var
config
=
getBuildConfiguration
(
)
;
if
(
!
config
[
'
moz
-
memory
'
]
)
quit
(
0
)
;
if
(
config
[
'
pointer
-
byte
-
size
'
]
=
=
4
)
var
s
=
(
s32
s64
)
=
>
s32
else
var
s
=
(
s32
s64
)
=
>
s64
/
/
Convert
an
input
string
which
is
probably
an
atom
because
it
'
s
a
literal
in
/
/
the
source
text
to
a
regular
(
non
-
rope
)
string
with
the
same
contents
.
function
copyString
(
str
)
{
if
(
str
.
length
=
=
0
)
return
str
;
/
/
Nothing
we
can
do
here
return
ensureFlatString
(
str
.
substr
(
0
1
)
+
str
.
substr
(
1
)
)
;
}
/
/
Return
the
tenured
byte
size
of
|
str
|
.
function
tByteSize
(
str
)
{
str
=
copyString
(
str
)
;
let
nurserySize
=
byteSize
(
str
)
;
minorgc
(
)
;
var
tenuredSize
=
byteSize
(
str
)
;
if
(
nurserySize
!
=
tenuredSize
)
{
print
(
"
nursery
size
:
"
+
nurserySize
+
"
tenured
size
:
"
+
tenuredSize
)
;
return
-
1
;
/
/
make
the
stack
trace
point
at
the
real
test
}
return
tenuredSize
;
}
/
/
There
are
four
representations
of
flat
strings
with
the
following
capacities
/
/
(
excluding
a
terminating
null
character
)
:
/
/
/
/
32
-
bit
64
-
bit
test
/
/
representation
Latin
-
1
char16_t
Latin
-
1
char16_t
label
/
/
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
/
/
JSExternalString
(
cannot
be
tested
in
shell
)
-
/
/
JSThinInlineString
7
3
15
7
T
/
/
JSFatInlineString
23
11
23
11
F
/
/
JSExtensibleString
-
limited
by
available
memory
-
X
/
/
JSUndependedString
-
same
as
JSExtensibleString
-
/
/
Notes
:
/
/
-
labels
are
suffixed
with
A
for
atoms
and
N
for
non
-
atoms
/
/
-
atoms
are
8
bytes
larger
than
non
-
atoms
to
store
the
atom
'
s
hash
code
.
/
/
Expected
sizes
based
on
type
of
string
const
m32
=
(
config
[
'
pointer
-
byte
-
size
'
]
=
=
4
)
;
const
TA
=
m32
?
24
:
32
;
/
/
ThinInlineString
atom
includes
a
hash
value
const
TN
=
m32
?
16
:
24
;
/
/
ThinInlineString
const
FN
=
m32
?
32
:
32
;
/
/
FatInlineString
const
XN
=
m32
?
16
:
24
;
/
/
ExtensibleString
has
additional
storage
buffer
const
RN
=
m32
?
16
:
24
;
/
/
Rope
const
DN
=
m32
?
16
:
24
;
/
/
DependentString
/
/
Latin
-
1
assertEq
(
tByteSize
(
"
"
)
s
(
TA
TA
)
)
;
assertEq
(
tByteSize
(
"
1
"
)
s
(
TA
TA
)
)
;
assertEq
(
tByteSize
(
"
1234567
"
)
s
(
TN
TN
)
)
;
assertEq
(
tByteSize
(
"
12345678
"
)
s
(
FN
TN
)
)
;
assertEq
(
tByteSize
(
"
123456789
.
12345
"
)
s
(
FN
TN
)
)
;
assertEq
(
tByteSize
(
"
123456789
.
123456
"
)
s
(
FN
FN
)
)
;
assertEq
(
tByteSize
(
"
123456789
.
123456789
.
123
"
)
s
(
FN
FN
)
)
;
assertEq
(
tByteSize
(
"
123456789
.
123456789
.
1234
"
)
s
(
XN
+
32
XN
+
32
)
)
;
assertEq
(
tByteSize
(
"
123456789
.
123456789
.
123456789
.
1
"
)
s
(
XN
+
32
XN
+
32
)
)
;
assertEq
(
tByteSize
(
"
123456789
.
123456789
.
123456789
.
12
"
)
s
(
XN
+
64
XN
+
64
)
)
;
/
/
Inline
char16_t
atoms
.
/
/
"
Impassionate
gods
have
never
seen
the
red
that
is
the
Tatsuta
River
.
"
/
/
-
Ariwara
no
Narihira
assertEq
(
tByteSize
(
"
"
)
s
(
TA
TA
)
)
;
assertEq
(
tByteSize
(
"
"
)
s
(
TN
TN
)
)
;
assertEq
(
tByteSize
(
"
"
)
s
(
TN
TN
)
)
;
assertEq
(
tByteSize
(
"
"
)
s
(
FN
TN
)
)
;
assertEq
(
tByteSize
(
"
"
)
s
(
FN
TN
)
)
;
assertEq
(
tByteSize
(
"
"
)
s
(
FN
TN
)
)
;
assertEq
(
tByteSize
(
"
"
)
s
(
FN
TN
)
)
;
assertEq
(
tByteSize
(
"
"
)
s
(
FN
FN
)
)
;
assertEq
(
tByteSize
(
"
"
)
s
(
FN
FN
)
)
;
assertEq
(
tByteSize
(
"
"
)
s
(
XN
+
32
XN
+
32
)
)
;
assertEq
(
tByteSize
(
"
"
)
s
(
XN
+
32
XN
+
32
)
)
;
assertEq
(
tByteSize
(
"
"
)
s
(
XN
+
64
XN
+
64
)
)
;
assertEq
(
tByteSize
(
"
"
)
s
(
XN
+
64
XN
+
64
)
)
;
assertEq
(
tByteSize
(
"
"
)
s
(
XN
+
64
XN
+
64
)
)
;
assertEq
(
tByteSize
(
"
"
)
s
(
XN
+
64
XN
+
64
)
)
;
/
/
A
Latin
-
1
rope
.
This
changes
size
when
flattened
.
/
/
"
In
a
village
of
La
Mancha
the
name
of
which
I
have
no
desire
to
call
to
mind
"
/
/
-
Miguel
de
Cervantes
Don
Quixote
var
fragment8
=
"
En
un
lugar
de
la
Mancha
de
cuyo
nombre
no
quiero
acordarme
"
;
/
/
60
characters
var
rope8
=
fragment8
;
for
(
var
i
=
0
;
i
<
10
;
i
+
+
)
/
/
1024
repetitions
rope8
=
rope8
+
rope8
;
assertEq
(
byteSize
(
rope8
)
s
(
RN
RN
)
)
;
var
matches8
=
rope8
.
match
(
/
(
de
cuyo
nombre
no
quiero
acordarme
)
/
)
;
assertEq
(
byteSize
(
rope8
)
s
(
XN
+
65536
XN
+
65536
)
)
;
/
/
Test
extensible
strings
.
/
/
/
/
Appending
another
copy
of
the
fragment
should
yield
another
rope
.
/
/
/
/
Flatting
that
should
turn
the
original
rope
into
a
dependent
string
and
/
/
yield
a
new
linear
string
of
the
same
size
as
the
original
.
rope8a
=
rope8
+
fragment8
;
assertEq
(
byteSize
(
rope8a
)
s
(
RN
RN
)
)
;
rope8a
.
match
(
/
x
/
function
(
)
{
assertEq
(
true
false
)
;
}
)
;
assertEq
(
byteSize
(
rope8a
)
s
(
XN
+
65536
XN
+
65536
)
)
;
assertEq
(
byteSize
(
rope8
)
s
(
RN
RN
)
)
;
/
/
A
char16_t
rope
.
This
changes
size
when
flattened
.
/
/
"
From
the
Heliconian
Muses
let
us
begin
to
sing
"
/
/
-
-
-
Hesiod
Theogony
var
fragment16
=
"
"
;
var
rope16
=
fragment16
;
for
(
var
i
=
0
;
i
<
10
;
i
+
+
)
/
/
1024
repetitions
rope16
=
rope16
+
rope16
;
assertEq
(
byteSize
(
rope16
)
s
(
RN
RN
)
)
;
let
matches16
=
rope16
.
match
(
/
(
)
/
)
;
assertEq
(
byteSize
(
rope16
)
s
(
RN
+
131072
RN
+
131072
)
)
;
/
/
Latin
-
1
and
char16_t
dependent
strings
.
assertEq
(
byteSize
(
rope8
.
substr
(
1000
2000
)
)
s
(
DN
DN
)
)
;
assertEq
(
byteSize
(
rope16
.
substr
(
1000
2000
)
)
s
(
DN
DN
)
)
;
assertEq
(
byteSize
(
matches8
[
0
]
)
s
(
DN
DN
)
)
;
assertEq
(
byteSize
(
matches8
[
1
]
)
s
(
DN
DN
)
)
;
assertEq
(
byteSize
(
matches16
[
0
]
)
s
(
DN
DN
)
)
;
assertEq
(
byteSize
(
matches16
[
1
]
)
s
(
DN
DN
)
)
;
/
/
Test
extensible
strings
.
/
/
/
/
Appending
another
copy
of
the
fragment
should
yield
another
rope
.
/
/
/
/
Flatting
that
should
turn
the
original
rope
into
a
dependent
string
and
/
/
yield
a
new
linear
string
of
the
some
size
as
the
original
.
rope16a
=
rope16
+
fragment16
;
assertEq
(
byteSize
(
rope16a
)
s
(
RN
RN
)
)
;
rope16a
.
match
(
/
x
/
function
(
)
{
assertEq
(
true
false
)
;
}
)
;
assertEq
(
byteSize
(
rope16a
)
s
(
XN
+
131072
XN
+
131072
)
)
;
assertEq
(
byteSize
(
rope16
)
s
(
XN
XN
)
)
;
