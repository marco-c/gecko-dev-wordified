/
*
-
*
-
Mode
:
C
+
+
;
tab
-
width
:
4
;
indent
-
tabs
-
mode
:
nil
;
c
-
basic
-
offset
:
4
-
*
-
*
vim
:
set
ts
=
4
sw
=
4
et
tw
=
99
:
*
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
#
include
"
BaselineCompiler
.
h
"
#
include
"
BaselineIC
.
h
"
#
include
"
BaselineJIT
.
h
"
#
include
"
CompileInfo
.
h
"
using
namespace
js
;
using
namespace
js
:
:
ion
;
BaselineScript
:
:
BaselineScript
(
)
:
method_
(
NULL
)
{
}
static
const
size_t
BUILDER_LIFO_ALLOC_PRIMARY_CHUNK_SIZE
=
1
<
<
12
;
/
/
XXX
/
/
XXX
copied
from
Ion
.
cpp
class
AutoDestroyAllocator
{
LifoAlloc
*
alloc
;
public
:
AutoDestroyAllocator
(
LifoAlloc
*
alloc
)
:
alloc
(
alloc
)
{
}
void
cancel
(
)
{
alloc
=
NULL
;
}
~
AutoDestroyAllocator
(
)
{
if
(
alloc
)
js_delete
(
alloc
)
;
}
}
;
static
IonExecStatus
EnterBaseline
(
JSContext
*
cx
StackFrame
*
fp
void
*
jitcode
)
{
JS_CHECK_RECURSION
(
cx
return
IonExec_Error
)
;
JS_ASSERT
(
ion
:
:
IsEnabled
(
cx
)
)
;
/
/
XXXJS_ASSERT
(
CheckFrame
(
fp
)
)
;
EnterIonCode
enter
=
cx
-
>
compartment
-
>
ionCompartment
(
)
-
>
enterJITInfallible
(
)
;
/
/
maxArgc
is
the
maximum
of
arguments
between
the
number
of
actual
/
/
arguments
and
the
number
of
formal
arguments
.
It
accounts
for
|
this
|
.
int
maxArgc
=
0
;
Value
*
maxArgv
=
NULL
;
int
numActualArgs
=
0
;
void
*
calleeToken
;
if
(
fp
-
>
isFunctionFrame
(
)
)
{
/
/
CountArgSlot
include
|
this
|
and
the
|
scopeChain
|
.
maxArgc
=
CountArgSlots
(
fp
-
>
fun
(
)
)
-
1
;
/
/
-
1
=
discard
|
scopeChain
|
maxArgv
=
fp
-
>
formals
(
)
-
1
;
/
/
-
1
=
include
|
this
|
/
/
Formal
arguments
are
the
argument
corresponding
to
the
function
/
/
definition
and
actual
arguments
are
corresponding
to
the
call
-
site
/
/
arguments
.
numActualArgs
=
fp
-
>
numActualArgs
(
)
;
/
/
We
do
not
need
to
handle
underflow
because
formal
arguments
are
pad
/
/
with
|
undefined
|
values
but
we
need
to
distinguish
between
the
if
(
fp
-
>
hasOverflowArgs
(
)
)
{
int
formalArgc
=
maxArgc
;
Value
*
formalArgv
=
maxArgv
;
maxArgc
=
numActualArgs
+
1
;
/
/
+
1
=
include
|
this
|
maxArgv
=
fp
-
>
actuals
(
)
-
1
;
/
/
-
1
=
include
|
this
|
/
/
The
beginning
of
the
actual
args
is
not
updated
so
we
just
copy
/
/
the
formal
args
into
the
actual
args
to
get
a
linear
vector
which
/
/
can
be
copied
by
generateEnterJit
.
memcpy
(
maxArgv
formalArgv
formalArgc
*
sizeof
(
Value
)
)
;
}
calleeToken
=
CalleeToToken
(
&
fp
-
>
callee
(
)
)
;
}
else
{
calleeToken
=
CalleeToToken
(
fp
-
>
script
(
)
.
unsafeGet
(
)
)
;
}
/
/
Caller
must
construct
|
this
|
before
invoking
the
Ion
function
.
JS_ASSERT_IF
(
fp
-
>
isConstructing
(
)
fp
-
>
functionThis
(
)
.
isObject
(
)
)
;
Value
result
=
Int32Value
(
numActualArgs
)
;
{
AssertCompartmentUnchanged
pcc
(
cx
)
;
IonContext
ictx
(
cx
cx
-
>
compartment
NULL
)
;
IonActivation
activation
(
cx
fp
)
;
JSAutoResolveFlags
rf
(
cx
RESOLVE_INFER
)
;
/
/
Single
transition
point
from
Interpreter
to
Ion
.
enter
(
jitcode
maxArgc
maxArgv
fp
calleeToken
&
result
)
;
}
JS_ASSERT
(
fp
=
=
cx
-
>
fp
(
)
)
;
JS_ASSERT
(
!
cx
-
>
runtime
-
>
hasIonReturnOverride
(
)
)
;
/
/
The
trampoline
wrote
the
return
value
but
did
not
set
the
HAS_RVAL
flag
.
fp
-
>
setReturnValue
(
result
)
;
/
/
Ion
callers
wrap
primitive
constructor
return
.
if
(
!
result
.
isMagic
(
)
&
&
fp
-
>
isConstructing
(
)
&
&
fp
-
>
returnValue
(
)
.
isPrimitive
(
)
)
fp
-
>
setReturnValue
(
ObjectValue
(
fp
-
>
constructorThis
(
)
)
)
;
JS_ASSERT_IF
(
result
.
isMagic
(
)
result
.
isMagic
(
JS_ION_ERROR
)
)
;
return
result
.
isMagic
(
)
?
IonExec_Error
:
IonExec_Ok
;
}
IonExecStatus
ion
:
:
EnterBaselineMethod
(
JSContext
*
cx
StackFrame
*
fp
)
{
RootedScript
script
(
cx
fp
-
>
script
(
)
)
;
BaselineScript
*
baseline
=
script
-
>
baseline
;
IonCode
*
code
=
baseline
-
>
method
(
)
;
void
*
jitcode
=
code
-
>
raw
(
)
;
return
EnterBaseline
(
cx
fp
jitcode
)
;
}
MethodStatus
ion
:
:
CanEnterBaselineJIT
(
JSContext
*
cx
HandleScript
script
StackFrame
*
fp
)
{
if
(
script
-
>
baseline
)
return
Method_Compiled
;
if
(
!
cx
-
>
compartment
-
>
ensureIonCompartmentExists
(
cx
)
)
return
Method_Error
;
LifoAlloc
*
alloc
=
cx
-
>
new_
<
LifoAlloc
>
(
BUILDER_LIFO_ALLOC_PRIMARY_CHUNK_SIZE
)
;
if
(
!
alloc
)
return
Method_Error
;
AutoDestroyAllocator
autoDestroy
(
alloc
)
;
TempAllocator
*
temp
=
alloc
-
>
new_
<
TempAllocator
>
(
alloc
)
;
if
(
!
temp
)
return
Method_Error
;
IonContext
ictx
(
cx
cx
-
>
compartment
temp
)
;
BaselineCompiler
compiler
(
cx
script
)
;
if
(
!
compiler
.
init
(
)
)
return
Method_Error
;
MethodStatus
status
=
compiler
.
compile
(
)
;
if
(
status
!
=
Method_Compiled
)
return
status
;
/
/
This
can
GC
so
afterward
script
-
>
ion
is
not
guaranteed
to
be
valid
.
if
(
!
cx
-
>
compartment
-
>
ionCompartment
(
)
-
>
enterJIT
(
cx
)
)
return
Method_Error
;
if
(
!
script
-
>
baseline
)
return
Method_Skipped
;
return
Method_Compiled
;
}
static
const
int
DataAlignment
=
4
;
/
/
XXX
copied
from
Ion
.
cpp
BaselineScript
*
BaselineScript
:
:
New
(
JSContext
*
cx
size_t
cacheEntries
)
{
size_t
paddedCacheEntriesSize
=
AlignBytes
(
cacheEntries
*
sizeof
(
CacheData
)
DataAlignment
)
;
size_t
bytes
=
paddedCacheEntriesSize
;
uint8
*
buffer
=
(
uint8
*
)
cx
-
>
malloc_
(
sizeof
(
BaselineScript
)
+
bytes
)
;
if
(
!
buffer
)
return
NULL
;
BaselineScript
*
script
=
reinterpret_cast
<
BaselineScript
*
>
(
buffer
)
;
new
(
script
)
BaselineScript
(
)
;
uint32
offsetCursor
=
sizeof
(
BaselineScript
)
;
script
-
>
cacheList_
=
offsetCursor
;
script
-
>
cacheEntries_
=
cacheEntries
;
offsetCursor
+
=
paddedCacheEntriesSize
;
/
/
uint32
offsetCursor
=
sizeof
(
BaselineScript
)
;
return
script
;
}
void
BaselineScript
:
:
copyCacheEntries
(
const
CacheData
*
caches
MacroAssembler
&
masm
)
{
memcpy
(
cacheList
(
)
caches
numCaches
(
)
*
sizeof
(
CacheData
)
)
;
/
/
Jumps
in
the
caches
reflect
the
offset
of
those
jumps
in
the
compiled
/
/
code
not
the
absolute
positions
of
the
jumps
.
Update
according
to
the
/
/
final
code
address
now
.
for
(
size_t
i
=
0
;
i
<
numCaches
(
)
;
i
+
+
)
getCache
(
i
)
.
updateBaseAddress
(
method_
masm
)
;
}
CacheData
&
BaselineScript
:
:
getCache
(
size_t
index
)
{
JS_ASSERT
(
index
<
numCaches
(
)
)
;
return
cacheList
(
)
[
index
]
;
}
CacheData
&
BaselineScript
:
:
cacheDataFromReturnAddr
(
uint8_t
*
addr
)
{
for
(
size_t
i
=
0
;
i
<
numCaches
(
)
;
i
+
+
)
{
CacheData
&
cache
=
getCache
(
i
)
;
if
(
cache
.
call
.
raw
(
)
=
=
addr
)
return
cache
;
}
JS_NOT_REACHED
(
"
No
cache
"
)
;
return
getCache
(
0
)
;
}
