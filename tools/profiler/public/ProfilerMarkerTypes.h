/
*
-
*
-
Mode
:
C
+
+
;
tab
-
width
:
2
;
indent
-
tabs
-
mode
:
nil
;
c
-
basic
-
offset
:
2
-
*
-
*
/
/
*
vim
:
set
ts
=
8
sts
=
2
et
sw
=
2
tw
=
80
:
*
/
/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
#
ifndef
ProfilerMarkerTypes_h
#
define
ProfilerMarkerTypes_h
/
/
This
header
contains
common
marker
type
definitions
that
rely
on
xpcom
.
/
/
/
/
It
#
include
'
s
"
mozilla
/
BaseProfilerMarkerTypess
.
h
"
and
"
ProfilerMarkers
.
h
"
/
/
see
these
files
for
more
marker
types
how
to
define
other
marker
types
and
/
/
how
to
add
markers
to
the
profiler
buffers
.
/
/
!
!
!
/
!
\
WORK
IN
PROGRESS
/
!
\
!
!
!
/
/
This
file
contains
draft
marker
definitions
but
most
are
not
used
yet
.
/
/
Further
work
is
needed
to
complete
these
definitions
and
use
them
to
convert
/
/
existing
PROFILER_ADD_MARKER
calls
.
See
meta
bug
1661394
.
#
include
"
mozilla
/
BaseProfilerMarkerTypes
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
ifdef
MOZ_GECKO_PROFILER
#
include
"
gfxASurface
.
h
"
#
include
"
js
/
AllocationRecording
.
h
"
#
include
"
js
/
ProfilingFrameIterator
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ServoTraversalStatistics
.
h
"
namespace
geckoprofiler
:
:
markers
{
/
/
Import
some
common
markers
from
mozilla
:
:
baseprofiler
:
:
markers
.
using
Tracing
=
mozilla
:
:
baseprofiler
:
:
markers
:
:
Tracing
;
using
UserTimingMark
=
mozilla
:
:
baseprofiler
:
:
markers
:
:
UserTimingMark
;
using
UserTimingMeasure
=
mozilla
:
:
baseprofiler
:
:
markers
:
:
UserTimingMeasure
;
using
MediaSample
=
mozilla
:
:
baseprofiler
:
:
markers
:
:
MediaSample
;
using
ContentBuildMarker
=
mozilla
:
:
baseprofiler
:
:
markers
:
:
ContentBuildMarker
;
struct
ScreenshotPayload
{
static
constexpr
mozilla
:
:
Span
<
const
char
>
MarkerTypeName
(
)
{
return
mozilla
:
:
MakeStringSpan
(
"
CompositorScreenshot
"
)
;
}
static
void
StreamJSONMarkerData
(
mozilla
:
:
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
mozilla
:
:
ProfilerString8View
&
aScreenshotDataURL
const
mozilla
:
:
gfx
:
:
IntSize
&
aWindowSize
uintptr_t
aWindowIdentifier
)
{
/
/
TODO
:
Use
UniqueStacks
&
Strings
/
/
aUniqueStacks
.
mUniqueStrings
-
>
WriteProperty
(
aWriter
"
url
"
/
/
mScreenshotDataURL
.
get
(
)
)
;
aWriter
.
StringProperty
(
"
url
"
aScreenshotDataURL
)
;
char
hexWindowID
[
32
]
;
SprintfLiteral
(
hexWindowID
"
0x
%
"
PRIXPTR
aWindowIdentifier
)
;
aWriter
.
StringProperty
(
"
windowID
"
hexWindowID
)
;
aWriter
.
DoubleProperty
(
"
windowWidth
"
aWindowSize
.
width
)
;
aWriter
.
DoubleProperty
(
"
windowHeight
"
aWindowSize
.
height
)
;
}
static
mozilla
:
:
MarkerSchema
MarkerTypeDisplay
(
)
{
return
mozilla
:
:
MarkerSchema
:
:
SpecialFrontendLocation
{
}
;
}
}
;
struct
GCSlice
{
static
constexpr
mozilla
:
:
Span
<
const
char
>
MarkerTypeName
(
)
{
return
mozilla
:
:
MakeStringSpan
(
"
GCSlice
"
)
;
}
static
void
StreamJSONMarkerData
(
mozilla
:
:
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
mozilla
:
:
ProfilerString8View
&
aTimingJSON
)
{
if
(
aTimingJSON
.
Length
(
)
!
=
0
)
{
/
/
TODO
:
Is
SplicedJSONProperty
necessary
here
?
(
Guessing
yes
!
)
/
/
aWriter
.
SplicedJSONProperty
(
"
timings
"
aTimingJSON
)
;
aWriter
.
StringProperty
(
"
timings
"
aTimingJSON
)
;
}
else
{
aWriter
.
NullProperty
(
"
timings
"
)
;
}
}
static
mozilla
:
:
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
mozilla
:
:
MarkerSchema
;
MS
schema
{
MS
:
:
Location
:
:
markerChart
MS
:
:
Location
:
:
markerTable
MS
:
:
Location
:
:
timelineMemory
}
;
/
/
No
display
instructions
here
there
is
special
handling
in
the
front
-
end
.
return
schema
;
}
}
;
struct
GCMajor
{
static
constexpr
mozilla
:
:
Span
<
const
char
>
MarkerTypeName
(
)
{
return
mozilla
:
:
MakeStringSpan
(
"
GCMajor
"
)
;
}
static
void
StreamJSONMarkerData
(
mozilla
:
:
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
mozilla
:
:
ProfilerString8View
&
aTimingJSON
)
{
if
(
aTimingJSON
.
Length
(
)
!
=
0
)
{
/
/
TODO
:
Is
SplicedJSONProperty
necessary
here
?
(
Guessing
yes
!
)
/
/
aWriter
.
SplicedJSONProperty
(
"
timings
"
aTimingJSON
)
;
aWriter
.
StringProperty
(
"
timings
"
aTimingJSON
)
;
}
else
{
aWriter
.
NullProperty
(
"
timings
"
)
;
}
}
static
mozilla
:
:
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
mozilla
:
:
MarkerSchema
;
MS
schema
{
MS
:
:
Location
:
:
markerChart
MS
:
:
Location
:
:
markerTable
MS
:
:
Location
:
:
timelineMemory
}
;
/
/
No
display
instructions
here
there
is
special
handling
in
the
front
-
end
.
return
schema
;
}
}
;
struct
GCMinor
{
static
constexpr
mozilla
:
:
Span
<
const
char
>
MarkerTypeName
(
)
{
return
mozilla
:
:
MakeStringSpan
(
"
GCMinor
"
)
;
}
static
void
StreamJSONMarkerData
(
mozilla
:
:
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
mozilla
:
:
ProfilerString8View
&
aTimingJSON
)
{
if
(
aTimingJSON
.
Length
(
)
!
=
0
)
{
/
/
TODO
:
Is
SplicedJSONProperty
necessary
here
?
(
Guessing
yes
!
)
/
/
aWriter
.
SplicedJSONProperty
(
"
nursery
"
aTimingJSON
)
;
aWriter
.
StringProperty
(
"
nursery
"
aTimingJSON
)
;
}
else
{
aWriter
.
NullProperty
(
"
nursery
"
)
;
}
}
static
mozilla
:
:
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
mozilla
:
:
MarkerSchema
;
MS
schema
{
MS
:
:
Location
:
:
markerChart
MS
:
:
Location
:
:
markerTable
MS
:
:
Location
:
:
timelineMemory
}
;
/
/
No
display
instructions
here
there
is
special
handling
in
the
front
-
end
.
return
schema
;
}
}
;
class
JsAllocationMarkerPayload
{
static
constexpr
mozilla
:
:
Span
<
const
char
>
MarkerTypeName
(
)
{
return
mozilla
:
:
MakeStringSpan
(
"
JS
allocation
"
)
;
}
static
void
StreamJSONMarkerData
(
mozilla
:
:
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
mozilla
:
:
ProfilerString16View
&
aTypeName
const
mozilla
:
:
ProfilerString8View
&
aClassName
const
mozilla
:
:
ProfilerString16View
&
aDescriptiveTypeName
const
mozilla
:
:
ProfilerString8View
&
aCoarseType
uint64_t
aSize
bool
aInNursery
)
{
if
(
aClassName
.
Length
(
)
!
=
0
)
{
aWriter
.
StringProperty
(
"
className
"
aClassName
)
;
}
if
(
aTypeName
.
Length
(
)
!
=
0
)
{
aWriter
.
StringProperty
(
"
typeName
"
NS_ConvertUTF16toUTF8
(
aTypeName
.
Data
(
)
aTypeName
.
Length
(
)
)
)
;
}
if
(
aDescriptiveTypeName
.
Length
(
)
!
=
0
)
{
aWriter
.
StringProperty
(
"
descriptiveTypeName
"
NS_ConvertUTF16toUTF8
(
aDescriptiveTypeName
.
Data
(
)
aDescriptiveTypeName
.
Length
(
)
)
)
;
}
aWriter
.
StringProperty
(
"
coarseType
"
aCoarseType
)
;
aWriter
.
IntProperty
(
"
size
"
aSize
)
;
aWriter
.
BoolProperty
(
"
inNursery
"
aInNursery
)
;
}
static
mozilla
:
:
MarkerSchema
MarkerTypeDisplay
(
)
{
return
mozilla
:
:
MarkerSchema
:
:
SpecialFrontendLocation
{
}
;
}
}
;
/
/
This
payload
is
for
collecting
information
about
native
allocations
.
There
is
/
/
a
memory
hook
into
malloc
and
other
memory
functions
that
can
sample
a
subset
/
/
of
the
allocations
.
This
information
is
then
stored
in
this
payload
.
struct
NativeAllocationMarkerPayload
{
static
constexpr
mozilla
:
:
Span
<
const
char
>
MarkerTypeName
(
)
{
return
mozilla
:
:
MakeStringSpan
(
"
Native
allocation
"
)
;
}
static
void
StreamJSONMarkerData
(
mozilla
:
:
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
int64_t
aSize
uintptr_t
aMemoryAddress
int
aThreadId
)
{
aWriter
.
IntProperty
(
"
size
"
aSize
)
;
aWriter
.
IntProperty
(
"
memoryAddress
"
static_cast
<
int64_t
>
(
aMemoryAddress
)
)
;
aWriter
.
IntProperty
(
"
threadId
"
aThreadId
)
;
}
static
mozilla
:
:
MarkerSchema
MarkerTypeDisplay
(
)
{
return
mozilla
:
:
MarkerSchema
:
:
SpecialFrontendLocation
{
}
;
}
}
;
struct
IPCMarkerPayload
{
static
constexpr
mozilla
:
:
Span
<
const
char
>
MarkerTypeName
(
)
{
return
mozilla
:
:
MakeStringSpan
(
"
IPC
"
)
;
}
static
void
StreamJSONMarkerData
(
mozilla
:
:
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
int32_t
aOtherPid
int32_t
aMessageSeqno
IPC
:
:
Message
:
:
msgid_t
aMessageType
mozilla
:
:
ipc
:
:
Side
aSide
mozilla
:
:
ipc
:
:
MessageDirection
aDirection
mozilla
:
:
ipc
:
:
MessagePhase
aPhase
bool
aSync
const
mozilla
:
:
TimeStamp
&
aTime
)
{
/
/
TODO
:
Remove
these
Legacy
times
when
frontend
is
updated
.
mozilla
:
:
baseprofiler
:
:
WritePropertyTime
(
aWriter
"
startTime
"
aTime
)
;
mozilla
:
:
baseprofiler
:
:
WritePropertyTime
(
aWriter
"
endTime
"
aTime
)
;
using
namespace
mozilla
:
:
ipc
;
aWriter
.
IntProperty
(
"
otherPid
"
aOtherPid
)
;
aWriter
.
IntProperty
(
"
messageSeqno
"
aMessageSeqno
)
;
aWriter
.
StringProperty
(
"
messageType
"
mozilla
:
:
MakeStringSpan
(
IPC
:
:
StringFromIPCMessageType
(
aMessageType
)
)
)
;
aWriter
.
StringProperty
(
"
side
"
IPCSideToString
(
aSide
)
)
;
aWriter
.
StringProperty
(
"
direction
"
aDirection
=
=
MessageDirection
:
:
eSending
?
mozilla
:
:
MakeStringSpan
(
"
sending
"
)
:
mozilla
:
:
MakeStringSpan
(
"
receiving
"
)
)
;
aWriter
.
StringProperty
(
"
phase
"
IPCPhaseToString
(
aPhase
)
)
;
aWriter
.
BoolProperty
(
"
sync
"
aSync
)
;
}
static
mozilla
:
:
MarkerSchema
MarkerTypeDisplay
(
)
{
return
mozilla
:
:
MarkerSchema
:
:
SpecialFrontendLocation
{
}
;
}
private
:
static
mozilla
:
:
Span
<
const
char
>
IPCSideToString
(
mozilla
:
:
ipc
:
:
Side
aSide
)
{
switch
(
aSide
)
{
case
mozilla
:
:
ipc
:
:
ParentSide
:
return
mozilla
:
:
MakeStringSpan
(
"
parent
"
)
;
case
mozilla
:
:
ipc
:
:
ChildSide
:
return
mozilla
:
:
MakeStringSpan
(
"
child
"
)
;
case
mozilla
:
:
ipc
:
:
UnknownSide
:
return
mozilla
:
:
MakeStringSpan
(
"
unknown
"
)
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
IPC
side
"
)
;
return
mozilla
:
:
MakeStringSpan
(
"
<
invalid
IPC
side
>
"
)
;
}
}
static
mozilla
:
:
Span
<
const
char
>
IPCPhaseToString
(
mozilla
:
:
ipc
:
:
MessagePhase
aPhase
)
{
switch
(
aPhase
)
{
case
mozilla
:
:
ipc
:
:
MessagePhase
:
:
Endpoint
:
return
mozilla
:
:
MakeStringSpan
(
"
endpoint
"
)
;
case
mozilla
:
:
ipc
:
:
MessagePhase
:
:
TransferStart
:
return
mozilla
:
:
MakeStringSpan
(
"
transferStart
"
)
;
case
mozilla
:
:
ipc
:
:
MessagePhase
:
:
TransferEnd
:
return
mozilla
:
:
MakeStringSpan
(
"
transferEnd
"
)
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
IPC
phase
"
)
;
return
mozilla
:
:
MakeStringSpan
(
"
<
invalid
IPC
phase
>
"
)
;
}
}
}
;
}
/
/
namespace
geckoprofiler
:
:
markers
#
endif
/
/
MOZ_GECKO_PROFILER
#
endif
/
/
ProfilerMarkerTypes_h
