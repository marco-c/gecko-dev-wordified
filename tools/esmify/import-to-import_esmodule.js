/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
/
/
jscodeshift
rule
to
replace
import
calls
for
JSM
with
import
calls
for
ESM
/
/
or
static
import
for
ESM
.
/
*
global
require
__dirname
process
*
/
const
_path
=
require
(
"
path
"
)
;
const
{
isESMified
getESMFiles
}
=
require
(
_path
.
resolve
(
__dirname
"
.
/
is
-
esmified
.
js
"
)
)
;
const
{
isIdentifier
isString
warnForPath
getPrevStatement
getNextStatement
}
=
require
(
_path
.
resolve
(
__dirname
"
.
/
utils
.
js
"
)
)
;
/
*
global
module
*
/
module
.
exports
=
function
(
fileInfo
api
)
{
const
{
jscodeshift
}
=
api
;
const
root
=
jscodeshift
(
fileInfo
.
source
)
;
doTranslate
(
fileInfo
.
path
jscodeshift
root
)
;
return
root
.
toSource
(
{
lineTerminator
:
"
\
n
"
}
)
;
}
;
module
.
exports
.
doTranslate
=
doTranslate
;
function
isESMifiedAndTarget
(
resourceURI
)
{
const
files
=
[
]
;
if
(
!
isESMified
(
resourceURI
files
)
)
{
return
false
;
}
if
(
"
ESMIFY_TARGET_PREFIX
"
in
process
.
env
)
{
const
targetPrefix
=
process
.
env
.
ESMIFY_TARGET_PREFIX
;
for
(
const
esm
of
files
)
{
if
(
esm
.
startsWith
(
targetPrefix
)
)
{
return
true
;
}
}
return
false
;
}
return
true
;
}
function
isTargetESM
(
resourceURI
)
{
if
(
"
ESMIFY_TARGET_PREFIX
"
in
process
.
env
)
{
const
files
=
getESMFiles
(
resourceURI
)
;
const
targetPrefix
=
process
.
env
.
ESMIFY_TARGET_PREFIX
;
for
(
const
esm
of
files
)
{
if
(
esm
.
startsWith
(
targetPrefix
)
)
{
return
true
;
}
}
return
false
;
}
return
true
;
}
function
calleeToString
(
node
)
{
if
(
node
.
type
=
=
=
"
Identifier
"
)
{
return
node
.
name
;
}
if
(
node
.
type
=
=
=
"
MemberExpression
"
&
&
!
node
.
computed
)
{
return
calleeToString
(
node
.
object
)
+
"
.
"
+
node
.
property
.
name
;
}
return
"
?
?
?
"
;
}
function
isImportCall
(
node
)
{
const
s
=
calleeToString
(
node
.
callee
)
;
return
[
"
Cu
.
import
"
"
ChromeUtils
.
import
"
]
.
includes
(
s
)
;
}
function
isImportESModuleCall
(
node
)
{
const
s
=
calleeToString
(
node
.
callee
)
;
return
[
"
ChromeUtils
.
importESModule
"
]
.
includes
(
s
)
;
}
function
isLazyGetterCall
(
node
)
{
const
s
=
calleeToString
(
node
.
callee
)
;
return
[
"
XPCOMUtils
.
defineLazyModuleGetter
"
"
ChromeUtils
.
defineModuleGetter
"
]
.
includes
(
s
)
;
}
function
isLazyGettersCall
(
node
)
{
const
s
=
calleeToString
(
node
.
callee
)
;
return
[
"
XPCOMUtils
.
defineLazyModuleGetters
"
]
.
includes
(
s
)
;
}
function
isESModuleGettersCall
(
node
)
{
const
s
=
calleeToString
(
node
.
callee
)
;
return
[
"
ChromeUtils
.
defineESModuleGetters
"
]
.
includes
(
s
)
;
}
const
extPattern
=
/
\
.
(
jsm
|
js
|
jsm
\
.
js
)
/
;
function
esmify
(
path
)
{
return
path
.
replace
(
extPattern
"
.
sys
.
mjs
"
)
;
}
/
/
Replace
ChromeUtils
.
import
Cu
.
import
and
ChromeUtils
.
importESModule
/
/
with
static
import
if
it
'
s
at
the
top
-
level
of
system
ESM
file
.
function
tryReplacingWithStaticImport
(
jscodeshift
inputFile
path
resourceURINode
)
{
if
(
!
inputFile
.
endsWith
(
"
.
sys
.
mjs
"
)
)
{
/
/
Static
import
is
available
only
in
system
ESM
.
return
false
;
}
/
/
Check
if
it
'
s
at
the
top
-
level
.
if
(
path
.
parent
.
node
.
type
!
=
=
"
VariableDeclarator
"
)
{
return
false
;
}
if
(
path
.
parent
.
parent
.
node
.
type
!
=
=
"
VariableDeclaration
"
)
{
return
false
;
}
const
decls
=
path
.
parent
.
parent
.
node
;
if
(
decls
.
declarations
.
length
!
=
=
1
)
{
return
false
;
}
if
(
path
.
parent
.
parent
.
parent
.
node
.
type
!
=
=
"
Program
"
)
{
return
false
;
}
if
(
path
.
node
.
arguments
.
length
!
=
=
1
)
{
return
false
;
}
const
resourceURI
=
resourceURINode
.
value
;
/
/
Collect
imported
symbols
.
const
specs
=
[
]
;
if
(
path
.
parent
.
node
.
id
.
type
=
=
=
"
Identifier
"
)
{
specs
.
push
(
jscodeshift
.
importNamespaceSpecifier
(
path
.
parent
.
node
.
id
)
)
;
}
else
if
(
path
.
parent
.
node
.
id
.
type
=
=
=
"
ObjectPattern
"
)
{
for
(
const
prop
of
path
.
parent
.
node
.
id
.
properties
)
{
if
(
prop
.
shorthand
)
{
specs
.
push
(
jscodeshift
.
importSpecifier
(
prop
.
key
)
)
;
}
else
if
(
prop
.
value
.
type
=
=
=
"
Identifier
"
)
{
specs
.
push
(
jscodeshift
.
importSpecifier
(
prop
.
key
prop
.
value
)
)
;
}
else
{
return
false
;
}
}
}
else
{
return
false
;
}
/
/
If
this
is
ChromeUtils
.
import
or
Cu
.
import
replace
the
extension
.
/
/
no
-
op
for
ChromeUtils
.
importESModule
.
resourceURINode
.
value
=
esmify
(
resourceURI
)
;
const
e
=
jscodeshift
.
importDeclaration
(
specs
resourceURINode
)
;
e
.
comments
=
path
.
parent
.
parent
.
node
.
comments
;
path
.
parent
.
parent
.
node
.
comments
=
[
]
;
path
.
parent
.
parent
.
replace
(
e
)
;
return
true
;
}
function
replaceImportCall
(
inputFile
jscodeshift
path
)
{
if
(
path
.
node
.
arguments
.
length
!
=
=
1
)
{
warnForPath
(
inputFile
path
import
call
should
have
only
one
argument
)
;
return
;
}
const
resourceURINode
=
path
.
node
.
arguments
[
0
]
;
if
(
!
isString
(
resourceURINode
)
)
{
warnForPath
(
inputFile
path
resource
URI
should
be
a
string
)
;
return
;
}
const
resourceURI
=
resourceURINode
.
value
;
if
(
!
resourceURI
.
match
(
extPattern
)
)
{
warnForPath
(
inputFile
path
Non
-
jsm
:
{
resourceURI
}
)
;
return
;
}
if
(
!
isESMifiedAndTarget
(
resourceURI
)
)
{
return
;
}
if
(
!
tryReplacingWithStaticImport
(
jscodeshift
inputFile
path
resourceURINode
)
)
{
path
.
node
.
callee
.
object
.
name
=
"
ChromeUtils
"
;
path
.
node
.
callee
.
property
.
name
=
"
importESModule
"
;
resourceURINode
.
value
=
esmify
(
resourceURI
)
;
}
}
function
replaceImportESModuleCall
(
inputFile
jscodeshift
path
)
{
if
(
path
.
node
.
arguments
.
length
!
=
=
1
)
{
warnForPath
(
inputFile
path
importESModule
call
should
have
only
one
argument
)
;
return
;
}
const
resourceURINode
=
path
.
node
.
arguments
[
0
]
;
if
(
!
isString
(
resourceURINode
)
)
{
warnForPath
(
inputFile
path
resource
URI
should
be
a
string
)
;
return
;
}
const
resourceURI
=
resourceURINode
.
value
;
if
(
!
isTargetESM
(
resourceURI
)
)
{
return
;
}
/
/
If
this
cannot
be
replaced
with
static
import
do
nothing
.
tryReplacingWithStaticImport
(
jscodeshift
inputFile
path
resourceURINode
)
;
}
/
/
Find
ChromeUtils
.
defineESModuleGetters
statement
adjacent
to
path
which
/
/
uses
the
same
target
object
.
function
findDefineESModuleGettersStmt
(
path
)
{
/
/
path
must
be
top
-
level
.
if
(
path
.
parent
.
node
.
type
!
=
=
"
ExpressionStatement
"
)
{
return
null
;
}
if
(
path
.
parent
.
parent
.
node
.
type
!
=
=
"
Program
"
)
{
return
null
;
}
/
/
Get
previous
or
next
statement
with
ChromeUtils
.
defineESModuleGetters
.
let
callStmt
;
const
prev
=
getPrevStatement
(
path
.
parent
)
;
if
(
prev
&
&
prev
.
type
=
=
=
"
ExpressionStatement
"
&
&
prev
.
expression
.
type
=
=
=
"
CallExpression
"
&
&
isESModuleGettersCall
(
prev
.
expression
)
)
{
callStmt
=
prev
;
}
else
{
const
next
=
getNextStatement
(
path
.
parent
)
;
if
(
next
&
&
next
.
type
=
=
=
"
ExpressionStatement
"
&
&
next
.
expression
.
type
=
=
=
"
CallExpression
"
&
&
isESModuleGettersCall
(
next
.
expression
)
)
{
callStmt
=
next
;
}
else
{
return
null
;
}
}
const
call
=
callStmt
.
expression
;
if
(
call
.
arguments
.
length
!
=
=
2
)
{
return
null
;
}
const
modulesNode
=
call
.
arguments
[
1
]
;
if
(
modulesNode
.
type
!
=
=
"
ObjectExpression
"
)
{
return
null
;
}
/
/
Check
if
the
target
object
is
same
.
if
(
path
.
node
.
arguments
[
0
]
.
type
=
=
=
"
ThisExpression
"
&
&
call
.
arguments
[
0
]
.
type
=
=
=
"
ThisExpression
"
)
{
return
callStmt
;
}
if
(
path
.
node
.
arguments
[
0
]
.
type
=
=
=
"
Identifier
"
&
&
call
.
arguments
[
0
]
.
type
=
=
=
"
Identifier
"
&
&
path
.
node
.
arguments
[
0
]
.
name
=
=
=
call
.
arguments
[
0
]
.
name
)
{
return
callStmt
;
}
return
null
;
}
function
getPropKeyString
(
prop
)
{
if
(
prop
.
key
.
type
=
=
=
"
Identifier
"
)
{
return
prop
.
key
.
name
;
}
if
(
prop
.
key
.
type
=
=
=
"
Literal
"
)
{
return
prop
.
key
.
value
.
toString
(
)
;
}
return
"
"
;
}
function
sortProps
(
obj
)
{
obj
.
properties
.
sort
(
(
a
b
)
=
>
{
return
getPropKeyString
(
a
)
<
getPropKeyString
(
b
)
?
-
1
:
1
;
}
)
;
}
/
/
Move
comments
above
nodeFrom
before
nodeTo
.
function
moveComments
(
nodeTo
nodeFrom
)
{
if
(
!
nodeFrom
.
comments
)
{
return
;
}
if
(
nodeTo
.
comments
)
{
nodeTo
.
comments
=
[
.
.
.
nodeTo
.
comments
.
.
.
nodeFrom
.
comments
]
;
}
else
{
nodeTo
.
comments
=
nodeFrom
.
comments
;
}
nodeFrom
.
comments
=
[
]
;
}
function
replaceLazyGetterCall
(
inputFile
jscodeshift
path
)
{
if
(
path
.
node
.
arguments
.
length
!
=
=
3
)
{
warnForPath
(
inputFile
path
lazy
getter
call
should
have
3
arguments
)
;
return
;
}
const
nameNode
=
path
.
node
.
arguments
[
1
]
;
if
(
!
isString
(
nameNode
)
)
{
warnForPath
(
inputFile
path
name
should
be
a
string
)
;
return
;
}
const
resourceURINode
=
path
.
node
.
arguments
[
2
]
;
if
(
!
isString
(
resourceURINode
)
)
{
warnForPath
(
inputFile
path
resource
URI
should
be
a
string
)
;
return
;
}
const
resourceURI
=
resourceURINode
.
value
;
if
(
!
resourceURI
.
match
(
extPattern
)
)
{
warnForPath
(
inputFile
path
Non
-
js
/
jsm
:
{
resourceURI
}
)
;
return
;
}
if
(
!
isESMifiedAndTarget
(
resourceURI
)
)
{
return
;
}
resourceURINode
.
value
=
esmify
(
resourceURI
)
;
const
prop
=
jscodeshift
.
property
(
"
init
"
jscodeshift
.
identifier
(
nameNode
.
value
)
resourceURINode
)
;
const
callStmt
=
findDefineESModuleGettersStmt
(
path
)
;
if
(
callStmt
)
{
/
/
Move
a
property
to
existing
ChromeUtils
.
defineESModuleGetters
call
.
moveComments
(
callStmt
path
.
parent
.
node
)
;
path
.
parent
.
prune
(
)
;
callStmt
.
expression
.
arguments
[
1
]
.
properties
.
push
(
prop
)
;
sortProps
(
callStmt
.
expression
.
arguments
[
1
]
)
;
}
else
{
/
/
Convert
this
call
into
ChromeUtils
.
defineESModuleGetters
.
path
.
node
.
callee
.
object
.
name
=
"
ChromeUtils
"
;
path
.
node
.
callee
.
property
.
name
=
"
defineESModuleGetters
"
;
path
.
node
.
arguments
=
[
path
.
node
.
arguments
[
0
]
jscodeshift
.
objectExpression
(
[
prop
]
)
]
;
}
}
function
replaceLazyGettersCall
(
inputFile
jscodeshift
path
)
{
if
(
path
.
node
.
arguments
.
length
!
=
=
2
)
{
warnForPath
(
inputFile
path
lazy
getters
call
should
have
2
arguments
)
;
return
;
}
const
modulesNode
=
path
.
node
.
arguments
[
1
]
;
if
(
modulesNode
.
type
!
=
=
"
ObjectExpression
"
)
{
warnForPath
(
inputFile
path
modules
parameter
should
be
an
object
)
;
return
;
}
const
esmProps
=
[
]
;
const
jsmProps
=
[
]
;
for
(
const
prop
of
modulesNode
.
properties
)
{
const
resourceURINode
=
prop
.
value
;
if
(
!
isString
(
resourceURINode
)
)
{
warnForPath
(
inputFile
path
resource
URI
should
be
a
string
)
;
jsmProps
.
push
(
prop
)
;
continue
;
}
const
resourceURI
=
resourceURINode
.
value
;
if
(
!
resourceURI
.
match
(
extPattern
)
)
{
warnForPath
(
inputFile
path
Non
-
js
/
jsm
:
{
resourceURI
}
)
;
jsmProps
.
push
(
prop
)
;
continue
;
}
if
(
!
isESMifiedAndTarget
(
resourceURI
)
)
{
jsmProps
.
push
(
prop
)
;
continue
;
}
esmProps
.
push
(
prop
)
;
}
if
(
esmProps
.
length
=
=
=
0
)
{
return
;
}
let
callStmt
=
findDefineESModuleGettersStmt
(
path
)
;
if
(
jsmProps
.
length
=
=
=
0
)
{
if
(
callStmt
)
{
/
/
Move
all
properties
to
existing
ChromeUtils
.
defineESModuleGetters
call
.
moveComments
(
callStmt
path
.
parent
.
node
)
;
path
.
parent
.
prune
(
)
;
for
(
const
prop
of
esmProps
)
{
const
resourceURINode
=
prop
.
value
;
resourceURINode
.
value
=
esmify
(
resourceURINode
.
value
)
;
callStmt
.
expression
.
arguments
[
1
]
.
properties
.
push
(
prop
)
;
}
sortProps
(
callStmt
.
expression
.
arguments
[
1
]
)
;
}
else
{
/
/
Convert
this
call
into
ChromeUtils
.
defineESModuleGetters
.
path
.
node
.
callee
.
object
.
name
=
"
ChromeUtils
"
;
path
.
node
.
callee
.
property
.
name
=
"
defineESModuleGetters
"
;
for
(
const
prop
of
esmProps
)
{
const
resourceURINode
=
prop
.
value
;
resourceURINode
.
value
=
esmify
(
resourceURINode
.
value
)
;
}
}
}
else
{
/
/
Move
some
properties
to
ChromeUtils
.
defineESModuleGetters
.
if
(
path
.
parent
.
node
.
type
!
=
=
"
ExpressionStatement
"
)
{
warnForPath
(
inputFile
path
lazy
getters
call
in
unexpected
context
)
;
return
;
}
if
(
!
callStmt
)
{
callStmt
=
jscodeshift
.
expressionStatement
(
jscodeshift
.
callExpression
(
jscodeshift
.
memberExpression
(
jscodeshift
.
identifier
(
"
ChromeUtils
"
)
jscodeshift
.
identifier
(
"
defineESModuleGetters
"
)
)
[
path
.
node
.
arguments
[
0
]
jscodeshift
.
objectExpression
(
[
]
)
]
)
)
;
path
.
parent
.
insertBefore
(
callStmt
)
;
}
moveComments
(
callStmt
path
.
parent
.
node
)
;
for
(
const
prop
of
esmProps
)
{
const
resourceURINode
=
prop
.
value
;
resourceURINode
.
value
=
esmify
(
resourceURINode
.
value
)
;
callStmt
.
expression
.
arguments
[
1
]
.
properties
.
push
(
prop
)
;
}
sortProps
(
callStmt
.
expression
.
arguments
[
1
]
)
;
path
.
node
.
arguments
[
1
]
.
properties
=
jsmProps
;
}
}
function
getProp
(
obj
key
)
{
if
(
obj
.
type
!
=
=
"
ObjectExpression
"
)
{
return
null
;
}
for
(
const
prop
of
obj
.
properties
)
{
if
(
prop
.
computed
)
{
continue
;
}
if
(
!
prop
.
key
)
{
continue
;
}
if
(
isIdentifier
(
prop
.
key
key
)
)
{
return
prop
;
}
}
return
null
;
}
function
tryReplaceActorDefinition
(
inputFile
path
name
)
{
const
obj
=
path
.
node
;
const
prop
=
getProp
(
obj
name
)
;
if
(
!
prop
)
{
return
;
}
const
moduleURIProp
=
getProp
(
prop
.
value
"
moduleURI
"
)
;
if
(
!
moduleURIProp
)
{
return
;
}
if
(
!
isString
(
moduleURIProp
.
value
)
)
{
warnForPath
(
inputFile
path
{
name
}
moduleURI
should
be
a
string
)
;
return
;
}
const
moduleURI
=
moduleURIProp
.
value
.
value
;
if
(
!
moduleURI
.
match
(
extPattern
)
)
{
warnForPath
(
inputFile
path
{
name
}
Non
-
js
/
jsm
:
{
moduleURI
}
)
;
return
;
}
if
(
!
isESMifiedAndTarget
(
moduleURI
)
)
{
return
;
}
moduleURIProp
.
key
.
name
=
"
esModuleURI
"
;
moduleURIProp
.
value
.
value
=
esmify
(
moduleURI
)
;
}
function
doTranslate
(
inputFile
jscodeshift
root
)
{
root
.
find
(
jscodeshift
.
CallExpression
)
.
forEach
(
path
=
>
{
if
(
isImportCall
(
path
.
node
)
)
{
replaceImportCall
(
inputFile
jscodeshift
path
)
;
}
else
if
(
isImportESModuleCall
(
path
.
node
)
)
{
replaceImportESModuleCall
(
inputFile
jscodeshift
path
)
;
}
else
if
(
isLazyGetterCall
(
path
.
node
)
)
{
replaceLazyGetterCall
(
inputFile
jscodeshift
path
)
;
}
else
if
(
isLazyGettersCall
(
path
.
node
)
)
{
replaceLazyGettersCall
(
inputFile
jscodeshift
path
)
;
}
}
)
;
root
.
find
(
jscodeshift
.
ObjectExpression
)
.
forEach
(
path
=
>
{
tryReplaceActorDefinition
(
inputFile
path
"
parent
"
)
;
tryReplaceActorDefinition
(
inputFile
path
"
child
"
)
;
}
)
;
}
