/
*
Any
copyright
is
dedicated
to
the
Public
Domain
.
*
http
:
/
/
creativecommons
.
org
/
publicdomain
/
zero
/
1
.
0
/
*
/
const
Cc
=
Components
.
classes
;
const
Ci
=
Components
.
interfaces
;
const
Cu
=
Components
.
utils
;
const
Cr
=
Components
.
results
;
/
/
The
following
boilerplate
makes
sure
that
XPCom
calls
/
/
that
use
the
profile
directory
work
.
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Identity
"
"
resource
:
/
/
gre
/
modules
/
identity
/
Identity
.
jsm
"
"
Identity
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Logger
"
"
resource
:
/
/
gre
/
modules
/
identity
/
LogUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
uuidGenerator
"
"
mozilla
.
org
/
uuid
-
generator
;
1
"
"
nsIUUIDGenerator
"
)
;
const
TEST_URL
=
"
https
:
/
/
myfavoriteflan
.
com
"
;
const
TEST_USER
=
"
uumellmahaye1969
hotmail
.
com
"
;
const
TEST_PRIVKEY
=
"
i
-
am
-
a
-
secret
"
;
const
TEST_CERT
=
"
i
-
am
-
a
-
cert
"
;
/
/
The
following
are
utility
functions
for
Identity
testing
function
log
(
.
.
.
aMessageArgs
)
{
Logger
.
log
.
apply
(
Logger
[
"
test
"
]
.
concat
(
aMessageArgs
)
)
;
}
function
partial
(
fn
)
{
let
args
=
Array
.
prototype
.
slice
.
call
(
arguments
1
)
;
return
function
(
)
{
return
fn
.
apply
(
this
args
.
concat
(
Array
.
prototype
.
slice
.
call
(
arguments
)
)
)
;
}
;
}
function
uuid
(
)
{
return
uuidGenerator
.
generateUUID
(
)
.
toString
(
)
;
}
/
/
create
a
mock
"
doc
"
object
which
the
Identity
Service
/
/
uses
as
a
pointer
back
into
the
doc
object
function
mock_doc
(
aIdentity
aOrigin
aDoFunc
)
{
let
mockedDoc
=
{
}
;
mockedDoc
.
id
=
uuid
(
)
;
mockedDoc
.
loggedInEmail
=
aIdentity
;
mockedDoc
.
origin
=
aOrigin
;
mockedDoc
[
'
do
'
]
=
aDoFunc
;
mockedDoc
.
doReady
=
partial
(
aDoFunc
'
ready
'
)
;
mockedDoc
.
doLogin
=
partial
(
aDoFunc
'
login
'
)
;
mockedDoc
.
doLogout
=
partial
(
aDoFunc
'
logout
'
)
;
mockedDoc
.
doError
=
partial
(
aDoFunc
'
error
'
)
;
mockedDoc
.
doCancel
=
partial
(
aDoFunc
'
cancel
'
)
;
mockedDoc
.
doCoffee
=
partial
(
aDoFunc
'
coffee
'
)
;
return
mockedDoc
;
}
/
/
mimicking
callback
funtionality
for
ease
of
testing
/
/
this
observer
auto
-
removes
itself
after
the
observe
function
/
/
is
called
so
this
is
meant
to
observe
only
ONE
event
.
function
makeObserver
(
aObserveTopic
aObserveFunc
)
{
let
observer
=
{
/
/
nsISupports
provides
type
management
in
C
+
+
/
/
nsIObserver
is
to
be
an
observer
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsISupports
Ci
.
nsIObserver
]
)
observe
:
function
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
aObserveTopic
)
{
aObserveFunc
(
aSubject
aTopic
aData
)
;
Services
.
obs
.
removeObserver
(
observer
aObserveTopic
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
observer
aObserveTopic
false
)
;
}
/
/
set
up
the
ID
service
with
an
identity
with
keypair
and
all
/
/
when
ready
invoke
callback
with
the
identity
function
setup_test_identity
(
identity
cert
cb
)
{
/
/
set
up
the
store
so
that
we
'
re
supposed
to
be
logged
in
let
store
=
get_idstore
(
)
;
function
keyGenerated
(
err
kpo
)
{
store
.
addIdentity
(
identity
kpo
cert
)
;
cb
(
)
;
}
;
jwcrypto
.
generateKeyPair
(
"
DS160
"
keyGenerated
)
;
}
/
/
takes
a
list
of
functions
and
returns
a
function
that
/
/
when
called
the
first
time
calls
the
first
func
/
/
then
the
next
time
the
second
etc
.
function
call_sequentially
(
)
{
let
numCalls
=
0
;
let
funcs
=
arguments
;
return
function
(
)
{
if
(
!
funcs
[
numCalls
]
)
{
let
argString
=
Array
.
prototype
.
slice
.
call
(
arguments
)
.
join
(
"
"
)
;
do_throw
(
"
Too
many
calls
:
"
+
argString
)
;
return
;
}
funcs
[
numCalls
]
.
apply
(
funcs
[
numCalls
]
arguments
)
;
numCalls
+
=
1
;
}
;
}
