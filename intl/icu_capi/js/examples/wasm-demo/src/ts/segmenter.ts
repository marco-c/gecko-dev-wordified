import
{
ICU4XDataProvider
ICU4XWordSegmenter
}
from
"
icu4x
"
;
export
class
SegmenterDemo
{
#
displayFn
:
(
formatted
:
string
)
=
>
void
;
#
dataProvider
:
ICU4XDataProvider
;
#
segmenter
:
ICU4XWordSegmenter
;
#
model
:
string
;
#
text
:
string
;
constructor
(
displayFn
:
(
formatted
:
string
)
=
>
void
dataProvider
:
ICU4XDataProvider
)
{
this
.
#
displayFn
=
displayFn
;
this
.
#
dataProvider
=
dataProvider
;
this
.
#
model
=
"
Auto
"
;
this
.
#
text
=
"
"
;
this
.
#
updateSegmenter
(
)
;
}
setModel
(
model
:
string
)
:
void
{
this
.
#
model
=
model
;
this
.
#
updateSegmenter
(
)
;
}
setText
(
text
:
string
)
:
void
{
this
.
#
text
=
text
;
this
.
#
render
(
)
;
}
#
updateSegmenter
(
)
:
void
{
if
(
this
.
#
model
=
=
=
"
Auto
"
)
{
this
.
#
segmenter
=
ICU4XWordSegmenter
.
create_auto
(
this
.
#
dataProvider
)
;
}
else
if
(
this
.
#
model
=
=
=
"
LSTM
"
)
{
this
.
#
segmenter
=
ICU4XWordSegmenter
.
create_lstm
(
this
.
#
dataProvider
)
;
}
else
if
(
this
.
#
model
=
=
=
"
Dictionary
"
)
{
this
.
#
segmenter
=
ICU4XWordSegmenter
.
create_dictionary
(
this
.
#
dataProvider
)
;
}
else
{
console
.
error
(
"
Unknown
model
:
"
+
this
.
#
model
)
;
}
this
.
#
render
(
)
;
}
#
render
(
)
:
void
{
const
segments
=
[
]
;
let
utf8Index
=
0
;
let
utf16Index
=
0
;
const
iter8
=
this
.
#
segmenter
.
segment_utf8
(
this
.
#
text
)
;
while
(
true
)
{
const
next
=
iter8
.
next
(
)
;
if
(
next
=
=
=
-
1
)
{
segments
.
push
(
this
.
#
text
.
slice
(
utf16Index
)
)
;
break
;
}
else
{
const
oldUtf16Index
=
utf16Index
;
while
(
utf8Index
<
next
)
{
const
codePoint
=
this
.
#
text
.
codePointAt
(
utf16Index
)
;
const
utf8Len
=
(
codePoint
<
=
0x7F
)
?
1
:
(
codePoint
<
=
0x7FF
)
?
2
:
(
codePoint
<
=
0xFFFF
)
?
3
:
4
;
const
utf16Len
=
(
codePoint
<
=
0xFFFF
)
?
1
:
2
;
utf8Index
+
=
utf8Len
;
utf16Index
+
=
utf16Len
;
}
segments
.
push
(
this
.
#
text
.
slice
(
oldUtf16Index
utf16Index
)
)
;
}
}
this
.
#
displayFn
(
segments
.
join
(
'
<
span
class
=
"
seg
-
delim
"
>
.
<
/
span
>
'
)
)
;
}
}
export
function
setup
(
dataProvider
:
ICU4XDataProvider
)
:
void
{
const
segmentedText
=
document
.
getElementById
(
'
seg
-
segmented
'
)
as
HTMLParagraphElement
;
const
segmenterDemo
=
new
SegmenterDemo
(
(
formatted
)
=
>
{
/
/
Use
innerHTML
because
we
have
actual
HTML
we
want
to
display
segmentedText
.
innerHTML
=
formatted
;
}
dataProvider
)
;
for
(
let
btn
of
document
.
querySelectorAll
<
HTMLInputElement
|
null
>
(
'
input
[
name
=
"
segmenter
-
model
"
]
'
)
)
{
btn
?
.
addEventListener
(
'
click
'
(
)
=
>
segmenterDemo
.
setModel
(
btn
.
value
)
)
;
}
const
inputText
=
document
.
getElementById
(
'
seg
-
input
'
)
as
HTMLTextAreaElement
|
null
;
inputText
?
.
addEventListener
(
'
input
'
(
)
=
>
segmenterDemo
.
setText
(
inputText
.
value
)
)
;
const
japaneseSamples
=
[
"
"
"
"
"
"
"
"
"
"
]
;
const
sampleJapaneseBtn
=
document
.
getElementById
(
'
seg
-
sample
-
japanese
'
)
as
HTMLButtonElement
|
null
;
sampleJapaneseBtn
?
.
addEventListener
(
'
click
'
(
)
=
>
{
inputText
.
value
=
japaneseSamples
[
Math
.
floor
(
Math
.
random
(
)
*
japaneseSamples
.
length
)
]
;
segmenterDemo
.
setText
(
inputText
.
value
)
;
}
)
;
const
chineseSamples
=
[
"
"
"
"
"
"
"
"
"
"
]
;
const
sampleChineseBtn
=
document
.
getElementById
(
'
seg
-
sample
-
chinese
'
)
as
HTMLButtonElement
|
null
;
sampleChineseBtn
?
.
addEventListener
(
'
click
'
(
)
=
>
{
inputText
.
value
=
chineseSamples
[
Math
.
floor
(
Math
.
random
(
)
*
chineseSamples
.
length
)
]
;
segmenterDemo
.
setText
(
inputText
.
value
)
;
}
)
;
const
thaiSamples
=
[
"
"
"
[
]
"
"
"
]
;
const
sampleThaiBtn
=
document
.
getElementById
(
'
seg
-
sample
-
thai
'
)
as
HTMLButtonElement
|
null
;
sampleThaiBtn
?
.
addEventListener
(
'
click
'
(
)
=
>
{
inputText
.
value
=
thaiSamples
[
Math
.
floor
(
Math
.
random
(
)
*
thaiSamples
.
length
)
]
;
segmenterDemo
.
setText
(
inputText
.
value
)
;
}
)
;
}
