/
/
generated
#
[
doc
=
"
Implement
DataProvider
<
SegmenterDictionaryExtendedV1
>
on
the
given
struct
using
the
data
\
n
hardcoded
in
this
file
.
This
allows
the
struct
to
be
used
with
\
n
icu
'
s
_unstable
constructors
.
\
n
\
n
Using
this
implementation
will
embed
the
following
data
in
the
binary
'
s
data
segment
:
\
n
*
79B
for
the
lookup
data
structure
(
4
data
identifiers
)
\
n
*
26B
[
^
1
]
for
the
actual
data
(
1
unique
structs
)
\
n
\
n
[
^
1
]
:
these
numbers
can
be
smaller
in
practice
due
to
linker
deduplication
"
]
#
[
doc
(
hidden
)
]
#
[
macro_export
]
macro_rules
!
__impl_segmenter_dictionary_extended_v1
{
(
provider
:
ty
)
=
>
{
#
[
clippy
:
:
msrv
=
"
1
.
82
"
]
const
_
:
(
)
=
<
provider
>
:
:
MUST_USE_MAKE_PROVIDER_MACRO
;
#
[
clippy
:
:
msrv
=
"
1
.
82
"
]
impl
provider
{
const
DATA_SEGMENTER_DICTIONARY_EXTENDED_V1
:
icu_provider
:
:
baked
:
:
zerotrie
:
:
Data
<
icu
:
:
segmenter
:
:
provider
:
:
SegmenterDictionaryExtendedV1
>
=
{
const
TRIE
:
icu_provider
:
:
baked
:
:
zerotrie
:
:
ZeroTrieSimpleAscii
<
&
'
static
[
u8
]
>
=
icu_provider
:
:
baked
:
:
zerotrie
:
:
ZeroTrieSimpleAscii
{
store
:
b
"
und
\
x1E
\
xC4bklt
\
x0B
\
x14
\
x1Burmesedict
\
x80hmerdict
\
x80aodict
\
x80haidict
\
x80
"
}
;
const
VALUES
:
&
'
static
[
<
icu
:
:
segmenter
:
:
provider
:
:
SegmenterDictionaryExtendedV1
as
icu_provider
:
:
baked
:
:
zerotrie
:
:
DynamicDataMarker
>
:
:
DataStruct
]
=
&
[
icu
:
:
segmenter
:
:
provider
:
:
UCharDictionaryBreakData
{
trie_data
:
unsafe
{
zerovec
:
:
ZeroVec
:
:
from_bytes_unchecked
(
b
"
\
0
\
0
"
)
}
}
]
;
unsafe
{
icu_provider
:
:
baked
:
:
zerotrie
:
:
Data
:
:
from_trie_and_values_unchecked
(
TRIE
VALUES
)
}
}
;
}
#
[
clippy
:
:
msrv
=
"
1
.
82
"
]
impl
icu_provider
:
:
DataProvider
<
icu
:
:
segmenter
:
:
provider
:
:
SegmenterDictionaryExtendedV1
>
for
provider
{
fn
load
(
&
self
req
:
icu_provider
:
:
DataRequest
)
-
>
Result
<
icu_provider
:
:
DataResponse
<
icu
:
:
segmenter
:
:
provider
:
:
SegmenterDictionaryExtendedV1
>
icu_provider
:
:
DataError
>
{
let
metadata
=
icu_provider
:
:
DataResponseMetadata
:
:
default
(
)
;
let
Some
(
payload
)
=
icu_provider
:
:
baked
:
:
DataStore
:
:
get
(
&
Self
:
:
DATA_SEGMENTER_DICTIONARY_EXTENDED_V1
req
.
id
req
.
metadata
.
attributes_prefix_match
)
else
{
return
Err
(
icu_provider
:
:
DataErrorKind
:
:
IdentifierNotFound
.
with_req
(
<
icu
:
:
segmenter
:
:
provider
:
:
SegmenterDictionaryExtendedV1
as
icu_provider
:
:
DataMarker
>
:
:
INFO
req
)
)
}
;
Ok
(
icu_provider
:
:
DataResponse
{
payload
metadata
}
)
}
}
}
;
(
provider
:
ty
ITER
)
=
>
{
__impl_segmenter_dictionary_extended_v1
!
(
provider
)
;
#
[
clippy
:
:
msrv
=
"
1
.
82
"
]
impl
icu_provider
:
:
IterableDataProvider
<
icu
:
:
segmenter
:
:
provider
:
:
SegmenterDictionaryExtendedV1
>
for
provider
{
fn
iter_ids
(
&
self
)
-
>
Result
<
std
:
:
collections
:
:
BTreeSet
<
icu_provider
:
:
DataIdentifierCow
<
'
static
>
>
icu_provider
:
:
DataError
>
{
Ok
(
icu_provider
:
:
baked
:
:
DataStore
:
:
iter
(
&
Self
:
:
DATA_SEGMENTER_DICTIONARY_EXTENDED_V1
)
.
collect
(
)
)
}
}
}
;
(
provider
:
ty
DRY
)
=
>
{
}
;
(
provider
:
ty
DRY
ITER
)
=
>
{
__impl_segmenter_dictionary_extended_v1
!
(
provider
ITER
)
;
}
;
}
#
[
doc
(
inline
)
]
pub
use
__impl_segmenter_dictionary_extended_v1
as
impl_segmenter_dictionary_extended_v1
;
