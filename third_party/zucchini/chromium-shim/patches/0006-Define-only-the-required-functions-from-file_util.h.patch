Define
only
the
required
functions
from
file_util
.
h
We
only
need
DeleteFile
and
FILEToFile
as
a
cross
-
platform
requirement
.
On
POSIX
platforms
we
also
need
AllocateFileRegion
OpenFile
and
ReadFileToString
.
-
-
-
base
/
files
/
file_util
.
cc
|
12
+
+
+
+
+
+
+
+
+
base
/
files
/
file_util_posix
.
cc
|
26
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
-
base
/
files
/
file_util_win
.
cc
|
23
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
3
files
changed
60
insertions
(
+
)
1
deletion
(
-
)
diff
-
-
git
a
/
base
/
files
/
file_util
.
cc
b
/
base
/
files
/
file_util
.
cc
index
48288660236d
.
.
0dfb561d585b
100644
-
-
-
a
/
base
/
files
/
file_util
.
cc
+
+
+
b
/
base
/
files
/
file_util
.
cc
-
4
7
+
4
9
#
include
"
base
/
files
/
file_util
.
h
"
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
#
include
"
base
/
task
/
sequenced_task_runner
.
h
"
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
#
include
"
build
/
build_config
.
h
"
#
if
BUILDFLAG
(
IS_WIN
)
-
18
6
+
20
7
#
include
<
utility
>
#
include
<
vector
>
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
#
include
"
base
/
bit_cast
.
h
"
#
include
"
base
/
check_op
.
h
"
#
include
"
base
/
containers
/
span
.
h
"
-
31
6
+
34
7
#
include
"
base
/
strings
/
stringprintf
.
h
"
#
include
"
base
/
strings
/
utf_string_conversions
.
h
"
#
include
"
base
/
task
/
bind_post_task
.
h
"
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
#
include
"
base
/
threading
/
scoped_blocking_call
.
h
"
#
if
BUILDFLAG
(
IS_WIN
)
-
41
6
+
45
7
namespace
base
{
namespace
{
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
#
if
!
BUILDFLAG
(
IS_WIN
)
void
RunAndReply
(
OnceCallback
<
bool
(
)
>
action_callback
-
51
6
+
56
7
void
RunAndReply
(
OnceCallback
<
bool
(
)
>
action_callback
}
#
endif
/
/
!
BUILDFLAG
(
IS_WIN
)
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
bool
ReadStreamToSpanWithMaxSize
(
FILE
*
stream
-
134
6
+
140
7
bool
ReadStreamToSpanWithMaxSize
(
}
/
/
namespace
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
#
if
!
BUILDFLAG
(
IS_WIN
)
OnceClosure
GetDeleteFileCallback
(
const
FilePath
&
path
-
301
6
+
308
7
bool
ReadStreamToString
(
FILE
*
stream
std
:
:
string
*
contents
)
{
return
ReadStreamToStringWithMaxSize
(
stream
std
:
:
numeric_limits
<
size_t
>
:
:
max
(
)
contents
)
;
}
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
bool
ReadStreamToStringWithMaxSize
(
FILE
*
stream
size_t
max_size
-
322
6
+
330
7
bool
ReadStreamToStringWithMaxSize
(
FILE
*
stream
return
read_successs
;
}
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
absl
:
:
optional
<
std
:
:
vector
<
uint8_t
>
>
ReadFileToBytes
(
const
FilePath
&
path
)
{
if
(
path
.
ReferencesParent
(
)
)
{
return
absl
:
:
nullopt
;
-
343
6
+
352
7
absl
:
:
optional
<
std
:
:
vector
<
uint8_t
>
>
ReadFileToBytes
(
const
FilePath
&
path
)
{
}
return
bytes
;
}
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
bool
ReadFileToString
(
const
FilePath
&
path
std
:
:
string
*
contents
)
{
return
ReadFileToStringWithMaxSize
(
path
contents
-
362
6
+
372
7
bool
ReadFileToStringWithMaxSize
(
const
FilePath
&
path
return
ReadStreamToStringWithMaxSize
(
file_stream
.
get
(
)
max_size
contents
)
;
}
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
bool
IsDirectoryEmpty
(
const
FilePath
&
dir_path
)
{
FileEnumerator
files
(
dir_path
false
FileEnumerator
:
:
FILES
|
FileEnumerator
:
:
DIRECTORIES
)
;
-
513
5
+
524
6
bool
PreReadFileSlow
(
const
FilePath
&
file_path
int64_t
max_bytes
)
{
}
}
/
/
namespace
internal
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
}
/
/
namespace
base
diff
-
-
git
a
/
base
/
files
/
file_util_posix
.
cc
b
/
base
/
files
/
file_util_posix
.
cc
index
da04b251ce91
.
.
2ea134235574
100644
-
-
-
a
/
base
/
files
/
file_util_posix
.
cc
+
+
+
b
/
base
/
files
/
file_util_posix
.
cc
-
20
9
+
20
12
#
include
<
time
.
h
>
#
include
<
unistd
.
h
>
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
#
include
"
base
/
base_export
.
h
"
#
include
"
base
/
base_switches
.
h
"
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
#
include
"
base
/
bits
.
h
"
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
#
include
"
base
/
command_line
.
h
"
#
include
"
base
/
containers
/
adapters
.
h
"
#
include
"
base
/
containers
/
contains
.
h
"
-
31
9
+
34
13
#
include
"
base
/
files
/
file_enumerator
.
h
"
#
include
"
base
/
files
/
file_path
.
h
"
#
include
"
base
/
files
/
scoped_file
.
h
"
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
#
include
"
base
/
logging
.
h
"
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
#
include
"
base
/
memory
/
singleton
.
h
"
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
#
include
"
base
/
notreached
.
h
"
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
#
include
"
base
/
numerics
/
safe_conversions
.
h
"
#
include
"
base
/
path_service
.
h
"
#
include
"
base
/
posix
/
eintr_wrapper
.
h
"
-
44
9
+
51
12
#
include
"
base
/
strings
/
sys_string_conversions
.
h
"
#
include
"
base
/
strings
/
utf_string_conversions
.
h
"
#
include
"
base
/
system
/
sys_info
.
h
"
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
#
include
"
base
/
threading
/
scoped_blocking_call
.
h
"
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
#
include
"
base
/
time
/
time
.
h
"
#
include
"
build
/
branding_buildflags
.
h
"
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
#
include
"
build
/
build_config
.
h
"
#
if
BUILDFLAG
(
IS_APPLE
)
-
77
6
+
87
7
namespace
base
{
namespace
{
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
#
if
BUILDFLAG
(
IS_MAC
)
/
/
Helper
for
VerifyPathControlledByUser
.
bool
VerifySpecificPathControlledByUser
(
const
FilePath
&
path
-
271
6
+
282
7
bool
DoCopyDirectory
(
const
FilePath
&
from_path
return
true
;
}
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
/
/
TODO
(
erikkay
)
:
The
Windows
version
of
this
accepts
paths
like
"
foo
/
bar
/
*
"
/
/
which
works
both
with
and
without
the
recursive
flag
.
I
'
m
not
sure
we
need
-
295
6
+
307
10
bool
DoDeleteFile
(
const
FilePath
&
path
bool
recursive
)
{
if
(
!
recursive
)
return
(
rmdir
(
path_str
)
=
=
0
)
|
|
(
errno
=
=
ENOENT
)
;
+
#
if
defined
(
MOZ_ZUCCHINI
)
+
NOTREACHED
(
)
;
+
return
false
;
+
#
else
bool
success
=
true
;
stack
<
std
:
:
string
>
directories
;
directories
.
push
(
path
.
value
(
)
)
;
-
315
6
+
331
7
bool
DoDeleteFile
(
const
FilePath
&
path
bool
recursive
)
{
success
&
=
(
rmdir
(
dir
.
value
(
)
.
c_str
(
)
)
=
=
0
)
|
|
(
errno
=
=
ENOENT
)
;
}
return
success
;
+
#
endif
/
/
defined
(
MOZ_ZUCCHINI
)
}
#
if
!
BUILDFLAG
(
IS_APPLE
)
-
332
6
+
349
7
std
:
:
string
AppendModeCharacter
(
StringPiece
mode
char
mode_char
)
{
}
/
/
namespace
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
FilePath
MakeAbsoluteFilePath
(
const
FilePath
&
input
)
{
ScopedBlockingCall
scoped_blocking_call
(
FROM_HERE
BlockingType
:
:
MAY_BLOCK
)
;
char
full_path
[
PATH_MAX
]
;
-
378
11
+
396
13
absl
:
:
optional
<
FilePath
>
MakeAbsoluteFilePathNoResolveSymbolicLinks
(
return
collapsed_path
;
}
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
bool
DeleteFile
(
const
FilePath
&
path
)
{
return
DoDeleteFile
(
path
/
*
recursive
=
*
/
false
)
;
}
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
bool
DeletePathRecursively
(
const
FilePath
&
path
)
{
return
DoDeleteFile
(
path
/
*
recursive
=
*
/
true
)
;
}
-
861
6
+
881
7
bool
GetFileInfo
(
const
FilePath
&
file_path
File
:
:
Info
*
results
)
{
results
-
>
FromStat
(
file_info
)
;
return
true
;
}
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
FILE
*
OpenFile
(
const
FilePath
&
filename
const
char
*
mode
)
{
/
/
'
e
'
is
unconditionally
added
below
so
be
sure
there
is
not
one
already
-
912
6
+
933
7
File
FILEToFile
(
FILE
*
file_stream
)
{
}
#
endif
/
/
!
BUILDFLAG
(
IS_NACL
)
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
int
ReadFile
(
const
FilePath
&
filename
char
*
data
int
max_size
)
{
ScopedBlockingCall
scoped_blocking_call
(
FROM_HERE
BlockingType
:
:
MAY_BLOCK
)
;
if
(
max_size
<
0
)
-
962
6
+
984
7
bool
WriteFileDescriptor
(
int
fd
span
<
const
uint8_t
>
data
)
{
bool
WriteFileDescriptor
(
int
fd
StringPiece
data
)
{
return
WriteFileDescriptor
(
fd
as_bytes
(
make_span
(
data
)
)
)
;
}
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
bool
AllocateFileRegion
(
File
*
file
int64_t
offset
size_t
size
)
{
DCHECK
(
file
)
;
-
1042
6
+
1065
7
bool
AllocateFileRegion
(
File
*
file
int64_t
offset
size_t
size
)
{
return
true
;
}
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
bool
AppendToFile
(
const
FilePath
&
filename
span
<
const
uint8_t
>
data
)
{
ScopedBlockingCall
scoped_blocking_call
(
FROM_HERE
BlockingType
:
:
MAY_BLOCK
)
;
bool
ret
=
true
;
-
1362
5
+
1386
5
BASE_EXPORT
bool
IsPathExecutable
(
const
FilePath
&
path
)
{
return
result
;
}
#
endif
/
/
BUILDFLAG
(
IS_LINUX
)
|
|
BUILDFLAG
(
IS_CHROMEOS
)
|
|
BUILDFLAG
(
IS_AIX
)
-
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
}
/
/
namespace
base
diff
-
-
git
a
/
base
/
files
/
file_util_win
.
cc
b
/
base
/
files
/
file_util_win
.
cc
index
d7b5fb20aeb3
.
.
fbcd25a755c2
100644
-
-
-
a
/
base
/
files
/
file_util_win
.
cc
+
+
+
b
/
base
/
files
/
file_util_win
.
cc
-
21
13
+
21
16
#
include
<
utility
>
#
include
<
vector
>
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
#
include
"
base
/
check
.
h
"
#
include
"
base
/
clang_profiling_buildflags
.
h
"
#
include
"
base
/
debug
/
alias
.
h
"
#
include
"
base
/
feature_list
.
h
"
#
include
"
base
/
features
.
h
"
#
include
"
base
/
files
/
file_enumerator
.
h
"
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
#
include
"
base
/
files
/
file_path
.
h
"
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
#
include
"
base
/
files
/
memory_mapped_file
.
h
"
#
include
"
base
/
functional
/
bind
.
h
"
#
include
"
base
/
functional
/
callback
.
h
"
-
46
7
+
49
9
#
include
"
base
/
task
/
bind_post_task
.
h
"
#
include
"
base
/
task
/
sequenced_task_runner
.
h
"
#
include
"
base
/
task
/
thread_pool
.
h
"
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
#
include
"
base
/
threading
/
scoped_blocking_call
.
h
"
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
#
include
"
base
/
threading
/
scoped_thread_priority
.
h
"
#
include
"
base
/
time
/
time
.
h
"
#
include
"
base
/
uuid
.
h
"
-
55
16
+
60
19
#
include
"
base
/
win
/
sid
.
h
"
#
include
"
base
/
win
/
windows_types
.
h
"
#
include
"
base
/
win
/
windows_version
.
h
"
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
namespace
base
{
namespace
{
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
int
g_extra_allowed_path_for_no_execute
=
0
;
const
DWORD
kFileShareAll
=
FILE_SHARE_READ
|
FILE_SHARE_WRITE
|
FILE_SHARE_DELETE
;
const
wchar_t
kDefaultTempDirPrefix
[
]
=
L
"
ChromiumTemp
"
;
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
/
/
Returns
the
Win32
last
error
code
or
ERROR_SUCCESS
if
the
last
error
code
is
/
/
ERROR_FILE_NOT_FOUND
or
ERROR_PATH_NOT_FOUND
.
This
is
useful
in
cases
where
-
78
6
+
86
7
DWORD
ReturnLastErrorOrSuccessOnNotFound
(
)
{
:
error_code
;
}
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
/
/
Deletes
all
files
and
directories
in
a
path
.
/
/
Returns
ERROR_SUCCESS
on
success
or
the
Windows
error
code
corresponding
to
/
/
the
first
error
encountered
.
ERROR_FILE_NOT_FOUND
and
ERROR_PATH_NOT_FOUND
-
254
6
+
263
7
bool
DoCopyDirectory
(
const
FilePath
&
from_path
return
success
;
}
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
/
/
Returns
ERROR_SUCCESS
on
success
or
a
Windows
error
code
on
failure
.
DWORD
DoDeleteFile
(
const
FilePath
&
path
bool
recursive
)
{
-
265
6
+
275
7
DWORD
DoDeleteFile
(
const
FilePath
&
path
bool
recursive
)
{
if
(
path
.
value
(
)
.
length
(
)
>
=
MAX_PATH
)
return
ERROR_BAD_PATHNAME
;
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
/
/
Handle
any
path
with
wildcards
.
if
(
path
.
BaseName
(
)
.
value
(
)
.
find_first_of
(
FILE_PATH_LITERAL
(
"
*
?
"
)
)
!
=
FilePath
:
:
StringType
:
:
npos
)
{
-
274
6
+
285
7
DWORD
DoDeleteFile
(
const
FilePath
&
path
bool
recursive
)
{
DCHECK_NE
(
static_cast
<
LONG
>
(
error_code
)
ERROR_PATH_NOT_FOUND
)
;
return
error_code
;
}
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
/
/
Report
success
if
the
file
or
path
does
not
exist
.
const
DWORD
attr
=
:
:
GetFileAttributes
(
path
.
value
(
)
.
c_str
(
)
)
;
-
295
6
+
307
7
DWORD
DoDeleteFile
(
const
FilePath
&
path
bool
recursive
)
{
:
ReturnLastErrorOrSuccessOnNotFound
(
)
;
}
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
if
(
recursive
)
{
const
DWORD
error_code
=
DeleteFileRecursive
(
path
FILE_PATH_LITERAL
(
"
*
"
)
true
)
;
-
303
6
+
316
7
DWORD
DoDeleteFile
(
const
FilePath
&
path
bool
recursive
)
{
if
(
error_code
!
=
ERROR_SUCCESS
)
return
error_code
;
}
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
return
:
:
RemoveDirectory
(
path
.
value
(
)
.
c_str
(
)
)
?
ERROR_SUCCESS
:
ReturnLastErrorOrSuccessOnNotFound
(
)
;
-
320
6
+
334
7
bool
DeleteFileOrSetLastError
(
const
FilePath
&
path
bool
recursive
)
{
return
false
;
}
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
constexpr
int
kMaxDeleteAttempts
=
9
;
void
DeleteFileWithRetry
(
const
FilePath
&
path
-
422
9
+
437
11
bool
IsPathSafeToSetAclOn
(
const
FilePath
&
path
)
{
return
false
;
}
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
}
/
/
namespace
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
OnceClosure
GetDeleteFileCallback
(
const
FilePath
&
path
OnceCallback
<
void
(
bool
)
>
reply_callback
)
{
return
GetDeleteFileCallbackInternal
(
path
/
*
recursive
=
*
/
false
-
445
11
+
462
13
FilePath
MakeAbsoluteFilePath
(
const
FilePath
&
input
)
{
return
FilePath
(
)
;
return
FilePath
(
file_path
)
;
}
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
bool
DeleteFile
(
const
FilePath
&
path
)
{
return
DeleteFileOrSetLastError
(
path
/
*
recursive
=
*
/
false
)
;
}
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
bool
DeletePathRecursively
(
const
FilePath
&
path
)
{
return
DeleteFileOrSetLastError
(
path
/
*
recursive
=
*
/
true
)
;
}
-
948
6
+
967
7
FILE
*
FileToFILE
(
File
file
const
char
*
mode
)
{
_close
(
fd
)
;
return
stream
;
}
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
File
FILEToFile
(
FILE
*
file_stream
)
{
if
(
!
file_stream
)
-
972
6
+
992
7
File
FILEToFile
(
FILE
*
file_stream
)
{
return
File
(
ScopedPlatformFile
(
other_handle
)
)
;
}
+
#
if
!
defined
(
MOZ_ZUCCHINI
)
int
ReadFile
(
const
FilePath
&
filename
char
*
data
int
max_size
)
{
ScopedBlockingCall
scoped_blocking_call
(
FROM_HERE
BlockingType
:
:
MAY_BLOCK
)
;
win
:
:
ScopedHandle
file
(
CreateFile
(
filename
.
value
(
)
.
c_str
(
)
GENERIC_READ
-
1257
4
+
1278
6
bool
CopyAndDeleteDirectory
(
const
FilePath
&
from_path
}
}
/
/
namespace
internal
+
#
endif
/
/
!
defined
(
MOZ_ZUCCHINI
)
+
}
/
/
namespace
base
-
-
2
.
42
.
0
.
windows
.
2
