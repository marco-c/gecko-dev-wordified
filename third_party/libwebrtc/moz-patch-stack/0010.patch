From
:
Dan
Minor
<
dminor
mozilla
.
com
>
Date
:
Tue
31
Jul
2018
13
:
32
:
00
-
0400
Subject
:
Bug
1376873
-
OS
X
desktop
capture
fixes
;
r
=
pehrsons
Differential
Revision
:
https
:
/
/
phabricator
.
services
.
mozilla
.
com
/
D7464
Mercurial
Revision
:
https
:
/
/
hg
.
mozilla
.
org
/
mozilla
-
central
/
rev
/
02c038eca65c1218b56fdf8937fdeab3d8767fe6
-
-
-
.
.
.
/
desktop_capture
/
mac
/
screen_capturer_mac
.
h
|
14
+
-
.
.
.
/
mac
/
screen_capturer_mac
.
mm
|
150
+
+
+
+
+
+
+
+
+
+
+
-
-
-
-
-
-
-
.
.
.
/
mouse_cursor_monitor_mac
.
mm
|
46
+
+
+
-
-
-
3
files
changed
127
insertions
(
+
)
83
deletions
(
-
)
diff
-
-
git
a
/
modules
/
desktop_capture
/
mac
/
screen_capturer_mac
.
h
b
/
modules
/
desktop_capture
/
mac
/
screen_capturer_mac
.
h
index
7e38b5bd08
.
.
7be05cc639
100644
-
-
-
a
/
modules
/
desktop_capture
/
mac
/
screen_capturer_mac
.
h
+
+
+
b
/
modules
/
desktop_capture
/
mac
/
screen_capturer_mac
.
h
-
36
9
+
36
10
class
DisplayStreamManager
;
/
/
A
class
to
perform
video
frame
capturing
for
mac
.
class
ScreenCapturerMac
final
:
public
DesktopCapturer
{
public
:
-
ScreenCapturerMac
(
rtc
:
:
scoped_refptr
<
DesktopConfigurationMonitor
>
desktop_config_monitor
-
bool
detect_updated_region
-
bool
allow_iosurface
)
;
+
ScreenCapturerMac
(
+
rtc
:
:
scoped_refptr
<
DesktopConfigurationMonitor
>
desktop_config_monitor
+
bool
detect_updated_region
+
bool
allow_iosurface
)
;
~
ScreenCapturerMac
(
)
override
;
ScreenCapturerMac
(
const
ScreenCapturerMac
&
)
=
delete
;
-
113
6
+
114
13
class
ScreenCapturerMac
final
:
public
DesktopCapturer
{
/
/
Start
CaptureFrame
and
destructor
have
to
called
in
the
same
thread
.
SequenceChecker
thread_checker_
;
+
+
/
/
Used
to
force
CaptureFrame
to
update
it
'
s
screen
configuration
+
/
/
and
reregister
event
handlers
.
This
ensure
that
this
+
/
/
occurs
on
the
ScreenCapture
thread
.
Read
and
written
from
+
/
/
both
the
VideoCapture
thread
and
ScreenCapture
thread
.
+
/
/
Protected
by
desktop_config_monitor_
.
+
bool
update_screen_configuration_
=
false
;
}
;
}
/
/
namespace
webrtc
diff
-
-
git
a
/
modules
/
desktop_capture
/
mac
/
screen_capturer_mac
.
mm
b
/
modules
/
desktop_capture
/
mac
/
screen_capturer_mac
.
mm
index
d4e9c111db
.
.
21a9c1ca4a
100644
-
-
-
a
/
modules
/
desktop_capture
/
mac
/
screen_capturer_mac
.
mm
+
+
+
b
/
modules
/
desktop_capture
/
mac
/
screen_capturer_mac
.
mm
-
26
10
+
26
11
namespace
{
/
/
Scales
all
coordinates
of
a
rect
by
a
specified
factor
.
DesktopRect
ScaleAndRoundCGRect
(
const
CGRect
&
rect
float
scale
)
{
-
return
DesktopRect
:
:
MakeLTRB
(
static_cast
<
int
>
(
floor
(
rect
.
origin
.
x
*
scale
)
)
-
static_cast
<
int
>
(
floor
(
rect
.
origin
.
y
*
scale
)
)
-
static_cast
<
int
>
(
ceil
(
(
rect
.
origin
.
x
+
rect
.
size
.
width
)
*
scale
)
)
-
static_cast
<
int
>
(
ceil
(
(
rect
.
origin
.
y
+
rect
.
size
.
height
)
*
scale
)
)
)
;
+
return
DesktopRect
:
:
MakeLTRB
(
+
static_cast
<
int
>
(
floor
(
rect
.
origin
.
x
*
scale
)
)
+
static_cast
<
int
>
(
floor
(
rect
.
origin
.
y
*
scale
)
)
+
static_cast
<
int
>
(
ceil
(
(
rect
.
origin
.
x
+
rect
.
size
.
width
)
*
scale
)
)
+
static_cast
<
int
>
(
ceil
(
(
rect
.
origin
.
y
+
rect
.
size
.
height
)
*
scale
)
)
)
;
}
/
/
Copy
pixels
in
the
rect
from
src_place
to
dest_plane
.
rect
should
be
-
63
8
+
64
8
void
CopyRect
(
const
uint8_t
*
src_plane
CFArrayRef
CreateWindowListWithExclusion
(
CGWindowID
window_to_exclude
)
{
if
(
!
window_to_exclude
)
return
nullptr
;
-
CFArrayRef
all_windows
=
-
CGWindowListCopyWindowInfo
(
kCGWindowListOptionOnScreenOnly
kCGNullWindowID
)
;
+
CFArrayRef
all_windows
=
CGWindowListCopyWindowInfo
(
+
kCGWindowListOptionOnScreenOnly
kCGNullWindowID
)
;
if
(
!
all_windows
)
return
nullptr
;
CFMutableArrayRef
returned_array
=
-
72
8
+
73
8
CFArrayRef
CreateWindowListWithExclusion
(
CGWindowID
window_to_exclude
)
{
bool
found
=
false
;
for
(
CFIndex
i
=
0
;
i
<
CFArrayGetCount
(
all_windows
)
;
+
+
i
)
{
-
CFDictionaryRef
window
=
-
reinterpret_cast
<
CFDictionaryRef
>
(
CFArrayGetValueAtIndex
(
all_windows
i
)
)
;
+
CFDictionaryRef
window
=
reinterpret_cast
<
CFDictionaryRef
>
(
+
CFArrayGetValueAtIndex
(
all_windows
i
)
)
;
CGWindowID
id
=
GetWindowId
(
window
)
;
if
(
id
=
=
window_to_exclude
)
{
-
93
7
+
94
8
CFArrayRef
CreateWindowListWithExclusion
(
CGWindowID
window_to_exclude
)
{
/
/
Returns
the
bounds
of
window
in
physical
pixels
enlarged
by
a
small
amount
/
/
on
four
edges
to
take
account
of
the
border
/
shadow
effects
.
-
DesktopRect
GetExcludedWindowPixelBounds
(
CGWindowID
window
float
dip_to_pixel_scale
)
{
+
DesktopRect
GetExcludedWindowPixelBounds
(
CGWindowID
window
+
float
dip_to_pixel_scale
)
{
/
/
The
amount
of
pixels
to
add
to
the
actual
window
bounds
to
take
into
/
/
account
of
the
border
/
shadow
effects
.
static
const
int
kBorderEffectSize
=
20
;
-
103
13
+
105
14
DesktopRect
GetExcludedWindowPixelBounds
(
CGWindowID
window
float
dip_to_pixel_s
CFArrayRef
window_id_array
=
CFArrayCreate
(
nullptr
reinterpret_cast
<
const
void
*
*
>
(
&
ids
)
1
nullptr
)
;
-
CFArrayRef
window_array
=
CGWindowListCreateDescriptionFromArray
(
window_id_array
)
;
+
CFArrayRef
window_array
=
+
CGWindowListCreateDescriptionFromArray
(
window_id_array
)
;
if
(
CFArrayGetCount
(
window_array
)
>
0
)
{
-
CFDictionaryRef
win
=
-
reinterpret_cast
<
CFDictionaryRef
>
(
CFArrayGetValueAtIndex
(
window_array
0
)
)
;
-
CFDictionaryRef
bounds_ref
=
-
reinterpret_cast
<
CFDictionaryRef
>
(
CFDictionaryGetValue
(
win
kCGWindowBounds
)
)
;
+
CFDictionaryRef
win
=
reinterpret_cast
<
CFDictionaryRef
>
(
+
CFArrayGetValueAtIndex
(
window_array
0
)
)
;
+
CFDictionaryRef
bounds_ref
=
reinterpret_cast
<
CFDictionaryRef
>
(
+
CFDictionaryGetValue
(
win
kCGWindowBounds
)
)
;
CGRectMakeWithDictionaryRepresentation
(
bounds_ref
&
rect
)
;
}
-
127
9
+
130
10
DesktopRect
GetExcludedWindowPixelBounds
(
CGWindowID
window
float
dip_to_pixel_s
/
/
Create
an
image
of
the
given
region
using
the
given
window_list
.
/
/
pixel_bounds
should
be
in
the
primary
display
'
s
coordinate
in
physical
/
/
pixels
.
-
rtc
:
:
ScopedCFTypeRef
<
CGImageRef
>
CreateExcludedWindowRegionImage
(
const
DesktopRect
&
pixel_bounds
-
float
dip_to_pixel_scale
-
CFArrayRef
window_list
)
{
+
rtc
:
:
ScopedCFTypeRef
<
CGImageRef
>
CreateExcludedWindowRegionImage
(
+
const
DesktopRect
&
pixel_bounds
+
float
dip_to_pixel_scale
+
CFArrayRef
window_list
)
{
CGRect
window_bounds
;
/
/
The
origin
is
in
DIP
while
the
size
is
in
physical
pixels
.
That
'
s
what
/
/
CGWindowListCreateImageFromArray
expects
.
-
138
8
+
142
8
rtc
:
:
ScopedCFTypeRef
<
CGImageRef
>
CreateExcludedWindowRegionImage
(
const
DesktopRe
window_bounds
.
size
.
width
=
pixel_bounds
.
width
(
)
;
window_bounds
.
size
.
height
=
pixel_bounds
.
height
(
)
;
-
return
rtc
:
:
ScopedCFTypeRef
<
CGImageRef
>
(
-
CGWindowListCreateImageFromArray
(
window_bounds
window_list
kCGWindowImageDefault
)
)
;
+
return
rtc
:
:
ScopedCFTypeRef
<
CGImageRef
>
(
CGWindowListCreateImageFromArray
(
+
window_bounds
window_list
kCGWindowImageDefault
)
)
;
}
}
/
/
namespace
-
185
6
+
189
7
void
ScreenCapturerMac
:
:
Start
(
Callback
*
callback
)
{
current_display_
)
;
callback_
=
callback
;
+
update_screen_configuration_
=
false
;
/
/
Start
and
operate
CGDisplayStream
handler
all
from
capture
thread
.
if
(
!
RegisterRefreshAndMoveHandlers
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
register
refresh
and
move
handlers
.
"
;
-
204
8
+
209
10
void
ScreenCapturerMac
:
:
CaptureFrame
(
)
{
RTC_DLOG
(
LS_WARNING
)
<
<
"
Overwriting
frame
that
is
still
shared
.
"
;
}
-
MacDesktopConfiguration
new_config
=
desktop_config_monitor_
-
>
desktop_configuration
(
)
;
-
if
(
!
desktop_config_
.
Equals
(
new_config
)
)
{
+
MacDesktopConfiguration
new_config
=
+
desktop_config_monitor_
-
>
desktop_configuration
(
)
;
+
if
(
update_screen_configuration_
|
|
!
desktop_config_
.
Equals
(
new_config
)
)
{
+
update_screen_configuration_
=
false
;
desktop_config_
=
new_config
;
/
/
If
the
display
configuraiton
has
changed
then
refresh
capturer
data
/
/
structures
.
Occasionally
the
refresh
and
move
handlers
are
lost
when
-
236
7
+
243
8
void
ScreenCapturerMac
:
:
CaptureFrame
(
)
{
/
/
If
the
current
buffer
is
from
an
older
generation
then
allocate
a
new
one
.
/
/
Note
that
we
can
'
t
reallocate
other
buffers
at
this
point
since
the
caller
/
/
may
still
be
reading
from
them
.
-
if
(
!
queue_
.
current_frame
(
)
)
queue_
.
ReplaceCurrentFrame
(
SharedDesktopFrame
:
:
Wrap
(
CreateFrame
(
)
)
)
;
+
if
(
!
queue_
.
current_frame
(
)
)
+
queue_
.
ReplaceCurrentFrame
(
SharedDesktopFrame
:
:
Wrap
(
CreateFrame
(
)
)
)
;
DesktopFrame
*
current_frame
=
queue_
.
current_frame
(
)
;
-
248
15
+
256
16
void
ScreenCapturerMac
:
:
CaptureFrame
(
)
{
if
(
detect_updated_region_
)
{
*
new_frame
-
>
mutable_updated_region
(
)
=
region
;
}
else
{
-
new_frame
-
>
mutable_updated_region
(
)
-
>
AddRect
(
DesktopRect
:
:
MakeSize
(
new_frame
-
>
size
(
)
)
)
;
+
new_frame
-
>
mutable_updated_region
(
)
-
>
AddRect
(
+
DesktopRect
:
:
MakeSize
(
new_frame
-
>
size
(
)
)
)
;
}
if
(
current_display_
)
{
const
MacDisplayConfiguration
*
config
=
desktop_config_
.
FindDisplayConfigurationById
(
current_display_
)
;
if
(
config
)
{
-
new_frame
-
>
set_top_left
(
-
config
-
>
bounds
.
top_left
(
)
.
subtract
(
desktop_config_
.
bounds
.
top_left
(
)
)
)
;
+
new_frame
-
>
set_top_left
(
config
-
>
bounds
.
top_left
(
)
.
subtract
(
+
desktop_config_
.
bounds
.
top_left
(
)
)
)
;
}
}
-
287
7
+
296
8
bool
ScreenCapturerMac
:
:
SelectSource
(
SourceId
id
)
{
current_display_
=
0
;
}
else
{
const
MacDisplayConfiguration
*
config
=
-
desktop_config_
.
FindDisplayConfigurationById
(
static_cast
<
CGDirectDisplayID
>
(
id
)
)
;
+
desktop_config_
.
FindDisplayConfigurationById
(
+
static_cast
<
CGDirectDisplayID
>
(
id
)
)
;
if
(
!
config
)
return
false
;
current_display_
=
config
-
>
id
;
}
-
296
11
+
306
15
bool
ScreenCapturerMac
:
:
SelectSource
(
SourceId
id
)
{
return
true
;
}
-
bool
ScreenCapturerMac
:
:
CgBlit
(
const
DesktopFrame
&
frame
const
DesktopRegion
&
region
)
{
-
/
/
If
not
all
screen
region
is
dirty
copy
the
entire
contents
of
the
previous
capture
buffer
-
/
/
to
capture
over
.
-
if
(
queue_
.
previous_frame
(
)
&
&
!
region
.
Equals
(
DesktopRegion
(
screen_pixel_bounds_
)
)
)
{
-
memcpy
(
frame
.
data
(
)
queue_
.
previous_frame
(
)
-
>
data
(
)
frame
.
stride
(
)
*
frame
.
size
(
)
.
height
(
)
)
;
+
bool
ScreenCapturerMac
:
:
CgBlit
(
const
DesktopFrame
&
frame
+
const
DesktopRegion
&
region
)
{
+
/
/
If
not
all
screen
region
is
dirty
copy
the
entire
contents
of
the
previous
+
/
/
capture
buffer
to
capture
over
.
+
if
(
queue_
.
previous_frame
(
)
&
&
+
!
region
.
Equals
(
DesktopRegion
(
screen_pixel_bounds_
)
)
)
{
+
memcpy
(
frame
.
data
(
)
+
queue_
.
previous_frame
(
)
-
>
data
(
)
+
frame
.
stride
(
)
*
frame
.
size
(
)
.
height
(
)
)
;
}
MacDisplayConfigurations
displays_to_capture
;
-
329
12
+
343
15
bool
ScreenCapturerMac
:
:
CgBlit
(
const
DesktopFrame
&
frame
const
DesktopRegion
&
r
/
/
Capturing
mixed
-
DPI
on
one
surface
is
hard
so
we
only
return
displays
/
/
that
match
the
"
primary
"
display
'
s
DPI
.
The
primary
display
is
always
/
/
the
first
in
the
list
.
-
if
(
i
>
0
&
&
display_config
.
dip_to_pixel_scale
!
=
displays_to_capture
[
0
]
.
dip_to_pixel_scale
)
{
+
if
(
i
>
0
&
&
+
display_config
.
dip_to_pixel_scale
!
=
+
displays_to_capture
[
0
]
.
dip_to_pixel_scale
)
{
continue
;
}
/
/
Determine
the
display
'
s
position
relative
to
the
desktop
in
pixels
.
DesktopRect
display_bounds
=
display_config
.
pixel_bounds
;
-
display_bounds
.
Translate
(
-
screen_pixel_bounds_
.
left
(
)
-
screen_pixel_bounds_
.
top
(
)
)
;
+
display_bounds
.
Translate
(
-
screen_pixel_bounds_
.
left
(
)
+
-
screen_pixel_bounds_
.
top
(
)
)
;
/
/
Determine
which
parts
of
the
blit
region
if
any
lay
within
the
monitor
.
DesktopRegion
copy_region
=
region
;
-
348
15
+
365
17
bool
ScreenCapturerMac
:
:
CgBlit
(
const
DesktopFrame
&
frame
const
DesktopRegion
&
r
rtc
:
:
ScopedCFTypeRef
<
CGImageRef
>
excluded_image
;
if
(
excluded_window_
&
&
window_list
)
{
/
/
Get
the
region
of
the
excluded
window
relative
the
primary
display
.
-
excluded_window_bounds
=
-
GetExcludedWindowPixelBounds
(
excluded_window_
display_config
.
dip_to_pixel_scale
)
;
+
excluded_window_bounds
=
GetExcludedWindowPixelBounds
(
+
excluded_window_
display_config
.
dip_to_pixel_scale
)
;
excluded_window_bounds
.
IntersectWith
(
display_config
.
pixel_bounds
)
;
/
/
Create
the
image
under
the
excluded
window
first
because
it
'
s
faster
/
/
than
captuing
the
whole
display
.
if
(
!
excluded_window_bounds
.
is_empty
(
)
)
{
-
excluded_image
=
CreateExcludedWindowRegionImage
(
-
excluded_window_bounds
display_config
.
dip_to_pixel_scale
window_list
)
;
+
excluded_image
=
+
CreateExcludedWindowRegionImage
(
excluded_window_bounds
+
display_config
.
dip_to_pixel_scale
+
window_list
)
;
}
}
-
370
8
+
389
8
bool
ScreenCapturerMac
:
:
CgBlit
(
const
DesktopFrame
&
frame
const
DesktopRegion
&
r
int
src_bytes_per_row
=
frame_source
-
>
stride
(
)
;
RTC_DCHECK
(
display_base_address
)
;
-
/
/
frame_source
size
may
be
different
from
display_bounds
in
case
the
screen
was
-
/
/
resized
recently
.
+
/
/
frame_source
size
may
be
different
from
display_bounds
in
case
the
+
/
/
screen
was
resized
recently
.
copy_region
.
IntersectWith
(
frame_source
-
>
rect
(
)
)
;
/
/
Copy
the
dirty
region
from
the
display
buffer
into
our
desktop
buffer
.
-
387
7
+
406
8
bool
ScreenCapturerMac
:
:
CgBlit
(
const
DesktopFrame
&
frame
const
DesktopRegion
&
r
if
(
excluded_image
)
{
CGDataProviderRef
provider
=
CGImageGetDataProvider
(
excluded_image
.
get
(
)
)
;
-
rtc
:
:
ScopedCFTypeRef
<
CFDataRef
>
excluded_image_data
(
CGDataProviderCopyData
(
provider
)
)
;
+
rtc
:
:
ScopedCFTypeRef
<
CFDataRef
>
excluded_image_data
(
+
CGDataProviderCopyData
(
provider
)
)
;
RTC_DCHECK
(
excluded_image_data
)
;
display_base_address
=
CFDataGetBytePtr
(
excluded_image_data
.
get
(
)
)
;
src_bytes_per_row
=
CGImageGetBytesPerRow
(
excluded_image
.
get
(
)
)
;
-
398
14
+
418
18
bool
ScreenCapturerMac
:
:
CgBlit
(
const
DesktopFrame
&
frame
const
DesktopRegion
&
r
window_bounds_relative_to_desktop
.
Translate
(
-
screen_pixel_bounds_
.
left
(
)
-
screen_pixel_bounds_
.
top
(
)
)
;
-
DesktopRect
rect_to_copy
=
DesktopRect
:
:
MakeSize
(
excluded_window_bounds
.
size
(
)
)
;
-
rect_to_copy
.
IntersectWith
(
DesktopRect
:
:
MakeWH
(
CGImageGetWidth
(
excluded_image
.
get
(
)
)
-
CGImageGetHeight
(
excluded_image
.
get
(
)
)
)
)
;
+
DesktopRect
rect_to_copy
=
+
DesktopRect
:
:
MakeSize
(
excluded_window_bounds
.
size
(
)
)
;
+
rect_to_copy
.
IntersectWith
(
+
DesktopRect
:
:
MakeWH
(
CGImageGetWidth
(
excluded_image
.
get
(
)
)
+
CGImageGetHeight
(
excluded_image
.
get
(
)
)
)
)
;
-
if
(
CGImageGetBitsPerPixel
(
excluded_image
.
get
(
)
)
/
8
=
=
DesktopFrame
:
:
kBytesPerPixel
)
{
+
if
(
CGImageGetBitsPerPixel
(
excluded_image
.
get
(
)
)
/
8
=
=
+
DesktopFrame
:
:
kBytesPerPixel
)
{
CopyRect
(
display_base_address
src_bytes_per_row
-
frame
.
GetFrameDataAtPos
(
window_bounds_relative_to_desktop
.
top_left
(
)
)
+
frame
.
GetFrameDataAtPos
(
+
window_bounds_relative_to_desktop
.
top_left
(
)
)
frame
.
stride
(
)
DesktopFrame
:
:
kBytesPerPixel
rect_to_copy
)
;
-
454
10
+
478
11
bool
ScreenCapturerMac
:
:
RegisterRefreshAndMoveHandlers
(
)
{
CGDirectDisplayID
display_id
=
config
.
id
;
DesktopVector
display_origin
=
config
.
pixel_bounds
.
top_left
(
)
;
-
CGDisplayStreamFrameAvailableHandler
handler
=
^
(
CGDisplayStreamFrameStatus
status
-
uint64_t
/
*
display_time
*
/
-
IOSurfaceRef
frame_surface
-
CGDisplayStreamUpdateRef
updateRef
)
{
+
CGDisplayStreamFrameAvailableHandler
handler
=
^
(
+
CGDisplayStreamFrameStatus
status
+
uint64_t
/
*
display_time
*
/
+
IOSurfaceRef
frame_surface
+
CGDisplayStreamUpdateRef
updateRef
)
{
RTC_DCHECK
(
thread_checker_
.
IsCurrent
(
)
)
;
if
(
status
=
=
kCGDisplayStreamFrameStatusStopped
)
return
;
-
465
8
+
490
8
bool
ScreenCapturerMac
:
:
RegisterRefreshAndMoveHandlers
(
)
{
if
(
status
!
=
kCGDisplayStreamFrameStatusFrameComplete
)
return
;
size_t
count
=
0
;
-
const
CGRect
*
rects
=
-
CGDisplayStreamUpdateGetRects
(
updateRef
kCGDisplayStreamUpdateDirtyRects
&
count
)
;
+
const
CGRect
*
rects
=
CGDisplayStreamUpdateGetRects
(
+
updateRef
kCGDisplayStreamUpdateDirtyRects
&
count
)
;
if
(
count
!
=
0
)
{
/
/
According
to
CGDisplayStream
.
h
it
'
s
safe
to
call
/
/
CGDisplayStreamStop
(
)
from
within
the
callback
.
-
482
14
+
507
20
bool
ScreenCapturerMac
:
:
RegisterRefreshAndMoveHandlers
(
)
{
&
kCFTypeDictionaryKeyCallBacks
&
kCFTypeDictionaryValueCallBacks
)
)
;
-
CGDisplayStreamRef
display_stream
=
CGDisplayStreamCreate
(
-
display_id
pixel_width
pixel_height
'
BGRA
'
properties_dict
.
get
(
)
handler
)
;
+
CGDisplayStreamRef
display_stream
=
+
CGDisplayStreamCreate
(
display_id
+
pixel_width
+
pixel_height
+
'
BGRA
'
+
properties_dict
.
get
(
)
+
handler
)
;
if
(
display_stream
)
{
CGError
error
=
CGDisplayStreamStart
(
display_stream
)
;
if
(
error
!
=
kCGErrorSuccess
)
return
false
;
-
CFRunLoopSourceRef
source
=
CGDisplayStreamGetRunLoopSource
(
display_stream
)
;
+
CFRunLoopSourceRef
source
=
+
CGDisplayStreamGetRunLoopSource
(
display_stream
)
;
CFRunLoopAddSource
(
CFRunLoopGetCurrent
(
)
source
kCFRunLoopCommonModes
)
;
display_streams_
.
push_back
(
display_stream
)
;
}
-
542
14
+
573
17
void
ScreenCapturerMac
:
:
ScreenRefresh
(
CGDirectDisplayID
display_id
/
/
Always
having
the
latest
iosurface
before
invalidating
a
region
.
/
/
See
https
:
/
/
bugs
.
chromium
.
org
/
p
/
webrtc
/
issues
/
detail
?
id
=
8652
for
details
.
desktop_frame_provider_
.
InvalidateIOSurface
(
-
display_id
rtc
:
:
ScopedCFTypeRef
<
IOSurfaceRef
>
(
io_surface
rtc
:
:
RetainPolicy
:
:
RETAIN
)
)
;
+
display_id
+
rtc
:
:
ScopedCFTypeRef
<
IOSurfaceRef
>
(
io_surface
+
rtc
:
:
RetainPolicy
:
:
RETAIN
)
)
;
helper_
.
InvalidateRegion
(
region
)
;
}
std
:
:
unique_ptr
<
DesktopFrame
>
ScreenCapturerMac
:
:
CreateFrame
(
)
{
-
std
:
:
unique_ptr
<
DesktopFrame
>
frame
(
new
BasicDesktopFrame
(
screen_pixel_bounds_
.
size
(
)
)
)
;
-
frame
-
>
set_dpi
(
-
DesktopVector
(
kStandardDPI
*
dip_to_pixel_scale_
kStandardDPI
*
dip_to_pixel_scale_
)
)
;
+
std
:
:
unique_ptr
<
DesktopFrame
>
frame
(
+
new
BasicDesktopFrame
(
screen_pixel_bounds_
.
size
(
)
)
)
;
+
frame
-
>
set_dpi
(
DesktopVector
(
kStandardDPI
*
dip_to_pixel_scale_
+
kStandardDPI
*
dip_to_pixel_scale_
)
)
;
return
frame
;
}
diff
-
-
git
a
/
modules
/
desktop_capture
/
mouse_cursor_monitor_mac
.
mm
b
/
modules
/
desktop_capture
/
mouse_cursor_monitor_mac
.
mm
index
3db4332cd1
.
.
e86d9210cf
100644
-
-
-
a
/
modules
/
desktop_capture
/
mouse_cursor_monitor_mac
.
mm
+
+
+
b
/
modules
/
desktop_capture
/
mouse_cursor_monitor_mac
.
mm
-
10
7
+
10
6
#
include
"
modules
/
desktop_capture
/
mouse_cursor_monitor
.
h
"
-
#
include
<
memory
>
#
include
<
ApplicationServices
/
ApplicationServices
.
h
>
-
33
13
+
32
14
namespace
{
CGImageRef
CreateScaledCGImage
(
CGImageRef
image
int
width
int
height
)
{
/
/
Create
context
keeping
original
image
properties
.
CGColorSpaceRef
colorspace
=
CGImageGetColorSpace
(
image
)
;
-
CGContextRef
context
=
CGBitmapContextCreate
(
nullptr
-
width
-
height
-
CGImageGetBitsPerComponent
(
image
)
-
width
*
DesktopFrame
:
:
kBytesPerPixel
-
colorspace
-
CGImageGetBitmapInfo
(
image
)
)
;
+
CGContextRef
context
=
+
CGBitmapContextCreate
(
nullptr
+
width
+
height
+
CGImageGetBitsPerComponent
(
image
)
+
width
*
DesktopFrame
:
:
kBytesPerPixel
+
colorspace
+
CGImageGetBitmapInfo
(
image
)
)
;
if
(
!
context
)
return
nil
;
-
66
7
+
66
7
class
MouseCursorMonitorMac
:
public
MouseCursorMonitor
{
private
:
static
void
DisplaysReconfiguredCallback
(
CGDirectDisplayID
display
CGDisplayChangeSummaryFlags
flags
-
void
*
user_parameter
)
;
+
void
*
user_parameter
)
;
void
DisplaysReconfigured
(
CGDirectDisplayID
display
CGDisplayChangeSummaryFlags
flags
)
;
-
80
9
+
80
10
class
MouseCursorMonitorMac
:
public
MouseCursorMonitor
{
__strong
NSImage
*
last_cursor_
=
NULL
;
}
;
-
MouseCursorMonitorMac
:
:
MouseCursorMonitorMac
(
const
DesktopCaptureOptions
&
options
-
CGWindowID
window_id
-
ScreenId
screen_id
)
+
MouseCursorMonitorMac
:
:
MouseCursorMonitorMac
(
+
const
DesktopCaptureOptions
&
options
+
CGWindowID
window_id
+
ScreenId
screen_id
)
:
configuration_monitor_
(
options
.
configuration_monitor
(
)
)
window_id_
(
window_id
)
screen_id_
(
screen_id
)
-
115
8
+
116
7
void
MouseCursorMonitorMac
:
:
Capture
(
)
{
CaptureImage
(
scale
)
;
-
if
(
mode_
!
=
SHAPE_AND_POSITION
)
-
return
;
+
if
(
mode_
!
=
SHAPE_AND_POSITION
)
return
;
/
/
Always
report
cursor
position
in
DIP
pixel
.
callback_
-
>
OnMouseCursorPosition
(
-
133
7
+
133
9
void
MouseCursorMonitorMac
:
:
CaptureImage
(
float
scale
)
{
NSSize
nssize
=
[
nsimage
size
]
;
/
/
DIP
size
/
/
No
need
to
caputre
cursor
image
if
it
'
s
unchanged
since
last
capture
.
-
if
(
[
[
nsimage
TIFFRepresentation
]
isEqual
:
[
last_cursor_
TIFFRepresentation
]
]
)
return
;
+
if
(
last_cursor_
&
&
+
[
[
nsimage
TIFFRepresentation
]
isEqual
:
[
last_cursor_
TIFFRepresentation
]
]
)
+
return
;
last_cursor_
=
nsimage
;
DesktopSize
size
(
round
(
nssize
.
width
*
scale
)
-
144
17
+
146
18
void
MouseCursorMonitorMac
:
:
CaptureImage
(
float
scale
)
{
std
:
:
min
(
size
.
width
(
)
static_cast
<
int
>
(
nshotspot
.
x
*
scale
)
)
)
std
:
:
max
(
0
std
:
:
min
(
size
.
height
(
)
static_cast
<
int
>
(
nshotspot
.
y
*
scale
)
)
)
)
;
-
CGImageRef
cg_image
=
-
[
nsimage
CGImageForProposedRect
:
NULL
context
:
nil
hints
:
nil
]
;
-
if
(
!
cg_image
)
-
return
;
+
CGImageRef
cg_image
=
[
nsimage
CGImageForProposedRect
:
NULL
+
context
:
nil
+
hints
:
nil
]
;
+
if
(
!
cg_image
)
return
;
/
/
Before
10
.
12
OSX
may
report
1X
cursor
on
Retina
screen
.
(
See
/
/
crbug
.
com
/
632995
.
)
After
10
.
12
OSX
may
report
2X
cursor
on
non
-
Retina
/
/
screen
.
(
See
crbug
.
com
/
671436
.
)
So
scaling
the
cursor
if
needed
.
CGImageRef
scaled_cg_image
=
nil
;
if
(
CGImageGetWidth
(
cg_image
)
!
=
static_cast
<
size_t
>
(
size
.
width
(
)
)
)
{
-
scaled_cg_image
=
CreateScaledCGImage
(
cg_image
size
.
width
(
)
size
.
height
(
)
)
;
+
scaled_cg_image
=
+
CreateScaledCGImage
(
cg_image
size
.
width
(
)
size
.
height
(
)
)
;
if
(
scaled_cg_image
!
=
nil
)
{
cg_image
=
scaled_cg_image
;
}
-
199
8
+
202
7
MouseCursorMonitor
*
MouseCursorMonitor
:
:
CreateForWindow
(
}
MouseCursorMonitor
*
MouseCursorMonitor
:
:
CreateForScreen
(
-
const
DesktopCaptureOptions
&
options
-
ScreenId
screen
)
{
+
const
DesktopCaptureOptions
&
options
ScreenId
screen
)
{
return
new
MouseCursorMonitorMac
(
options
kCGNullWindowID
screen
)
;
}
