From
:
Michael
Froman
<
mjfroman
mac
.
com
>
Date
:
Fri
7
Feb
2025
16
:
50
:
15
-
0600
Subject
:
(
tmp
-
cherry
-
pick
)
Revert
"
srtp
:
spanify
Protect
+
Unprotect
"
(
897906d950
)
MIME
-
Version
:
1
.
0
Content
-
Type
:
text
/
plain
;
charset
=
UTF
-
8
Content
-
Transfer
-
Encoding
:
8bit
This
reverts
commit
9572b2fa5850da6d319b9efb5ee36290e2895f7f
.
Reason
for
revert
:
Breaks
internal
tests
Original
change
'
s
description
:
>
srtp
:
spanify
Protect
+
Unprotect
>
>
Makes
SrtpSession
and
SrtpTransport
use
rtc
:
:
CopyOnWriteBuffer
for
the
Protect
and
Unprotect
operations
instead
of
passing
around
void
pointers
.
>
>
Also
updates
the
unit
tests
to
use
CopyOnWriteBuffer
instead
of
char
arrays
with
a
fixed
length
.
>
>
BUG
=
webrtc
:
357776213
>
No
-
Iwyu
:
missing
include
is
a
private
libsrtp
header
>
>
Change
-
Id
:
I02a22ceb4e183e93c4ebd8c0a9c931404e0e32f3
>
Reviewed
-
on
:
https
:
/
/
webrtc
-
review
.
googlesource
.
com
/
c
/
src
/
+
/
358442
>
Reviewed
-
by
:
Henrik
Bostr
m
<
hbos
webrtc
.
org
>
>
Reviewed
-
by
:
Harald
Alvestrand
<
hta
webrtc
.
org
>
>
Commit
-
Queue
:
Philipp
Hancke
<
phancke
meta
.
com
>
>
Cr
-
Commit
-
Position
:
refs
/
heads
/
main
{
#
43601
}
Bug
:
webrtc
:
357776213
Change
-
Id
:
I5c36ecc2fd9ab672f61cd6b15398452cbd5e98a8
No
-
Presubmit
:
true
No
-
Tree
-
Checks
:
true
No
-
Try
:
true
Reviewed
-
on
:
https
:
/
/
webrtc
-
review
.
googlesource
.
com
/
c
/
src
/
+
/
372200
Commit
-
Queue
:
Harald
Alvestrand
<
hta
webrtc
.
org
>
Bot
-
Commit
:
rubber
-
stamper
appspot
.
gserviceaccount
.
com
<
rubber
-
stamper
appspot
.
gserviceaccount
.
com
>
Reviewed
-
by
:
Harald
Alvestrand
<
hta
webrtc
.
org
>
Auto
-
Submit
:
Henrik
Bostr
m
<
hbos
webrtc
.
org
>
Cr
-
Commit
-
Position
:
refs
/
heads
/
main
{
#
43608
}
-
-
-
pc
/
BUILD
.
gn
|
5
-
-
pc
/
srtp_session
.
cc
|
164
+
+
+
+
+
+
+
+
+
+
+
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
pc
/
srtp_session
.
h
|
40
+
+
+
-
-
-
-
-
-
pc
/
srtp_session_unittest
.
cc
|
167
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
pc
/
srtp_transport
.
cc
|
101
+
+
+
+
+
+
+
+
+
+
+
+
+
-
-
-
-
-
-
-
-
-
pc
/
srtp_transport
.
h
|
19
+
+
-
-
6
files
changed
213
insertions
(
+
)
283
deletions
(
-
)
diff
-
-
git
a
/
pc
/
BUILD
.
gn
b
/
pc
/
BUILD
.
gn
index
d33b3f492f
.
.
e13a04628c
100644
-
-
-
a
/
pc
/
BUILD
.
gn
+
+
+
b
/
pc
/
BUILD
.
gn
-
594
8
+
594
6
rtc_source_set
(
"
srtp_session
"
)
{
"
.
.
/
rtc_base
:
buffer
"
"
.
.
/
rtc_base
:
byte_order
"
"
.
.
/
rtc_base
:
checks
"
-
"
.
.
/
rtc_base
:
copy_on_write_buffer
"
-
"
.
.
/
rtc_base
:
ip_address
"
"
.
.
/
rtc_base
:
logging
"
"
.
.
/
rtc_base
:
macromagic
"
"
.
.
/
rtc_base
:
ssl_adapter
"
-
622
8
+
620
6
rtc_source_set
(
"
srtp_transport
"
)
{
"
.
.
/
api
:
field_trials_view
"
"
.
.
/
api
:
libjingle_peerconnection_api
"
"
.
.
/
api
:
rtc_error
"
-
"
.
.
/
api
/
units
:
timestamp
"
-
"
.
.
/
call
:
rtp_receiver
"
"
.
.
/
media
:
rtp_utils
"
"
.
.
/
modules
/
rtp_rtcp
:
rtp_rtcp_format
"
"
.
.
/
p2p
:
packet_transport_internal
"
-
637
7
+
633
6
rtc_source_set
(
"
srtp_transport
"
)
{
"
.
.
/
rtc_base
:
safe_conversions
"
"
.
.
/
rtc_base
:
ssl_adapter
"
"
.
.
/
rtc_base
:
zero_memory
"
-
"
.
.
/
rtc_base
/
network
:
received_packet
"
"
/
/
third_party
/
abseil
-
cpp
/
absl
/
strings
"
]
}
diff
-
-
git
a
/
pc
/
srtp_session
.
cc
b
/
pc
/
srtp_session
.
cc
index
755cf215ea
.
.
bf27e63d39
100644
-
-
-
a
/
pc
/
srtp_session
.
cc
+
+
+
b
/
pc
/
srtp_session
.
cc
-
12
21
+
12
18
#
include
<
string
.
h
>
-
#
include
<
cstdint
>
-
#
include
<
cstring
>
#
include
<
iomanip
>
-
#
include
<
vector
>
+
#
include
<
string
>
+
#
include
"
absl
/
base
/
attributes
.
h
"
+
#
include
"
absl
/
base
/
const_init
.
h
"
#
include
"
absl
/
strings
/
string_view
.
h
"
#
include
"
api
/
array_view
.
h
"
#
include
"
api
/
field_trials_view
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_util
.
h
"
#
include
"
pc
/
external_hmac
.
h
"
-
#
include
"
rtc_base
/
buffer
.
h
"
#
include
"
rtc_base
/
byte_order
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
-
#
include
"
rtc_base
/
copy_on_write_buffer
.
h
"
-
#
include
"
rtc_base
/
ip_address
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
ssl_stream_adapter
.
h
"
#
include
"
rtc_base
/
string_encode
.
h
"
-
152
6
+
149
8
void
LibSrtpInitializer
:
:
DecrementLibsrtpUsageCountAndMaybeDeinit
(
)
{
}
/
/
namespace
+
using
:
:
webrtc
:
:
ParseRtpSequenceNumber
;
+
/
/
One
more
than
the
maximum
libsrtp
error
code
.
Required
by
/
/
RTC_HISTOGRAM_ENUMERATION
.
Keep
this
in
sync
with
srtp_error_status_t
defined
/
/
in
srtp
.
h
.
-
197
22
+
196
7
bool
SrtpSession
:
:
UpdateReceive
(
int
crypto_suite
return
UpdateKey
(
ssrc_any_inbound
crypto_suite
key
extension_ids
)
;
}
-
bool
SrtpSession
:
:
ProtectRtp
(
void
*
data
-
int
in_len
-
int
max_len
-
int
*
out_len
)
{
-
/
/
Note
:
this
creates
a
copy
of
data
then
needs
to
memcpy
back
.
-
/
/
Do
not
use
this
variant
.
-
rtc
:
:
CopyOnWriteBuffer
buffer
(
static_cast
<
uint8_t
*
>
(
data
)
in_len
max_len
)
;
-
bool
ok
=
ProtectRtp
(
buffer
)
;
-
if
(
ok
)
{
-
*
out_len
=
buffer
.
size
(
)
;
-
std
:
:
memcpy
(
data
buffer
.
data
(
)
*
out_len
)
;
-
}
-
return
ok
;
-
}
-
-
bool
SrtpSession
:
:
ProtectRtp
(
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
{
+
bool
SrtpSession
:
:
ProtectRtp
(
void
*
p
int
in_len
int
max_len
int
*
out_len
)
{
RTC_DCHECK
(
thread_checker_
.
IsCurrent
(
)
)
;
if
(
!
session_
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
protect
SRTP
packet
:
no
SRTP
Session
"
;
-
223
52
+
207
42
bool
SrtpSession
:
:
ProtectRtp
(
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
{
/
/
SRTP_MAX_TRAILER_LEN
bytes
of
free
space
after
the
data
.
WebRTC
/
/
never
includes
a
MKI
therefore
the
amount
of
bytes
added
by
the
/
/
srtp_protect
call
is
known
in
advance
and
depends
on
the
cipher
suite
.
-
size_t
need_len
=
buffer
.
size
(
)
+
rtp_auth_tag_len_
;
/
/
NOLINT
-
if
(
buffer
.
capacity
(
)
<
need_len
)
{
+
int
need_len
=
in_len
+
rtp_auth_tag_len_
;
/
/
NOLINT
+
if
(
max_len
<
need_len
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
protect
SRTP
packet
:
The
buffer
length
"
-
<
<
buffer
.
capacity
(
)
<
<
"
is
less
than
the
needed
"
-
<
<
need_len
;
+
<
<
max_len
<
<
"
is
less
than
the
needed
"
<
<
need_len
;
return
false
;
}
if
(
dump_plain_rtp_
)
{
-
DumpPacket
(
buffer
/
*
outbound
=
*
/
true
)
;
+
DumpPacket
(
p
in_len
/
*
outbound
=
*
/
true
)
;
}
-
int
out_len
=
buffer
.
size
(
)
;
-
int
err
=
srtp_protect
(
session_
buffer
.
MutableData
<
char
>
(
)
&
out_len
)
;
-
int
seq_num
=
webrtc
:
:
ParseRtpSequenceNumber
(
buffer
)
;
+
*
out_len
=
in_len
;
+
int
err
=
srtp_protect
(
session_
p
out_len
)
;
+
int
seq_num
=
ParseRtpSequenceNumber
(
+
rtc
:
:
MakeArrayView
(
reinterpret_cast
<
const
uint8_t
*
>
(
p
)
in_len
)
)
;
if
(
err
!
=
srtp_err_status_ok
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
protect
SRTP
packet
seqnum
=
"
<
<
seq_num
<
<
"
err
=
"
<
<
err
<
<
"
last
seqnum
=
"
<
<
last_send_seq_num_
;
return
false
;
}
-
buffer
.
SetSize
(
out_len
)
;
last_send_seq_num_
=
seq_num
;
return
true
;
}
-
bool
SrtpSession
:
:
ProtectRtp
(
rtc
:
:
CopyOnWriteBuffer
&
buffer
int64_t
*
index
)
{
-
if
(
!
ProtectRtp
(
buffer
)
)
{
-
return
false
;
-
}
-
return
(
index
)
?
GetSendStreamPacketIndex
(
buffer
index
)
:
true
;
-
}
-
-
bool
SrtpSession
:
:
ProtectRtp
(
void
*
data
+
bool
SrtpSession
:
:
ProtectRtp
(
void
*
p
int
in_len
int
max_len
int
*
out_len
int64_t
*
index
)
{
-
rtc
:
:
CopyOnWriteBuffer
buffer
(
static_cast
<
uint8_t
*
>
(
data
)
in_len
max_len
)
;
-
if
(
!
ProtectRtp
(
buffer
)
)
{
+
if
(
!
ProtectRtp
(
p
in_len
max_len
out_len
)
)
{
return
false
;
}
-
*
out_len
=
buffer
.
size
(
)
;
-
return
(
index
)
?
GetSendStreamPacketIndex
(
buffer
index
)
:
true
;
+
return
(
index
)
?
GetSendStreamPacketIndex
(
p
in_len
index
)
:
true
;
}
-
bool
SrtpSession
:
:
ProtectRtcp
(
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
{
+
bool
SrtpSession
:
:
ProtectRtcp
(
void
*
p
int
in_len
int
max_len
int
*
out_len
)
{
RTC_DCHECK
(
thread_checker_
.
IsCurrent
(
)
)
;
if
(
!
session_
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
protect
SRTCP
packet
:
no
SRTP
Session
"
;
-
279
52
+
253
34
bool
SrtpSession
:
:
ProtectRtcp
(
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
{
/
/
SRTP_MAX_TRAILER_LEN
bytes
of
free
space
after
the
data
.
WebRTC
/
/
never
includes
a
MKI
therefore
the
amount
of
bytes
added
by
the
/
/
srtp_protect_rtp
call
is
known
in
advance
and
depends
on
the
cipher
suite
.
-
size_t
need_len
=
-
buffer
.
size
(
)
+
sizeof
(
uint32_t
)
+
rtcp_auth_tag_len_
;
/
/
NOLINT
-
if
(
buffer
.
capacity
(
)
<
need_len
)
{
-
RTC_LOG
(
LS_WARNING
)
-
<
<
"
Failed
to
protect
SRTCP
packet
:
The
buffer
capacity
"
-
<
<
buffer
.
capacity
(
)
<
<
"
is
less
than
the
needed
"
<
<
need_len
;
+
int
need_len
=
in_len
+
sizeof
(
uint32_t
)
+
rtcp_auth_tag_len_
;
/
/
NOLINT
+
if
(
max_len
<
need_len
)
{
+
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
protect
SRTCP
packet
:
The
buffer
length
"
+
<
<
max_len
<
<
"
is
less
than
the
needed
"
<
<
need_len
;
return
false
;
}
if
(
dump_plain_rtp_
)
{
-
DumpPacket
(
buffer
/
*
outbound
=
*
/
true
)
;
+
DumpPacket
(
p
in_len
/
*
outbound
=
*
/
true
)
;
}
-
int
out_len
=
buffer
.
size
(
)
;
-
int
err
=
srtp_protect_rtcp
(
session_
buffer
.
MutableData
<
char
>
(
)
&
out_len
)
;
+
*
out_len
=
in_len
;
+
int
err
=
srtp_protect_rtcp
(
session_
p
out_len
)
;
if
(
err
!
=
srtp_err_status_ok
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
protect
SRTCP
packet
err
=
"
<
<
err
;
return
false
;
}
-
buffer
.
SetSize
(
out_len
)
;
return
true
;
}
-
bool
SrtpSession
:
:
ProtectRtcp
(
void
*
data
-
int
in_len
-
int
max_len
-
int
*
out_len
)
{
-
/
/
Note
:
this
creates
a
copy
of
data
then
needs
to
memcpy
back
.
-
/
/
Do
not
use
this
variant
.
-
rtc
:
:
CopyOnWriteBuffer
buffer
(
static_cast
<
uint8_t
*
>
(
data
)
in_len
max_len
)
;
-
bool
result
=
ProtectRtcp
(
buffer
)
;
-
if
(
result
)
{
-
*
out_len
=
buffer
.
size
(
)
;
-
std
:
:
memcpy
(
data
buffer
.
data
(
)
*
out_len
)
;
-
}
-
return
result
;
-
}
-
-
bool
SrtpSession
:
:
UnprotectRtp
(
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
{
+
bool
SrtpSession
:
:
UnprotectRtp
(
void
*
p
int
in_len
int
*
out_len
)
{
RTC_DCHECK
(
thread_checker_
.
IsCurrent
(
)
)
;
if
(
!
session_
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
unprotect
SRTP
packet
:
no
SRTP
Session
"
;
return
false
;
}
-
int
out_len
=
buffer
.
size
(
)
;
-
int
err
=
srtp_unprotect
(
session_
buffer
.
MutableData
<
char
>
(
)
&
out_len
)
;
+
*
out_len
=
in_len
;
+
int
err
=
srtp_unprotect
(
session_
p
out_len
)
;
if
(
err
!
=
srtp_err_status_ok
)
{
/
/
Limit
the
error
logging
to
avoid
excessive
logs
when
there
are
lots
of
/
/
bad
packets
.
-
339
55
+
295
33
bool
SrtpSession
:
:
UnprotectRtp
(
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
{
static_cast
<
int
>
(
err
)
kSrtpErrorCodeBoundary
)
;
return
false
;
}
-
buffer
.
SetSize
(
out_len
)
;
if
(
dump_plain_rtp_
)
{
-
DumpPacket
(
buffer
/
*
outbound
=
*
/
false
)
;
+
DumpPacket
(
p
*
out_len
/
*
outbound
=
*
/
false
)
;
}
return
true
;
}
-
bool
SrtpSession
:
:
UnprotectRtp
(
void
*
data
int
in_len
int
*
out_len
)
{
-
rtc
:
:
CopyOnWriteBuffer
buffer
(
static_cast
<
uint8_t
*
>
(
data
)
in_len
)
;
-
bool
ok
=
UnprotectRtp
(
buffer
)
;
-
if
(
ok
)
{
-
*
out_len
=
buffer
.
size
(
)
;
-
std
:
:
memcpy
(
data
buffer
.
data
(
)
*
out_len
)
;
-
}
-
return
ok
;
-
}
-
-
bool
SrtpSession
:
:
UnprotectRtcp
(
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
{
+
bool
SrtpSession
:
:
UnprotectRtcp
(
void
*
p
int
in_len
int
*
out_len
)
{
RTC_DCHECK
(
thread_checker_
.
IsCurrent
(
)
)
;
if
(
!
session_
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
unprotect
SRTCP
packet
:
no
SRTP
Session
"
;
return
false
;
}
-
int
out_len
=
buffer
.
size
(
)
;
-
int
err
=
srtp_unprotect_rtcp
(
session_
buffer
.
MutableData
<
char
>
(
)
&
out_len
)
;
+
*
out_len
=
in_len
;
+
int
err
=
srtp_unprotect_rtcp
(
session_
p
out_len
)
;
if
(
err
!
=
srtp_err_status_ok
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
unprotect
SRTCP
packet
err
=
"
<
<
err
;
RTC_HISTOGRAM_ENUMERATION
(
"
WebRTC
.
PeerConnection
.
SrtcpUnprotectError
"
static_cast
<
int
>
(
err
)
kSrtpErrorCodeBoundary
)
;
return
false
;
}
-
buffer
.
SetSize
(
out_len
)
;
if
(
dump_plain_rtp_
)
{
-
DumpPacket
(
buffer
/
*
outbound
=
*
/
false
)
;
+
DumpPacket
(
p
*
out_len
/
*
outbound
=
*
/
false
)
;
}
return
true
;
}
-
bool
SrtpSession
:
:
UnprotectRtcp
(
void
*
data
int
in_len
int
*
out_len
)
{
-
rtc
:
:
CopyOnWriteBuffer
buffer
(
static_cast
<
uint8_t
*
>
(
data
)
in_len
)
;
-
bool
ok
=
UnprotectRtp
(
buffer
)
;
-
if
(
ok
)
{
-
*
out_len
=
buffer
.
size
(
)
;
-
std
:
:
memcpy
(
data
buffer
.
data
(
)
*
out_len
)
;
-
}
-
return
ok
;
-
}
-
bool
SrtpSession
:
:
GetRtpAuthParams
(
uint8_t
*
*
key
int
*
key_len
int
*
tag_len
)
{
RTC_DCHECK
(
thread_checker_
.
IsCurrent
(
)
)
;
RTC_DCHECK
(
IsExternalAuthActive
(
)
)
;
-
439
12
+
373
12
bool
SrtpSession
:
:
RemoveSsrcFromSession
(
uint32_t
ssrc
)
{
return
srtp_remove_stream
(
session_
htonl
(
ssrc
)
)
=
=
srtp_err_status_ok
;
}
-
bool
SrtpSession
:
:
GetSendStreamPacketIndex
(
rtc
:
:
CopyOnWriteBuffer
&
buffer
+
bool
SrtpSession
:
:
GetSendStreamPacketIndex
(
void
*
p
+
int
in_len
int64_t
*
index
)
{
RTC_DCHECK
(
thread_checker_
.
IsCurrent
(
)
)
;
-
/
/
libSRTP
expects
the
SSRC
to
be
in
network
byte
order
.
-
srtp_stream_ctx_t
*
stream
=
-
srtp_get_stream
(
session_
htonl
(
webrtc
:
:
ParseRtpSsrc
(
buffer
)
)
)
;
+
srtp_hdr_t
*
hdr
=
reinterpret_cast
<
srtp_hdr_t
*
>
(
p
)
;
+
srtp_stream_ctx_t
*
stream
=
srtp_get_stream
(
session_
hdr
-
>
ssrc
)
;
if
(
!
stream
)
{
return
false
;
}
-
600
25
+
534
25
void
SrtpSession
:
:
HandleEventThunk
(
srtp_event_data_t
*
ev
)
{
/
/
extracted
by
searching
for
RTP_DUMP
/
/
grep
RTP_DUMP
chrome_debug
.
log
>
in
.
txt
/
/
and
converted
to
pcap
using
-
/
/
text2pcap
-
D
-
u
1000
2000
-
t
%
H
:
%
M
:
%
S
.
%
f
in
.
txt
out
.
pcap
+
/
/
text2pcap
-
D
-
u
1000
2000
-
t
%
H
:
%
M
:
%
S
.
in
.
txt
out
.
pcap
/
/
The
resulting
file
can
be
replayed
using
the
WebRTC
video_replay
tool
and
/
/
be
inspected
in
Wireshark
using
the
RTP
VP8
and
H264
dissectors
.
-
void
SrtpSession
:
:
DumpPacket
(
const
rtc
:
:
CopyOnWriteBuffer
&
buffer
-
bool
outbound
)
{
+
void
SrtpSession
:
:
DumpPacket
(
const
void
*
buf
int
len
bool
outbound
)
{
int64_t
time_of_day
=
rtc
:
:
TimeUTCMillis
(
)
%
(
24
*
3600
*
1000
)
;
int64_t
hours
=
time_of_day
/
(
3600
*
1000
)
;
int64_t
minutes
=
(
time_of_day
/
(
60
*
1000
)
)
%
60
;
int64_t
seconds
=
(
time_of_day
/
1000
)
%
60
;
int64_t
millis
=
time_of_day
%
1000
;
-
RTC_LOG
(
LS_VERBOSE
)
-
<
<
"
\
n
"
-
<
<
(
outbound
?
"
O
"
:
"
I
"
)
<
<
"
"
<
<
std
:
:
setfill
(
'
0
'
)
<
<
std
:
:
setw
(
2
)
-
<
<
hours
<
<
"
:
"
<
<
std
:
:
setfill
(
'
0
'
)
<
<
std
:
:
setw
(
2
)
<
<
minutes
<
<
"
:
"
-
<
<
std
:
:
setfill
(
'
0
'
)
<
<
std
:
:
setw
(
2
)
<
<
seconds
<
<
"
.
"
-
<
<
std
:
:
setfill
(
'
0
'
)
<
<
std
:
:
setw
(
3
)
<
<
millis
<
<
"
"
<
<
"
000000
"
-
<
<
rtc
:
:
hex_encode_with_delimiter
(
-
absl
:
:
string_view
(
buffer
.
data
<
char
>
(
)
buffer
.
size
(
)
)
'
'
)
-
<
<
"
#
RTP_DUMP
"
;
+
RTC_LOG
(
LS_VERBOSE
)
<
<
"
\
n
"
+
<
<
(
outbound
?
"
O
"
:
"
I
"
)
<
<
"
"
<
<
std
:
:
setfill
(
'
0
'
)
+
<
<
std
:
:
setw
(
2
)
<
<
hours
<
<
"
:
"
<
<
std
:
:
setfill
(
'
0
'
)
+
<
<
std
:
:
setw
(
2
)
<
<
minutes
<
<
"
:
"
<
<
std
:
:
setfill
(
'
0
'
)
+
<
<
std
:
:
setw
(
2
)
<
<
seconds
<
<
"
.
"
<
<
std
:
:
setfill
(
'
0
'
)
+
<
<
std
:
:
setw
(
3
)
<
<
millis
<
<
"
"
+
<
<
"
000000
"
+
<
<
rtc
:
:
hex_encode_with_delimiter
(
+
absl
:
:
string_view
(
(
const
char
*
)
buf
len
)
'
'
)
+
<
<
"
#
RTP_DUMP
"
;
}
}
/
/
namespace
cricket
diff
-
-
git
a
/
pc
/
srtp_session
.
h
b
/
pc
/
srtp_session
.
h
index
4dde928318
.
.
f9e7ae5d40
100644
-
-
-
a
/
pc
/
srtp_session
.
h
+
+
+
b
/
pc
/
srtp_session
.
h
-
17
9
+
17
9
#
include
<
vector
>
#
include
"
api
/
field_trials_view
.
h
"
+
#
include
"
api
/
scoped_refptr
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
rtc_base
/
buffer
.
h
"
-
#
include
"
rtc_base
/
copy_on_write_buffer
.
h
"
/
/
Forward
declaration
to
avoid
pulling
in
libsrtp
headers
here
struct
srtp_event_data_t
;
-
62
34
+
62
18
class
SrtpSession
{
/
/
Encrypts
/
signs
an
individual
RTP
/
RTCP
packet
in
-
place
.
/
/
If
an
HMAC
is
used
this
will
increase
the
packet
size
.
-
[
[
deprecated
(
"
Pass
CopyOnWriteBuffer
"
)
]
]
bool
ProtectRtp
(
void
*
data
-
int
in_len
-
int
max_len
-
int
*
out_len
)
;
-
bool
ProtectRtp
(
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
;
+
bool
ProtectRtp
(
void
*
data
int
in_len
int
max_len
int
*
out_len
)
;
/
/
Overloaded
version
outputs
packet
index
.
-
[
[
deprecated
(
"
Pass
CopyOnWriteBuffer
"
)
]
]
bool
ProtectRtp
(
void
*
data
-
int
in_len
-
int
max_len
-
int
*
out_len
-
int64_t
*
index
)
;
-
bool
ProtectRtp
(
rtc
:
:
CopyOnWriteBuffer
&
buffer
int64_t
*
index
)
;
-
-
[
[
deprecated
(
"
Pass
CopyOnWriteBuffer
"
)
]
]
bool
ProtectRtcp
(
void
*
data
-
int
in_len
-
int
max_len
-
int
*
out_len
)
;
-
bool
ProtectRtcp
(
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
;
+
bool
ProtectRtp
(
void
*
data
+
int
in_len
+
int
max_len
+
int
*
out_len
+
int64_t
*
index
)
;
+
bool
ProtectRtcp
(
void
*
data
int
in_len
int
max_len
int
*
out_len
)
;
/
/
Decrypts
/
verifies
an
invidiual
RTP
/
RTCP
packet
.
/
/
If
an
HMAC
is
used
this
will
decrease
the
packet
size
.
-
[
[
deprecated
(
"
Pass
CopyOnWriteBuffer
"
)
]
]
bool
UnprotectRtp
(
void
*
data
-
int
in_len
-
int
*
out_len
)
;
-
bool
UnprotectRtp
(
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
;
-
[
[
deprecated
(
"
Pass
CopyOnWriteBuffer
"
)
]
]
bool
UnprotectRtcp
(
void
*
data
-
int
in_len
-
int
*
out_len
)
;
-
bool
UnprotectRtcp
(
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
;
+
bool
UnprotectRtp
(
void
*
data
int
in_len
int
*
out_len
)
;
+
bool
UnprotectRtcp
(
void
*
data
int
in_len
int
*
out_len
)
;
/
/
Helper
method
to
get
authentication
params
.
bool
GetRtpAuthParams
(
uint8_t
*
*
key
int
*
key_len
int
*
tag_len
)
;
-
131
11
+
115
11
class
SrtpSession
{
const
rtc
:
:
ZeroOnFreeBuffer
<
uint8_t
>
&
key
const
std
:
:
vector
<
int
>
&
extension_ids
)
;
/
/
Returns
send
stream
current
packet
index
from
srtp
db
.
-
bool
GetSendStreamPacketIndex
(
rtc
:
:
CopyOnWriteBuffer
&
buffer
int64_t
*
index
)
;
+
bool
GetSendStreamPacketIndex
(
void
*
data
int
in_len
int64_t
*
index
)
;
/
/
Writes
unencrypted
packets
in
text2pcap
format
to
the
log
file
/
/
for
debugging
.
-
void
DumpPacket
(
const
rtc
:
:
CopyOnWriteBuffer
&
buffer
bool
outbound
)
;
+
void
DumpPacket
(
const
void
*
buf
int
len
bool
outbound
)
;
void
HandleEvent
(
const
srtp_event_data_t
*
ev
)
;
static
void
HandleEventThunk
(
srtp_event_data_t
*
ev
)
;
diff
-
-
git
a
/
pc
/
srtp_session_unittest
.
cc
b
/
pc
/
srtp_session_unittest
.
cc
index
35d4108afc
.
.
0785cc0c56
100644
-
-
-
a
/
pc
/
srtp_session_unittest
.
cc
+
+
+
b
/
pc
/
srtp_session_unittest
.
cc
-
12
16
+
12
11
#
include
<
string
.
h
>
-
#
include
<
cstdint
>
-
#
include
<
cstring
>
-
#
include
<
limits
>
-
#
include
<
vector
>
+
#
include
<
string
>
#
include
"
media
/
base
/
fake_rtp
.
h
"
#
include
"
pc
/
test
/
srtp_test_util
.
h
"
-
#
include
"
rtc_base
/
buffer
.
h
"
#
include
"
rtc_base
/
byte_order
.
h
"
-
#
include
"
rtc_base
/
copy_on_write_buffer
.
h
"
#
include
"
rtc_base
/
ssl_stream_adapter
.
h
"
/
/
For
rtc
:
:
SRTP_
*
#
include
"
system_wrappers
/
include
/
metrics
.
h
"
#
include
"
test
/
gmock
.
h
"
-
46
45
+
41
45
class
SrtpSessionTest
:
public
:
:
testing
:
:
Test
{
virtual
void
SetUp
(
)
{
rtp_len_
=
sizeof
(
kPcmuFrame
)
;
rtcp_len_
=
sizeof
(
kRtcpReport
)
;
-
rtp_packet_
.
EnsureCapacity
(
rtp_len_
+
10
)
;
-
rtp_packet_
.
SetData
(
kPcmuFrame
rtp_len_
)
;
-
rtcp_packet_
.
EnsureCapacity
(
rtcp_len_
+
4
+
10
)
;
-
rtcp_packet_
.
SetData
(
kRtcpReport
rtcp_len_
)
;
+
memcpy
(
rtp_packet_
kPcmuFrame
rtp_len_
)
;
+
memcpy
(
rtcp_packet_
kRtcpReport
rtcp_len_
)
;
}
void
TestProtectRtp
(
int
crypto_suite
)
{
-
EXPECT_TRUE
(
s1_
.
ProtectRtp
(
rtp_packet_
)
)
;
-
EXPECT_EQ
(
rtp_packet_
.
size
(
)
rtp_len_
+
rtp_auth_tag_len
(
crypto_suite
)
)
;
-
/
/
Check
that
Protect
changed
the
content
(
up
to
the
original
length
)
.
-
EXPECT_NE
(
0
std
:
:
memcmp
(
kPcmuFrame
rtp_packet_
.
data
(
)
rtp_len_
)
)
;
-
rtp_len_
=
rtp_packet_
.
size
(
)
;
+
int
out_len
=
0
;
+
EXPECT_TRUE
(
+
s1_
.
ProtectRtp
(
rtp_packet_
rtp_len_
sizeof
(
rtp_packet_
)
&
out_len
)
)
;
+
EXPECT_EQ
(
out_len
rtp_len_
+
rtp_auth_tag_len
(
crypto_suite
)
)
;
+
EXPECT_NE
(
0
memcmp
(
rtp_packet_
kPcmuFrame
rtp_len_
)
)
;
+
rtp_len_
=
out_len
;
}
void
TestProtectRtcp
(
int
crypto_suite
)
{
-
EXPECT_TRUE
(
s1_
.
ProtectRtcp
(
rtcp_packet_
)
)
;
-
EXPECT_EQ
(
rtcp_packet_
.
size
(
)
-
rtcp_len_
+
4
+
rtcp_auth_tag_len
(
crypto_suite
)
)
;
-
/
/
Check
that
Protect
changed
the
content
(
up
to
the
original
length
)
.
-
EXPECT_NE
(
0
std
:
:
memcmp
(
kRtcpReport
rtcp_packet_
.
data
(
)
rtcp_len_
)
)
;
-
rtcp_len_
=
rtcp_packet_
.
size
(
)
;
+
int
out_len
=
0
;
+
EXPECT_TRUE
(
s1_
.
ProtectRtcp
(
rtcp_packet_
rtcp_len_
sizeof
(
rtcp_packet_
)
+
&
out_len
)
)
;
+
EXPECT_EQ
(
out_len
+
rtcp_len_
+
4
+
rtcp_auth_tag_len
(
crypto_suite
)
)
;
/
/
NOLINT
+
EXPECT_NE
(
0
memcmp
(
rtcp_packet_
kRtcpReport
rtcp_len_
)
)
;
+
rtcp_len_
=
out_len
;
}
void
TestUnprotectRtp
(
int
crypto_suite
)
{
-
EXPECT_TRUE
(
s2_
.
UnprotectRtp
(
rtp_packet_
)
)
;
-
EXPECT_EQ
(
rtp_packet_
.
size
(
)
sizeof
(
kPcmuFrame
)
)
;
-
EXPECT_EQ
(
0
-
std
:
:
memcmp
(
kPcmuFrame
rtp_packet_
.
data
(
)
rtp_packet_
.
size
(
)
)
)
;
+
int
out_len
=
0
expected_len
=
sizeof
(
kPcmuFrame
)
;
+
EXPECT_TRUE
(
s2_
.
UnprotectRtp
(
rtp_packet_
rtp_len_
&
out_len
)
)
;
+
EXPECT_EQ
(
expected_len
out_len
)
;
+
EXPECT_EQ
(
0
memcmp
(
rtp_packet_
kPcmuFrame
out_len
)
)
;
}
void
TestUnprotectRtcp
(
int
crypto_suite
)
{
-
EXPECT_TRUE
(
s2_
.
UnprotectRtcp
(
rtcp_packet_
)
)
;
-
EXPECT_EQ
(
rtcp_packet_
.
size
(
)
sizeof
(
kRtcpReport
)
)
;
-
EXPECT_EQ
(
-
0
std
:
:
memcmp
(
kRtcpReport
rtcp_packet_
.
data
(
)
rtcp_packet_
.
size
(
)
)
)
;
+
int
out_len
=
0
expected_len
=
sizeof
(
kRtcpReport
)
;
+
EXPECT_TRUE
(
s2_
.
UnprotectRtcp
(
rtcp_packet_
rtcp_len_
&
out_len
)
)
;
+
EXPECT_EQ
(
expected_len
out_len
)
;
+
EXPECT_EQ
(
0
memcmp
(
rtcp_packet_
kRtcpReport
out_len
)
)
;
}
webrtc
:
:
test
:
:
ScopedKeyValueConfig
field_trials_
;
cricket
:
:
SrtpSession
s1_
;
cricket
:
:
SrtpSession
s2_
;
-
rtc
:
:
CopyOnWriteBuffer
rtp_packet_
;
-
rtc
:
:
CopyOnWriteBuffer
rtcp_packet_
;
-
size_t
rtp_len_
;
-
size_t
rtcp_len_
;
+
char
rtp_packet_
[
sizeof
(
kPcmuFrame
)
+
10
]
;
+
char
rtcp_packet_
[
sizeof
(
kRtcpReport
)
+
4
+
10
]
;
+
int
rtp_len_
;
+
int
rtcp_len_
;
}
;
/
/
Test
that
we
can
set
up
the
session
and
keys
properly
.
-
145
7
+
140
9
TEST_F
(
SrtpSessionTest
TestGetSendStreamPacketIndex
)
{
EXPECT_TRUE
(
s1_
.
SetSend
(
kSrtpAes128CmSha1_32
kTestKey1
kEncryptedHeaderExtensionIds
)
)
;
int64_t
index
;
-
EXPECT_TRUE
(
s1_
.
ProtectRtp
(
rtp_packet_
&
index
)
)
;
+
int
out_len
=
0
;
+
EXPECT_TRUE
(
s1_
.
ProtectRtp
(
rtp_packet_
rtp_len_
sizeof
(
rtp_packet_
)
+
&
out_len
&
index
)
)
;
/
/
index
will
be
shifted
by
16
.
int64_t
be64_index
=
static_cast
<
int64_t
>
(
NetworkToHost64
(
1
<
<
16
)
)
;
EXPECT_EQ
(
be64_index
index
)
;
-
153
20
+
150
20
TEST_F
(
SrtpSessionTest
TestGetSendStreamPacketIndex
)
{
/
/
Test
that
we
fail
to
unprotect
if
someone
tampers
with
the
RTP
/
RTCP
paylaods
.
TEST_F
(
SrtpSessionTest
TestTamperReject
)
{
+
int
out_len
;
EXPECT_TRUE
(
s1_
.
SetSend
(
kSrtpAes128CmSha1_80
kTestKey1
kEncryptedHeaderExtensionIds
)
)
;
EXPECT_TRUE
(
s2_
.
SetReceive
(
kSrtpAes128CmSha1_80
kTestKey1
kEncryptedHeaderExtensionIds
)
)
;
TestProtectRtp
(
kSrtpAes128CmSha1_80
)
;
-
rtp_packet_
.
MutableData
<
uint8_t
>
(
)
[
0
]
=
0x12
;
-
EXPECT_FALSE
(
s2_
.
UnprotectRtp
(
rtp_packet_
)
)
;
+
TestProtectRtcp
(
kSrtpAes128CmSha1_80
)
;
+
rtp_packet_
[
0
]
=
0x12
;
+
rtcp_packet_
[
1
]
=
0x34
;
+
EXPECT_FALSE
(
s2_
.
UnprotectRtp
(
rtp_packet_
rtp_len_
&
out_len
)
)
;
EXPECT_METRIC_THAT
(
webrtc
:
:
metrics
:
:
Samples
(
"
WebRTC
.
PeerConnection
.
SrtpUnprotectError
"
)
ElementsAre
(
Pair
(
srtp_err_status_bad_param
1
)
)
)
;
-
-
TestProtectRtcp
(
kSrtpAes128CmSha1_80
)
;
-
rtcp_packet_
.
MutableData
<
uint8_t
>
(
)
[
1
]
=
0x34
;
-
EXPECT_FALSE
(
s2_
.
UnprotectRtcp
(
rtcp_packet_
)
)
;
+
EXPECT_FALSE
(
s2_
.
UnprotectRtcp
(
rtcp_packet_
rtcp_len_
&
out_len
)
)
;
EXPECT_METRIC_THAT
(
webrtc
:
:
metrics
:
:
Samples
(
"
WebRTC
.
PeerConnection
.
SrtcpUnprotectError
"
)
ElementsAre
(
Pair
(
srtp_err_status_auth_fail
1
)
)
)
;
-
174
15
+
171
16
TEST_F
(
SrtpSessionTest
TestTamperReject
)
{
/
/
Test
that
we
fail
to
unprotect
if
the
payloads
are
not
authenticated
.
TEST_F
(
SrtpSessionTest
TestUnencryptReject
)
{
+
int
out_len
;
EXPECT_TRUE
(
s1_
.
SetSend
(
kSrtpAes128CmSha1_80
kTestKey1
kEncryptedHeaderExtensionIds
)
)
;
EXPECT_TRUE
(
s2_
.
SetReceive
(
kSrtpAes128CmSha1_80
kTestKey1
kEncryptedHeaderExtensionIds
)
)
;
-
EXPECT_FALSE
(
s2_
.
UnprotectRtp
(
rtp_packet_
)
)
;
+
EXPECT_FALSE
(
s2_
.
UnprotectRtp
(
rtp_packet_
rtp_len_
&
out_len
)
)
;
EXPECT_METRIC_THAT
(
webrtc
:
:
metrics
:
:
Samples
(
"
WebRTC
.
PeerConnection
.
SrtpUnprotectError
"
)
ElementsAre
(
Pair
(
srtp_err_status_auth_fail
1
)
)
)
;
-
EXPECT_FALSE
(
s2_
.
UnprotectRtcp
(
rtcp_packet_
)
)
;
+
EXPECT_FALSE
(
s2_
.
UnprotectRtcp
(
rtcp_packet_
rtcp_len_
&
out_len
)
)
;
EXPECT_METRIC_THAT
(
webrtc
:
:
metrics
:
:
Samples
(
"
WebRTC
.
PeerConnection
.
SrtcpUnprotectError
"
)
ElementsAre
(
Pair
(
srtp_err_status_cant_check
1
)
)
)
;
-
190
23
+
188
21
TEST_F
(
SrtpSessionTest
TestUnencryptReject
)
{
/
/
Test
that
we
fail
when
using
buffers
that
are
too
small
.
TEST_F
(
SrtpSessionTest
TestBuffersTooSmall
)
{
+
int
out_len
;
EXPECT_TRUE
(
s1_
.
SetSend
(
kSrtpAes128CmSha1_80
kTestKey1
kEncryptedHeaderExtensionIds
)
)
;
-
/
/
This
buffer
does
not
have
extra
capacity
which
we
treat
as
an
error
.
-
rtc
:
:
CopyOnWriteBuffer
rtp_packet
(
rtp_packet_
.
data
(
)
rtp_packet_
.
size
(
)
-
rtp_packet_
.
size
(
)
)
;
-
EXPECT_FALSE
(
s1_
.
ProtectRtp
(
rtp_packet
)
)
;
-
/
/
This
buffer
does
not
have
extra
capacity
which
we
treat
as
an
error
.
-
rtc
:
:
CopyOnWriteBuffer
rtcp_packet
(
rtcp_packet_
.
data
(
)
rtcp_packet_
.
size
(
)
-
rtcp_packet_
.
size
(
)
)
;
-
EXPECT_FALSE
(
s1_
.
ProtectRtcp
(
rtcp_packet
)
)
;
+
EXPECT_FALSE
(
s1_
.
ProtectRtp
(
rtp_packet_
rtp_len_
sizeof
(
rtp_packet_
)
-
10
+
&
out_len
)
)
;
+
EXPECT_FALSE
(
s1_
.
ProtectRtcp
(
rtcp_packet_
rtcp_len_
+
sizeof
(
rtcp_packet_
)
-
14
&
out_len
)
)
;
}
TEST_F
(
SrtpSessionTest
TestReplay
)
{
-
static
const
uint16_t
kMaxSeqnum
=
std
:
:
numeric_limits
<
uint16_t
>
:
:
max
(
)
-
1
;
+
static
const
uint16_t
kMaxSeqnum
=
static_cast
<
uint16_t
>
(
-
1
)
;
static
const
uint16_t
seqnum_big
=
62275
;
static
const
uint16_t
seqnum_small
=
10
;
static
const
uint16_t
replay_window
=
1024
;
+
int
out_len
;
EXPECT_TRUE
(
s1_
.
SetSend
(
kSrtpAes128CmSha1_80
kTestKey1
kEncryptedHeaderExtensionIds
)
)
;
-
214
37
+
210
38
TEST_F
(
SrtpSessionTest
TestReplay
)
{
kEncryptedHeaderExtensionIds
)
)
;
/
/
Initial
sequence
number
.
-
SetBE16
(
rtp_packet_
.
MutableData
<
uint8_t
>
(
)
+
2
seqnum_big
)
;
-
EXPECT_TRUE
(
s1_
.
ProtectRtp
(
rtp_packet_
)
)
;
-
rtp_packet_
.
SetData
(
kPcmuFrame
sizeof
(
kPcmuFrame
)
)
;
+
SetBE16
(
reinterpret_cast
<
uint8_t
*
>
(
rtp_packet_
)
+
2
seqnum_big
)
;
+
EXPECT_TRUE
(
+
s1_
.
ProtectRtp
(
rtp_packet_
rtp_len_
sizeof
(
rtp_packet_
)
&
out_len
)
)
;
/
/
Replay
within
the
1024
window
should
succeed
.
-
SetBE16
(
rtp_packet_
.
MutableData
<
uint8_t
>
(
)
+
2
+
SetBE16
(
reinterpret_cast
<
uint8_t
*
>
(
rtp_packet_
)
+
2
seqnum_big
-
replay_window
+
1
)
;
-
EXPECT_TRUE
(
s1_
.
ProtectRtp
(
rtp_packet_
)
)
;
-
rtp_packet_
.
SetData
(
kPcmuFrame
sizeof
(
kPcmuFrame
)
)
;
+
EXPECT_TRUE
(
+
s1_
.
ProtectRtp
(
rtp_packet_
rtp_len_
sizeof
(
rtp_packet_
)
&
out_len
)
)
;
/
/
Replay
out
side
of
the
1024
window
should
fail
.
-
SetBE16
(
rtp_packet_
.
MutableData
<
uint8_t
>
(
)
+
2
+
SetBE16
(
reinterpret_cast
<
uint8_t
*
>
(
rtp_packet_
)
+
2
seqnum_big
-
replay_window
-
1
)
;
-
EXPECT_FALSE
(
s1_
.
ProtectRtp
(
rtp_packet_
)
)
;
-
rtp_packet_
.
SetData
(
kPcmuFrame
sizeof
(
kPcmuFrame
)
)
;
+
EXPECT_FALSE
(
+
s1_
.
ProtectRtp
(
rtp_packet_
rtp_len_
sizeof
(
rtp_packet_
)
&
out_len
)
)
;
/
/
Increment
sequence
number
to
a
small
number
.
-
SetBE16
(
rtp_packet_
.
MutableData
<
uint8_t
>
(
)
+
2
seqnum_small
)
;
-
EXPECT_TRUE
(
s1_
.
ProtectRtp
(
rtp_packet_
)
)
;
+
SetBE16
(
reinterpret_cast
<
uint8_t
*
>
(
rtp_packet_
)
+
2
seqnum_small
)
;
+
EXPECT_TRUE
(
+
s1_
.
ProtectRtp
(
rtp_packet_
rtp_len_
sizeof
(
rtp_packet_
)
&
out_len
)
)
;
/
/
Replay
around
0
but
out
side
of
the
1024
window
should
fail
.
-
SetBE16
(
rtp_packet_
.
MutableData
<
uint8_t
>
(
)
+
2
+
SetBE16
(
reinterpret_cast
<
uint8_t
*
>
(
rtp_packet_
)
+
2
kMaxSeqnum
+
seqnum_small
-
replay_window
-
1
)
;
-
EXPECT_FALSE
(
s1_
.
ProtectRtp
(
rtp_packet_
)
)
;
-
rtp_packet_
.
SetData
(
kPcmuFrame
sizeof
(
kPcmuFrame
)
)
;
+
EXPECT_FALSE
(
+
s1_
.
ProtectRtp
(
rtp_packet_
rtp_len_
sizeof
(
rtp_packet_
)
&
out_len
)
)
;
/
/
Replay
around
0
but
within
the
1024
window
should
succeed
.
for
(
uint16_t
seqnum
=
65000
;
seqnum
<
65003
;
+
+
seqnum
)
{
-
SetBE16
(
rtp_packet_
.
MutableData
<
uint8_t
>
(
)
+
2
seqnum
)
;
-
EXPECT_TRUE
(
s1_
.
ProtectRtp
(
rtp_packet_
)
)
;
-
rtp_packet_
.
SetData
(
kPcmuFrame
sizeof
(
kPcmuFrame
)
)
;
+
SetBE16
(
reinterpret_cast
<
uint8_t
*
>
(
rtp_packet_
)
+
2
seqnum
)
;
+
EXPECT_TRUE
(
+
s1_
.
ProtectRtp
(
rtp_packet_
rtp_len_
sizeof
(
rtp_packet_
)
&
out_len
)
)
;
}
/
/
Go
back
to
normal
sequence
nubmer
.
-
252
8
+
249
9
TEST_F
(
SrtpSessionTest
TestReplay
)
{
/
/
without
the
fix
the
loop
above
would
keep
incrementing
local
sequence
/
/
number
in
libsrtp
eventually
the
new
sequence
number
would
go
out
side
/
/
of
the
window
.
-
SetBE16
(
rtp_packet_
.
MutableData
<
uint8_t
>
(
)
+
2
seqnum_small
+
1
)
;
-
EXPECT_TRUE
(
s1_
.
ProtectRtp
(
rtp_packet_
)
)
;
+
SetBE16
(
reinterpret_cast
<
uint8_t
*
>
(
rtp_packet_
)
+
2
seqnum_small
+
1
)
;
+
EXPECT_TRUE
(
+
s1_
.
ProtectRtp
(
rtp_packet_
rtp_len_
sizeof
(
rtp_packet_
)
&
out_len
)
)
;
}
TEST_F
(
SrtpSessionTest
RemoveSsrc
)
{
-
261
32
+
259
33
TEST_F
(
SrtpSessionTest
RemoveSsrc
)
{
kEncryptedHeaderExtensionIds
)
)
;
EXPECT_TRUE
(
s2_
.
SetReceive
(
kSrtpAes128CmSha1_80
kTestKey1
kEncryptedHeaderExtensionIds
)
)
;
+
int
out_len
;
/
/
Encrypt
and
decrypt
the
packet
once
.
-
EXPECT_TRUE
(
s1_
.
ProtectRtp
(
rtp_packet_
)
)
;
-
EXPECT_TRUE
(
s2_
.
UnprotectRtp
(
rtp_packet_
)
)
;
-
EXPECT_EQ
(
sizeof
(
kPcmuFrame
)
rtp_packet_
.
size
(
)
)
;
-
EXPECT_EQ
(
0
std
:
:
memcmp
(
kPcmuFrame
rtp_packet_
.
data
(
)
rtp_packet_
.
size
(
)
)
)
;
+
EXPECT_TRUE
(
+
s1_
.
ProtectRtp
(
rtp_packet_
rtp_len_
sizeof
(
rtp_packet_
)
&
out_len
)
)
;
+
EXPECT_TRUE
(
s2_
.
UnprotectRtp
(
rtp_packet_
out_len
&
out_len
)
)
;
+
EXPECT_EQ
(
rtp_len_
out_len
)
;
+
EXPECT_EQ
(
0
memcmp
(
rtp_packet_
kPcmuFrame
out_len
)
)
;
/
/
Recreate
the
original
packet
and
encrypt
again
.
-
rtp_packet_
.
SetData
(
kPcmuFrame
sizeof
(
kPcmuFrame
)
)
;
-
EXPECT_TRUE
(
s1_
.
ProtectRtp
(
rtp_packet_
)
)
;
+
memcpy
(
rtp_packet_
kPcmuFrame
rtp_len_
)
;
+
EXPECT_TRUE
(
+
s1_
.
ProtectRtp
(
rtp_packet_
rtp_len_
sizeof
(
rtp_packet_
)
&
out_len
)
)
;
/
/
Attempting
to
decrypt
will
fail
as
a
replay
attack
.
/
/
(
srtp_err_status_replay_fail
)
since
the
sequence
number
was
already
seen
.
-
EXPECT_FALSE
(
s2_
.
UnprotectRtp
(
rtp_packet_
)
)
;
+
EXPECT_FALSE
(
s2_
.
UnprotectRtp
(
rtp_packet_
out_len
&
out_len
)
)
;
/
/
Remove
the
fake
packet
SSRC
1
from
the
session
.
EXPECT_TRUE
(
s2_
.
RemoveSsrcFromSession
(
1
)
)
;
EXPECT_FALSE
(
s2_
.
RemoveSsrcFromSession
(
1
)
)
;
/
/
Since
the
SRTP
state
was
discarded
this
is
no
longer
a
replay
attack
.
-
EXPECT_TRUE
(
s2_
.
UnprotectRtp
(
rtp_packet_
)
)
;
-
EXPECT_EQ
(
sizeof
(
kPcmuFrame
)
rtp_packet_
.
size
(
)
)
;
-
EXPECT_EQ
(
0
std
:
:
memcmp
(
kPcmuFrame
rtp_packet_
.
data
(
)
rtp_packet_
.
size
(
)
)
)
;
+
EXPECT_TRUE
(
s2_
.
UnprotectRtp
(
rtp_packet_
out_len
&
out_len
)
)
;
+
EXPECT_EQ
(
rtp_len_
out_len
)
;
+
EXPECT_EQ
(
0
memcmp
(
rtp_packet_
kPcmuFrame
out_len
)
)
;
EXPECT_TRUE
(
s2_
.
RemoveSsrcFromSession
(
1
)
)
;
}
-
#
pragma
clang
diagnostic
push
-
#
pragma
clang
diagnostic
ignored
"
-
Wdeprecated
-
declarations
"
TEST_F
(
SrtpSessionTest
ProtectUnprotectWrapAroundRocMismatch
)
{
/
/
This
unit
tests
demonstrates
why
you
should
be
careful
when
/
/
choosing
the
initial
RTP
sequence
number
as
there
can
be
decryption
-
317
7
+
316
6
TEST_F
(
SrtpSessionTest
ProtectUnprotectWrapAroundRocMismatch
)
{
0xFF
0xFF
0xFF
0xFF
0xFF
0xFF
0xFF
0xFF
0xFF
0xFF
/
/
clang
-
format
on
}
;
-
const
unsigned
char
kPayload
[
]
=
{
0xBE
0xEF
}
;
int
out_len
;
/
/
Encrypt
the
frames
in
-
order
.
There
is
a
sequence
number
rollover
from
-
339
12
+
337
9
TEST_F
(
SrtpSessionTest
ProtectUnprotectWrapAroundRocMismatch
)
{
EXPECT_FALSE
(
s2_
.
UnprotectRtp
(
kFrame2
sizeof
(
kFrame2
)
&
out_len
)
)
;
/
/
Decrypt
frame
1
.
EXPECT_TRUE
(
s2_
.
UnprotectRtp
(
kFrame1
sizeof
(
kFrame1
)
&
out_len
)
)
;
-
EXPECT_EQ
(
0
std
:
:
memcmp
(
kFrame1
+
12
kPayload
sizeof
(
kPayload
)
)
)
;
/
/
Now
decrypt
frame
2
again
.
A
rollover
is
detected
which
increases
/
/
the
ROC
to
1
so
this
succeeds
.
EXPECT_TRUE
(
s2_
.
UnprotectRtp
(
kFrame2
sizeof
(
kFrame2
)
&
out_len
)
)
;
-
EXPECT_EQ
(
0
std
:
:
memcmp
(
kFrame2
+
12
kPayload
sizeof
(
kPayload
)
)
)
;
}
-
#
pragma
clang
diagnostic
pop
}
/
/
namespace
rtc
diff
-
-
git
a
/
pc
/
srtp_transport
.
cc
b
/
pc
/
srtp_transport
.
cc
index
90992c1e1a
.
.
0f4acea090
100644
-
-
-
a
/
pc
/
srtp_transport
.
cc
+
+
+
b
/
pc
/
srtp_transport
.
cc
-
10
26
+
10
25
#
include
"
pc
/
srtp_transport
.
h
"
-
#
include
<
cstdint
>
-
#
include
<
optional
>
+
#
include
<
string
.
h
>
+
+
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
-
#
include
"
api
/
field_trials_view
.
h
"
-
#
include
"
api
/
units
/
timestamp
.
h
"
-
#
include
"
call
/
rtp_demuxer
.
h
"
+
#
include
"
absl
/
strings
/
match
.
h
"
#
include
"
media
/
base
/
rtp_utils
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_util
.
h
"
#
include
"
pc
/
rtp_transport
.
h
"
#
include
"
pc
/
srtp_session
.
h
"
#
include
"
rtc_base
/
async_packet_socket
.
h
"
-
#
include
"
rtc_base
/
buffer
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
copy_on_write_buffer
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
-
#
include
"
rtc_base
/
network
/
received_packet
.
h
"
-
#
include
"
rtc_base
/
network_route
.
h
"
+
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
+
#
include
"
rtc_base
/
ssl_stream_adapter
.
h
"
#
include
"
rtc_base
/
trace_event
.
h
"
+
#
include
"
rtc_base
/
zero_memory
.
h
"
namespace
webrtc
{
-
41
7
+
40
6
SrtpTransport
:
:
SrtpTransport
(
bool
rtcp_mux_enabled
bool
SrtpTransport
:
:
SendRtpPacket
(
rtc
:
:
CopyOnWriteBuffer
*
packet
const
rtc
:
:
PacketOptions
&
options
int
flags
)
{
-
RTC_DCHECK
(
packet
)
;
if
(
!
IsSrtpActive
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
send
the
packet
because
SRTP
transport
is
inactive
.
"
;
-
49
21
+
47
23
bool
SrtpTransport
:
:
SendRtpPacket
(
rtc
:
:
CopyOnWriteBuffer
*
packet
}
rtc
:
:
PacketOptions
updated_options
=
options
;
TRACE_EVENT0
(
"
webrtc
"
"
SRTP
Encode
"
)
;
-
/
/
If
ENABLE_EXTERNAL_AUTH
flag
is
on
then
packet
authentication
is
not
done
-
/
/
inside
libsrtp
for
a
RTP
packet
.
A
external
HMAC
module
will
be
writing
-
/
/
a
fake
HMAC
value
.
This
is
ONLY
done
for
a
RTP
packet
.
-
/
/
Socket
layer
will
update
rtp
sendtime
extension
header
if
present
in
-
/
/
packet
with
current
time
before
updating
the
HMAC
.
bool
res
;
+
uint8_t
*
data
=
packet
-
>
MutableData
(
)
;
+
int
len
=
rtc
:
:
checked_cast
<
int
>
(
packet
-
>
size
(
)
)
;
+
/
/
If
ENABLE_EXTERNAL_AUTH
flag
is
on
then
packet
authentication
is
not
done
+
/
/
inside
libsrtp
for
a
RTP
packet
.
A
external
HMAC
module
will
be
writing
+
/
/
a
fake
HMAC
value
.
This
is
ONLY
done
for
a
RTP
packet
.
+
/
/
Socket
layer
will
update
rtp
sendtime
extension
header
if
present
in
+
/
/
packet
with
current
time
before
updating
the
HMAC
.
#
if
!
defined
(
ENABLE_EXTERNAL_AUTH
)
-
res
=
ProtectRtp
(
*
packet
)
;
+
res
=
ProtectRtp
(
data
len
static_cast
<
int
>
(
packet
-
>
capacity
(
)
)
&
len
)
;
#
else
if
(
!
IsExternalAuthActive
(
)
)
{
-
res
=
ProtectRtp
(
*
packet
)
;
+
res
=
ProtectRtp
(
data
len
static_cast
<
int
>
(
packet
-
>
capacity
(
)
)
&
len
)
;
}
else
{
updated_options
.
packet_time_params
.
rtp_sendtime_extension_id
=
rtp_abs_sendtime_extn_id_
;
-
res
=
ProtectRtp
(
*
packet
+
res
=
ProtectRtp
(
data
len
static_cast
<
int
>
(
packet
-
>
capacity
(
)
)
&
len
&
updated_options
.
packet_time_params
.
srtp_packet_index
)
;
/
/
If
protection
succeeds
let
'
s
get
auth
params
from
srtp
.
if
(
res
)
{
-
83
18
+
83
19
bool
SrtpTransport
:
:
SendRtpPacket
(
rtc
:
:
CopyOnWriteBuffer
*
packet
if
(
!
res
)
{
uint16_t
seq_num
=
ParseRtpSequenceNumber
(
*
packet
)
;
uint32_t
ssrc
=
ParseRtpSsrc
(
*
packet
)
;
-
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
protect
RTP
packet
:
size
=
"
<
<
packet
-
>
size
(
)
+
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
protect
RTP
packet
:
size
=
"
<
<
len
<
<
"
seqnum
=
"
<
<
seq_num
<
<
"
SSRC
=
"
<
<
ssrc
;
return
false
;
}
+
/
/
Update
the
length
of
the
packet
now
that
we
'
ve
added
the
auth
tag
.
+
packet
-
>
SetSize
(
len
)
;
return
SendPacket
(
/
*
rtcp
=
*
/
false
packet
updated_options
flags
)
;
}
bool
SrtpTransport
:
:
SendRtcpPacket
(
rtc
:
:
CopyOnWriteBuffer
*
packet
const
rtc
:
:
PacketOptions
&
options
int
flags
)
{
-
RTC_DCHECK
(
packet
)
;
if
(
!
IsSrtpActive
(
)
)
{
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
send
the
packet
because
SRTP
transport
is
inactive
.
"
;
-
102
13
+
103
17
bool
SrtpTransport
:
:
SendRtcpPacket
(
rtc
:
:
CopyOnWriteBuffer
*
packet
}
TRACE_EVENT0
(
"
webrtc
"
"
SRTP
Encode
"
)
;
-
if
(
!
ProtectRtcp
(
*
packet
)
)
{
+
uint8_t
*
data
=
packet
-
>
MutableData
(
)
;
+
int
len
=
rtc
:
:
checked_cast
<
int
>
(
packet
-
>
size
(
)
)
;
+
if
(
!
ProtectRtcp
(
data
len
static_cast
<
int
>
(
packet
-
>
capacity
(
)
)
&
len
)
)
{
int
type
=
-
1
;
-
cricket
:
:
GetRtcpType
(
packet
-
>
data
(
)
packet
-
>
size
(
)
&
type
)
;
-
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
protect
RTCP
packet
:
size
=
"
-
<
<
packet
-
>
size
(
)
<
<
"
type
=
"
<
<
type
;
+
cricket
:
:
GetRtcpType
(
data
len
&
type
)
;
+
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
protect
RTCP
packet
:
size
=
"
<
<
len
+
<
<
"
type
=
"
<
<
type
;
return
false
;
}
+
/
/
Update
the
length
of
the
packet
now
that
we
'
ve
added
the
auth
tag
.
+
packet
-
>
SetSize
(
len
)
;
return
SendPacket
(
/
*
rtcp
=
*
/
true
packet
options
flags
)
;
}
-
122
13
+
127
14
void
SrtpTransport
:
:
OnRtpPacketReceived
(
const
rtc
:
:
ReceivedPacket
&
packet
)
{
}
rtc
:
:
CopyOnWriteBuffer
payload
(
packet
.
payload
(
)
)
;
-
if
(
!
UnprotectRtp
(
payload
)
)
{
+
char
*
data
=
payload
.
MutableData
<
char
>
(
)
;
+
int
len
=
rtc
:
:
checked_cast
<
int
>
(
payload
.
size
(
)
)
;
+
if
(
!
UnprotectRtp
(
data
len
&
len
)
)
{
/
/
Limit
the
error
logging
to
avoid
excessive
logs
when
there
are
lots
of
/
/
bad
packets
.
const
int
kFailureLogThrottleCount
=
100
;
if
(
decryption_failure_count_
%
kFailureLogThrottleCount
=
=
0
)
{
-
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
unprotect
RTP
packet
:
size
=
"
-
<
<
payload
.
size
(
)
+
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
unprotect
RTP
packet
:
size
=
"
<
<
len
<
<
"
seqnum
=
"
<
<
ParseRtpSequenceNumber
(
payload
)
<
<
"
SSRC
=
"
<
<
ParseRtpSsrc
(
payload
)
<
<
"
previous
failure
count
:
"
-
137
6
+
143
7
void
SrtpTransport
:
:
OnRtpPacketReceived
(
const
rtc
:
:
ReceivedPacket
&
packet
)
{
+
+
decryption_failure_count_
;
return
;
}
+
payload
.
SetSize
(
len
)
;
DemuxPacket
(
std
:
:
move
(
payload
)
packet
.
arrival_time
(
)
.
value_or
(
Timestamp
:
:
MinusInfinity
(
)
)
packet
.
ecn
(
)
)
;
-
150
13
+
157
16
void
SrtpTransport
:
:
OnRtcpPacketReceived
(
const
rtc
:
:
ReceivedPacket
&
packet
)
{
return
;
}
rtc
:
:
CopyOnWriteBuffer
payload
(
packet
.
payload
(
)
)
;
-
if
(
!
UnprotectRtcp
(
payload
)
)
{
+
char
*
data
=
payload
.
MutableData
<
char
>
(
)
;
+
int
len
=
rtc
:
:
checked_cast
<
int
>
(
payload
.
size
(
)
)
;
+
if
(
!
UnprotectRtcp
(
data
len
&
len
)
)
{
int
type
=
-
1
;
-
cricket
:
:
GetRtcpType
(
payload
.
data
(
)
payload
.
size
(
)
&
type
)
;
-
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
unprotect
RTCP
packet
:
size
=
"
-
<
<
payload
.
size
(
)
<
<
"
type
=
"
<
<
type
;
+
cricket
:
:
GetRtcpType
(
data
len
&
type
)
;
+
RTC_LOG
(
LS_ERROR
)
<
<
"
Failed
to
unprotect
RTCP
packet
:
size
=
"
<
<
len
+
<
<
"
type
=
"
<
<
type
;
return
;
}
+
payload
.
SetSize
(
len
)
;
SendRtcpPacketReceived
(
&
payload
packet
.
arrival_time
(
)
?
packet
.
arrival_time
(
)
-
>
us
(
)
:
-
1
)
;
}
-
281
56
+
291
63
void
SrtpTransport
:
:
CreateSrtpSessions
(
)
{
}
}
-
bool
SrtpTransport
:
:
ProtectRtp
(
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
{
+
bool
SrtpTransport
:
:
ProtectRtp
(
void
*
p
int
in_len
int
max_len
int
*
out_len
)
{
if
(
!
IsSrtpActive
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
ProtectRtp
:
SRTP
not
active
"
;
return
false
;
}
RTC_CHECK
(
send_session_
)
;
-
return
send_session_
-
>
ProtectRtp
(
buffer
)
;
+
return
send_session_
-
>
ProtectRtp
(
p
in_len
max_len
out_len
)
;
}
-
bool
SrtpTransport
:
:
ProtectRtp
(
rtc
:
:
CopyOnWriteBuffer
&
buffer
int64_t
*
index
)
{
+
bool
SrtpTransport
:
:
ProtectRtp
(
void
*
p
+
int
in_len
+
int
max_len
+
int
*
out_len
+
int64_t
*
index
)
{
if
(
!
IsSrtpActive
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
ProtectRtp
:
SRTP
not
active
"
;
return
false
;
}
RTC_CHECK
(
send_session_
)
;
-
return
send_session_
-
>
ProtectRtp
(
buffer
index
)
;
+
return
send_session_
-
>
ProtectRtp
(
p
in_len
max_len
out_len
index
)
;
}
-
bool
SrtpTransport
:
:
ProtectRtcp
(
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
{
+
bool
SrtpTransport
:
:
ProtectRtcp
(
void
*
p
+
int
in_len
+
int
max_len
+
int
*
out_len
)
{
if
(
!
IsSrtpActive
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
ProtectRtcp
:
SRTP
not
active
"
;
return
false
;
}
if
(
send_rtcp_session_
)
{
-
return
send_rtcp_session_
-
>
ProtectRtcp
(
buffer
)
;
+
return
send_rtcp_session_
-
>
ProtectRtcp
(
p
in_len
max_len
out_len
)
;
}
else
{
RTC_CHECK
(
send_session_
)
;
-
return
send_session_
-
>
ProtectRtcp
(
buffer
)
;
+
return
send_session_
-
>
ProtectRtcp
(
p
in_len
max_len
out_len
)
;
}
}
-
bool
SrtpTransport
:
:
UnprotectRtp
(
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
{
+
bool
SrtpTransport
:
:
UnprotectRtp
(
void
*
p
int
in_len
int
*
out_len
)
{
if
(
!
IsSrtpActive
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
UnprotectRtp
:
SRTP
not
active
"
;
return
false
;
}
RTC_CHECK
(
recv_session_
)
;
-
return
recv_session_
-
>
UnprotectRtp
(
buffer
)
;
+
return
recv_session_
-
>
UnprotectRtp
(
p
in_len
out_len
)
;
}
-
bool
SrtpTransport
:
:
UnprotectRtcp
(
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
{
+
bool
SrtpTransport
:
:
UnprotectRtcp
(
void
*
p
int
in_len
int
*
out_len
)
{
if
(
!
IsSrtpActive
(
)
)
{
RTC_LOG
(
LS_WARNING
)
<
<
"
Failed
to
UnprotectRtcp
:
SRTP
not
active
"
;
return
false
;
}
if
(
recv_rtcp_session_
)
{
-
return
recv_rtcp_session_
-
>
UnprotectRtcp
(
buffer
)
;
+
return
recv_rtcp_session_
-
>
UnprotectRtcp
(
p
in_len
out_len
)
;
}
else
{
RTC_CHECK
(
recv_session_
)
;
-
return
recv_session_
-
>
UnprotectRtcp
(
buffer
)
;
+
return
recv_session_
-
>
UnprotectRtcp
(
p
in_len
out_len
)
;
}
}
diff
-
-
git
a
/
pc
/
srtp_transport
.
h
b
/
pc
/
srtp_transport
.
h
index
f5ddc46faa
.
.
dd86006ee1
100644
-
-
-
a
/
pc
/
srtp_transport
.
h
+
+
+
b
/
pc
/
srtp_transport
.
h
-
20
14
+
20
13
#
include
<
vector
>
#
include
"
api
/
field_trials_view
.
h
"
-
#
include
"
call
/
rtp_demuxer
.
h
"
+
#
include
"
api
/
rtc_error
.
h
"
#
include
"
p2p
/
base
/
packet_transport_internal
.
h
"
#
include
"
pc
/
rtp_transport
.
h
"
#
include
"
pc
/
srtp_session
.
h
"
#
include
"
rtc_base
/
async_packet_socket
.
h
"
#
include
"
rtc_base
/
buffer
.
h
"
#
include
"
rtc_base
/
copy_on_write_buffer
.
h
"
-
#
include
"
rtc_base
/
network
/
received_packet
.
h
"
#
include
"
rtc_base
/
network_route
.
h
"
namespace
webrtc
{
-
122
15
+
121
21
class
SrtpTransport
:
public
RtpTransport
{
/
/
Override
the
RtpTransport
:
:
OnWritableState
.
void
OnWritableState
(
rtc
:
:
PacketTransportInternal
*
packet_transport
)
override
;
-
bool
ProtectRtp
(
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
;
+
bool
ProtectRtp
(
void
*
data
int
in_len
int
max_len
int
*
out_len
)
;
+
/
/
Overloaded
version
outputs
packet
index
.
-
bool
ProtectRtp
(
rtc
:
:
CopyOnWriteBuffer
&
buffer
int64_t
*
index
)
;
-
bool
ProtectRtcp
(
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
;
+
bool
ProtectRtp
(
void
*
data
+
int
in_len
+
int
max_len
+
int
*
out_len
+
int64_t
*
index
)
;
+
bool
ProtectRtcp
(
void
*
data
int
in_len
int
max_len
int
*
out_len
)
;
/
/
Decrypts
/
verifies
an
invidiual
RTP
/
RTCP
packet
.
/
/
If
an
HMAC
is
used
this
will
decrease
the
packet
size
.
-
bool
UnprotectRtp
(
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
;
-
bool
UnprotectRtcp
(
rtc
:
:
CopyOnWriteBuffer
&
buffer
)
;
+
bool
UnprotectRtp
(
void
*
data
int
in_len
int
*
out_len
)
;
+
+
bool
UnprotectRtcp
(
void
*
data
int
in_len
int
*
out_len
)
;
const
std
:
:
string
content_name_
;
