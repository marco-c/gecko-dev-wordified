From
:
Michael
Froman
<
mjfroman
mac
.
com
>
Date
:
Tue
19
Nov
2024
11
:
34
:
14
-
0600
Subject
:
(
tmp
-
cherry
-
pick
)
Revert
"
Delete
AcmReceiver
"
(
0a281e2c1a
)
MIME
-
Version
:
1
.
0
Content
-
Type
:
text
/
plain
;
charset
=
UTF
-
8
Content
-
Transfer
-
Encoding
:
8bit
This
reverts
commit
0d3dcc499767166b32a941abc9563e259ce1770f
.
Reason
for
revert
:
Potentially
causing
downstream
issues
.
Revert
and
investigate
.
Original
change
'
s
description
:
>
Delete
AcmReceiver
>
>
The
code
now
uses
NetEq
directly
instead
of
AcmReceiver
.
>
>
Bug
:
webrtc
:
14867
>
Change
-
Id
:
I11c7e2ca00060ab15bba5ec67dfd92ec413196f6
>
Reviewed
-
on
:
https
:
/
/
webrtc
-
review
.
googlesource
.
com
/
c
/
src
/
+
/
364140
>
Commit
-
Queue
:
Henrik
Lundin
<
henrik
.
lundin
webrtc
.
org
>
>
Reviewed
-
by
:
Jakob
Ivarsson
<
jakobi
webrtc
.
org
>
>
Cr
-
Commit
-
Position
:
refs
/
heads
/
main
{
#
43108
}
Bug
:
webrtc
:
14867
Change
-
Id
:
Icf82d9d8148d219563a1a7edd472b28349599e31
No
-
Presubmit
:
true
No
-
Tree
-
Checks
:
true
No
-
Try
:
true
Reviewed
-
on
:
https
:
/
/
webrtc
-
review
.
googlesource
.
com
/
c
/
src
/
+
/
364261
Commit
-
Queue
:
Henrik
Lundin
<
henrik
.
lundin
webrtc
.
org
>
Auto
-
Submit
:
Henrik
Lundin
<
henrik
.
lundin
webrtc
.
org
>
Reviewed
-
by
:
Henrik
Lundin
<
henrik
.
lundin
webrtc
.
org
>
Bot
-
Commit
:
rubber
-
stamper
appspot
.
gserviceaccount
.
com
<
rubber
-
stamper
appspot
.
gserviceaccount
.
com
>
Cr
-
Commit
-
Position
:
refs
/
heads
/
main
{
#
43111
}
-
-
-
modules
/
audio_coding
/
BUILD
.
gn
|
3
+
modules
/
audio_coding
/
acm2
/
acm_receiver
.
cc
|
273
+
+
+
+
+
+
+
+
+
+
+
+
modules
/
audio_coding
/
acm2
/
acm_receiver
.
h
|
236
+
+
+
+
+
+
+
+
+
+
.
.
.
/
acm2
/
acm_receiver_unittest
.
cc
|
418
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
4
files
changed
930
insertions
(
+
)
create
mode
100644
modules
/
audio_coding
/
acm2
/
acm_receiver
.
cc
create
mode
100644
modules
/
audio_coding
/
acm2
/
acm_receiver
.
h
create
mode
100644
modules
/
audio_coding
/
acm2
/
acm_receiver_unittest
.
cc
diff
-
-
git
a
/
modules
/
audio_coding
/
BUILD
.
gn
b
/
modules
/
audio_coding
/
BUILD
.
gn
index
30d66566af
.
.
c77719a135
100644
-
-
-
a
/
modules
/
audio_coding
/
BUILD
.
gn
+
+
+
b
/
modules
/
audio_coding
/
BUILD
.
gn
-
22
6
+
22
8
rtc_source_set
(
"
audio_coding_module_typedefs
"
)
{
rtc_library
(
"
audio_coding
"
)
{
visibility
+
=
[
"
*
"
]
sources
=
[
+
"
acm2
/
acm_receiver
.
cc
"
+
"
acm2
/
acm_receiver
.
h
"
"
acm2
/
acm_remixing
.
cc
"
"
acm2
/
acm_remixing
.
h
"
"
acm2
/
acm_resampler
.
cc
"
-
1569
6
+
1571
7
if
(
rtc_include_tests
)
{
visibility
+
=
webrtc_default_visibility
sources
=
[
+
"
acm2
/
acm_receiver_unittest
.
cc
"
"
acm2
/
acm_remixing_unittest
.
cc
"
"
acm2
/
audio_coding_module_unittest
.
cc
"
"
acm2
/
call_statistics_unittest
.
cc
"
diff
-
-
git
a
/
modules
/
audio_coding
/
acm2
/
acm_receiver
.
cc
b
/
modules
/
audio_coding
/
acm2
/
acm_receiver
.
cc
new
file
mode
100644
index
0000000000
.
.
674ed868c9
-
-
-
/
dev
/
null
+
+
+
b
/
modules
/
audio_coding
/
acm2
/
acm_receiver
.
cc
-
0
0
+
1
273
+
/
*
+
*
Copyright
(
c
)
2013
The
WebRTC
project
authors
.
All
Rights
Reserved
.
+
*
+
*
Use
of
this
source
code
is
governed
by
a
BSD
-
style
license
+
*
that
can
be
found
in
the
LICENSE
file
in
the
root
of
the
source
+
*
tree
.
An
additional
intellectual
property
rights
grant
can
be
found
+
*
in
the
file
PATENTS
.
All
contributing
project
authors
may
+
*
be
found
in
the
AUTHORS
file
in
the
root
of
the
source
tree
.
+
*
/
+
+
#
include
"
modules
/
audio_coding
/
acm2
/
acm_receiver
.
h
"
+
+
#
include
<
stdlib
.
h
>
+
#
include
<
string
.
h
>
+
+
#
include
<
cstdint
>
+
#
include
<
vector
>
+
+
#
include
"
absl
/
strings
/
match
.
h
"
+
#
include
"
api
/
audio
/
audio_frame
.
h
"
+
#
include
"
api
/
audio_codecs
/
audio_decoder
.
h
"
+
#
include
"
api
/
neteq
/
default_neteq_factory
.
h
"
+
#
include
"
api
/
neteq
/
neteq
.
h
"
+
#
include
"
api
/
units
/
timestamp
.
h
"
+
#
include
"
modules
/
audio_coding
/
acm2
/
acm_resampler
.
h
"
+
#
include
"
modules
/
audio_coding
/
acm2
/
call_statistics
.
h
"
+
#
include
"
rtc_base
/
checks
.
h
"
+
#
include
"
rtc_base
/
logging
.
h
"
+
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
+
#
include
"
rtc_base
/
strings
/
audio_format_to_string
.
h
"
+
#
include
"
system_wrappers
/
include
/
clock
.
h
"
+
+
namespace
webrtc
{
+
+
namespace
acm2
{
+
+
namespace
{
+
+
std
:
:
unique_ptr
<
NetEq
>
CreateNetEq
(
+
NetEqFactory
*
neteq_factory
+
const
NetEq
:
:
Config
&
config
+
const
Environment
&
env
+
scoped_refptr
<
AudioDecoderFactory
>
decoder_factory
)
{
+
if
(
neteq_factory
)
{
+
return
neteq_factory
-
>
Create
(
env
config
std
:
:
move
(
decoder_factory
)
)
;
+
}
+
return
DefaultNetEqFactory
(
)
.
Create
(
env
config
std
:
:
move
(
decoder_factory
)
)
;
+
}
+
+
}
/
/
namespace
+
+
AcmReceiver
:
:
Config
:
:
Config
(
+
rtc
:
:
scoped_refptr
<
AudioDecoderFactory
>
decoder_factory
)
+
:
decoder_factory
(
decoder_factory
)
{
}
+
+
AcmReceiver
:
:
Config
:
:
Config
(
const
Config
&
)
=
default
;
+
AcmReceiver
:
:
Config
:
:
~
Config
(
)
=
default
;
+
+
AcmReceiver
:
:
AcmReceiver
(
const
Environment
&
env
Config
config
)
+
:
env_
(
env
)
+
neteq_
(
CreateNetEq
(
config
.
neteq_factory
+
config
.
neteq_config
+
env_
+
std
:
:
move
(
config
.
decoder_factory
)
)
)
{
}
+
+
AcmReceiver
:
:
~
AcmReceiver
(
)
=
default
;
+
+
int
AcmReceiver
:
:
SetMinimumDelay
(
int
delay_ms
)
{
+
if
(
neteq_
-
>
SetMinimumDelay
(
delay_ms
)
)
+
return
0
;
+
RTC_LOG
(
LS_ERROR
)
<
<
"
AcmReceiver
:
:
SetExtraDelay
"
<
<
delay_ms
;
+
return
-
1
;
+
}
+
+
int
AcmReceiver
:
:
SetMaximumDelay
(
int
delay_ms
)
{
+
if
(
neteq_
-
>
SetMaximumDelay
(
delay_ms
)
)
+
return
0
;
+
RTC_LOG
(
LS_ERROR
)
<
<
"
AcmReceiver
:
:
SetExtraDelay
"
<
<
delay_ms
;
+
return
-
1
;
+
}
+
+
bool
AcmReceiver
:
:
SetBaseMinimumDelayMs
(
int
delay_ms
)
{
+
return
neteq_
-
>
SetBaseMinimumDelayMs
(
delay_ms
)
;
+
}
+
+
int
AcmReceiver
:
:
GetBaseMinimumDelayMs
(
)
const
{
+
return
neteq_
-
>
GetBaseMinimumDelayMs
(
)
;
+
}
+
+
std
:
:
optional
<
int
>
AcmReceiver
:
:
last_packet_sample_rate_hz
(
)
const
{
+
std
:
:
optional
<
NetEq
:
:
DecoderFormat
>
decoder
=
+
neteq_
-
>
GetCurrentDecoderFormat
(
)
;
+
if
(
!
decoder
)
{
+
return
std
:
:
nullopt
;
+
}
+
return
decoder
-
>
sample_rate_hz
;
+
}
+
+
int
AcmReceiver
:
:
last_output_sample_rate_hz
(
)
const
{
+
return
neteq_
-
>
last_output_sample_rate_hz
(
)
;
+
}
+
+
int
AcmReceiver
:
:
InsertPacket
(
const
RTPHeader
&
rtp_header
+
rtc
:
:
ArrayView
<
const
uint8_t
>
incoming_payload
+
Timestamp
receive_time
)
{
+
if
(
incoming_payload
.
empty
(
)
)
{
+
neteq_
-
>
InsertEmptyPacket
(
rtp_header
)
;
+
return
0
;
+
}
+
if
(
neteq_
-
>
InsertPacket
(
rtp_header
incoming_payload
receive_time
)
<
0
)
{
+
RTC_LOG
(
LS_ERROR
)
<
<
"
AcmReceiver
:
:
InsertPacket
"
+
<
<
static_cast
<
int
>
(
rtp_header
.
payloadType
)
+
<
<
"
Failed
to
insert
packet
"
;
+
return
-
1
;
+
}
+
return
0
;
+
}
+
+
int
AcmReceiver
:
:
GetAudio
(
int
desired_freq_hz
+
AudioFrame
*
audio_frame
+
bool
*
muted
)
{
+
int
current_sample_rate_hz
=
0
;
+
if
(
neteq_
-
>
GetAudio
(
audio_frame
muted
&
current_sample_rate_hz
)
!
=
+
NetEq
:
:
kOK
)
{
+
RTC_LOG
(
LS_ERROR
)
<
<
"
AcmReceiver
:
:
GetAudio
-
NetEq
Failed
.
"
;
+
return
-
1
;
+
}
+
RTC_DCHECK_EQ
(
audio_frame
-
>
sample_rate_hz_
current_sample_rate_hz
)
;
+
+
/
/
Accessing
members
take
the
lock
.
+
MutexLock
lock
(
&
mutex_
)
;
+
if
(
!
resampler_helper_
.
MaybeResample
(
desired_freq_hz
audio_frame
)
)
{
+
return
-
1
;
+
}
+
call_stats_
.
DecodedByNetEq
(
audio_frame
-
>
speech_type_
audio_frame
-
>
muted
(
)
)
;
+
return
0
;
+
}
+
+
void
AcmReceiver
:
:
SetCodecs
(
const
std
:
:
map
<
int
SdpAudioFormat
>
&
codecs
)
{
+
neteq_
-
>
SetCodecs
(
codecs
)
;
+
}
+
+
void
AcmReceiver
:
:
FlushBuffers
(
)
{
+
neteq_
-
>
FlushBuffers
(
)
;
+
}
+
+
std
:
:
optional
<
uint32_t
>
AcmReceiver
:
:
GetPlayoutTimestamp
(
)
{
+
return
neteq_
-
>
GetPlayoutTimestamp
(
)
;
+
}
+
+
int
AcmReceiver
:
:
FilteredCurrentDelayMs
(
)
const
{
+
return
neteq_
-
>
FilteredCurrentDelayMs
(
)
;
+
}
+
+
int
AcmReceiver
:
:
TargetDelayMs
(
)
const
{
+
return
neteq_
-
>
TargetDelayMs
(
)
;
+
}
+
+
std
:
:
optional
<
std
:
:
pair
<
int
SdpAudioFormat
>
>
AcmReceiver
:
:
LastDecoder
(
)
const
{
+
std
:
:
optional
<
NetEq
:
:
DecoderFormat
>
decoder
=
+
neteq_
-
>
GetCurrentDecoderFormat
(
)
;
+
if
(
!
decoder
)
{
+
return
std
:
:
nullopt
;
+
}
+
return
std
:
:
make_pair
(
decoder
-
>
payload_type
decoder
-
>
sdp_format
)
;
+
}
+
+
void
AcmReceiver
:
:
GetNetworkStatistics
(
+
NetworkStatistics
*
acm_stat
+
bool
get_and_clear_legacy_stats
/
*
=
true
*
/
)
const
{
+
NetEqNetworkStatistics
neteq_stat
;
+
if
(
get_and_clear_legacy_stats
)
{
+
/
/
NetEq
function
always
returns
zero
so
we
don
'
t
check
the
return
value
.
+
neteq_
-
>
NetworkStatistics
(
&
neteq_stat
)
;
+
+
acm_stat
-
>
currentExpandRate
=
neteq_stat
.
expand_rate
;
+
acm_stat
-
>
currentSpeechExpandRate
=
neteq_stat
.
speech_expand_rate
;
+
acm_stat
-
>
currentPreemptiveRate
=
neteq_stat
.
preemptive_rate
;
+
acm_stat
-
>
currentAccelerateRate
=
neteq_stat
.
accelerate_rate
;
+
acm_stat
-
>
currentSecondaryDecodedRate
=
neteq_stat
.
secondary_decoded_rate
;
+
acm_stat
-
>
currentSecondaryDiscardedRate
=
+
neteq_stat
.
secondary_discarded_rate
;
+
acm_stat
-
>
meanWaitingTimeMs
=
neteq_stat
.
mean_waiting_time_ms
;
+
acm_stat
-
>
maxWaitingTimeMs
=
neteq_stat
.
max_waiting_time_ms
;
+
}
else
{
+
neteq_stat
=
neteq_
-
>
CurrentNetworkStatistics
(
)
;
+
acm_stat
-
>
currentExpandRate
=
0
;
+
acm_stat
-
>
currentSpeechExpandRate
=
0
;
+
acm_stat
-
>
currentPreemptiveRate
=
0
;
+
acm_stat
-
>
currentAccelerateRate
=
0
;
+
acm_stat
-
>
currentSecondaryDecodedRate
=
0
;
+
acm_stat
-
>
currentSecondaryDiscardedRate
=
0
;
+
acm_stat
-
>
meanWaitingTimeMs
=
-
1
;
+
acm_stat
-
>
maxWaitingTimeMs
=
1
;
+
}
+
acm_stat
-
>
currentBufferSize
=
neteq_stat
.
current_buffer_size_ms
;
+
acm_stat
-
>
preferredBufferSize
=
neteq_stat
.
preferred_buffer_size_ms
;
+
acm_stat
-
>
jitterPeaksFound
=
neteq_stat
.
jitter_peaks_found
?
true
:
false
;
+
+
NetEqLifetimeStatistics
neteq_lifetime_stat
=
neteq_
-
>
GetLifetimeStatistics
(
)
;
+
acm_stat
-
>
totalSamplesReceived
=
neteq_lifetime_stat
.
total_samples_received
;
+
acm_stat
-
>
concealedSamples
=
neteq_lifetime_stat
.
concealed_samples
;
+
acm_stat
-
>
silentConcealedSamples
=
+
neteq_lifetime_stat
.
silent_concealed_samples
;
+
acm_stat
-
>
concealmentEvents
=
neteq_lifetime_stat
.
concealment_events
;
+
acm_stat
-
>
jitterBufferDelayMs
=
neteq_lifetime_stat
.
jitter_buffer_delay_ms
;
+
acm_stat
-
>
jitterBufferTargetDelayMs
=
+
neteq_lifetime_stat
.
jitter_buffer_target_delay_ms
;
+
acm_stat
-
>
jitterBufferMinimumDelayMs
=
+
neteq_lifetime_stat
.
jitter_buffer_minimum_delay_ms
;
+
acm_stat
-
>
jitterBufferEmittedCount
=
+
neteq_lifetime_stat
.
jitter_buffer_emitted_count
;
+
acm_stat
-
>
delayedPacketOutageSamples
=
+
neteq_lifetime_stat
.
delayed_packet_outage_samples
;
+
acm_stat
-
>
relativePacketArrivalDelayMs
=
+
neteq_lifetime_stat
.
relative_packet_arrival_delay_ms
;
+
acm_stat
-
>
interruptionCount
=
neteq_lifetime_stat
.
interruption_count
;
+
acm_stat
-
>
totalInterruptionDurationMs
=
+
neteq_lifetime_stat
.
total_interruption_duration_ms
;
+
acm_stat
-
>
insertedSamplesForDeceleration
=
+
neteq_lifetime_stat
.
inserted_samples_for_deceleration
;
+
acm_stat
-
>
removedSamplesForAcceleration
=
+
neteq_lifetime_stat
.
removed_samples_for_acceleration
;
+
acm_stat
-
>
fecPacketsReceived
=
neteq_lifetime_stat
.
fec_packets_received
;
+
acm_stat
-
>
fecPacketsDiscarded
=
neteq_lifetime_stat
.
fec_packets_discarded
;
+
acm_stat
-
>
totalProcessingDelayUs
=
+
neteq_lifetime_stat
.
total_processing_delay_us
;
+
acm_stat
-
>
packetsDiscarded
=
neteq_lifetime_stat
.
packets_discarded
;
+
+
NetEqOperationsAndState
neteq_operations_and_state
=
+
neteq_
-
>
GetOperationsAndState
(
)
;
+
acm_stat
-
>
packetBufferFlushes
=
+
neteq_operations_and_state
.
packet_buffer_flushes
;
+
}
+
+
int
AcmReceiver
:
:
EnableNack
(
size_t
max_nack_list_size
)
{
+
neteq_
-
>
EnableNack
(
max_nack_list_size
)
;
+
return
0
;
+
}
+
+
void
AcmReceiver
:
:
DisableNack
(
)
{
+
neteq_
-
>
DisableNack
(
)
;
+
}
+
+
std
:
:
vector
<
uint16_t
>
AcmReceiver
:
:
GetNackList
(
+
int64_t
round_trip_time_ms
)
const
{
+
return
neteq_
-
>
GetNackList
(
round_trip_time_ms
)
;
+
}
+
+
void
AcmReceiver
:
:
ResetInitialDelay
(
)
{
+
neteq_
-
>
SetMinimumDelay
(
0
)
;
+
/
/
TODO
(
turajs
)
:
Should
NetEq
Buffer
be
flushed
?
+
}
+
+
uint32_t
AcmReceiver
:
:
NowInTimestamp
(
int
decoder_sampling_rate
)
const
{
+
/
/
Down
-
cast
the
time
to
(
32
-
6
)
-
bit
since
we
only
care
about
+
/
/
the
least
significant
bits
.
(
32
-
6
)
bits
cover
2
^
(
32
-
6
)
=
67108864
ms
.
+
/
/
We
masked
6
most
significant
bits
of
32
-
bit
so
there
is
no
overflow
in
+
/
/
the
conversion
from
milliseconds
to
timestamp
.
+
const
uint32_t
now_in_ms
=
+
static_cast
<
uint32_t
>
(
env_
.
clock
(
)
.
TimeInMilliseconds
(
)
&
0x03ffffff
)
;
+
return
static_cast
<
uint32_t
>
(
(
decoder_sampling_rate
/
1000
)
*
now_in_ms
)
;
+
}
+
+
void
AcmReceiver
:
:
GetDecodingCallStatistics
(
+
AudioDecodingCallStats
*
stats
)
const
{
+
MutexLock
lock
(
&
mutex_
)
;
+
*
stats
=
call_stats_
.
GetDecodingStatistics
(
)
;
+
}
+
+
}
/
/
namespace
acm2
+
+
}
/
/
namespace
webrtc
diff
-
-
git
a
/
modules
/
audio_coding
/
acm2
/
acm_receiver
.
h
b
/
modules
/
audio_coding
/
acm2
/
acm_receiver
.
h
new
file
mode
100644
index
0000000000
.
.
47de3bc9fd
-
-
-
/
dev
/
null
+
+
+
b
/
modules
/
audio_coding
/
acm2
/
acm_receiver
.
h
-
0
0
+
1
236
+
/
*
+
*
Copyright
(
c
)
2013
The
WebRTC
project
authors
.
All
Rights
Reserved
.
+
*
+
*
Use
of
this
source
code
is
governed
by
a
BSD
-
style
license
+
*
that
can
be
found
in
the
LICENSE
file
in
the
root
of
the
source
+
*
tree
.
An
additional
intellectual
property
rights
grant
can
be
found
+
*
in
the
file
PATENTS
.
All
contributing
project
authors
may
+
*
be
found
in
the
AUTHORS
file
in
the
root
of
the
source
tree
.
+
*
/
+
+
#
ifndef
MODULES_AUDIO_CODING_ACM2_ACM_RECEIVER_H_
+
#
define
MODULES_AUDIO_CODING_ACM2_ACM_RECEIVER_H_
+
+
#
include
<
stdint
.
h
>
+
+
#
include
<
array
>
+
#
include
<
map
>
+
#
include
<
memory
>
+
#
include
<
optional
>
+
#
include
<
string
>
+
#
include
<
utility
>
+
#
include
<
vector
>
+
+
#
include
"
api
/
array_view
.
h
"
+
#
include
"
api
/
audio
/
audio_frame
.
h
"
+
#
include
"
api
/
audio_codecs
/
audio_decoder
.
h
"
+
#
include
"
api
/
audio_codecs
/
audio_decoder_factory
.
h
"
+
#
include
"
api
/
audio_codecs
/
audio_format
.
h
"
+
#
include
"
api
/
environment
/
environment
.
h
"
+
#
include
"
api
/
neteq
/
neteq
.
h
"
+
#
include
"
api
/
neteq
/
neteq_factory
.
h
"
+
#
include
"
api
/
units
/
timestamp
.
h
"
+
#
include
"
modules
/
audio_coding
/
acm2
/
acm_resampler
.
h
"
+
#
include
"
modules
/
audio_coding
/
acm2
/
call_statistics
.
h
"
+
#
include
"
modules
/
audio_coding
/
include
/
audio_coding_module_typedefs
.
h
"
+
#
include
"
rtc_base
/
synchronization
/
mutex
.
h
"
+
#
include
"
rtc_base
/
thread_annotations
.
h
"
+
+
namespace
webrtc
{
+
+
class
NetEq
;
+
struct
RTPHeader
;
+
+
namespace
acm2
{
+
+
/
/
This
class
is
deprecated
.
See
https
:
/
/
issues
.
webrtc
.
org
/
issues
/
42225167
.
+
class
AcmReceiver
{
+
public
:
+
struct
Config
{
+
explicit
Config
(
+
rtc
:
:
scoped_refptr
<
AudioDecoderFactory
>
decoder_factory
=
nullptr
)
;
+
Config
(
const
Config
&
)
;
+
~
Config
(
)
;
+
+
NetEq
:
:
Config
neteq_config
;
+
rtc
:
:
scoped_refptr
<
AudioDecoderFactory
>
decoder_factory
;
+
NetEqFactory
*
neteq_factory
=
nullptr
;
+
}
;
+
+
AcmReceiver
(
const
Environment
&
env
Config
config
)
;
+
+
/
/
Destructor
of
the
class
.
+
~
AcmReceiver
(
)
;
+
+
/
/
+
/
/
Inserts
a
payload
with
its
associated
RTP
-
header
into
NetEq
.
+
/
/
+
/
/
Input
:
+
/
/
-
rtp_header
:
RTP
header
for
the
incoming
payload
containing
+
/
/
information
about
payload
type
sequence
number
+
/
/
timestamp
SSRC
and
marker
bit
.
+
/
/
-
incoming_payload
:
Incoming
audio
payload
.
+
/
/
-
receive_time
:
Timestamp
when
the
packet
has
been
seen
on
the
+
/
/
network
card
.
+
/
/
+
/
/
Return
value
:
0
if
OK
.
+
/
/
<
0
if
NetEq
returned
an
error
.
+
/
/
+
int
InsertPacket
(
const
RTPHeader
&
rtp_header
+
rtc
:
:
ArrayView
<
const
uint8_t
>
incoming_payload
+
Timestamp
receive_time
=
Timestamp
:
:
MinusInfinity
(
)
)
;
+
+
/
/
+
/
/
Asks
NetEq
for
10
milliseconds
of
decoded
audio
.
+
/
/
+
/
/
Input
:
+
/
/
-
desired_freq_hz
:
specifies
the
sampling
rate
[
Hz
]
of
the
output
+
/
/
audio
.
If
set
-
1
indicates
to
resampling
is
+
/
/
is
required
and
the
audio
returned
at
the
+
/
/
sampling
rate
of
the
decoder
.
+
/
/
+
/
/
Output
:
+
/
/
-
audio_frame
:
an
audio
frame
were
output
data
and
+
/
/
associated
parameters
are
written
to
.
+
/
/
-
muted
:
if
true
the
sample
data
in
audio_frame
is
not
+
/
/
populated
and
must
be
interpreted
as
all
zero
.
+
/
/
+
/
/
Return
value
:
0
if
OK
.
+
/
/
-
1
if
NetEq
returned
an
error
.
+
/
/
+
int
GetAudio
(
int
desired_freq_hz
+
AudioFrame
*
audio_frame
+
bool
*
muted
=
nullptr
)
;
+
+
/
/
Replace
the
current
set
of
decoders
with
the
specified
set
.
+
void
SetCodecs
(
const
std
:
:
map
<
int
SdpAudioFormat
>
&
codecs
)
;
+
+
/
/
+
/
/
Sets
a
minimum
delay
for
packet
buffer
.
The
given
delay
is
maintained
+
/
/
unless
channel
condition
dictates
a
higher
delay
.
+
/
/
+
/
/
Input
:
+
/
/
-
delay_ms
:
minimum
delay
in
milliseconds
.
+
/
/
+
/
/
Return
value
:
0
if
OK
.
+
/
/
<
0
if
NetEq
returned
an
error
.
+
/
/
+
int
SetMinimumDelay
(
int
delay_ms
)
;
+
+
/
/
+
/
/
Sets
a
maximum
delay
[
ms
]
for
the
packet
buffer
.
The
target
delay
does
not
+
/
/
exceed
the
given
value
even
if
channel
condition
requires
so
.
+
/
/
+
/
/
Input
:
+
/
/
-
delay_ms
:
maximum
delay
in
milliseconds
.
+
/
/
+
/
/
Return
value
:
0
if
OK
.
+
/
/
<
0
if
NetEq
returned
an
error
.
+
/
/
+
int
SetMaximumDelay
(
int
delay_ms
)
;
+
+
/
/
Sets
a
base
minimum
delay
in
milliseconds
for
the
packet
buffer
.
+
/
/
Base
minimum
delay
sets
lower
bound
minimum
delay
value
which
+
/
/
is
set
via
SetMinimumDelay
.
+
/
/
+
/
/
Returns
true
if
value
was
successfully
set
false
overwise
.
+
bool
SetBaseMinimumDelayMs
(
int
delay_ms
)
;
+
+
/
/
Returns
current
value
of
base
minimum
delay
in
milliseconds
.
+
int
GetBaseMinimumDelayMs
(
)
const
;
+
+
/
/
+
/
/
Resets
the
initial
delay
to
zero
.
+
/
/
+
void
ResetInitialDelay
(
)
;
+
+
/
/
Returns
the
sample
rate
of
the
decoder
associated
with
the
last
incoming
+
/
/
packet
.
If
no
packet
of
a
registered
non
-
CNG
codec
has
been
received
the
+
/
/
return
value
is
empty
.
Also
if
the
decoder
was
unregistered
since
the
last
+
/
/
packet
was
inserted
the
return
value
is
empty
.
+
std
:
:
optional
<
int
>
last_packet_sample_rate_hz
(
)
const
;
+
+
/
/
Returns
last_output_sample_rate_hz
from
the
NetEq
instance
.
+
int
last_output_sample_rate_hz
(
)
const
;
+
+
/
/
+
/
/
Get
the
current
network
statistics
from
NetEq
.
+
/
/
+
/
/
Output
:
+
/
/
-
statistics
:
The
current
network
statistics
.
+
/
/
+
void
GetNetworkStatistics
(
NetworkStatistics
*
statistics
+
bool
get_and_clear_legacy_stats
=
true
)
const
;
+
+
/
/
+
/
/
Flushes
the
NetEq
packet
and
speech
buffers
.
+
/
/
+
void
FlushBuffers
(
)
;
+
+
/
/
Returns
the
RTP
timestamp
for
the
last
sample
delivered
by
GetAudio
(
)
.
+
/
/
The
return
value
will
be
empty
if
no
valid
timestamp
is
available
.
+
std
:
:
optional
<
uint32_t
>
GetPlayoutTimestamp
(
)
;
+
+
/
/
Returns
the
current
total
delay
from
NetEq
(
packet
buffer
and
sync
buffer
)
+
/
/
in
ms
with
smoothing
applied
to
even
out
short
-
time
fluctuations
due
to
+
/
/
jitter
.
The
packet
buffer
part
of
the
delay
is
not
updated
during
DTX
/
CNG
+
/
/
periods
.
+
/
/
+
int
FilteredCurrentDelayMs
(
)
const
;
+
+
/
/
Returns
the
current
target
delay
for
NetEq
in
ms
.
+
/
/
+
int
TargetDelayMs
(
)
const
;
+
+
/
/
+
/
/
Get
payload
type
and
format
of
the
last
non
-
CNG
/
non
-
DTMF
received
payload
.
+
/
/
If
no
non
-
CNG
/
non
-
DTMF
packet
is
received
std
:
:
nullopt
is
returned
.
+
/
/
+
std
:
:
optional
<
std
:
:
pair
<
int
SdpAudioFormat
>
>
LastDecoder
(
)
const
;
+
+
/
/
+
/
/
Enable
NACK
and
set
the
maximum
size
of
the
NACK
list
.
If
NACK
is
already
+
/
/
enabled
then
the
maximum
NACK
list
size
is
modified
accordingly
.
+
/
/
+
/
/
If
the
sequence
number
of
last
received
packet
is
N
the
sequence
numbers
+
/
/
of
NACK
list
are
in
the
range
of
[
N
-
max_nack_list_size
N
)
.
+
/
/
+
/
/
max_nack_list_size
should
be
positive
(
none
zero
)
and
less
than
or
+
/
/
equal
to
Nack
:
:
kNackListSizeLimit
.
Otherwise
No
change
is
applied
and
-
1
+
/
/
is
returned
.
0
is
returned
at
success
.
+
/
/
+
int
EnableNack
(
size_t
max_nack_list_size
)
;
+
+
/
/
Disable
NACK
.
+
void
DisableNack
(
)
;
+
+
/
/
+
/
/
Get
a
list
of
packets
to
be
retransmitted
.
round_trip_time_ms
is
an
+
/
/
estimate
of
the
round
-
trip
-
time
(
in
milliseconds
)
.
Missing
packets
which
+
/
/
will
be
playout
in
a
shorter
time
than
the
round
-
trip
-
time
(
with
respect
+
/
/
to
the
time
this
API
is
called
)
will
not
be
included
in
the
list
.
+
/
/
+
/
/
Negative
round_trip_time_ms
results
is
an
error
message
and
empty
list
+
/
/
is
returned
.
+
/
/
+
std
:
:
vector
<
uint16_t
>
GetNackList
(
int64_t
round_trip_time_ms
)
const
;
+
+
/
/
+
/
/
Get
statistics
of
calls
to
GetAudio
(
)
.
+
void
GetDecodingCallStatistics
(
AudioDecodingCallStats
*
stats
)
const
;
+
+
private
:
+
uint32_t
NowInTimestamp
(
int
decoder_sampling_rate
)
const
;
+
+
const
Environment
env_
;
+
mutable
Mutex
mutex_
;
+
CallStatistics
call_stats_
RTC_GUARDED_BY
(
mutex_
)
;
+
const
std
:
:
unique_ptr
<
NetEq
>
neteq_
;
/
/
NetEq
is
thread
-
safe
;
no
lock
needed
.
+
ResamplerHelper
resampler_helper_
RTC_GUARDED_BY
(
mutex_
)
;
+
}
;
+
+
}
/
/
namespace
acm2
+
+
}
/
/
namespace
webrtc
+
+
#
endif
/
/
MODULES_AUDIO_CODING_ACM2_ACM_RECEIVER_H_
diff
-
-
git
a
/
modules
/
audio_coding
/
acm2
/
acm_receiver_unittest
.
cc
b
/
modules
/
audio_coding
/
acm2
/
acm_receiver_unittest
.
cc
new
file
mode
100644
index
0000000000
.
.
55b5c49663
-
-
-
/
dev
/
null
+
+
+
b
/
modules
/
audio_coding
/
acm2
/
acm_receiver_unittest
.
cc
-
0
0
+
1
418
+
/
*
+
*
Copyright
(
c
)
2013
The
WebRTC
project
authors
.
All
Rights
Reserved
.
+
*
+
*
Use
of
this
source
code
is
governed
by
a
BSD
-
style
license
+
*
that
can
be
found
in
the
LICENSE
file
in
the
root
of
the
source
+
*
tree
.
An
additional
intellectual
property
rights
grant
can
be
found
+
*
in
the
file
PATENTS
.
All
contributing
project
authors
may
+
*
be
found
in
the
AUTHORS
file
in
the
root
of
the
source
tree
.
+
*
/
+
+
#
include
"
modules
/
audio_coding
/
acm2
/
acm_receiver
.
h
"
+
+
#
include
<
algorithm
>
/
/
std
:
:
min
+
#
include
<
memory
>
+
#
include
<
optional
>
+
+
#
include
"
api
/
audio_codecs
/
builtin_audio_decoder_factory
.
h
"
+
#
include
"
api
/
audio_codecs
/
builtin_audio_encoder_factory
.
h
"
+
#
include
"
api
/
environment
/
environment
.
h
"
+
#
include
"
api
/
environment
/
environment_factory
.
h
"
+
#
include
"
api
/
units
/
timestamp
.
h
"
+
#
include
"
modules
/
audio_coding
/
codecs
/
cng
/
audio_encoder_cng
.
h
"
+
#
include
"
modules
/
audio_coding
/
include
/
audio_coding_module
.
h
"
+
#
include
"
modules
/
audio_coding
/
neteq
/
tools
/
rtp_generator
.
h
"
+
#
include
"
modules
/
include
/
module_common_types
.
h
"
+
#
include
"
rtc_base
/
checks
.
h
"
+
#
include
"
rtc_base
/
numerics
/
safe_conversions
.
h
"
+
#
include
"
system_wrappers
/
include
/
clock
.
h
"
+
#
include
"
test
/
gtest
.
h
"
+
#
include
"
test
/
testsupport
/
file_utils
.
h
"
+
+
namespace
webrtc
{
+
+
namespace
acm2
{
+
+
class
AcmReceiverTestOldApi
:
public
AudioPacketizationCallback
+
public
:
:
testing
:
:
Test
{
+
protected
:
+
AcmReceiverTestOldApi
(
)
+
:
timestamp_
(
0
)
+
packet_sent_
(
false
)
+
last_packet_send_timestamp_
(
timestamp_
)
+
last_frame_type_
(
AudioFrameType
:
:
kEmptyFrame
)
{
+
config_
.
decoder_factory
=
decoder_factory_
;
+
}
+
+
~
AcmReceiverTestOldApi
(
)
{
}
+
+
void
SetUp
(
)
override
{
+
acm_
=
AudioCodingModule
:
:
Create
(
)
;
+
receiver_
=
std
:
:
make_unique
<
AcmReceiver
>
(
env_
config_
)
;
+
ASSERT_TRUE
(
receiver_
.
get
(
)
!
=
NULL
)
;
+
ASSERT_TRUE
(
acm_
.
get
(
)
!
=
NULL
)
;
+
acm_
-
>
RegisterTransportCallback
(
this
)
;
+
+
rtp_header_
.
sequenceNumber
=
0
;
+
rtp_header_
.
timestamp
=
0
;
+
rtp_header_
.
markerBit
=
false
;
+
rtp_header_
.
ssrc
=
0x12345678
;
/
/
Arbitrary
.
+
rtp_header_
.
numCSRCs
=
0
;
+
rtp_header_
.
payloadType
=
0
;
+
}
+
+
void
TearDown
(
)
override
{
}
+
+
AudioCodecInfo
SetEncoder
(
int
payload_type
+
const
SdpAudioFormat
&
format
+
const
std
:
:
map
<
int
int
>
cng_payload_types
=
{
}
)
{
+
/
/
Create
the
speech
encoder
.
+
std
:
:
optional
<
AudioCodecInfo
>
info
=
+
encoder_factory_
-
>
QueryAudioEncoder
(
format
)
;
+
RTC_CHECK
(
info
.
has_value
(
)
)
;
+
std
:
:
unique_ptr
<
AudioEncoder
>
enc
=
+
encoder_factory_
-
>
Create
(
env_
format
{
.
payload_type
=
payload_type
}
)
;
+
+
/
/
If
we
have
a
compatible
CN
specification
stack
a
CNG
on
top
.
+
auto
it
=
cng_payload_types
.
find
(
info
-
>
sample_rate_hz
)
;
+
if
(
it
!
=
cng_payload_types
.
end
(
)
)
{
+
AudioEncoderCngConfig
config
;
+
config
.
speech_encoder
=
std
:
:
move
(
enc
)
;
+
config
.
num_channels
=
1
;
+
config
.
payload_type
=
it
-
>
second
;
+
config
.
vad_mode
=
Vad
:
:
kVadNormal
;
+
enc
=
CreateComfortNoiseEncoder
(
std
:
:
move
(
config
)
)
;
+
}
+
+
/
/
Actually
start
using
the
new
encoder
.
+
acm_
-
>
SetEncoder
(
std
:
:
move
(
enc
)
)
;
+
return
*
info
;
+
}
+
+
int
InsertOnePacketOfSilence
(
const
AudioCodecInfo
&
info
)
{
+
/
/
Frame
setup
according
to
the
codec
.
+
AudioFrame
frame
;
+
frame
.
sample_rate_hz_
=
info
.
sample_rate_hz
;
+
frame
.
samples_per_channel_
=
info
.
sample_rate_hz
/
100
;
/
/
10
ms
.
+
frame
.
num_channels_
=
info
.
num_channels
;
+
frame
.
Mute
(
)
;
+
packet_sent_
=
false
;
+
last_packet_send_timestamp_
=
timestamp_
;
+
int
num_10ms_frames
=
0
;
+
while
(
!
packet_sent_
)
{
+
frame
.
timestamp_
=
timestamp_
;
+
timestamp_
+
=
rtc
:
:
checked_cast
<
uint32_t
>
(
frame
.
samples_per_channel_
)
;
+
EXPECT_GE
(
acm_
-
>
Add10MsData
(
frame
)
0
)
;
+
+
+
num_10ms_frames
;
+
}
+
return
num_10ms_frames
;
+
}
+
+
int
SendData
(
AudioFrameType
frame_type
+
uint8_t
payload_type
+
uint32_t
timestamp
+
const
uint8_t
*
payload_data
+
size_t
payload_len_bytes
+
int64_t
absolute_capture_timestamp_ms
)
override
{
+
if
(
frame_type
=
=
AudioFrameType
:
:
kEmptyFrame
)
+
return
0
;
+
+
rtp_header_
.
payloadType
=
payload_type
;
+
rtp_header_
.
timestamp
=
timestamp
;
+
+
int
ret_val
=
receiver_
-
>
InsertPacket
(
+
rtp_header_
+
rtc
:
:
ArrayView
<
const
uint8_t
>
(
payload_data
payload_len_bytes
)
+
Timestamp
:
:
MinusInfinity
(
)
)
;
+
if
(
ret_val
<
0
)
{
+
RTC_DCHECK_NOTREACHED
(
)
;
+
return
-
1
;
+
}
+
rtp_header_
.
sequenceNumber
+
+
;
+
packet_sent_
=
true
;
+
last_frame_type_
=
frame_type
;
+
return
0
;
+
}
+
+
const
Environment
env_
=
CreateEnvironment
(
)
;
+
const
rtc
:
:
scoped_refptr
<
AudioEncoderFactory
>
encoder_factory_
=
+
CreateBuiltinAudioEncoderFactory
(
)
;
+
const
rtc
:
:
scoped_refptr
<
AudioDecoderFactory
>
decoder_factory_
=
+
CreateBuiltinAudioDecoderFactory
(
)
;
+
acm2
:
:
AcmReceiver
:
:
Config
config_
;
+
std
:
:
unique_ptr
<
AcmReceiver
>
receiver_
;
+
std
:
:
unique_ptr
<
AudioCodingModule
>
acm_
;
+
RTPHeader
rtp_header_
;
+
uint32_t
timestamp_
;
+
bool
packet_sent_
;
/
/
Set
when
SendData
is
called
reset
when
inserting
audio
.
+
uint32_t
last_packet_send_timestamp_
;
+
AudioFrameType
last_frame_type_
;
+
}
;
+
+
#
if
defined
(
WEBRTC_ANDROID
)
+
#
define
MAYBE_SampleRate
DISABLED_SampleRate
+
#
else
+
#
define
MAYBE_SampleRate
SampleRate
+
#
endif
+
TEST_F
(
AcmReceiverTestOldApi
MAYBE_SampleRate
)
{
+
const
std
:
:
map
<
int
SdpAudioFormat
>
codecs
=
{
{
0
{
"
OPUS
"
48000
2
}
}
}
;
+
receiver_
-
>
SetCodecs
(
codecs
)
;
+
+
constexpr
int
kOutSampleRateHz
=
8000
;
/
/
Different
than
codec
sample
rate
.
+
for
(
size_t
i
=
0
;
i
<
codecs
.
size
(
)
;
+
+
i
)
{
+
const
int
payload_type
=
rtc
:
:
checked_cast
<
int
>
(
i
)
;
+
const
int
num_10ms_frames
=
+
InsertOnePacketOfSilence
(
SetEncoder
(
payload_type
codecs
.
at
(
i
)
)
)
;
+
for
(
int
k
=
0
;
k
<
num_10ms_frames
;
+
+
k
)
{
+
AudioFrame
frame
;
+
bool
muted
;
+
EXPECT_EQ
(
0
receiver_
-
>
GetAudio
(
kOutSampleRateHz
&
frame
&
muted
)
)
;
+
}
+
EXPECT_EQ
(
encoder_factory_
-
>
QueryAudioEncoder
(
codecs
.
at
(
i
)
)
-
>
sample_rate_hz
+
receiver_
-
>
last_output_sample_rate_hz
(
)
)
;
+
}
+
}
+
+
class
AcmReceiverTestFaxModeOldApi
:
public
AcmReceiverTestOldApi
{
+
protected
:
+
AcmReceiverTestFaxModeOldApi
(
)
{
+
config_
.
neteq_config
.
for_test_no_time_stretching
=
true
;
+
}
+
+
void
RunVerifyAudioFrame
(
const
SdpAudioFormat
&
codec
)
{
+
/
/
Make
sure
"
fax
mode
"
is
enabled
.
This
will
avoid
delay
changes
unless
the
+
/
/
packet
-
loss
concealment
is
made
.
We
do
this
in
order
to
make
the
+
/
/
timestamp
increments
predictable
;
in
normal
mode
NetEq
may
decide
to
do
+
/
/
accelerate
or
pre
-
emptive
expand
operations
after
some
time
offsetting
+
/
/
the
timestamp
.
+
EXPECT_TRUE
(
config_
.
neteq_config
.
for_test_no_time_stretching
)
;
+
+
constexpr
int
payload_type
=
17
;
+
receiver_
-
>
SetCodecs
(
{
{
payload_type
codec
}
}
)
;
+
+
const
AudioCodecInfo
info
=
SetEncoder
(
payload_type
codec
)
;
+
const
int
output_sample_rate_hz
=
info
.
sample_rate_hz
;
+
const
size_t
output_channels
=
info
.
num_channels
;
+
const
size_t
samples_per_ms
=
rtc
:
:
checked_cast
<
size_t
>
(
+
rtc
:
:
CheckedDivExact
(
output_sample_rate_hz
1000
)
)
;
+
+
/
/
Expect
the
first
output
timestamp
to
be
5
*
fs
/
8000
samples
before
the
+
/
/
first
inserted
timestamp
(
because
of
NetEq
'
s
look
-
ahead
)
.
(
This
value
is
+
/
/
defined
in
Expand
:
:
overlap_length_
.
)
+
uint32_t
expected_output_ts
=
+
last_packet_send_timestamp_
-
+
rtc
:
:
CheckedDivExact
(
5
*
output_sample_rate_hz
8000
)
;
+
+
AudioFrame
frame
;
+
bool
muted
;
+
EXPECT_EQ
(
0
receiver_
-
>
GetAudio
(
output_sample_rate_hz
&
frame
&
muted
)
)
;
+
/
/
Expect
timestamp
=
0
before
first
packet
is
inserted
.
+
EXPECT_EQ
(
0u
frame
.
timestamp_
)
;
+
for
(
int
i
=
0
;
i
<
5
;
+
+
i
)
{
+
const
int
num_10ms_frames
=
InsertOnePacketOfSilence
(
info
)
;
+
for
(
int
k
=
0
;
k
<
num_10ms_frames
;
+
+
k
)
{
+
EXPECT_EQ
(
0
+
receiver_
-
>
GetAudio
(
output_sample_rate_hz
&
frame
&
muted
)
)
;
+
EXPECT_EQ
(
expected_output_ts
frame
.
timestamp_
)
;
+
expected_output_ts
+
=
rtc
:
:
checked_cast
<
uint32_t
>
(
10
*
samples_per_ms
)
;
+
EXPECT_EQ
(
10
*
samples_per_ms
frame
.
samples_per_channel_
)
;
+
EXPECT_EQ
(
output_sample_rate_hz
frame
.
sample_rate_hz_
)
;
+
EXPECT_EQ
(
output_channels
frame
.
num_channels_
)
;
+
EXPECT_EQ
(
AudioFrame
:
:
kNormalSpeech
frame
.
speech_type_
)
;
+
EXPECT_FALSE
(
muted
)
;
+
}
+
}
+
}
+
}
;
+
+
#
if
defined
(
WEBRTC_ANDROID
)
+
#
define
MAYBE_VerifyAudioFramePCMU
DISABLED_VerifyAudioFramePCMU
+
#
else
+
#
define
MAYBE_VerifyAudioFramePCMU
VerifyAudioFramePCMU
+
#
endif
+
TEST_F
(
AcmReceiverTestFaxModeOldApi
MAYBE_VerifyAudioFramePCMU
)
{
+
RunVerifyAudioFrame
(
{
"
PCMU
"
8000
1
}
)
;
+
}
+
+
#
if
defined
(
WEBRTC_ANDROID
)
+
#
define
MAYBE_VerifyAudioFrameOpus
DISABLED_VerifyAudioFrameOpus
+
#
else
+
#
define
MAYBE_VerifyAudioFrameOpus
VerifyAudioFrameOpus
+
#
endif
+
TEST_F
(
AcmReceiverTestFaxModeOldApi
MAYBE_VerifyAudioFrameOpus
)
{
+
RunVerifyAudioFrame
(
{
"
opus
"
48000
2
}
)
;
+
}
+
+
#
if
defined
(
WEBRTC_ANDROID
)
+
#
define
MAYBE_LastAudioCodec
DISABLED_LastAudioCodec
+
#
else
+
#
define
MAYBE_LastAudioCodec
LastAudioCodec
+
#
endif
+
#
if
defined
(
WEBRTC_CODEC_OPUS
)
+
TEST_F
(
AcmReceiverTestOldApi
MAYBE_LastAudioCodec
)
{
+
const
std
:
:
map
<
int
SdpAudioFormat
>
codecs
=
{
+
{
0
{
"
PCMU
"
8000
1
}
}
{
1
{
"
PCMA
"
8000
1
}
}
{
2
{
"
L16
"
32000
1
}
}
}
;
+
const
std
:
:
map
<
int
int
>
cng_payload_types
=
{
+
{
8000
100
}
{
16000
101
}
{
32000
102
}
}
;
+
{
+
std
:
:
map
<
int
SdpAudioFormat
>
receive_codecs
=
codecs
;
+
for
(
const
auto
&
cng_type
:
cng_payload_types
)
{
+
receive_codecs
.
emplace
(
std
:
:
make_pair
(
+
cng_type
.
second
SdpAudioFormat
(
"
CN
"
cng_type
.
first
1
)
)
)
;
+
}
+
receiver_
-
>
SetCodecs
(
receive_codecs
)
;
+
}
+
+
/
/
No
audio
payload
is
received
.
+
EXPECT_EQ
(
std
:
:
nullopt
receiver_
-
>
LastDecoder
(
)
)
;
+
+
/
/
Start
with
sending
DTX
.
+
packet_sent_
=
false
;
+
InsertOnePacketOfSilence
(
+
SetEncoder
(
0
codecs
.
at
(
0
)
cng_payload_types
)
)
;
/
/
Enough
to
test
+
/
/
with
one
codec
.
+
ASSERT_TRUE
(
packet_sent_
)
;
+
EXPECT_EQ
(
AudioFrameType
:
:
kAudioFrameCN
last_frame_type_
)
;
+
+
/
/
Has
received
only
DTX
.
Last
Audio
codec
is
undefined
.
+
EXPECT_EQ
(
std
:
:
nullopt
receiver_
-
>
LastDecoder
(
)
)
;
+
EXPECT_EQ
(
std
:
:
nullopt
receiver_
-
>
last_packet_sample_rate_hz
(
)
)
;
+
+
for
(
size_t
i
=
0
;
i
<
codecs
.
size
(
)
;
+
+
i
)
{
+
/
/
Set
DTX
off
to
send
audio
payload
.
+
packet_sent_
=
false
;
+
const
int
payload_type
=
rtc
:
:
checked_cast
<
int
>
(
i
)
;
+
const
AudioCodecInfo
info_without_cng
=
+
SetEncoder
(
payload_type
codecs
.
at
(
i
)
)
;
+
InsertOnePacketOfSilence
(
info_without_cng
)
;
+
+
/
/
Sanity
check
if
Actually
an
audio
payload
received
and
it
should
be
+
/
/
of
type
"
speech
.
"
+
ASSERT_TRUE
(
packet_sent_
)
;
+
ASSERT_EQ
(
AudioFrameType
:
:
kAudioFrameSpeech
last_frame_type_
)
;
+
EXPECT_EQ
(
info_without_cng
.
sample_rate_hz
+
receiver_
-
>
last_packet_sample_rate_hz
(
)
)
;
+
+
/
/
Set
VAD
on
to
send
DTX
.
Then
check
if
the
"
Last
Audio
codec
"
returns
+
/
/
the
expected
codec
.
Encode
repeatedly
until
a
DTX
is
sent
.
+
const
AudioCodecInfo
info_with_cng
=
+
SetEncoder
(
payload_type
codecs
.
at
(
i
)
cng_payload_types
)
;
+
while
(
last_frame_type_
!
=
AudioFrameType
:
:
kAudioFrameCN
)
{
+
packet_sent_
=
false
;
+
InsertOnePacketOfSilence
(
info_with_cng
)
;
+
ASSERT_TRUE
(
packet_sent_
)
;
+
}
+
EXPECT_EQ
(
info_with_cng
.
sample_rate_hz
+
receiver_
-
>
last_packet_sample_rate_hz
(
)
)
;
+
EXPECT_EQ
(
codecs
.
at
(
i
)
receiver_
-
>
LastDecoder
(
)
-
>
second
)
;
+
}
+
}
+
#
endif
+
+
/
/
Check
if
the
statistics
are
initialized
correctly
.
Before
any
call
to
ACM
+
/
/
all
fields
have
to
be
zero
.
+
#
if
defined
(
WEBRTC_ANDROID
)
+
#
define
MAYBE_InitializedToZero
DISABLED_InitializedToZero
+
#
else
+
#
define
MAYBE_InitializedToZero
InitializedToZero
+
#
endif
+
TEST_F
(
AcmReceiverTestOldApi
MAYBE_InitializedToZero
)
{
+
AudioDecodingCallStats
stats
;
+
receiver_
-
>
GetDecodingCallStatistics
(
&
stats
)
;
+
EXPECT_EQ
(
0
stats
.
calls_to_neteq
)
;
+
EXPECT_EQ
(
0
stats
.
calls_to_silence_generator
)
;
+
EXPECT_EQ
(
0
stats
.
decoded_normal
)
;
+
EXPECT_EQ
(
0
stats
.
decoded_cng
)
;
+
EXPECT_EQ
(
0
stats
.
decoded_neteq_plc
)
;
+
EXPECT_EQ
(
0
stats
.
decoded_plc_cng
)
;
+
EXPECT_EQ
(
0
stats
.
decoded_muted_output
)
;
+
}
+
+
#
if
defined
(
WEBRTC_ANDROID
)
+
#
define
MAYBE_VerifyOutputFrame
DISABLED_VerifyOutputFrame
+
#
else
+
#
define
MAYBE_VerifyOutputFrame
VerifyOutputFrame
+
#
endif
+
TEST_F
(
AcmReceiverTestOldApi
MAYBE_VerifyOutputFrame
)
{
+
AudioFrame
audio_frame
;
+
const
int
kSampleRateHz
=
32000
;
+
bool
muted
;
+
EXPECT_EQ
(
0
receiver_
-
>
GetAudio
(
kSampleRateHz
&
audio_frame
&
muted
)
)
;
+
ASSERT_FALSE
(
muted
)
;
+
EXPECT_EQ
(
0u
audio_frame
.
timestamp_
)
;
+
EXPECT_GT
(
audio_frame
.
num_channels_
0u
)
;
+
EXPECT_EQ
(
static_cast
<
size_t
>
(
kSampleRateHz
/
100
)
+
audio_frame
.
samples_per_channel_
)
;
+
EXPECT_EQ
(
kSampleRateHz
audio_frame
.
sample_rate_hz_
)
;
+
}
+
+
/
/
Insert
some
packets
and
pull
audio
.
Check
statistics
are
valid
.
Then
+
/
/
simulate
packet
loss
and
check
if
PLC
and
PLC
-
to
-
CNG
statistics
are
+
/
/
correctly
updated
.
+
#
if
defined
(
WEBRTC_ANDROID
)
+
#
define
MAYBE_NetEqCalls
DISABLED_NetEqCalls
+
#
else
+
#
define
MAYBE_NetEqCalls
NetEqCalls
+
#
endif
+
TEST_F
(
AcmReceiverTestOldApi
MAYBE_NetEqCalls
)
{
+
AudioDecodingCallStats
stats
;
+
const
int
kNumNormalCalls
=
10
;
+
const
int
kSampleRateHz
=
16000
;
+
const
int
kNumSamples10ms
=
kSampleRateHz
/
100
;
+
const
int
kFrameSizeMs
=
10
;
/
/
Multiple
of
10
.
+
const
int
kFrameSizeSamples
=
kFrameSizeMs
/
10
*
kNumSamples10ms
;
+
const
int
kPayloadSizeBytes
=
kFrameSizeSamples
*
sizeof
(
int16_t
)
;
+
const
uint8_t
kPayloadType
=
111
;
+
RTPHeader
rtp_header
;
+
AudioFrame
audio_frame
;
+
bool
muted
;
+
+
receiver_
-
>
SetCodecs
(
+
{
{
kPayloadType
SdpAudioFormat
(
"
L16
"
kSampleRateHz
1
)
}
}
)
;
+
rtp_header
.
sequenceNumber
=
0xABCD
;
+
rtp_header
.
timestamp
=
0xABCDEF01
;
+
rtp_header
.
payloadType
=
kPayloadType
;
+
rtp_header
.
markerBit
=
false
;
+
rtp_header
.
ssrc
=
0x1234
;
+
rtp_header
.
numCSRCs
=
0
;
+
+
for
(
int
num_calls
=
0
;
num_calls
<
kNumNormalCalls
;
+
+
num_calls
)
{
+
const
uint8_t
kPayload
[
kPayloadSizeBytes
]
=
{
0
}
;
+
ASSERT_EQ
(
0
receiver_
-
>
InsertPacket
(
rtp_header
kPayload
+
Timestamp
:
:
MinusInfinity
(
)
)
)
;
+
+
+
rtp_header
.
sequenceNumber
;
+
rtp_header
.
timestamp
+
=
kFrameSizeSamples
;
+
ASSERT_EQ
(
0
receiver_
-
>
GetAudio
(
-
1
&
audio_frame
&
muted
)
)
;
+
EXPECT_FALSE
(
muted
)
;
+
}
+
receiver_
-
>
GetDecodingCallStatistics
(
&
stats
)
;
+
EXPECT_EQ
(
kNumNormalCalls
stats
.
calls_to_neteq
)
;
+
EXPECT_EQ
(
0
stats
.
calls_to_silence_generator
)
;
+
EXPECT_EQ
(
kNumNormalCalls
stats
.
decoded_normal
)
;
+
EXPECT_EQ
(
0
stats
.
decoded_cng
)
;
+
EXPECT_EQ
(
0
stats
.
decoded_neteq_plc
)
;
+
EXPECT_EQ
(
0
stats
.
decoded_plc_cng
)
;
+
EXPECT_EQ
(
0
stats
.
decoded_muted_output
)
;
+
+
const
int
kNumPlc
=
3
;
+
const
int
kNumPlcCng
=
5
;
+
+
/
/
Simulate
packet
-
loss
.
NetEq
first
performs
PLC
then
PLC
fades
to
CNG
.
+
for
(
int
n
=
0
;
n
<
kNumPlc
+
kNumPlcCng
;
+
+
n
)
{
+
ASSERT_EQ
(
0
receiver_
-
>
GetAudio
(
-
1
&
audio_frame
&
muted
)
)
;
+
EXPECT_FALSE
(
muted
)
;
+
}
+
receiver_
-
>
GetDecodingCallStatistics
(
&
stats
)
;
+
EXPECT_EQ
(
kNumNormalCalls
+
kNumPlc
+
kNumPlcCng
stats
.
calls_to_neteq
)
;
+
EXPECT_EQ
(
0
stats
.
calls_to_silence_generator
)
;
+
EXPECT_EQ
(
kNumNormalCalls
stats
.
decoded_normal
)
;
+
EXPECT_EQ
(
0
stats
.
decoded_cng
)
;
+
EXPECT_EQ
(
kNumPlc
stats
.
decoded_neteq_plc
)
;
+
EXPECT_EQ
(
kNumPlcCng
stats
.
decoded_plc_cng
)
;
+
EXPECT_EQ
(
0
stats
.
decoded_muted_output
)
;
+
/
/
TODO
(
henrik
.
lundin
)
Add
a
test
with
muted
state
enabled
.
+
}
+
+
}
/
/
namespace
acm2
+
+
}
/
/
namespace
webrtc
