From
:
Michael
Froman
<
mjfroman
mac
.
com
>
Date
:
Fri
7
Feb
2025
14
:
36
:
39
-
0600
Subject
:
(
tmp
-
cherry
-
pick
)
Revert
"
Remove
stun_prober
"
(
414706543d
)
This
reverts
commit
03f56d75d5a4bbbc6b6fe93e119f73c69ff98267
.
Reason
for
revert
:
Breaks
downstream
project
.
Original
change
'
s
description
:
>
Remove
stun_prober
>
>
The
STUN
prober
shows
the
old
RFC
3489
way
of
determining
the
NAT
type
>
by
pinging
two
different
servers
.
This
is
known
to
be
faulty
as
pointed
>
out
by
>
https
:
/
/
datatracker
.
ietf
.
org
/
doc
/
html
/
rfc5389
#
section
-
2
>
>
Chromium
dependency
removed
in
>
https
:
/
/
chromium
-
review
.
googlesource
.
com
/
c
/
chromium
/
src
/
+
/
6036622
>
>
BUG
=
None
>
>
Change
-
Id
:
I2b61dfe2ff899ce71ec9d2253dc836c5908cf8c6
>
Reviewed
-
on
:
https
:
/
/
webrtc
-
review
.
googlesource
.
com
/
c
/
src
/
+
/
368182
>
Commit
-
Queue
:
Philipp
Hancke
<
phancke
meta
.
com
>
>
Reviewed
-
by
:
Harald
Alvestrand
<
hta
webrtc
.
org
>
>
Reviewed
-
by
:
Mirko
Bonadei
<
mbonadei
webrtc
.
org
>
>
Cr
-
Commit
-
Position
:
refs
/
heads
/
main
{
#
43503
}
Bug
:
None
Change
-
Id
:
I08d01d4c9d882aca883e1c889aed8bddbca65b91
No
-
Presubmit
:
true
No
-
Tree
-
Checks
:
true
No
-
Try
:
true
Reviewed
-
on
:
https
:
/
/
webrtc
-
review
.
googlesource
.
com
/
c
/
src
/
+
/
370540
Bot
-
Commit
:
rubber
-
stamper
appspot
.
gserviceaccount
.
com
<
rubber
-
stamper
appspot
.
gserviceaccount
.
com
>
Reviewed
-
by
:
Jeremy
Leconte
<
jleconte
webrtc
.
org
>
Commit
-
Queue
:
Mirko
Bonadei
<
mbonadei
webrtc
.
org
>
Reviewed
-
by
:
Harald
Alvestrand
<
hta
webrtc
.
org
>
Cr
-
Commit
-
Position
:
refs
/
heads
/
main
{
#
43506
}
-
-
-
BUILD
.
gn
|
1
+
examples
/
BUILD
.
gn
|
33
+
+
examples
/
stunprober
/
main
.
cc
|
153
+
+
+
+
+
+
+
p2p
/
BUILD
.
gn
|
55
+
+
-
p2p
/
stunprober
/
stun_prober
.
cc
|
602
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
p2p
/
stunprober
/
stun_prober
.
h
|
251
+
+
+
+
+
+
+
+
+
+
+
p2p
/
stunprober
/
stun_prober_unittest
.
cc
|
177
+
+
+
+
+
+
+
+
7
files
changed
1271
insertions
(
+
)
1
deletion
(
-
)
create
mode
100644
examples
/
stunprober
/
main
.
cc
create
mode
100644
p2p
/
stunprober
/
stun_prober
.
cc
create
mode
100644
p2p
/
stunprober
/
stun_prober
.
h
create
mode
100644
p2p
/
stunprober
/
stun_prober_unittest
.
cc
diff
-
-
git
a
/
BUILD
.
gn
b
/
BUILD
.
gn
index
d829c0fccc
.
.
f05f71b687
100644
-
-
-
a
/
BUILD
.
gn
+
+
+
b
/
BUILD
.
gn
-
650
6
+
650
7
if
(
rtc_include_tests
&
&
!
build_with_chromium
)
{
"
api
/
video_codecs
/
test
:
video_codecs_api_unittests
"
"
api
/
voip
:
compile_all_headers
"
"
call
:
fake_network_pipe_unittests
"
+
"
p2p
:
libstunprober_unittests
"
"
p2p
:
rtc_p2p_unittests
"
"
rtc_base
:
async_dns_resolver_unittests
"
"
rtc_base
:
async_packet_socket_unittest
"
diff
-
-
git
a
/
examples
/
BUILD
.
gn
b
/
examples
/
BUILD
.
gn
index
6183b9fe3d
.
.
d21d70535e
100644
-
-
-
a
/
examples
/
BUILD
.
gn
+
+
+
b
/
examples
/
BUILD
.
gn
-
42
6
+
42
10
group
(
"
examples
"
)
{
}
}
+
if
(
!
build_with_chromium
)
{
+
deps
+
=
[
"
:
stun_prober
"
]
+
}
+
if
(
is_ios
|
|
(
is_mac
&
&
target_cpu
!
=
"
x86
"
)
)
{
deps
+
=
[
"
:
AppRTCMobile
"
]
}
-
865
3
+
869
32
if
(
is_android
)
{
]
]
}
}
+
+
if
(
!
build_with_chromium
)
{
+
#
Doesn
'
t
build
within
Chrome
on
Win
.
+
rtc_executable
(
"
stun_prober
"
)
{
+
testonly
=
true
+
sources
=
[
"
stunprober
/
main
.
cc
"
]
+
deps
=
[
+
"
.
.
/
p2p
:
basic_packet_socket_factory
"
+
"
.
.
/
p2p
:
libstunprober
"
+
"
.
.
/
p2p
:
rtc_p2p
"
+
"
.
.
/
rtc_base
:
checks
"
+
"
.
.
/
rtc_base
:
crypto_random
"
+
"
.
.
/
rtc_base
:
logging
"
+
"
.
.
/
rtc_base
:
network
"
+
"
.
.
/
rtc_base
:
socket_address
"
+
"
.
.
/
rtc_base
:
ssl_adapter
"
+
"
.
.
/
rtc_base
:
threading
"
+
"
.
.
/
rtc_base
:
timeutils
"
+
"
.
.
/
test
:
scoped_key_value_config
"
+
"
/
/
third_party
/
abseil
-
cpp
/
absl
/
flags
:
flag
"
+
"
/
/
third_party
/
abseil
-
cpp
/
absl
/
flags
:
parse
"
+
]
+
if
(
is_win
)
{
+
deps
+
=
[
+
"
.
.
/
rtc_base
:
win32_socket_init
"
+
]
+
}
+
}
+
}
diff
-
-
git
a
/
examples
/
stunprober
/
main
.
cc
b
/
examples
/
stunprober
/
main
.
cc
new
file
mode
100644
index
0000000000
.
.
023c52fa0e
-
-
-
/
dev
/
null
+
+
+
b
/
examples
/
stunprober
/
main
.
cc
-
0
0
+
1
153
+
/
*
+
*
Copyright
2015
The
WebRTC
Project
Authors
.
All
rights
reserved
.
+
*
+
*
Use
of
this
source
code
is
governed
by
a
BSD
-
style
license
+
*
that
can
be
found
in
the
LICENSE
file
in
the
root
of
the
source
+
*
tree
.
An
additional
intellectual
property
rights
grant
can
be
found
+
*
in
the
file
PATENTS
.
All
contributing
project
authors
may
+
*
be
found
in
the
AUTHORS
file
in
the
root
of
the
source
tree
.
+
*
/
+
+
#
include
<
memory
>
+
#
include
<
set
>
+
#
include
<
sstream
>
+
#
include
<
string
>
+
#
include
<
vector
>
+
+
#
include
"
absl
/
flags
/
flag
.
h
"
+
#
include
"
absl
/
flags
/
parse
.
h
"
+
#
include
"
p2p
/
base
/
basic_packet_socket_factory
.
h
"
+
#
include
"
p2p
/
stunprober
/
stun_prober
.
h
"
+
#
include
"
rtc_base
/
crypto_random
.
h
"
+
#
include
"
rtc_base
/
logging
.
h
"
+
#
include
"
rtc_base
/
network
.
h
"
+
#
include
"
rtc_base
/
physical_socket_server
.
h
"
+
#
include
"
rtc_base
/
socket_address
.
h
"
+
#
include
"
rtc_base
/
ssl_adapter
.
h
"
+
#
include
"
rtc_base
/
thread
.
h
"
+
#
include
"
rtc_base
/
time_utils
.
h
"
+
#
include
"
test
/
scoped_key_value_config
.
h
"
+
+
#
ifdef
WEBRTC_WIN
+
#
include
"
rtc_base
/
win32_socket_init
.
h
"
+
#
endif
/
/
WEBRTC_WIN
+
+
using
stunprober
:
:
AsyncCallback
;
+
using
stunprober
:
:
StunProber
;
+
+
ABSL_FLAG
(
int
+
interval
+
10
+
"
Interval
of
consecutive
stun
pings
in
milliseconds
"
)
;
+
ABSL_FLAG
(
bool
+
shared_socket
+
false
+
"
Share
socket
mode
for
different
remote
IPs
"
)
;
+
ABSL_FLAG
(
int
+
pings_per_ip
+
10
+
"
Number
of
consecutive
stun
pings
to
send
for
each
IP
"
)
;
+
ABSL_FLAG
(
int
+
timeout
+
1000
+
"
Milliseconds
of
wait
after
the
last
ping
sent
before
exiting
"
)
;
+
ABSL_FLAG
(
+
std
:
:
string
+
servers
+
"
stun
.
l
.
google
.
com
:
19302
stun1
.
l
.
google
.
com
:
19302
stun2
.
l
.
google
.
com
:
19302
"
+
"
Comma
separated
STUN
server
addresses
with
ports
"
)
;
+
+
namespace
{
+
+
const
char
*
PrintNatType
(
stunprober
:
:
NatType
type
)
{
+
switch
(
type
)
{
+
case
stunprober
:
:
NATTYPE_NONE
:
+
return
"
Not
behind
a
NAT
"
;
+
case
stunprober
:
:
NATTYPE_UNKNOWN
:
+
return
"
Unknown
NAT
type
"
;
+
case
stunprober
:
:
NATTYPE_SYMMETRIC
:
+
return
"
Symmetric
NAT
"
;
+
case
stunprober
:
:
NATTYPE_NON_SYMMETRIC
:
+
return
"
Non
-
Symmetric
NAT
"
;
+
default
:
+
return
"
Invalid
"
;
+
}
+
}
+
+
void
PrintStats
(
StunProber
*
prober
)
{
+
StunProber
:
:
Stats
stats
;
+
if
(
!
prober
-
>
GetStats
(
&
stats
)
)
{
+
RTC_LOG
(
LS_WARNING
)
<
<
"
Results
are
inconclusive
.
"
;
+
return
;
+
}
+
+
RTC_LOG
(
LS_INFO
)
<
<
"
Shared
Socket
Mode
:
"
<
<
stats
.
shared_socket_mode
;
+
RTC_LOG
(
LS_INFO
)
<
<
"
Requests
sent
:
"
<
<
stats
.
num_request_sent
;
+
RTC_LOG
(
LS_INFO
)
<
<
"
Responses
received
:
"
<
<
stats
.
num_response_received
;
+
RTC_LOG
(
LS_INFO
)
<
<
"
Target
interval
(
ns
)
:
"
+
<
<
stats
.
target_request_interval_ns
;
+
RTC_LOG
(
LS_INFO
)
<
<
"
Actual
interval
(
ns
)
:
"
+
<
<
stats
.
actual_request_interval_ns
;
+
RTC_LOG
(
LS_INFO
)
<
<
"
NAT
Type
:
"
<
<
PrintNatType
(
stats
.
nat_type
)
;
+
RTC_LOG
(
LS_INFO
)
<
<
"
Host
IP
:
"
<
<
stats
.
host_ip
;
+
RTC_LOG
(
LS_INFO
)
<
<
"
Server
-
reflexive
ips
:
"
;
+
for
(
auto
&
ip
:
stats
.
srflx_addrs
)
{
+
RTC_LOG
(
LS_INFO
)
<
<
"
\
t
"
<
<
ip
;
+
}
+
+
RTC_LOG
(
LS_INFO
)
<
<
"
Success
Precent
:
"
<
<
stats
.
success_percent
;
+
RTC_LOG
(
LS_INFO
)
<
<
"
Response
Latency
:
"
<
<
stats
.
average_rtt_ms
;
+
}
+
+
void
StopTrial
(
rtc
:
:
Thread
*
thread
StunProber
*
prober
int
result
)
{
+
thread
-
>
Quit
(
)
;
+
if
(
prober
)
{
+
RTC_LOG
(
LS_INFO
)
<
<
"
Result
:
"
<
<
result
;
+
if
(
result
=
=
StunProber
:
:
SUCCESS
)
{
+
PrintStats
(
prober
)
;
+
}
+
}
+
}
+
+
}
/
/
namespace
+
+
int
main
(
int
argc
char
*
argv
[
]
)
{
+
#
ifdef
WEBRTC_WIN
+
rtc
:
:
WinsockInitializer
winsock_init
;
+
#
endif
/
/
WEBRTC_WIN
+
absl
:
:
ParseCommandLine
(
argc
argv
)
;
+
+
std
:
:
vector
<
rtc
:
:
SocketAddress
>
server_addresses
;
+
std
:
:
istringstream
servers
(
absl
:
:
GetFlag
(
FLAGS_servers
)
)
;
+
std
:
:
string
server
;
+
while
(
getline
(
servers
server
'
'
)
)
{
+
rtc
:
:
SocketAddress
addr
;
+
if
(
!
addr
.
FromString
(
server
)
)
{
+
RTC_LOG
(
LS_ERROR
)
<
<
"
Parsing
"
<
<
server
<
<
"
failed
.
"
;
+
return
-
1
;
+
}
+
server_addresses
.
push_back
(
addr
)
;
+
}
+
+
rtc
:
:
InitializeSSL
(
)
;
+
rtc
:
:
InitRandom
(
rtc
:
:
Time32
(
)
)
;
+
webrtc
:
:
test
:
:
ScopedKeyValueConfig
field_trials
;
+
rtc
:
:
PhysicalSocketServer
socket_server
;
+
rtc
:
:
AutoSocketServerThread
thread
(
&
socket_server
)
;
+
auto
socket_factory
=
+
std
:
:
make_unique
<
rtc
:
:
BasicPacketSocketFactory
>
(
&
socket_server
)
;
+
std
:
:
unique_ptr
<
rtc
:
:
BasicNetworkManager
>
network_manager
(
+
new
rtc
:
:
BasicNetworkManager
(
&
socket_server
&
field_trials
)
)
;
+
std
:
:
vector
<
const
rtc
:
:
Network
*
>
networks
=
network_manager
-
>
GetNetworks
(
)
;
+
auto
prober
=
std
:
:
make_unique
<
StunProber
>
(
socket_factory
.
get
(
)
+
rtc
:
:
Thread
:
:
Current
(
)
networks
)
;
+
auto
finish_callback
=
[
&
thread
]
(
StunProber
*
prober
int
result
)
{
+
StopTrial
(
&
thread
prober
result
)
;
+
}
;
+
prober
-
>
Start
(
server_addresses
absl
:
:
GetFlag
(
FLAGS_shared_socket
)
+
absl
:
:
GetFlag
(
FLAGS_interval
)
+
absl
:
:
GetFlag
(
FLAGS_pings_per_ip
)
absl
:
:
GetFlag
(
FLAGS_timeout
)
+
AsyncCallback
(
finish_callback
)
)
;
+
thread
.
Run
(
)
;
+
return
0
;
+
}
diff
-
-
git
a
/
p2p
/
BUILD
.
gn
b
/
p2p
/
BUILD
.
gn
index
0c58b5e482
.
.
d0de88b60b
100644
-
-
-
a
/
p2p
/
BUILD
.
gn
+
+
+
b
/
p2p
/
BUILD
.
gn
-
9
7
+
9
10
import
(
"
.
.
/
webrtc
.
gni
"
)
group
(
"
p2p
"
)
{
-
deps
=
[
"
:
rtc_p2p
"
]
+
deps
=
[
+
"
:
libstunprober
"
+
"
:
rtc_p2p
"
+
]
}
rtc_library
(
"
rtc_p2p
"
)
{
-
1255
3
+
1258
53
rtc_library
(
"
p2p_server_utils
"
)
{
"
/
/
third_party
/
abseil
-
cpp
/
absl
/
strings
:
string_view
"
]
}
+
+
rtc_library
(
"
libstunprober
"
)
{
+
visibility
=
[
"
*
"
]
+
sources
=
[
+
"
stunprober
/
stun_prober
.
cc
"
+
"
stunprober
/
stun_prober
.
h
"
+
]
+
+
deps
=
[
+
"
.
.
/
api
:
array_view
"
+
"
.
.
/
api
:
async_dns_resolver
"
+
"
.
.
/
api
:
packet_socket_factory
"
+
"
.
.
/
api
:
sequence_checker
"
+
"
.
.
/
api
/
task_queue
:
pending_task_safety_flag
"
+
"
.
.
/
api
/
transport
:
stun_types
"
+
"
.
.
/
api
/
units
:
time_delta
"
+
"
.
.
/
rtc_base
:
async_packet_socket
"
+
"
.
.
/
rtc_base
:
byte_buffer
"
+
"
.
.
/
rtc_base
:
checks
"
+
"
.
.
/
rtc_base
:
ip_address
"
+
"
.
.
/
rtc_base
:
logging
"
+
"
.
.
/
rtc_base
:
network
"
+
"
.
.
/
rtc_base
:
socket_address
"
+
"
.
.
/
rtc_base
:
ssl
"
+
"
.
.
/
rtc_base
:
threading
"
+
"
.
.
/
rtc_base
:
timeutils
"
+
"
.
.
/
rtc_base
/
network
:
received_packet
"
+
"
.
.
/
rtc_base
/
system
:
rtc_export
"
+
]
+
}
+
+
if
(
rtc_include_tests
)
{
+
rtc_library
(
"
libstunprober_unittests
"
)
{
+
testonly
=
true
+
+
sources
=
[
"
stunprober
/
stun_prober_unittest
.
cc
"
]
+
deps
=
[
+
"
:
basic_packet_socket_factory
"
+
"
:
libstunprober
"
+
"
:
p2p_test_utils
"
+
"
.
.
/
rtc_base
:
checks
"
+
"
.
.
/
rtc_base
:
gunit_helpers
"
+
"
.
.
/
rtc_base
:
ip_address
"
+
"
.
.
/
rtc_base
:
rtc_base_tests_utils
"
+
"
.
.
/
rtc_base
:
ssl_adapter
"
+
"
.
.
/
test
:
test_support
"
+
"
/
/
testing
/
gtest
"
+
]
+
}
+
}
diff
-
-
git
a
/
p2p
/
stunprober
/
stun_prober
.
cc
b
/
p2p
/
stunprober
/
stun_prober
.
cc
new
file
mode
100644
index
0000000000
.
.
d130d780dc
-
-
-
/
dev
/
null
+
+
+
b
/
p2p
/
stunprober
/
stun_prober
.
cc
-
0
0
+
1
602
+
/
*
+
*
Copyright
2015
The
WebRTC
Project
Authors
.
All
rights
reserved
.
+
*
+
*
Use
of
this
source
code
is
governed
by
a
BSD
-
style
license
+
*
that
can
be
found
in
the
LICENSE
file
in
the
root
of
the
source
+
*
tree
.
An
additional
intellectual
property
rights
grant
can
be
found
+
*
in
the
file
PATENTS
.
All
contributing
project
authors
may
+
*
be
found
in
the
AUTHORS
file
in
the
root
of
the
source
tree
.
+
*
/
+
+
#
include
"
p2p
/
stunprober
/
stun_prober
.
h
"
+
+
#
include
<
cstdint
>
+
#
include
<
map
>
+
#
include
<
memory
>
+
#
include
<
set
>
+
#
include
<
string
>
+
#
include
<
utility
>
+
+
#
include
"
api
/
array_view
.
h
"
+
#
include
"
api
/
packet_socket_factory
.
h
"
+
#
include
"
api
/
task_queue
/
pending_task_safety_flag
.
h
"
+
#
include
"
api
/
transport
/
stun
.
h
"
+
#
include
"
api
/
units
/
time_delta
.
h
"
+
#
include
"
rtc_base
/
async_packet_socket
.
h
"
+
#
include
"
rtc_base
/
checks
.
h
"
+
#
include
"
rtc_base
/
network
/
received_packet
.
h
"
+
#
include
"
rtc_base
/
thread
.
h
"
+
#
include
"
rtc_base
/
time_utils
.
h
"
+
+
namespace
stunprober
{
+
+
namespace
{
+
using
:
:
webrtc
:
:
SafeTask
;
+
using
:
:
webrtc
:
:
TimeDelta
;
+
+
const
int
THREAD_WAKE_UP_INTERVAL_MS
=
5
;
+
+
template
<
typename
T
>
+
void
IncrementCounterByAddress
(
std
:
:
map
<
T
int
>
*
counter_per_ip
const
T
&
ip
)
{
+
counter_per_ip
-
>
insert
(
std
:
:
make_pair
(
ip
0
)
)
.
first
-
>
second
+
+
;
+
}
+
+
}
/
/
namespace
+
+
/
/
A
requester
tracks
the
requests
and
responses
from
a
single
socket
to
many
+
/
/
STUN
servers
+
class
StunProber
:
:
Requester
:
public
sigslot
:
:
has_slots
<
>
{
+
public
:
+
/
/
Each
Request
maps
to
a
request
and
response
.
+
struct
Request
{
+
/
/
Actual
time
the
STUN
bind
request
was
sent
.
+
int64_t
sent_time_ms
=
0
;
+
/
/
Time
the
response
was
received
.
+
int64_t
received_time_ms
=
0
;
+
+
/
/
Server
reflexive
address
from
STUN
response
for
this
given
request
.
+
rtc
:
:
SocketAddress
srflx_addr
;
+
+
rtc
:
:
IPAddress
server_addr
;
+
+
int64_t
rtt
(
)
{
return
received_time_ms
-
sent_time_ms
;
}
+
void
ProcessResponse
(
rtc
:
:
ArrayView
<
const
uint8_t
>
payload
)
;
+
}
;
+
+
/
/
StunProber
provides
server_ips
for
Requester
to
probe
.
For
shared
+
/
/
socket
mode
it
'
ll
be
all
the
resolved
IP
addresses
.
For
non
-
shared
mode
+
/
/
it
'
ll
just
be
a
single
address
.
+
Requester
(
StunProber
*
prober
+
rtc
:
:
AsyncPacketSocket
*
socket
+
const
std
:
:
vector
<
rtc
:
:
SocketAddress
>
&
server_ips
)
;
+
~
Requester
(
)
override
;
+
+
Requester
(
const
Requester
&
)
=
delete
;
+
Requester
&
operator
=
(
const
Requester
&
)
=
delete
;
+
+
/
/
There
is
no
callback
for
SendStunRequest
as
the
underneath
socket
send
is
+
/
/
expected
to
be
completed
immediately
.
Otherwise
it
'
ll
skip
this
request
+
/
/
and
move
to
the
next
one
.
+
void
SendStunRequest
(
)
;
+
+
void
OnStunResponseReceived
(
rtc
:
:
AsyncPacketSocket
*
socket
+
const
rtc
:
:
ReceivedPacket
&
packet
)
;
+
+
const
std
:
:
vector
<
Request
*
>
&
requests
(
)
{
return
requests_
;
}
+
+
/
/
Whether
this
Requester
has
completed
all
requests
.
+
bool
Done
(
)
{
+
return
static_cast
<
size_t
>
(
num_request_sent_
)
=
=
server_ips_
.
size
(
)
;
+
}
+
+
private
:
+
Request
*
GetRequestByAddress
(
const
rtc
:
:
IPAddress
&
ip
)
;
+
+
StunProber
*
prober_
;
+
+
/
/
The
socket
for
this
session
.
+
std
:
:
unique_ptr
<
rtc
:
:
AsyncPacketSocket
>
socket_
;
+
+
/
/
Temporary
SocketAddress
and
buffer
for
RecvFrom
.
+
rtc
:
:
SocketAddress
addr_
;
+
std
:
:
unique_ptr
<
rtc
:
:
ByteBufferWriter
>
response_packet_
;
+
+
std
:
:
vector
<
Request
*
>
requests_
;
+
std
:
:
vector
<
rtc
:
:
SocketAddress
>
server_ips_
;
+
int16_t
num_request_sent_
=
0
;
+
int16_t
num_response_received_
=
0
;
+
+
webrtc
:
:
SequenceChecker
&
thread_checker_
;
+
}
;
+
+
StunProber
:
:
Requester
:
:
Requester
(
+
StunProber
*
prober
+
rtc
:
:
AsyncPacketSocket
*
socket
+
const
std
:
:
vector
<
rtc
:
:
SocketAddress
>
&
server_ips
)
+
:
prober_
(
prober
)
+
socket_
(
socket
)
+
response_packet_
(
new
rtc
:
:
ByteBufferWriter
(
nullptr
kMaxUdpBufferSize
)
)
+
server_ips_
(
server_ips
)
+
thread_checker_
(
prober
-
>
thread_checker_
)
{
+
socket_
-
>
RegisterReceivedPacketCallback
(
+
[
&
]
(
rtc
:
:
AsyncPacketSocket
*
socket
const
rtc
:
:
ReceivedPacket
&
packet
)
{
+
OnStunResponseReceived
(
socket
packet
)
;
+
}
)
;
+
}
+
+
StunProber
:
:
Requester
:
:
~
Requester
(
)
{
+
if
(
socket_
)
{
+
socket_
-
>
Close
(
)
;
+
}
+
for
(
auto
*
req
:
requests_
)
{
+
if
(
req
)
{
+
delete
req
;
+
}
+
}
+
}
+
+
void
StunProber
:
:
Requester
:
:
SendStunRequest
(
)
{
+
RTC_DCHECK
(
thread_checker_
.
IsCurrent
(
)
)
;
+
requests_
.
push_back
(
new
Request
(
)
)
;
+
Request
&
request
=
*
(
requests_
.
back
(
)
)
;
+
/
/
Random
transaction
ID
STUN_BINDING_REQUEST
+
cricket
:
:
StunMessage
message
(
cricket
:
:
STUN_BINDING_REQUEST
)
;
+
+
std
:
:
unique_ptr
<
rtc
:
:
ByteBufferWriter
>
request_packet
(
+
new
rtc
:
:
ByteBufferWriter
(
nullptr
kMaxUdpBufferSize
)
)
;
+
if
(
!
message
.
Write
(
request_packet
.
get
(
)
)
)
{
+
prober_
-
>
ReportOnFinished
(
WRITE_FAILED
)
;
+
return
;
+
}
+
+
auto
addr
=
server_ips_
[
num_request_sent_
]
;
+
request
.
server_addr
=
addr
.
ipaddr
(
)
;
+
+
/
/
The
write
must
succeed
immediately
.
Otherwise
the
calculating
of
the
STUN
+
/
/
request
timing
could
become
too
complicated
.
Callback
is
ignored
by
passing
+
/
/
empty
AsyncCallback
.
+
rtc
:
:
PacketOptions
options
;
+
int
rv
=
socket_
-
>
SendTo
(
request_packet
-
>
Data
(
)
request_packet
-
>
Length
(
)
+
addr
options
)
;
+
if
(
rv
<
0
)
{
+
prober_
-
>
ReportOnFinished
(
WRITE_FAILED
)
;
+
return
;
+
}
+
+
request
.
sent_time_ms
=
rtc
:
:
TimeMillis
(
)
;
+
+
num_request_sent_
+
+
;
+
RTC_DCHECK
(
static_cast
<
size_t
>
(
num_request_sent_
)
<
=
server_ips_
.
size
(
)
)
;
+
}
+
+
void
StunProber
:
:
Requester
:
:
Request
:
:
ProcessResponse
(
+
rtc
:
:
ArrayView
<
const
uint8_t
>
payload
)
{
+
int64_t
now
=
rtc
:
:
TimeMillis
(
)
;
+
rtc
:
:
ByteBufferReader
message
(
payload
)
;
+
cricket
:
:
StunMessage
stun_response
;
+
if
(
!
stun_response
.
Read
(
&
message
)
)
{
+
/
/
Invalid
or
incomplete
STUN
packet
.
+
received_time_ms
=
0
;
+
return
;
+
}
+
+
/
/
Get
external
address
of
the
socket
.
+
const
cricket
:
:
StunAddressAttribute
*
addr_attr
=
+
stun_response
.
GetAddress
(
cricket
:
:
STUN_ATTR_MAPPED_ADDRESS
)
;
+
if
(
addr_attr
=
=
nullptr
)
{
+
/
/
Addresses
not
available
to
detect
whether
or
not
behind
a
NAT
.
+
return
;
+
}
+
+
if
(
addr_attr
-
>
family
(
)
!
=
cricket
:
:
STUN_ADDRESS_IPV4
&
&
+
addr_attr
-
>
family
(
)
!
=
cricket
:
:
STUN_ADDRESS_IPV6
)
{
+
return
;
+
}
+
+
received_time_ms
=
now
;
+
+
srflx_addr
=
addr_attr
-
>
GetAddress
(
)
;
+
}
+
+
void
StunProber
:
:
Requester
:
:
OnStunResponseReceived
(
+
rtc
:
:
AsyncPacketSocket
*
socket
+
const
rtc
:
:
ReceivedPacket
&
packet
)
{
+
RTC_DCHECK
(
thread_checker_
.
IsCurrent
(
)
)
;
+
RTC_DCHECK
(
socket_
)
;
+
Request
*
request
=
GetRequestByAddress
(
packet
.
source_address
(
)
.
ipaddr
(
)
)
;
+
if
(
!
request
)
{
+
/
/
Something
is
wrong
finish
the
test
.
+
prober_
-
>
ReportOnFinished
(
GENERIC_FAILURE
)
;
+
return
;
+
}
+
+
num_response_received_
+
+
;
+
request
-
>
ProcessResponse
(
packet
.
payload
(
)
)
;
+
}
+
+
StunProber
:
:
Requester
:
:
Request
*
StunProber
:
:
Requester
:
:
GetRequestByAddress
(
+
const
rtc
:
:
IPAddress
&
ipaddr
)
{
+
RTC_DCHECK
(
thread_checker_
.
IsCurrent
(
)
)
;
+
for
(
auto
*
request
:
requests_
)
{
+
if
(
request
-
>
server_addr
=
=
ipaddr
)
{
+
return
request
;
+
}
+
}
+
+
return
nullptr
;
+
}
+
+
StunProber
:
:
Stats
:
:
Stats
(
)
=
default
;
+
+
StunProber
:
:
Stats
:
:
~
Stats
(
)
=
default
;
+
+
StunProber
:
:
ObserverAdapter
:
:
ObserverAdapter
(
)
=
default
;
+
+
StunProber
:
:
ObserverAdapter
:
:
~
ObserverAdapter
(
)
=
default
;
+
+
void
StunProber
:
:
ObserverAdapter
:
:
OnPrepared
(
StunProber
*
stunprober
+
Status
status
)
{
+
if
(
status
=
=
SUCCESS
)
{
+
stunprober
-
>
Start
(
this
)
;
+
}
else
{
+
callback_
(
stunprober
status
)
;
+
}
+
}
+
+
void
StunProber
:
:
ObserverAdapter
:
:
OnFinished
(
StunProber
*
stunprober
+
Status
status
)
{
+
callback_
(
stunprober
status
)
;
+
}
+
+
StunProber
:
:
StunProber
(
rtc
:
:
PacketSocketFactory
*
socket_factory
+
rtc
:
:
Thread
*
thread
+
std
:
:
vector
<
const
rtc
:
:
Network
*
>
networks
)
+
:
interval_ms_
(
0
)
+
socket_factory_
(
socket_factory
)
+
thread_
(
thread
)
+
networks_
(
std
:
:
move
(
networks
)
)
{
}
+
+
StunProber
:
:
~
StunProber
(
)
{
+
RTC_DCHECK
(
thread_checker_
.
IsCurrent
(
)
)
;
+
for
(
auto
*
req
:
requesters_
)
{
+
if
(
req
)
{
+
delete
req
;
+
}
+
}
+
for
(
auto
*
s
:
sockets_
)
{
+
if
(
s
)
{
+
delete
s
;
+
}
+
}
+
}
+
+
bool
StunProber
:
:
Start
(
const
std
:
:
vector
<
rtc
:
:
SocketAddress
>
&
servers
+
bool
shared_socket_mode
+
int
interval_ms
+
int
num_request_per_ip
+
int
timeout_ms
+
const
AsyncCallback
callback
)
{
+
observer_adapter_
.
set_callback
(
callback
)
;
+
return
Prepare
(
servers
shared_socket_mode
interval_ms
num_request_per_ip
+
timeout_ms
&
observer_adapter_
)
;
+
}
+
+
bool
StunProber
:
:
Prepare
(
const
std
:
:
vector
<
rtc
:
:
SocketAddress
>
&
servers
+
bool
shared_socket_mode
+
int
interval_ms
+
int
num_request_per_ip
+
int
timeout_ms
+
StunProber
:
:
Observer
*
observer
)
{
+
RTC_DCHECK
(
thread_checker_
.
IsCurrent
(
)
)
;
+
interval_ms_
=
interval_ms
;
+
shared_socket_mode_
=
shared_socket_mode
;
+
+
requests_per_ip_
=
num_request_per_ip
;
+
if
(
requests_per_ip_
=
=
0
|
|
servers
.
size
(
)
=
=
0
)
{
+
return
false
;
+
}
+
+
timeout_ms_
=
timeout_ms
;
+
servers_
=
servers
;
+
observer_
=
observer
;
+
/
/
Remove
addresses
that
are
already
resolved
.
+
for
(
auto
it
=
servers_
.
begin
(
)
;
it
!
=
servers_
.
end
(
)
;
)
{
+
if
(
it
-
>
ipaddr
(
)
.
family
(
)
!
=
AF_UNSPEC
)
{
+
all_servers_addrs_
.
push_back
(
*
it
)
;
+
it
=
servers_
.
erase
(
it
)
;
+
}
else
{
+
+
+
it
;
+
}
+
}
+
if
(
servers_
.
empty
(
)
)
{
+
CreateSockets
(
)
;
+
return
true
;
+
}
+
return
ResolveServerName
(
servers_
.
back
(
)
)
;
+
}
+
+
bool
StunProber
:
:
Start
(
StunProber
:
:
Observer
*
observer
)
{
+
observer_
=
observer
;
+
if
(
total_ready_sockets_
!
=
total_socket_required
(
)
)
{
+
return
false
;
+
}
+
MaybeScheduleStunRequests
(
)
;
+
return
true
;
+
}
+
+
bool
StunProber
:
:
ResolveServerName
(
const
rtc
:
:
SocketAddress
&
addr
)
{
+
RTC_DCHECK
(
!
resolver_
)
;
+
resolver_
=
socket_factory_
-
>
CreateAsyncDnsResolver
(
)
;
+
if
(
!
resolver_
)
{
+
return
false
;
+
}
+
resolver_
-
>
Start
(
addr
[
this
]
{
OnServerResolved
(
resolver_
-
>
result
(
)
)
;
}
)
;
+
return
true
;
+
}
+
+
void
StunProber
:
:
OnSocketReady
(
rtc
:
:
AsyncPacketSocket
*
socket
+
const
rtc
:
:
SocketAddress
&
addr
)
{
+
total_ready_sockets_
+
+
;
+
if
(
total_ready_sockets_
=
=
total_socket_required
(
)
)
{
+
ReportOnPrepared
(
SUCCESS
)
;
+
}
+
}
+
+
void
StunProber
:
:
OnServerResolved
(
+
const
webrtc
:
:
AsyncDnsResolverResult
&
result
)
{
+
RTC_DCHECK
(
thread_checker_
.
IsCurrent
(
)
)
;
+
rtc
:
:
SocketAddress
received_address
;
+
if
(
result
.
GetResolvedAddress
(
AF_INET
&
received_address
)
)
{
+
/
/
Construct
an
address
without
the
name
in
it
.
+
rtc
:
:
SocketAddress
addr
(
received_address
.
ipaddr
(
)
received_address
.
port
(
)
)
;
+
all_servers_addrs_
.
push_back
(
addr
)
;
+
}
+
resolver_
.
reset
(
)
;
+
servers_
.
pop_back
(
)
;
+
if
(
servers_
.
size
(
)
)
{
+
if
(
!
ResolveServerName
(
servers_
.
back
(
)
)
)
{
+
ReportOnPrepared
(
RESOLVE_FAILED
)
;
+
}
+
return
;
+
}
+
+
if
(
all_servers_addrs_
.
size
(
)
=
=
0
)
{
+
ReportOnPrepared
(
RESOLVE_FAILED
)
;
+
return
;
+
}
+
+
CreateSockets
(
)
;
+
}
+
+
void
StunProber
:
:
CreateSockets
(
)
{
+
/
/
Dedupe
.
+
std
:
:
set
<
rtc
:
:
SocketAddress
>
addrs
(
all_servers_addrs_
.
begin
(
)
+
all_servers_addrs_
.
end
(
)
)
;
+
all_servers_addrs_
.
assign
(
addrs
.
begin
(
)
addrs
.
end
(
)
)
;
+
+
/
/
Prepare
all
the
sockets
beforehand
.
All
of
them
will
bind
to
"
any
"
address
.
+
while
(
sockets_
.
size
(
)
<
total_socket_required
(
)
)
{
+
std
:
:
unique_ptr
<
rtc
:
:
AsyncPacketSocket
>
socket
(
+
socket_factory_
-
>
CreateUdpSocket
(
rtc
:
:
SocketAddress
(
INADDR_ANY
0
)
0
+
0
)
)
;
+
if
(
!
socket
)
{
+
ReportOnPrepared
(
GENERIC_FAILURE
)
;
+
return
;
+
}
+
/
/
Chrome
and
WebRTC
behave
differently
in
terms
of
the
state
of
a
socket
+
/
/
once
returned
from
PacketSocketFactory
:
:
CreateUdpSocket
.
+
if
(
socket
-
>
GetState
(
)
=
=
rtc
:
:
AsyncPacketSocket
:
:
STATE_BINDING
)
{
+
socket
-
>
SignalAddressReady
.
connect
(
this
&
StunProber
:
:
OnSocketReady
)
;
+
}
else
{
+
OnSocketReady
(
socket
.
get
(
)
rtc
:
:
SocketAddress
(
INADDR_ANY
0
)
)
;
+
}
+
sockets_
.
push_back
(
socket
.
release
(
)
)
;
+
}
+
}
+
+
StunProber
:
:
Requester
*
StunProber
:
:
CreateRequester
(
)
{
+
RTC_DCHECK
(
thread_checker_
.
IsCurrent
(
)
)
;
+
if
(
!
sockets_
.
size
(
)
)
{
+
return
nullptr
;
+
}
+
StunProber
:
:
Requester
*
requester
;
+
if
(
shared_socket_mode_
)
{
+
requester
=
new
Requester
(
this
sockets_
.
back
(
)
all_servers_addrs_
)
;
+
}
else
{
+
std
:
:
vector
<
rtc
:
:
SocketAddress
>
server_ip
;
+
server_ip
.
push_back
(
+
all_servers_addrs_
[
(
num_request_sent_
%
all_servers_addrs_
.
size
(
)
)
]
)
;
+
requester
=
new
Requester
(
this
sockets_
.
back
(
)
server_ip
)
;
+
}
+
+
sockets_
.
pop_back
(
)
;
+
return
requester
;
+
}
+
+
bool
StunProber
:
:
SendNextRequest
(
)
{
+
if
(
!
current_requester_
|
|
current_requester_
-
>
Done
(
)
)
{
+
current_requester_
=
CreateRequester
(
)
;
+
requesters_
.
push_back
(
current_requester_
)
;
+
}
+
if
(
!
current_requester_
)
{
+
return
false
;
+
}
+
current_requester_
-
>
SendStunRequest
(
)
;
+
num_request_sent_
+
+
;
+
return
true
;
+
}
+
+
bool
StunProber
:
:
should_send_next_request
(
int64_t
now
)
{
+
if
(
interval_ms_
<
THREAD_WAKE_UP_INTERVAL_MS
)
{
+
return
now
>
=
next_request_time_ms_
;
+
}
else
{
+
return
(
now
+
(
THREAD_WAKE_UP_INTERVAL_MS
/
2
)
)
>
=
next_request_time_ms_
;
+
}
+
}
+
+
int
StunProber
:
:
get_wake_up_interval_ms
(
)
{
+
if
(
interval_ms_
<
THREAD_WAKE_UP_INTERVAL_MS
)
{
+
return
1
;
+
}
else
{
+
return
THREAD_WAKE_UP_INTERVAL_MS
;
+
}
+
}
+
+
void
StunProber
:
:
MaybeScheduleStunRequests
(
)
{
+
RTC_DCHECK_RUN_ON
(
thread_
)
;
+
int64_t
now
=
rtc
:
:
TimeMillis
(
)
;
+
+
if
(
Done
(
)
)
{
+
thread_
-
>
PostDelayedTask
(
+
SafeTask
(
task_safety_
.
flag
(
)
[
this
]
{
ReportOnFinished
(
SUCCESS
)
;
}
)
+
TimeDelta
:
:
Millis
(
timeout_ms_
)
)
;
+
return
;
+
}
+
if
(
should_send_next_request
(
now
)
)
{
+
if
(
!
SendNextRequest
(
)
)
{
+
ReportOnFinished
(
GENERIC_FAILURE
)
;
+
return
;
+
}
+
next_request_time_ms_
=
now
+
interval_ms_
;
+
}
+
thread_
-
>
PostDelayedTask
(
+
SafeTask
(
task_safety_
.
flag
(
)
[
this
]
{
MaybeScheduleStunRequests
(
)
;
}
)
+
TimeDelta
:
:
Millis
(
get_wake_up_interval_ms
(
)
)
)
;
+
}
+
+
bool
StunProber
:
:
GetStats
(
StunProber
:
:
Stats
*
prob_stats
)
const
{
+
/
/
No
need
to
be
on
the
same
thread
.
+
if
(
!
prob_stats
)
{
+
return
false
;
+
}
+
+
StunProber
:
:
Stats
stats
;
+
+
int
rtt_sum
=
0
;
+
int64_t
first_sent_time
=
0
;
+
int64_t
last_sent_time
=
0
;
+
NatType
nat_type
=
NATTYPE_INVALID
;
+
+
/
/
Track
of
how
many
srflx
IP
that
we
have
seen
.
+
std
:
:
set
<
rtc
:
:
IPAddress
>
srflx_ips
;
+
+
/
/
If
we
'
re
not
receiving
any
response
on
a
given
IP
all
requests
sent
to
+
/
/
that
IP
should
be
ignored
as
this
could
just
be
an
DNS
error
.
+
std
:
:
map
<
rtc
:
:
IPAddress
int
>
num_response_per_server
;
+
std
:
:
map
<
rtc
:
:
IPAddress
int
>
num_request_per_server
;
+
+
for
(
auto
*
requester
:
requesters_
)
{
+
std
:
:
map
<
rtc
:
:
SocketAddress
int
>
num_response_per_srflx_addr
;
+
for
(
auto
*
request
:
requester
-
>
requests
(
)
)
{
+
if
(
request
-
>
sent_time_ms
<
=
0
)
{
+
continue
;
+
}
+
+
+
+
stats
.
raw_num_request_sent
;
+
IncrementCounterByAddress
(
&
num_request_per_server
request
-
>
server_addr
)
;
+
+
if
(
!
first_sent_time
)
{
+
first_sent_time
=
request
-
>
sent_time_ms
;
+
}
+
last_sent_time
=
request
-
>
sent_time_ms
;
+
+
if
(
request
-
>
received_time_ms
<
request
-
>
sent_time_ms
)
{
+
continue
;
+
}
+
+
IncrementCounterByAddress
(
&
num_response_per_server
request
-
>
server_addr
)
;
+
IncrementCounterByAddress
(
&
num_response_per_srflx_addr
+
request
-
>
srflx_addr
)
;
+
rtt_sum
+
=
request
-
>
rtt
(
)
;
+
stats
.
srflx_addrs
.
insert
(
request
-
>
srflx_addr
.
ToString
(
)
)
;
+
srflx_ips
.
insert
(
request
-
>
srflx_addr
.
ipaddr
(
)
)
;
+
}
+
+
/
/
If
we
'
re
using
shared
mode
and
seeing
>
1
srflx
addresses
for
a
single
+
/
/
requester
it
'
s
symmetric
NAT
.
+
if
(
shared_socket_mode_
&
&
num_response_per_srflx_addr
.
size
(
)
>
1
)
{
+
nat_type
=
NATTYPE_SYMMETRIC
;
+
}
+
}
+
+
/
/
We
'
re
probably
not
behind
a
regular
NAT
.
We
have
more
than
1
distinct
+
/
/
server
reflexive
IPs
.
+
if
(
srflx_ips
.
size
(
)
>
1
)
{
+
return
false
;
+
}
+
+
int
num_sent
=
0
;
+
int
num_received
=
0
;
+
int
num_server_ip_with_response
=
0
;
+
+
for
(
const
auto
&
kv
:
num_response_per_server
)
{
+
RTC_DCHECK_GT
(
kv
.
second
0
)
;
+
num_server_ip_with_response
+
+
;
+
num_received
+
=
kv
.
second
;
+
num_sent
+
=
num_request_per_server
[
kv
.
first
]
;
+
}
+
+
/
/
Shared
mode
is
only
true
if
we
use
the
shared
socket
and
there
are
more
+
/
/
than
1
responding
servers
.
+
stats
.
shared_socket_mode
=
+
shared_socket_mode_
&
&
(
num_server_ip_with_response
>
1
)
;
+
+
if
(
stats
.
shared_socket_mode
&
&
nat_type
=
=
NATTYPE_INVALID
)
{
+
nat_type
=
NATTYPE_NON_SYMMETRIC
;
+
}
+
+
/
/
If
we
could
find
a
local
IP
matching
srflx
we
'
re
not
behind
a
NAT
.
+
rtc
:
:
SocketAddress
srflx_addr
;
+
if
(
stats
.
srflx_addrs
.
size
(
)
&
&
+
!
srflx_addr
.
FromString
(
*
(
stats
.
srflx_addrs
.
begin
(
)
)
)
)
{
+
return
false
;
+
}
+
for
(
const
auto
*
net
:
networks_
)
{
+
if
(
srflx_addr
.
ipaddr
(
)
=
=
net
-
>
GetBestIP
(
)
)
{
+
nat_type
=
stunprober
:
:
NATTYPE_NONE
;
+
stats
.
host_ip
=
net
-
>
GetBestIP
(
)
.
ToString
(
)
;
+
break
;
+
}
+
}
+
+
/
/
Finally
we
know
we
'
re
behind
a
NAT
but
can
'
t
determine
which
type
it
is
.
+
if
(
nat_type
=
=
NATTYPE_INVALID
)
{
+
nat_type
=
NATTYPE_UNKNOWN
;
+
}
+
+
stats
.
nat_type
=
nat_type
;
+
stats
.
num_request_sent
=
num_sent
;
+
stats
.
num_response_received
=
num_received
;
+
stats
.
target_request_interval_ns
=
interval_ms_
*
1000
;
+
+
if
(
num_sent
)
{
+
stats
.
success_percent
=
static_cast
<
int
>
(
100
*
num_received
/
num_sent
)
;
+
}
+
+
if
(
stats
.
raw_num_request_sent
>
1
)
{
+
stats
.
actual_request_interval_ns
=
+
(
1000
*
(
last_sent_time
-
first_sent_time
)
)
/
+
(
stats
.
raw_num_request_sent
-
1
)
;
+
}
+
+
if
(
num_received
)
{
+
stats
.
average_rtt_ms
=
static_cast
<
int
>
(
(
rtt_sum
/
num_received
)
)
;
+
}
+
+
*
prob_stats
=
stats
;
+
return
true
;
+
}
+
+
void
StunProber
:
:
ReportOnPrepared
(
StunProber
:
:
Status
status
)
{
+
if
(
observer_
)
{
+
observer_
-
>
OnPrepared
(
this
status
)
;
+
}
+
}
+
+
void
StunProber
:
:
ReportOnFinished
(
StunProber
:
:
Status
status
)
{
+
if
(
observer_
)
{
+
observer_
-
>
OnFinished
(
this
status
)
;
+
}
+
}
+
+
}
/
/
namespace
stunprober
diff
-
-
git
a
/
p2p
/
stunprober
/
stun_prober
.
h
b
/
p2p
/
stunprober
/
stun_prober
.
h
new
file
mode
100644
index
0000000000
.
.
07f3a17233
-
-
-
/
dev
/
null
+
+
+
b
/
p2p
/
stunprober
/
stun_prober
.
h
-
0
0
+
1
251
+
/
*
+
*
Copyright
2015
The
WebRTC
Project
Authors
.
All
rights
reserved
.
+
*
+
*
Use
of
this
source
code
is
governed
by
a
BSD
-
style
license
+
*
that
can
be
found
in
the
LICENSE
file
in
the
root
of
the
source
+
*
tree
.
An
additional
intellectual
property
rights
grant
can
be
found
+
*
in
the
file
PATENTS
.
All
contributing
project
authors
may
+
*
be
found
in
the
AUTHORS
file
in
the
root
of
the
source
tree
.
+
*
/
+
+
#
ifndef
P2P_STUNPROBER_STUN_PROBER_H_
+
#
define
P2P_STUNPROBER_STUN_PROBER_H_
+
+
#
include
<
memory
>
+
#
include
<
set
>
+
#
include
<
string
>
+
#
include
<
vector
>
+
+
#
include
"
api
/
async_dns_resolver
.
h
"
+
#
include
"
api
/
sequence_checker
.
h
"
+
#
include
"
api
/
task_queue
/
pending_task_safety_flag
.
h
"
+
#
include
"
rtc_base
/
network
.
h
"
+
#
include
"
rtc_base
/
socket_address
.
h
"
+
#
include
"
rtc_base
/
system
/
rtc_export
.
h
"
+
#
include
"
rtc_base
/
thread
.
h
"
+
+
namespace
rtc
{
+
class
AsyncPacketSocket
;
+
class
PacketSocketFactory
;
+
class
Thread
;
+
class
NetworkManager
;
+
class
AsyncResolverInterface
;
+
}
/
/
namespace
rtc
+
+
namespace
stunprober
{
+
+
class
StunProber
;
+
+
static
const
int
kMaxUdpBufferSize
=
1200
;
+
+
typedef
std
:
:
function
<
void
(
StunProber
*
int
)
>
AsyncCallback
;
+
+
enum
NatType
{
+
NATTYPE_INVALID
+
NATTYPE_NONE
/
/
Not
behind
a
NAT
.
+
NATTYPE_UNKNOWN
/
/
Behind
a
NAT
but
type
can
'
t
be
determine
.
+
NATTYPE_SYMMETRIC
/
/
Behind
a
symmetric
NAT
.
+
NATTYPE_NON_SYMMETRIC
/
/
Behind
a
non
-
symmetric
NAT
.
+
}
;
+
+
class
RTC_EXPORT
StunProber
:
public
sigslot
:
:
has_slots
<
>
{
+
public
:
+
enum
Status
{
/
/
Used
in
UMA_HISTOGRAM_ENUMERATION
.
+
SUCCESS
/
/
Successfully
received
bytes
from
the
server
.
+
GENERIC_FAILURE
/
/
Generic
failure
.
+
RESOLVE_FAILED
/
/
Host
resolution
failed
.
+
WRITE_FAILED
/
/
Sending
a
message
to
the
server
failed
.
+
READ_FAILED
/
/
Reading
the
reply
from
the
server
failed
.
+
}
;
+
+
class
Observer
{
+
public
:
+
virtual
~
Observer
(
)
=
default
;
+
virtual
void
OnPrepared
(
StunProber
*
prober
StunProber
:
:
Status
status
)
=
0
;
+
virtual
void
OnFinished
(
StunProber
*
prober
StunProber
:
:
Status
status
)
=
0
;
+
}
;
+
+
struct
RTC_EXPORT
Stats
{
+
Stats
(
)
;
+
~
Stats
(
)
;
+
+
/
/
raw_num_request_sent
is
the
total
number
of
requests
+
/
/
sent
.
num_request_sent
is
the
count
of
requests
against
a
server
where
+
/
/
we
see
at
least
one
response
.
num_request_sent
is
designed
to
protect
+
/
/
against
DNS
resolution
failure
or
the
STUN
server
is
not
responsive
+
/
/
which
could
skew
the
result
.
+
int
raw_num_request_sent
=
0
;
+
int
num_request_sent
=
0
;
+
+
int
num_response_received
=
0
;
+
NatType
nat_type
=
NATTYPE_INVALID
;
+
int
average_rtt_ms
=
-
1
;
+
int
success_percent
=
0
;
+
int
target_request_interval_ns
=
0
;
+
int
actual_request_interval_ns
=
0
;
+
+
/
/
Also
report
whether
this
trial
can
'
t
be
considered
truly
as
shared
+
/
/
mode
.
Share
mode
only
makes
sense
when
we
have
multiple
IP
resolved
and
+
/
/
successfully
probed
.
+
bool
shared_socket_mode
=
false
;
+
+
std
:
:
string
host_ip
;
+
+
/
/
If
the
srflx_addrs
has
more
than
1
element
the
NAT
is
symmetric
.
+
std
:
:
set
<
std
:
:
string
>
srflx_addrs
;
+
}
;
+
+
StunProber
(
rtc
:
:
PacketSocketFactory
*
socket_factory
+
rtc
:
:
Thread
*
thread
+
std
:
:
vector
<
const
rtc
:
:
Network
*
>
networks
)
;
+
~
StunProber
(
)
override
;
+
+
StunProber
(
const
StunProber
&
)
=
delete
;
+
StunProber
&
operator
=
(
const
StunProber
&
)
=
delete
;
+
+
/
/
Begin
performing
the
probe
test
against
the
servers
.
If
+
/
/
shared_socket_mode
is
false
each
request
will
be
done
with
a
new
socket
.
+
/
/
Otherwise
a
unique
socket
will
be
used
for
a
single
round
of
requests
+
/
/
against
all
resolved
IPs
.
No
single
socket
will
be
used
against
a
given
IP
+
/
/
more
than
once
.
The
interval
of
requests
will
be
as
close
to
the
requested
+
/
/
inter
-
probe
interval
stun_ta_interval_ms
as
possible
.
After
sending
out
+
/
/
the
last
scheduled
request
the
probe
will
wait
timeout_ms
for
request
+
/
/
responses
and
then
call
finish_callback
.
requests_per_ip
indicates
how
+
/
/
many
requests
should
be
tried
for
each
resolved
IP
address
.
In
shared
mode
+
/
/
(
the
number
of
sockets
to
be
created
)
equals
to
requests_per_ip
.
In
+
/
/
non
-
shared
mode
(
the
number
of
sockets
)
equals
to
requests_per_ip
*
(
the
+
/
/
number
of
resolved
IP
addresses
)
.
TODO
(
guoweis
)
:
Remove
this
once
+
/
/
everything
moved
to
Prepare
(
)
and
Run
(
)
.
+
bool
Start
(
const
std
:
:
vector
<
rtc
:
:
SocketAddress
>
&
servers
+
bool
shared_socket_mode
+
int
stun_ta_interval_ms
+
int
requests_per_ip
+
int
timeout_ms
+
AsyncCallback
finish_callback
)
;
+
+
/
/
TODO
(
guoweis
)
:
The
combination
of
Prepare
(
)
and
Run
(
)
are
equivalent
to
the
+
/
/
Start
(
)
above
.
Remove
Start
(
)
once
everything
is
migrated
.
+
bool
Prepare
(
const
std
:
:
vector
<
rtc
:
:
SocketAddress
>
&
servers
+
bool
shared_socket_mode
+
int
stun_ta_interval_ms
+
int
requests_per_ip
+
int
timeout_ms
+
StunProber
:
:
Observer
*
observer
)
;
+
+
/
/
Start
to
send
out
the
STUN
probes
.
+
bool
Start
(
StunProber
:
:
Observer
*
observer
)
;
+
+
/
/
Method
to
retrieve
the
Stats
once
finish_callback
is
invoked
.
Returning
+
/
/
false
when
the
result
is
inconclusive
for
example
whether
it
'
s
behind
a
+
/
/
NAT
or
not
.
+
bool
GetStats
(
Stats
*
stats
)
const
;
+
+
int
estimated_execution_time
(
)
{
+
return
static_cast
<
int
>
(
requests_per_ip_
*
all_servers_addrs_
.
size
(
)
*
+
interval_ms_
)
;
+
}
+
+
private
:
+
/
/
A
requester
tracks
the
requests
and
responses
from
a
single
socket
to
many
+
/
/
STUN
servers
.
+
class
Requester
;
+
+
/
/
TODO
(
guoweis
)
:
Remove
this
once
all
dependencies
move
away
from
+
/
/
AsyncCallback
.
+
class
ObserverAdapter
:
public
Observer
{
+
public
:
+
ObserverAdapter
(
)
;
+
~
ObserverAdapter
(
)
override
;
+
+
void
set_callback
(
AsyncCallback
callback
)
{
callback_
=
callback
;
}
+
void
OnPrepared
(
StunProber
*
stunprober
Status
status
)
override
;
+
void
OnFinished
(
StunProber
*
stunprober
Status
status
)
override
;
+
+
private
:
+
AsyncCallback
callback_
;
+
}
;
+
+
bool
ResolveServerName
(
const
rtc
:
:
SocketAddress
&
addr
)
;
+
void
OnServerResolved
(
const
webrtc
:
:
AsyncDnsResolverResult
&
resolver
)
;
+
+
void
OnSocketReady
(
rtc
:
:
AsyncPacketSocket
*
socket
+
const
rtc
:
:
SocketAddress
&
addr
)
;
+
+
void
CreateSockets
(
)
;
+
+
bool
Done
(
)
{
+
return
num_request_sent_
>
=
requests_per_ip_
*
all_servers_addrs_
.
size
(
)
;
+
}
+
+
size_t
total_socket_required
(
)
{
+
return
(
shared_socket_mode_
?
1
:
all_servers_addrs_
.
size
(
)
)
*
+
requests_per_ip_
;
+
}
+
+
bool
should_send_next_request
(
int64_t
now
)
;
+
int
get_wake_up_interval_ms
(
)
;
+
+
bool
SendNextRequest
(
)
;
+
+
/
/
Will
be
invoked
in
1ms
intervals
and
schedule
the
next
request
from
the
+
/
/
current_requester_
if
the
time
has
passed
for
another
request
.
+
void
MaybeScheduleStunRequests
(
)
;
+
+
void
ReportOnPrepared
(
StunProber
:
:
Status
status
)
;
+
void
ReportOnFinished
(
StunProber
:
:
Status
status
)
;
+
+
Requester
*
CreateRequester
(
)
;
+
+
Requester
*
current_requester_
=
nullptr
;
+
+
/
/
The
time
when
the
next
request
should
go
out
.
+
int64_t
next_request_time_ms_
=
0
;
+
+
/
/
Total
requests
sent
so
far
.
+
uint32_t
num_request_sent_
=
0
;
+
+
bool
shared_socket_mode_
=
false
;
+
+
/
/
How
many
requests
should
be
done
against
each
resolved
IP
.
+
uint32_t
requests_per_ip_
=
0
;
+
+
/
/
Milliseconds
to
pause
between
each
STUN
request
.
+
int
interval_ms_
;
+
+
/
/
Timeout
period
after
the
last
request
is
sent
.
+
int
timeout_ms_
;
+
+
/
/
STUN
server
name
to
be
resolved
.
+
std
:
:
vector
<
rtc
:
:
SocketAddress
>
servers_
;
+
+
/
/
Weak
references
.
+
rtc
:
:
PacketSocketFactory
*
socket_factory_
;
+
rtc
:
:
Thread
*
thread_
;
+
+
/
/
Accumulate
all
resolved
addresses
.
+
std
:
:
vector
<
rtc
:
:
SocketAddress
>
all_servers_addrs_
;
+
+
/
/
The
set
of
STUN
probe
sockets
and
their
state
.
+
std
:
:
vector
<
Requester
*
>
requesters_
;
+
+
webrtc
:
:
SequenceChecker
thread_checker_
;
+
+
/
/
Temporary
storage
for
created
sockets
.
+
std
:
:
vector
<
rtc
:
:
AsyncPacketSocket
*
>
sockets_
;
+
/
/
This
tracks
how
many
of
the
sockets
are
ready
.
+
size_t
total_ready_sockets_
=
0
;
+
+
Observer
*
observer_
=
nullptr
;
+
/
/
TODO
(
guoweis
)
:
Remove
this
once
all
dependencies
move
away
from
+
/
/
AsyncCallback
.
+
ObserverAdapter
observer_adapter_
;
+
+
const
std
:
:
vector
<
const
rtc
:
:
Network
*
>
networks_
;
+
std
:
:
unique_ptr
<
webrtc
:
:
AsyncDnsResolverInterface
>
resolver_
;
+
+
webrtc
:
:
ScopedTaskSafety
task_safety_
;
+
}
;
+
+
}
/
/
namespace
stunprober
+
+
#
endif
/
/
P2P_STUNPROBER_STUN_PROBER_H_
diff
-
-
git
a
/
p2p
/
stunprober
/
stun_prober_unittest
.
cc
b
/
p2p
/
stunprober
/
stun_prober_unittest
.
cc
new
file
mode
100644
index
0000000000
.
.
1aa2be2844
-
-
-
/
dev
/
null
+
+
+
b
/
p2p
/
stunprober
/
stun_prober_unittest
.
cc
-
0
0
+
1
177
+
/
*
+
*
Copyright
2015
The
WebRTC
Project
Authors
.
All
rights
reserved
.
+
*
+
*
Use
of
this
source
code
is
governed
by
a
BSD
-
style
license
+
*
that
can
be
found
in
the
LICENSE
file
in
the
root
of
the
source
+
*
tree
.
An
additional
intellectual
property
rights
grant
can
be
found
+
*
in
the
file
PATENTS
.
All
contributing
project
authors
may
+
*
be
found
in
the
AUTHORS
file
in
the
root
of
the
source
tree
.
+
*
/
+
+
#
include
"
p2p
/
stunprober
/
stun_prober
.
h
"
+
+
#
include
<
stdint
.
h
>
+
+
#
include
<
memory
>
+
#
include
<
utility
>
+
+
#
include
"
p2p
/
base
/
basic_packet_socket_factory
.
h
"
+
#
include
"
p2p
/
base
/
test_stun_server
.
h
"
+
#
include
"
rtc_base
/
gunit
.
h
"
+
#
include
"
rtc_base
/
ip_address
.
h
"
+
#
include
"
rtc_base
/
ssl_adapter
.
h
"
+
#
include
"
rtc_base
/
virtual_socket_server
.
h
"
+
#
include
"
test
/
gtest
.
h
"
+
+
using
stunprober
:
:
AsyncCallback
;
+
using
stunprober
:
:
StunProber
;
+
+
namespace
stunprober
{
+
+
namespace
{
+
+
const
rtc
:
:
SocketAddress
kLocalAddr
(
"
192
.
168
.
0
.
1
"
0
)
;
+
const
rtc
:
:
SocketAddress
kStunAddr1
(
"
1
.
1
.
1
.
1
"
3478
)
;
+
const
rtc
:
:
SocketAddress
kStunAddr2
(
"
1
.
1
.
1
.
2
"
3478
)
;
+
const
rtc
:
:
SocketAddress
kFailedStunAddr
(
"
1
.
1
.
1
.
3
"
3478
)
;
+
const
rtc
:
:
SocketAddress
kStunMappedAddr
(
"
77
.
77
.
77
.
77
"
0
)
;
+
+
}
/
/
namespace
+
+
class
StunProberTest
:
public
:
:
testing
:
:
Test
{
+
public
:
+
StunProberTest
(
)
+
:
ss_
(
std
:
:
make_unique
<
rtc
:
:
VirtualSocketServer
>
(
)
)
+
main_
(
ss_
.
get
(
)
)
+
result_
(
StunProber
:
:
SUCCESS
)
+
stun_server_1_
(
+
cricket
:
:
TestStunServer
:
:
Create
(
ss_
.
get
(
)
kStunAddr1
main_
)
)
+
stun_server_2_
(
+
cricket
:
:
TestStunServer
:
:
Create
(
ss_
.
get
(
)
kStunAddr2
main_
)
)
{
+
stun_server_1_
-
>
set_fake_stun_addr
(
kStunMappedAddr
)
;
+
stun_server_2_
-
>
set_fake_stun_addr
(
kStunMappedAddr
)
;
+
rtc
:
:
InitializeSSL
(
)
;
+
}
+
+
static
constexpr
int
pings_per_ip
=
3
;
+
+
void
set_expected_result
(
int
result
)
{
result_
=
result
;
}
+
+
void
CreateProber
(
rtc
:
:
PacketSocketFactory
*
socket_factory
+
std
:
:
vector
<
const
rtc
:
:
Network
*
>
networks
)
{
+
prober_
=
std
:
:
make_unique
<
StunProber
>
(
socket_factory
&
main_
+
std
:
:
move
(
networks
)
)
;
+
}
+
+
void
StartProbing
(
rtc
:
:
PacketSocketFactory
*
socket_factory
+
const
std
:
:
vector
<
rtc
:
:
SocketAddress
>
&
addrs
+
std
:
:
vector
<
const
rtc
:
:
Network
*
>
networks
+
bool
shared_socket
+
uint16_t
interval
+
uint16_t
pings_per_ip
)
{
+
CreateProber
(
socket_factory
networks
)
;
+
prober_
-
>
Start
(
addrs
shared_socket
interval
pings_per_ip
+
100
/
*
timeout_ms
*
/
+
[
this
]
(
StunProber
*
prober
int
result
)
{
+
StopCallback
(
prober
result
)
;
+
}
)
;
+
}
+
+
void
RunProber
(
bool
shared_mode
)
{
+
std
:
:
vector
<
rtc
:
:
SocketAddress
>
addrs
;
+
addrs
.
push_back
(
kStunAddr1
)
;
+
addrs
.
push_back
(
kStunAddr2
)
;
+
/
/
Add
a
non
-
existing
server
.
This
shouldn
'
t
pollute
the
result
.
+
addrs
.
push_back
(
kFailedStunAddr
)
;
+
RunProber
(
shared_mode
addrs
/
*
check_results
=
*
/
true
)
;
+
}
+
+
void
RunProber
(
bool
shared_mode
+
const
std
:
:
vector
<
rtc
:
:
SocketAddress
>
&
addrs
+
bool
check_results
)
{
+
rtc
:
:
Network
ipv4_network1
(
"
test_eth0
"
"
Test
Network
Adapter
1
"
+
rtc
:
:
IPAddress
(
0x12345600U
)
24
)
;
+
ipv4_network1
.
AddIP
(
rtc
:
:
IPAddress
(
0x12345678
)
)
;
+
std
:
:
vector
<
const
rtc
:
:
Network
*
>
networks
;
+
networks
.
push_back
(
&
ipv4_network1
)
;
+
+
auto
socket_factory
=
+
std
:
:
make_unique
<
rtc
:
:
BasicPacketSocketFactory
>
(
ss_
.
get
(
)
)
;
+
+
/
/
Set
up
the
expected
results
for
verification
.
+
std
:
:
set
<
std
:
:
string
>
srflx_addresses
;
+
srflx_addresses
.
insert
(
kStunMappedAddr
.
ToString
(
)
)
;
+
const
uint32_t
total_pings_tried
=
+
static_cast
<
uint32_t
>
(
pings_per_ip
*
addrs
.
size
(
)
)
;
+
+
/
/
The
reported
total_pings
should
not
count
for
pings
sent
to
the
+
/
/
kFailedStunAddr
.
+
const
uint32_t
total_pings_reported
=
total_pings_tried
-
pings_per_ip
;
+
+
StartProbing
(
socket_factory
.
get
(
)
addrs
std
:
:
move
(
networks
)
shared_mode
+
3
pings_per_ip
)
;
+
+
WAIT
(
stopped_
1000
)
;
+
+
EXPECT_TRUE
(
prober_
-
>
GetStats
(
&
stats_
)
)
;
+
if
(
check_results
)
{
+
EXPECT_EQ
(
stats_
.
success_percent
100
)
;
+
EXPECT_TRUE
(
stats_
.
nat_type
>
stunprober
:
:
NATTYPE_NONE
)
;
+
EXPECT_EQ
(
stats_
.
srflx_addrs
srflx_addresses
)
;
+
EXPECT_EQ
(
static_cast
<
uint32_t
>
(
stats_
.
num_request_sent
)
+
total_pings_reported
)
;
+
EXPECT_EQ
(
static_cast
<
uint32_t
>
(
stats_
.
num_response_received
)
+
total_pings_reported
)
;
+
}
+
}
+
+
StunProber
*
prober
(
)
{
return
prober_
.
get
(
)
;
}
+
StunProber
:
:
Stats
&
stats
(
)
{
return
stats_
;
}
+
+
private
:
+
void
StopCallback
(
StunProber
*
prober
int
result
)
{
+
EXPECT_EQ
(
result
result_
)
;
+
stopped_
=
true
;
+
}
+
+
std
:
:
unique_ptr
<
rtc
:
:
VirtualSocketServer
>
ss_
;
+
rtc
:
:
AutoSocketServerThread
main_
;
+
std
:
:
unique_ptr
<
StunProber
>
prober_
;
+
int
result_
=
0
;
+
bool
stopped_
=
false
;
+
cricket
:
:
TestStunServer
:
:
StunServerPtr
stun_server_1_
;
+
cricket
:
:
TestStunServer
:
:
StunServerPtr
stun_server_2_
;
+
StunProber
:
:
Stats
stats_
;
+
}
;
+
+
TEST_F
(
StunProberTest
NonSharedMode
)
{
+
RunProber
(
false
)
;
+
}
+
+
TEST_F
(
StunProberTest
SharedMode
)
{
+
RunProber
(
true
)
;
+
}
+
+
TEST_F
(
StunProberTest
ResolveNonexistentHostname
)
{
+
std
:
:
vector
<
rtc
:
:
SocketAddress
>
addrs
;
+
addrs
.
push_back
(
kStunAddr1
)
;
+
/
/
Add
a
non
-
existing
server
by
name
.
This
should
cause
a
failed
lookup
.
+
addrs
.
push_back
(
rtc
:
:
SocketAddress
(
"
nonexistent
.
test
"
3478
)
)
;
+
RunProber
(
false
addrs
false
)
;
+
/
/
One
server
is
pinged
+
EXPECT_EQ
(
stats
(
)
.
raw_num_request_sent
pings_per_ip
)
;
+
}
+
+
TEST_F
(
StunProberTest
ResolveExistingHostname
)
{
+
std
:
:
vector
<
rtc
:
:
SocketAddress
>
addrs
;
+
addrs
.
push_back
(
kStunAddr1
)
;
+
/
/
Add
a
non
-
existing
server
by
name
.
This
should
cause
a
failed
lookup
.
+
addrs
.
push_back
(
rtc
:
:
SocketAddress
(
"
localhost
"
3478
)
)
;
+
RunProber
(
false
addrs
false
)
;
+
/
/
Two
servers
are
pinged
only
one
responds
.
+
/
/
TODO
(
bugs
.
webrtc
.
org
/
15559
)
:
Figure
out
why
this
doesn
'
t
always
work
+
/
/
EXPECT_EQ
(
stats
(
)
.
raw_num_request_sent
pings_per_ip
*
2
)
;
+
EXPECT_EQ
(
stats
(
)
.
num_request_sent
pings_per_ip
)
;
+
}
+
+
}
/
/
namespace
stunprober
