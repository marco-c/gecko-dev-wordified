From
:
Michael
Froman
<
mjfroman
mac
.
com
>
Date
:
Tue
19
Nov
2024
13
:
10
:
26
-
0600
Subject
:
(
tmp
-
cherry
-
pick
)
Revert
"
Use
ArrayView
for
byte
stream
parsing
in
VideoRtpDepacketizerH264
"
(
208491c8b9
)
This
reverts
commit
4b53e9af6126028497239b39321ec6740f8e2bc2
.
Reason
for
revert
:
Bug
:
chromium
:
371054866
Original
change
'
s
description
:
>
Use
ArrayView
for
byte
stream
parsing
in
VideoRtpDepacketizerH264
>
>
>
Bug
:
webrtc
:
42223344
webrtc
:
42225170
>
Change
-
Id
:
Ia2025ab225499702c0abe47690742a9c0d6109b7
>
Reviewed
-
on
:
https
:
/
/
webrtc
-
review
.
googlesource
.
com
/
c
/
src
/
+
/
364380
>
Reviewed
-
by
:
Danil
Chapovalov
<
danilchap
webrtc
.
org
>
>
Reviewed
-
by
:
Sergey
Silkin
<
ssilkin
webrtc
.
org
>
>
Commit
-
Queue
:
Danil
Chapovalov
<
danilchap
webrtc
.
org
>
>
Cr
-
Commit
-
Position
:
refs
/
heads
/
main
{
#
43147
}
Bug
:
webrtc
:
42223344
webrtc
:
42225170
chromium
:
371054866
Change
-
Id
:
I5c0222add560622a6ce34622d80a4bf7f1fc3fae
No
-
Try
:
true
Reviewed
-
on
:
https
:
/
/
webrtc
-
review
.
googlesource
.
com
/
c
/
src
/
+
/
364560
Bot
-
Commit
:
rubber
-
stamper
appspot
.
gserviceaccount
.
com
<
rubber
-
stamper
appspot
.
gserviceaccount
.
com
>
Commit
-
Queue
:
Danil
Chapovalov
<
danilchap
webrtc
.
org
>
Cr
-
Commit
-
Position
:
refs
/
heads
/
main
{
#
43155
}
-
-
-
.
.
.
/
source
/
video_rtp_depacketizer_h264
.
cc
|
92
+
+
+
+
+
+
+
+
+
+
+
-
-
-
-
-
-
-
-
1
file
changed
55
insertions
(
+
)
37
deletions
(
-
)
diff
-
-
git
a
/
modules
/
rtp_rtcp
/
source
/
video_rtp_depacketizer_h264
.
cc
b
/
modules
/
rtp_rtcp
/
source
/
video_rtp_depacketizer_h264
.
cc
index
8ea399ff08
.
.
19ada0fa6f
100644
-
-
-
a
/
modules
/
rtp_rtcp
/
source
/
video_rtp_depacketizer_h264
.
cc
+
+
+
b
/
modules
/
rtp_rtcp
/
source
/
video_rtp_depacketizer_h264
.
cc
-
24
7
+
24
6
#
include
"
modules
/
rtp_rtcp
/
source
/
byte_io
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
rtp_format_h264
.
h
"
#
include
"
modules
/
rtp_rtcp
/
source
/
video_rtp_depacketizer
.
h
"
-
#
include
"
rtc_base
/
byte_buffer
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
copy_on_write_buffer
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
-
35
32
+
34
34
namespace
{
constexpr
size_t
kNalHeaderSize
=
1
;
constexpr
size_t
kFuAHeaderSize
=
2
;
constexpr
size_t
kLengthFieldSize
=
2
;
+
constexpr
size_t
kStapAHeaderSize
=
kNalHeaderSize
+
kLengthFieldSize
;
-
std
:
:
vector
<
rtc
:
:
ArrayView
<
const
uint8_t
>
>
ParseStapA
(
-
rtc
:
:
ArrayView
<
const
uint8_t
>
data
)
{
-
std
:
:
vector
<
rtc
:
:
ArrayView
<
const
uint8_t
>
>
nal_units
;
-
rtc
:
:
ByteBufferReader
reader
(
data
)
;
-
if
(
!
reader
.
Consume
(
kNalHeaderSize
)
)
{
-
return
nal_units
;
-
}
+
/
/
TODO
(
pbos
)
:
Avoid
parsing
this
here
as
well
as
inside
the
jitter
buffer
.
+
bool
ParseStapAStartOffsets
(
const
uint8_t
*
nalu_ptr
+
size_t
length_remaining
+
std
:
:
vector
<
size_t
>
*
offsets
)
{
+
size_t
offset
=
0
;
+
while
(
length_remaining
>
0
)
{
+
/
/
Buffer
doesn
'
t
contain
room
for
additional
nalu
length
.
+
if
(
length_remaining
<
sizeof
(
uint16_t
)
)
+
return
false
;
+
uint16_t
nalu_size
=
ByteReader
<
uint16_t
>
:
:
ReadBigEndian
(
nalu_ptr
)
;
+
nalu_ptr
+
=
sizeof
(
uint16_t
)
;
+
length_remaining
-
=
sizeof
(
uint16_t
)
;
+
if
(
nalu_size
>
length_remaining
)
+
return
false
;
+
nalu_ptr
+
=
nalu_size
;
+
length_remaining
-
=
nalu_size
;
-
while
(
reader
.
Length
(
)
>
0
)
{
-
uint16_t
nalu_size
;
-
if
(
!
reader
.
ReadUInt16
(
&
nalu_size
)
)
{
-
return
{
}
;
-
}
-
if
(
nalu_size
=
=
0
|
|
nalu_size
>
reader
.
Length
(
)
)
{
-
return
{
}
;
-
}
-
nal_units
.
emplace_back
(
reader
.
Data
(
)
nalu_size
)
;
-
reader
.
Consume
(
nalu_size
)
;
+
offsets
-
>
push_back
(
offset
+
kStapAHeaderSize
)
;
+
offset
+
=
kLengthFieldSize
+
nalu_size
;
}
-
return
nal_units
;
+
return
true
;
}
std
:
:
optional
<
VideoRtpDepacketizer
:
:
ParsedRtpPayload
>
ProcessStapAOrSingleNalu
(
rtc
:
:
CopyOnWriteBuffer
rtp_payload
)
{
-
rtc
:
:
ArrayView
<
const
uint8_t
>
payload_data
(
rtp_payload
)
;
+
const
uint8_t
*
const
payload_data
=
rtp_payload
.
cdata
(
)
;
std
:
:
optional
<
VideoRtpDepacketizer
:
:
ParsedRtpPayload
>
parsed_payload
(
std
:
:
in_place
)
;
bool
modified_buffer
=
false
;
-
73
32
+
74
50
std
:
:
optional
<
VideoRtpDepacketizer
:
:
ParsedRtpPayload
>
ProcessStapAOrSingleNalu
(
auto
&
h264_header
=
parsed_payload
-
>
video_header
.
video_type_header
.
emplace
<
RTPVideoHeaderH264
>
(
)
;
+
const
uint8_t
*
nalu_start
=
payload_data
+
kNalHeaderSize
;
+
const
size_t
nalu_length
=
rtp_payload
.
size
(
)
-
kNalHeaderSize
;
uint8_t
nal_type
=
payload_data
[
0
]
&
kH264TypeMask
;
-
std
:
:
vector
<
rtc
:
:
ArrayView
<
const
uint8_t
>
>
nal_units
;
+
std
:
:
vector
<
size_t
>
nalu_start_offsets
;
if
(
nal_type
=
=
H264
:
:
NaluType
:
:
kStapA
)
{
-
nal_units
=
ParseStapA
(
payload_data
)
;
-
if
(
nal_units
.
empty
(
)
)
{
-
RTC_LOG
(
LS_ERROR
)
<
<
"
Incorrect
StapA
packet
.
"
;
+
/
/
Skip
the
StapA
header
(
StapA
NAL
type
+
length
)
.
+
if
(
rtp_payload
.
size
(
)
<
=
kStapAHeaderSize
)
{
+
RTC_LOG
(
LS_ERROR
)
<
<
"
StapA
header
truncated
.
"
;
+
return
std
:
:
nullopt
;
+
}
+
+
if
(
!
ParseStapAStartOffsets
(
nalu_start
nalu_length
&
nalu_start_offsets
)
)
{
+
RTC_LOG
(
LS_ERROR
)
<
<
"
StapA
packet
with
incorrect
NALU
packet
lengths
.
"
;
return
std
:
:
nullopt
;
}
+
h264_header
.
packetization_type
=
kH264StapA
;
-
h264_header
.
nalu_type
=
nal_units
[
0
]
[
0
]
&
kH264TypeMask
;
+
nal_type
=
payload_data
[
kStapAHeaderSize
]
&
kH264TypeMask
;
}
else
{
h264_header
.
packetization_type
=
kH264SingleNalu
;
-
h264_header
.
nalu_type
=
nal_type
;
-
nal_units
.
push_back
(
payload_data
)
;
+
nalu_start_offsets
.
push_back
(
0
)
;
}
-
+
h264_header
.
nalu_type
=
nal_type
;
parsed_payload
-
>
video_header
.
frame_type
=
VideoFrameType
:
:
kVideoFrameDelta
;
-
for
(
const
rtc
:
:
ArrayView
<
const
uint8_t
>
&
nal_unit
:
nal_units
)
{
+
nalu_start_offsets
.
push_back
(
rtp_payload
.
size
(
)
+
+
kLengthFieldSize
)
;
/
/
End
offset
.
+
for
(
size_t
i
=
0
;
i
<
nalu_start_offsets
.
size
(
)
-
1
;
+
+
i
)
{
+
size_t
start_offset
=
nalu_start_offsets
[
i
]
;
+
/
/
End
offset
is
actually
start
offset
for
next
unit
excluding
length
field
+
/
/
so
remove
that
from
this
units
length
.
+
size_t
end_offset
=
nalu_start_offsets
[
i
+
1
]
-
kLengthFieldSize
;
+
if
(
end_offset
-
start_offset
<
H264
:
:
kNaluTypeSize
)
{
+
RTC_LOG
(
LS_ERROR
)
<
<
"
STAP
-
A
packet
too
short
"
;
+
return
std
:
:
nullopt
;
+
}
+
NaluInfo
nalu
;
-
nalu
.
type
=
nal_unit
[
0
]
&
kH264TypeMask
;
+
nalu
.
type
=
payload_data
[
start_offset
]
&
kH264TypeMask
;
nalu
.
sps_id
=
-
1
;
nalu
.
pps_id
=
-
1
;
-
rtc
:
:
ArrayView
<
const
uint8_t
>
nalu_data
=
-
nal_unit
.
subview
(
H264
:
:
kNaluTypeSize
)
;
-
+
start_offset
+
=
H264
:
:
kNaluTypeSize
;
+
rtc
:
:
ArrayView
<
const
uint8_t
>
nalu_data
(
&
payload_data
[
start_offset
]
+
end_offset
-
start_offset
)
;
switch
(
nalu
.
type
)
{
case
H264
:
:
NaluType
:
:
kSps
:
{
/
/
Check
if
VUI
is
present
in
SPS
and
if
it
needs
to
be
modified
to
-
106
10
+
125
8
std
:
:
optional
<
VideoRtpDepacketizer
:
:
ParsedRtpPayload
>
ProcessStapAOrSingleNalu
(
/
/
Copy
any
previous
data
first
(
likely
just
the
first
header
)
.
rtc
:
:
Buffer
output_buffer
;
-
size_t
start_offset
=
nalu_data
.
data
(
)
-
payload_data
.
data
(
)
;
-
size_t
end_offset
=
start_offset
+
nalu_data
.
size
(
)
;
if
(
start_offset
)
-
output_buffer
.
AppendData
(
payload_data
.
data
(
)
start_offset
)
;
+
output_buffer
.
AppendData
(
payload_data
start_offset
)
;
std
:
:
optional
<
SpsParser
:
:
SpsState
>
sps
;
-
143
7
+
160
8
std
:
:
optional
<
VideoRtpDepacketizer
:
:
ParsedRtpPayload
>
ProcessStapAOrSingleNalu
(
output_buffer
.
size
(
)
)
;
/
/
Append
rest
of
packet
.
parsed_payload
-
>
video_payload
.
AppendData
(
-
payload_data
.
subview
(
end_offset
)
)
;
+
&
payload_data
[
end_offset
]
+
nalu_length
+
kNalHeaderSize
-
end_offset
)
;
modified_buffer
=
true
;
[
[
fallthrough
]
]
;
