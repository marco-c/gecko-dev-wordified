From
:
Michael
Froman
<
mjfroman
mac
.
com
>
Date
:
Tue
18
Jun
2024
10
:
07
:
36
-
0500
Subject
:
(
tmp
-
cherry
-
pick
)
Revert
"
New
video
encoder
API
.
"
(
56e6309749
)
MIME
-
Version
:
1
.
0
Content
-
Type
:
text
/
plain
;
charset
=
UTF
-
8
Content
-
Transfer
-
Encoding
:
8bit
This
reverts
commit
42f12d5183016060dcddc0b515a53294853559fe
.
Reason
for
revert
:
tests
fails
downstream
Original
change
'
s
description
:
>
New
video
encoder
API
.
>
>
Also
initial
implementation
wrapping
the
libaom
AV1
encoder
.
>
>
Note
that
for
now
this
is
intended
for
prototype
purposes
.
>
>
Bug
:
none
>
Change
-
Id
:
Iac42ca4aecb6a204601c9f00bfb300e3eda3c4f4
>
Reviewed
-
on
:
https
:
/
/
webrtc
-
review
.
googlesource
.
com
/
c
/
src
/
+
/
306181
>
Reviewed
-
by
:
Mirko
Bonadei
<
mbonadei
webrtc
.
org
>
>
Commit
-
Queue
:
Philip
Eliasson
<
philipel
webrtc
.
org
>
>
Reviewed
-
by
:
Erik
Spr
ng
<
sprang
webrtc
.
org
>
>
Cr
-
Commit
-
Position
:
refs
/
heads
/
main
{
#
42108
}
Bug
:
none
Change
-
Id
:
I927260353afb91df6c7650364baee4f13a098efd
No
-
Presubmit
:
true
No
-
Tree
-
Checks
:
true
No
-
Try
:
true
Reviewed
-
on
:
https
:
/
/
webrtc
-
review
.
googlesource
.
com
/
c
/
src
/
+
/
347883
Commit
-
Queue
:
Philip
Eliasson
<
philipel
webrtc
.
org
>
Bot
-
Commit
:
rubber
-
stamper
appspot
.
gserviceaccount
.
com
<
rubber
-
stamper
appspot
.
gserviceaccount
.
com
>
Reviewed
-
by
:
Philip
Eliasson
<
philipel
webrtc
.
org
>
Owners
-
Override
:
Philip
Eliasson
<
philipel
webrtc
.
org
>
Auto
-
Submit
:
Danil
Chapovalov
<
danilchap
webrtc
.
org
>
Cr
-
Commit
-
Position
:
refs
/
heads
/
main
{
#
42111
}
-
-
-
BUILD
.
gn
|
18
-
api
/
DEPS
|
13
-
api
/
video_codecs
/
BUILD
.
gn
|
119
-
-
-
.
.
.
/
libaom_av1_encoder_factory
.
cc
|
842
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
api
/
video_codecs
/
libaom_av1_encoder_factory
.
h
|
35
-
.
.
.
/
libaom_av1_encoder_factory_test
.
cc
|
822
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
api
/
video_codecs
/
simple_encoder_wrapper
.
cc
|
216
-
-
-
-
-
api
/
video_codecs
/
simple_encoder_wrapper
.
h
|
71
-
-
.
.
.
/
simple_encoder_wrapper_unittests
.
cc
|
302
-
-
-
-
-
-
-
.
.
.
/
video_encoder_factory_interface
.
h
|
104
-
-
-
api
/
video_codecs
/
video_encoder_interface
.
h
|
89
-
-
api
/
video_codecs
/
video_encoding_general
.
h
|
23
-
rtc_base
/
BUILD
.
gn
|
1
-
rtc_base
/
numerics
/
rational
.
h
|
28
-
14
files
changed
2683
deletions
(
-
)
delete
mode
100644
api
/
video_codecs
/
libaom_av1_encoder_factory
.
cc
delete
mode
100644
api
/
video_codecs
/
libaom_av1_encoder_factory
.
h
delete
mode
100644
api
/
video_codecs
/
libaom_av1_encoder_factory_test
.
cc
delete
mode
100644
api
/
video_codecs
/
simple_encoder_wrapper
.
cc
delete
mode
100644
api
/
video_codecs
/
simple_encoder_wrapper
.
h
delete
mode
100644
api
/
video_codecs
/
simple_encoder_wrapper_unittests
.
cc
delete
mode
100644
api
/
video_codecs
/
video_encoder_factory_interface
.
h
delete
mode
100644
api
/
video_codecs
/
video_encoder_interface
.
h
delete
mode
100644
api
/
video_codecs
/
video_encoding_general
.
h
delete
mode
100644
rtc_base
/
numerics
/
rational
.
h
diff
-
-
git
a
/
BUILD
.
gn
b
/
BUILD
.
gn
index
1b591a149e
.
.
571049f3e4
100644
-
-
-
a
/
BUILD
.
gn
+
+
+
b
/
BUILD
.
gn
-
589
16
+
589
6
if
(
use_libfuzzer
|
|
use_afl
)
{
}
if
(
rtc_include_tests
&
&
!
build_with_chromium
)
{
-
rtc_unittests_resources
=
[
"
resources
/
reference_video_640x360_30fps
.
y4m
"
]
-
-
if
(
is_ios
)
{
-
bundle_data
(
"
rtc_unittests_bundle_data
"
)
{
-
testonly
=
true
-
sources
=
rtc_unittests_resources
-
outputs
=
[
"
{
{
bundle_resources_dir
}
}
/
{
{
source_file_part
}
}
"
]
-
}
-
}
-
rtc_test
(
"
rtc_unittests
"
)
{
testonly
=
true
-
612
8
+
602
6
if
(
rtc_include_tests
&
&
!
build_with_chromium
)
{
"
api
/
test
/
metrics
:
metrics_unittests
"
"
api
/
transport
:
stun_unittest
"
"
api
/
video
/
test
:
rtc_api_video_unittests
"
-
"
api
/
video_codecs
:
libaom_av1_encoder_factory_test
"
-
"
api
/
video_codecs
:
simple_encoder_wrapper_unittests
"
"
api
/
video_codecs
/
test
:
video_codecs_api_unittests
"
"
api
/
voip
:
compile_all_headers
"
"
call
:
fake_network_pipe_unittests
"
-
642
16
+
630
10
if
(
rtc_include_tests
&
&
!
build_with_chromium
)
{
"
test
/
network
:
network_emulation_unittests
"
]
-
data
=
rtc_unittests_resources
-
if
(
rtc_enable_protobuf
)
{
deps
+
=
[
"
logging
:
rtc_event_log_tests
"
]
}
-
if
(
is_ios
)
{
-
deps
+
=
[
"
:
rtc_unittests_bundle_data
"
]
-
}
-
if
(
is_android
)
{
#
Do
not
use
Chromium
'
s
launcher
.
native_unittests
defines
its
own
JNI_OnLoad
.
use_default_launcher
=
false
diff
-
-
git
a
/
api
/
DEPS
b
/
api
/
DEPS
index
ddd6897139
.
.
5a5c285856
100644
-
-
-
a
/
api
/
DEPS
+
+
+
b
/
api
/
DEPS
-
213
19
+
213
6
specific_include_rules
=
{
"
+
modules
/
video_coding
"
]
-
"
video_encoder_factory_interface
\
.
h
"
:
[
-
"
+
rtc_base
/
numerics
"
-
]
-
-
"
video_encoder_interface
\
.
h
"
:
[
-
"
+
rtc_base
/
numerics
"
-
]
-
-
"
simple_encoder_wrapper
\
.
h
"
:
[
-
"
+
common_video
"
-
"
+
modules
"
-
]
-
"
video_decoder_factory_template
.
*
\
.
h
"
:
[
"
+
modules
/
video_coding
"
]
diff
-
-
git
a
/
api
/
video_codecs
/
BUILD
.
gn
b
/
api
/
video_codecs
/
BUILD
.
gn
index
40912a423a
.
.
444a8fcaeb
100644
-
-
-
a
/
api
/
video_codecs
/
BUILD
.
gn
+
+
+
b
/
api
/
video_codecs
/
BUILD
.
gn
-
280
125
+
280
6
rtc_source_set
(
"
video_decoder_factory_template_dav1d_adapter
"
)
{
]
}
-
rtc_source_set
(
"
video_encoding_general
"
)
{
-
public
=
[
"
video_encoding_general
.
h
"
]
-
}
-
-
rtc_source_set
(
"
video_encoder_interface
"
)
{
-
public
=
[
"
video_encoder_interface
.
h
"
]
-
-
deps
=
[
-
"
:
video_encoding_general
"
-
"
.
.
/
.
.
/
api
/
units
:
data_rate
"
-
"
.
.
/
.
.
/
api
/
units
:
time_delta
"
-
"
.
.
/
.
.
/
api
/
units
:
timestamp
"
-
"
.
.
/
.
.
/
api
/
video
:
encoded_image
"
-
"
.
.
/
.
.
/
api
/
video
:
resolution
"
-
"
.
.
/
.
.
/
api
/
video
:
video_frame
"
-
"
.
.
/
.
.
/
api
/
video_codecs
:
video_codecs_api
"
-
"
.
.
/
.
.
/
rtc_base
:
rtc_numerics
"
-
]
-
-
absl_deps
=
[
-
"
/
/
third_party
/
abseil
-
cpp
/
absl
/
functional
:
any_invocable
"
-
"
/
/
third_party
/
abseil
-
cpp
/
absl
/
types
:
optional
"
-
"
/
/
third_party
/
abseil
-
cpp
/
absl
/
types
:
variant
"
-
]
-
}
-
-
rtc_source_set
(
"
video_encoder_factory_interface
"
)
{
-
public
=
[
"
video_encoder_factory_interface
.
h
"
]
-
-
deps
=
[
-
"
:
video_encoder_interface
"
-
"
:
video_encoding_general
"
-
"
.
.
/
.
.
/
api
/
units
:
time_delta
"
-
"
.
.
/
.
.
/
api
/
video
:
resolution
"
-
"
.
.
/
.
.
/
rtc_base
:
rtc_numerics
"
-
]
-
-
absl_deps
=
[
-
"
/
/
third_party
/
abseil
-
cpp
/
absl
/
types
:
optional
"
-
"
/
/
third_party
/
abseil
-
cpp
/
absl
/
types
:
variant
"
-
]
-
}
-
-
rtc_library
(
"
simple_encoder_wrapper
"
)
{
-
sources
=
[
-
"
simple_encoder_wrapper
.
cc
"
-
"
simple_encoder_wrapper
.
h
"
-
]
-
-
deps
=
[
-
"
:
video_encoder_factory_interface
"
-
"
:
video_encoder_interface
"
-
"
.
.
/
.
.
/
api
/
units
:
data_rate
"
-
"
.
.
/
.
.
/
api
/
video_codecs
:
scalability_mode
"
-
"
.
.
/
.
.
/
api
/
video_codecs
:
scalability_mode_helper
"
-
"
.
.
/
.
.
/
common_video
/
generic_frame_descriptor
:
generic_frame_descriptor
"
-
"
.
.
/
.
.
/
modules
/
video_coding
/
svc
:
scalability_structures
"
-
"
.
.
/
.
.
/
rtc_base
:
logging
"
-
]
-
-
absl_deps
=
[
-
"
/
/
third_party
/
abseil
-
cpp
/
absl
/
algorithm
:
container
"
-
"
/
/
third_party
/
abseil
-
cpp
/
absl
/
functional
:
any_invocable
"
-
]
-
}
-
-
rtc_library
(
"
simple_encoder_wrapper_unittests
"
)
{
-
testonly
=
true
-
-
sources
=
[
"
simple_encoder_wrapper_unittests
.
cc
"
]
-
-
deps
=
[
-
"
:
simple_encoder_wrapper
"
-
"
:
video_encoder_factory_interface
"
-
"
:
video_encoder_interface
"
-
"
.
.
/
.
.
/
api
/
video
:
video_frame
"
-
"
.
.
/
.
.
/
api
/
video_codecs
:
libaom_av1_encoder_factory
"
-
"
.
.
/
.
.
/
test
:
fileutils
"
-
"
.
.
/
.
.
/
test
:
test_support
"
-
"
.
.
/
.
.
/
test
:
video_test_support
"
-
]
-
}
-
-
rtc_library
(
"
libaom_av1_encoder_factory
"
)
{
-
sources
=
[
-
"
libaom_av1_encoder_factory
.
cc
"
-
"
libaom_av1_encoder_factory
.
h
"
-
]
-
-
deps
=
[
-
"
:
video_encoder_factory_interface
"
-
"
:
video_encoder_interface
"
-
"
.
.
/
.
.
/
api
/
units
:
time_delta
"
-
"
.
.
/
.
.
/
rtc_base
:
logging
"
-
"
/
/
third_party
/
libaom
"
-
]
-
-
absl_deps
=
[
"
/
/
third_party
/
abseil
-
cpp
/
absl
/
algorithm
:
container
"
]
-
}
-
-
rtc_library
(
"
libaom_av1_encoder_factory_test
"
)
{
-
testonly
=
true
-
sources
=
[
"
libaom_av1_encoder_factory_test
.
cc
"
]
-
data
=
[
"
.
.
/
.
.
/
resources
/
reference_video_640x360_30fps
.
y4m
"
]
-
-
deps
=
[
-
"
:
libaom_av1_encoder_factory
"
-
"
:
video_encoder_interface
"
-
"
.
.
/
.
.
/
api
/
video
:
video_frame
"
-
"
.
.
/
.
.
/
api
/
video_codecs
:
video_codecs_api
"
-
"
.
.
/
.
.
/
common_video
:
common_video
"
-
"
.
.
/
.
.
/
modules
/
video_coding
/
codecs
/
av1
:
dav1d_decoder
"
-
"
.
.
/
.
.
/
rtc_base
:
logging
"
-
"
.
.
/
.
.
/
test
:
fileutils
"
-
"
.
.
/
.
.
/
test
:
test_support
"
-
"
.
.
/
.
.
/
test
:
video_test_support
"
-
]
-
}
-
rtc_library
(
"
vp8_temporal_layers_factory
"
)
{
visibility
=
[
"
*
"
]
allow_poison
=
[
"
software_video_codecs
"
]
diff
-
-
git
a
/
api
/
video_codecs
/
libaom_av1_encoder_factory
.
cc
b
/
api
/
video_codecs
/
libaom_av1_encoder_factory
.
cc
deleted
file
mode
100644
index
eab6eaefe8
.
.
0000000000
-
-
-
a
/
api
/
video_codecs
/
libaom_av1_encoder_factory
.
cc
+
+
+
/
dev
/
null
-
1
842
+
0
0
-
/
*
-
*
Copyright
(
c
)
2024
The
WebRTC
project
authors
.
All
Rights
Reserved
.
-
*
-
*
Use
of
this
source
code
is
governed
by
a
BSD
-
style
license
-
*
that
can
be
found
in
the
LICENSE
file
in
the
root
of
the
source
-
*
tree
.
An
additional
intellectual
property
rights
grant
can
be
found
-
*
in
the
file
PATENTS
.
All
contributing
project
authors
may
-
*
be
found
in
the
AUTHORS
file
in
the
root
of
the
source
tree
.
-
*
/
-
-
#
include
"
api
/
video_codecs
/
libaom_av1_encoder_factory
.
h
"
-
-
#
include
<
algorithm
>
-
#
include
<
map
>
-
#
include
<
memory
>
-
#
include
<
string
>
-
#
include
<
vector
>
-
-
#
include
"
absl
/
algorithm
/
container
.
h
"
-
#
include
"
api
/
video_codecs
/
video_encoder_interface
.
h
"
-
#
include
"
rtc_base
/
logging
.
h
"
-
#
include
"
third_party
/
libaom
/
source
/
libaom
/
aom
/
aom_codec
.
h
"
-
#
include
"
third_party
/
libaom
/
source
/
libaom
/
aom
/
aom_encoder
.
h
"
-
#
include
"
third_party
/
libaom
/
source
/
libaom
/
aom
/
aomcx
.
h
"
-
-
#
define
SET_OR_DO_ERROR_CALLBACK_AND_RETURN
(
param_id
param_value
)
\
-
do
{
\
-
if
(
!
SetEncoderControlParameters
(
&
ctx_
param_id
param_value
)
)
{
\
-
encode_result_callback
(
{
}
)
;
\
-
return
;
\
-
}
\
-
}
while
(
0
)
-
-
#
define
SET_OR_RETURN_FALSE
(
param_id
param_value
)
\
-
do
{
\
-
if
(
!
SetEncoderControlParameters
(
&
ctx_
param_id
param_value
)
)
{
\
-
return
false
;
\
-
}
\
-
}
while
(
0
)
-
-
namespace
webrtc
{
-
-
using
Cbr
=
VideoEncoderInterface
:
:
FrameEncodeSettings
:
:
Cbr
;
-
using
Cqp
=
VideoEncoderInterface
:
:
FrameEncodeSettings
:
:
Cqp
;
-
using
aom_img_ptr
=
std
:
:
unique_ptr
<
aom_image_t
decltype
(
&
aom_img_free
)
>
;
-
-
namespace
{
-
/
/
MaxQp
defined
here
:
-
/
/
http
:
/
/
google3
/
third_party
/
libaom
/
git_root
/
av1
/
av1_cx_iface
.
c
;
l
=
3510
;
rcl
=
527067478
-
constexpr
int
kMaxQp
=
63
;
-
constexpr
int
kNumBuffers
=
8
;
-
constexpr
int
kMaxReferences
=
3
;
-
constexpr
int
kMinEffortLevel
=
-
2
;
-
constexpr
int
kMaxEffortLevel
=
2
;
-
constexpr
int
kMaxSpatialLayersWtf
=
4
;
-
constexpr
int
kMaxTemporalLayers
=
4
;
-
constexpr
int
kRtpTicksPerSecond
=
90000
;
-
constexpr
std
:
:
array
<
VideoFrameBuffer
:
:
Type
2
>
kSupportedInputFormats
=
{
-
VideoFrameBuffer
:
:
Type
:
:
kI420
VideoFrameBuffer
:
:
Type
:
:
kNV12
}
;
-
-
constexpr
std
:
:
array
<
Rational
7
>
kSupportedScalingFactors
=
{
-
{
{
8
1
}
{
4
1
}
{
2
1
}
{
1
1
}
{
1
2
}
{
1
4
}
{
1
8
}
}
}
;
-
-
absl
:
:
optional
<
Rational
>
GetScalingFactor
(
const
Resolution
&
from
-
const
Resolution
&
to
)
{
-
auto
it
=
absl
:
:
c_find_if
(
kSupportedScalingFactors
[
&
]
(
const
Rational
&
r
)
{
-
return
(
from
.
width
*
r
.
numerator
/
r
.
denominator
)
=
=
to
.
width
&
&
-
(
from
.
height
*
r
.
numerator
/
r
.
denominator
)
=
=
to
.
height
;
-
}
)
;
-
-
if
(
it
!
=
kSupportedScalingFactors
.
end
(
)
)
{
-
return
*
it
;
-
}
-
-
return
{
}
;
-
}
-
-
class
LibaomAv1Encoder
:
public
VideoEncoderInterface
{
-
public
:
-
LibaomAv1Encoder
(
)
=
default
;
-
~
LibaomAv1Encoder
(
)
override
;
-
-
bool
InitEncode
(
-
const
VideoEncoderFactoryInterface
:
:
StaticEncoderSettings
&
settings
-
const
std
:
:
map
<
std
:
:
string
std
:
:
string
>
&
encoder_specific_settings
)
;
-
-
void
Encode
(
rtc
:
:
scoped_refptr
<
webrtc
:
:
VideoFrameBuffer
>
frame_buffer
-
const
TemporalUnitSettings
&
tu_settings
-
const
std
:
:
vector
<
FrameEncodeSettings
>
&
frame_settings
-
EncodeResultCallback
encode_result_callback
)
override
;
-
-
private
:
-
aom_img_ptr
image_to_encode_
=
aom_img_ptr
(
nullptr
aom_img_free
)
;
-
aom_codec_ctx_t
ctx_
;
-
aom_codec_enc_cfg_t
cfg_
;
-
-
absl
:
:
optional
<
VideoCodecMode
>
current_content_type_
;
-
absl
:
:
optional
<
int
>
current_effort_level_
;
-
int
max_number_of_threads_
;
-
std
:
:
array
<
absl
:
:
optional
<
Resolution
>
8
>
last_resolution_in_buffer_
;
-
}
;
-
-
template
<
typename
T
>
-
bool
SetEncoderControlParameters
(
aom_codec_ctx_t
*
ctx
int
id
T
value
)
{
-
aom_codec_err_t
error_code
=
aom_codec_control
(
ctx
id
value
)
;
-
if
(
error_code
!
=
AOM_CODEC_OK
)
{
-
RTC_LOG
(
LS_WARNING
)
<
<
"
aom_codec_control
returned
"
<
<
error_code
-
<
<
"
with
id
:
"
<
<
id
<
<
"
.
"
;
-
}
-
return
error_code
=
=
AOM_CODEC_OK
;
-
}
-
-
LibaomAv1Encoder
:
:
~
LibaomAv1Encoder
(
)
{
-
aom_codec_destroy
(
&
ctx_
)
;
-
}
-
-
bool
LibaomAv1Encoder
:
:
InitEncode
(
-
const
VideoEncoderFactoryInterface
:
:
StaticEncoderSettings
&
settings
-
const
std
:
:
map
<
std
:
:
string
std
:
:
string
>
&
encoder_specific_settings
)
{
-
if
(
!
encoder_specific_settings
.
empty
(
)
)
{
-
RTC_LOG
(
LS_ERROR
)
-
<
<
"
libaom
av1
encoder
accepts
no
encoder
specific
settings
"
;
-
return
false
;
-
}
-
-
if
(
aom_codec_err_t
ret
=
aom_codec_enc_config_default
(
-
aom_codec_av1_cx
(
)
&
cfg_
AOM_USAGE_REALTIME
)
;
-
ret
!
=
AOM_CODEC_OK
)
{
-
RTC_LOG
(
LS_ERROR
)
<
<
"
aom_codec_enc_config_default
returned
"
<
<
ret
;
-
return
false
;
-
}
-
-
max_number_of_threads_
=
settings
.
max_number_of_threads
;
-
-
/
/
The
encode
resolution
is
set
dynamically
for
each
call
to
Encode
but
for
-
/
/
aom_codec_enc_init
to
not
fail
we
set
it
here
as
well
.
-
cfg_
.
g_w
=
settings
.
max_encode_dimensions
.
width
;
-
cfg_
.
g_h
=
settings
.
max_encode_dimensions
.
height
;
-
cfg_
.
g_timebase
.
num
=
1
;
-
/
/
TD
:
does
90khz
timebase
make
sense
use
microseconds
instead
maybe
?
-
cfg_
.
g_timebase
.
den
=
kRtpTicksPerSecond
;
-
cfg_
.
g_input_bit_depth
=
settings
.
encoding_format
.
bit_depth
;
-
cfg_
.
kf_mode
=
AOM_KF_DISABLED
;
-
/
/
TD
:
rc_undershoot_pct
and
rc_overshoot_pct
should
probably
be
removed
.
-
cfg_
.
rc_undershoot_pct
=
50
;
-
cfg_
.
rc_overshoot_pct
=
50
;
-
auto
*
cbr
=
-
absl
:
:
get_if
<
VideoEncoderFactoryInterface
:
:
StaticEncoderSettings
:
:
Cbr
>
(
-
&
settings
.
rc_mode
)
;
-
cfg_
.
rc_buf_initial_sz
=
cbr
?
cbr
-
>
target_buffer_size
.
ms
(
)
:
600
;
-
cfg_
.
rc_buf_optimal_sz
=
cbr
?
cbr
-
>
target_buffer_size
.
ms
(
)
:
600
;
-
cfg_
.
rc_buf_sz
=
cbr
?
cbr
-
>
max_buffer_size
.
ms
(
)
:
1000
;
-
cfg_
.
g_usage
=
AOM_USAGE_REALTIME
;
-
cfg_
.
g_pass
=
AOM_RC_ONE_PASS
;
-
cfg_
.
g_lag_in_frames
=
0
;
-
cfg_
.
g_error_resilient
=
0
;
-
cfg_
.
rc_end_usage
=
cbr
?
AOM_CBR
:
AOM_Q
;
-
-
if
(
aom_codec_err_t
ret
=
-
aom_codec_enc_init
(
&
ctx_
aom_codec_av1_cx
(
)
&
cfg_
/
*
flags
=
*
/
0
)
;
-
ret
!
=
AOM_CODEC_OK
)
{
-
RTC_LOG
(
LS_ERROR
)
<
<
"
aom_codec_enc_init
returned
"
<
<
ret
;
-
return
false
;
-
}
-
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ENABLE_CDEF
1
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ENABLE_TPL_MODEL
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_DELTAQ_MODE
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ENABLE_ORDER_HINT
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_AQ_MODE
3
)
;
-
SET_OR_RETURN_FALSE
(
AOME_SET_MAX_INTRA_BITRATE_PCT
300
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_COEFF_COST_UPD_FREQ
3
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_MODE_COST_UPD_FREQ
3
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_MV_COST_UPD_FREQ
3
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ROW_MT
1
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ENABLE_OBMC
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_NOISE_SENSITIVITY
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ENABLE_WARPED_MOTION
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ENABLE_GLOBAL_MOTION
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ENABLE_REF_FRAME_MVS
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ENABLE_CFL_INTRA
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ENABLE_SMOOTH_INTRA
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ENABLE_ANGLE_DELTA
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ENABLE_FILTER_INTRA
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_INTRA_DEFAULT_TX_ONLY
1
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_DISABLE_TRELLIS_QUANT
1
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ENABLE_DIST_WTD_COMP
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ENABLE_DIFF_WTD_COMP
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ENABLE_DUAL_FILTER
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ENABLE_INTERINTRA_COMP
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ENABLE_INTERINTRA_WEDGE
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ENABLE_INTRA_EDGE_FILTER
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ENABLE_INTRABC
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ENABLE_MASKED_COMP
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ENABLE_PAETH_INTRA
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ENABLE_QM
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ENABLE_RECT_PARTITIONS
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ENABLE_RESTORATION
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ENABLE_SMOOTH_INTERINTRA
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_ENABLE_TX64
0
)
;
-
SET_OR_RETURN_FALSE
(
AV1E_SET_MAX_REFERENCE_FRAMES
3
)
;
-
-
return
true
;
-
}
-
-
struct
ThreadTilesAndSuperblockSizeInfo
{
-
int
num_threads
;
-
int
exp_tile_rows
;
-
int
exp_tile_colums
;
-
aom_superblock_size_t
superblock_size
;
-
}
;
-
-
ThreadTilesAndSuperblockSizeInfo
GetThreadingTilesAndSuperblockSize
(
-
int
width
-
int
height
-
int
max_number_of_threads
)
{
-
ThreadTilesAndSuperblockSizeInfo
res
;
-
const
int
num_pixels
=
width
*
height
;
-
if
(
num_pixels
>
=
1920
*
1080
&
&
max_number_of_threads
>
8
)
{
-
res
.
num_threads
=
8
;
-
res
.
exp_tile_rows
=
2
;
-
res
.
exp_tile_colums
=
1
;
-
}
else
if
(
num_pixels
>
=
640
*
360
&
&
max_number_of_threads
>
4
)
{
-
res
.
num_threads
=
4
;
-
res
.
exp_tile_rows
=
1
;
-
res
.
exp_tile_colums
=
1
;
-
}
else
if
(
num_pixels
>
=
320
*
180
&
&
max_number_of_threads
>
2
)
{
-
res
.
num_threads
=
2
;
-
res
.
exp_tile_rows
=
1
;
-
res
.
exp_tile_colums
=
0
;
-
}
else
{
-
res
.
num_threads
=
1
;
-
res
.
exp_tile_rows
=
0
;
-
res
.
exp_tile_colums
=
0
;
-
}
-
-
if
(
res
.
num_threads
>
4
&
&
num_pixels
>
=
960
*
540
)
{
-
res
.
superblock_size
=
AOM_SUPERBLOCK_SIZE_64X64
;
-
}
else
{
-
res
.
superblock_size
=
AOM_SUPERBLOCK_SIZE_DYNAMIC
;
-
}
-
-
RTC_LOG
(
LS_WARNING
)
<
<
__FUNCTION__
<
<
"
res
.
num_threads
=
"
<
<
res
.
num_threads
-
<
<
"
res
.
exp_tile_rows
=
"
<
<
res
.
exp_tile_rows
-
<
<
"
res
.
exp_tile_colums
=
"
<
<
res
.
exp_tile_colums
-
<
<
"
res
.
superblock_size
=
"
<
<
res
.
superblock_size
;
-
-
return
res
;
-
}
-
-
bool
ValidateEncodeParams
(
-
const
webrtc
:
:
VideoFrameBuffer
&
frame_buffer
-
const
VideoEncoderInterface
:
:
TemporalUnitSettings
&
tu_settings
-
const
std
:
:
vector
<
VideoEncoderInterface
:
:
FrameEncodeSettings
>
&
-
frame_settings
-
const
std
:
:
array
<
absl
:
:
optional
<
Resolution
>
8
>
&
last_resolution_in_buffer
-
aom_rc_mode
rc_mode
)
{
-
if
(
frame_settings
.
empty
(
)
)
{
-
RTC_LOG
(
LS_ERROR
)
<
<
"
No
frame
settings
provided
.
"
;
-
return
false
;
-
}
-
-
auto
in_range
=
[
]
(
int
low
int
high
int
val
)
{
-
return
low
<
=
val
&
&
val
<
high
;
-
}
;
-
-
if
(
!
in_range
(
kMinEffortLevel
kMaxEffortLevel
+
1
-
tu_settings
.
effort_level
)
)
{
-
RTC_LOG
(
LS_ERROR
)
<
<
"
Unsupported
effort
level
"
-
<
<
tu_settings
.
effort_level
;
-
return
false
;
-
}
-
-
for
(
size_t
i
=
0
;
i
<
frame_settings
.
size
(
)
;
+
+
i
)
{
-
const
VideoEncoderInterface
:
:
FrameEncodeSettings
&
settings
=
-
frame_settings
[
i
]
;
-
-
if
(
!
in_range
(
0
kMaxSpatialLayersWtf
settings
.
spatial_id
)
)
{
-
RTC_LOG
(
LS_ERROR
)
<
<
"
invalid
spatial
id
"
<
<
settings
.
spatial_id
;
-
return
false
;
-
}
-
-
if
(
!
in_range
(
0
kMaxTemporalLayers
settings
.
temporal_id
)
)
{
-
RTC_LOG
(
LS_ERROR
)
<
<
"
invalid
temporal
id
"
<
<
settings
.
temporal_id
;
-
return
false
;
-
}
-
-
if
(
(
settings
.
frame_type
=
=
FrameType
:
:
kKeyframe
|
|
-
settings
.
frame_type
=
=
FrameType
:
:
kStartFrame
)
&
&
-
!
settings
.
reference_buffers
.
empty
(
)
)
{
-
RTC_LOG
(
LS_ERROR
)
<
<
"
Reference
buffers
can
not
be
used
for
keyframes
.
"
;
-
return
false
;
-
}
-
-
if
(
(
settings
.
frame_type
=
=
FrameType
:
:
kKeyframe
|
|
-
settings
.
frame_type
=
=
FrameType
:
:
kStartFrame
)
&
&
-
!
settings
.
update_buffer
)
{
-
RTC_LOG
(
LS_ERROR
)
-
<
<
"
Buffer
to
update
must
be
specified
for
keyframe
/
startframe
"
;
-
return
false
;
-
}
-
-
if
(
settings
.
update_buffer
&
&
-
!
in_range
(
0
kNumBuffers
*
settings
.
update_buffer
)
)
{
-
RTC_LOG
(
LS_ERROR
)
<
<
"
Invalid
update
buffer
id
.
"
;
-
return
false
;
-
}
-
-
if
(
settings
.
reference_buffers
.
size
(
)
>
kMaxReferences
)
{
-
RTC_LOG
(
LS_ERROR
)
<
<
"
Too
many
referenced
buffers
.
"
;
-
return
false
;
-
}
-
-
for
(
size_t
j
=
0
;
j
<
settings
.
reference_buffers
.
size
(
)
;
+
+
j
)
{
-
if
(
!
in_range
(
0
kNumBuffers
settings
.
reference_buffers
[
j
]
)
)
{
-
RTC_LOG
(
LS_ERROR
)
<
<
"
Invalid
reference
buffer
id
.
"
;
-
return
false
;
-
}
-
-
/
/
Figure
out
which
frame
resolution
a
certain
buffer
will
hold
when
the
-
/
/
frame
described
by
settings
is
encoded
.
-
absl
:
:
optional
<
Resolution
>
referenced_resolution
;
-
bool
keyframe_on_previous_layer
=
false
;
-
-
/
/
Will
some
other
frame
in
this
temporal
unit
update
the
buffer
?
-
for
(
size_t
k
=
0
;
k
<
i
;
+
+
k
)
{
-
if
(
frame_settings
[
k
]
.
frame_type
=
=
FrameType
:
:
kKeyframe
)
{
-
keyframe_on_previous_layer
=
true
;
-
referenced_resolution
.
reset
(
)
;
-
}
-
if
(
frame_settings
[
k
]
.
update_buffer
=
=
settings
.
reference_buffers
[
j
]
)
{
-
referenced_resolution
=
frame_settings
[
k
]
.
resolution
;
-
}
-
}
-
-
/
/
Not
updated
by
another
frame
in
the
temporal
unit
what
is
the
-
/
/
resolution
of
the
last
frame
stored
into
that
buffer
?
-
if
(
!
referenced_resolution
&
&
!
keyframe_on_previous_layer
)
{
-
referenced_resolution
=
-
last_resolution_in_buffer
[
settings
.
reference_buffers
[
j
]
]
;
-
}
-
-
if
(
!
referenced_resolution
)
{
-
RTC_LOG
(
LS_ERROR
)
<
<
"
Referenced
buffer
holds
no
frame
.
"
;
-
return
false
;
-
}
-
-
if
(
!
GetScalingFactor
(
*
referenced_resolution
settings
.
resolution
)
)
{
-
RTC_LOG
(
LS_ERROR
)
-
<
<
"
Required
resolution
scaling
factor
not
supported
.
"
;
-
return
false
;
-
}
-
-
for
(
size_t
l
=
i
+
1
;
l
<
settings
.
reference_buffers
.
size
(
)
;
+
+
l
)
{
-
if
(
settings
.
reference_buffers
[
i
]
=
=
settings
.
reference_buffers
[
l
]
)
{
-
RTC_LOG
(
LS_ERROR
)
<
<
"
Duplicate
reference
buffer
specified
.
"
;
-
return
false
;
-
}
-
}
-
}
-
-
if
(
(
rc_mode
=
=
AOM_CBR
&
&
-
absl
:
:
holds_alternative
<
Cqp
>
(
settings
.
rate_options
)
)
|
|
-
(
rc_mode
=
=
AOM_Q
&
&
-
absl
:
:
holds_alternative
<
Cbr
>
(
settings
.
rate_options
)
)
)
{
-
RTC_LOG
(
LS_ERROR
)
<
<
"
Invalid
rate
options
encoder
configured
with
"
-
<
<
(
rc_mode
=
=
AOM_CBR
?
"
AOM_CBR
"
:
"
AOM_Q
"
)
;
-
return
false
;
-
}
-
-
for
(
size_t
j
=
i
+
1
;
j
<
frame_settings
.
size
(
)
;
+
+
j
)
{
-
if
(
settings
.
spatial_id
>
=
frame_settings
[
j
]
.
spatial_id
)
{
-
RTC_LOG
(
LS_ERROR
)
<
<
"
Frame
spatial
id
specified
out
of
order
.
"
;
-
return
false
;
-
}
-
}
-
}
-
-
return
true
;
-
}
-
-
void
PrepareInputImage
(
const
VideoFrameBuffer
&
input_buffer
-
aom_img_ptr
&
out_aom_image
)
{
-
aom_img_fmt_t
input_format
;
-
switch
(
input_buffer
.
type
(
)
)
{
-
case
VideoFrameBuffer
:
:
Type
:
:
kI420
:
-
input_format
=
AOM_IMG_FMT_I420
;
-
break
;
-
case
VideoFrameBuffer
:
:
Type
:
:
kNV12
:
-
input_format
=
AOM_IMG_FMT_NV12
;
-
break
;
-
default
:
-
RTC_CHECK_NOTREACHED
(
)
;
-
return
;
-
}
-
-
if
(
!
out_aom_image
|
|
out_aom_image
-
>
fmt
!
=
input_format
|
|
-
static_cast
<
int
>
(
out_aom_image
-
>
w
)
!
=
input_buffer
.
width
(
)
|
|
-
static_cast
<
int
>
(
out_aom_image
-
>
h
)
!
=
input_buffer
.
height
(
)
)
{
-
out_aom_image
.
reset
(
-
aom_img_wrap
(
/
*
img
=
*
/
nullptr
input_format
input_buffer
.
width
(
)
-
input_buffer
.
height
(
)
/
*
align
=
*
/
1
/
*
img_data
=
*
/
nullptr
)
)
;
-
-
RTC_LOG
(
LS_WARNING
)
<
<
__FUNCTION__
<
<
"
input_format
=
"
<
<
input_format
-
<
<
"
input_buffer
.
width
(
)
=
"
<
<
input_buffer
.
width
(
)
-
<
<
"
input_buffer
.
height
(
)
=
"
<
<
input_buffer
.
height
(
)
-
<
<
"
w
=
"
<
<
out_aom_image
-
>
w
-
<
<
"
h
=
"
<
<
out_aom_image
-
>
h
-
<
<
"
d_w
=
"
<
<
out_aom_image
-
>
d_w
-
<
<
"
d_h
=
"
<
<
out_aom_image
-
>
d_h
-
<
<
"
r_w
=
"
<
<
out_aom_image
-
>
r_w
-
<
<
"
r_h
=
"
<
<
out_aom_image
-
>
r_h
;
-
}
-
-
if
(
input_format
=
=
AOM_IMG_FMT_I420
)
{
-
const
I420BufferInterface
*
i420_buffer
=
input_buffer
.
GetI420
(
)
;
-
RTC_DCHECK
(
i420_buffer
)
;
-
out_aom_image
-
>
planes
[
AOM_PLANE_Y
]
=
-
const_cast
<
unsigned
char
*
>
(
i420_buffer
-
>
DataY
(
)
)
;
-
out_aom_image
-
>
planes
[
AOM_PLANE_U
]
=
-
const_cast
<
unsigned
char
*
>
(
i420_buffer
-
>
DataU
(
)
)
;
-
out_aom_image
-
>
planes
[
AOM_PLANE_V
]
=
-
const_cast
<
unsigned
char
*
>
(
i420_buffer
-
>
DataV
(
)
)
;
-
out_aom_image
-
>
stride
[
AOM_PLANE_Y
]
=
i420_buffer
-
>
StrideY
(
)
;
-
out_aom_image
-
>
stride
[
AOM_PLANE_U
]
=
i420_buffer
-
>
StrideU
(
)
;
-
out_aom_image
-
>
stride
[
AOM_PLANE_V
]
=
i420_buffer
-
>
StrideV
(
)
;
-
}
else
{
-
const
NV12BufferInterface
*
nv12_buffer
=
input_buffer
.
GetNV12
(
)
;
-
RTC_DCHECK
(
nv12_buffer
)
;
-
out_aom_image
-
>
planes
[
AOM_PLANE_Y
]
=
-
const_cast
<
unsigned
char
*
>
(
nv12_buffer
-
>
DataY
(
)
)
;
-
out_aom_image
-
>
planes
[
AOM_PLANE_U
]
=
-
const_cast
<
unsigned
char
*
>
(
nv12_buffer
-
>
DataUV
(
)
)
;
-
out_aom_image
-
>
planes
[
AOM_PLANE_V
]
=
nullptr
;
-
out_aom_image
-
>
stride
[
AOM_PLANE_Y
]
=
nv12_buffer
-
>
StrideY
(
)
;
-
out_aom_image
-
>
stride
[
AOM_PLANE_U
]
=
nv12_buffer
-
>
StrideUV
(
)
;
-
out_aom_image
-
>
stride
[
AOM_PLANE_V
]
=
0
;
-
}
-
}
-
-
aom_svc_ref_frame_config_t
GetSvcRefFrameConfig
(
-
const
VideoEncoderInterface
:
:
FrameEncodeSettings
&
settings
)
{
-
/
/
Buffer
alias
to
use
for
each
position
.
In
particular
when
there
are
two
-
/
/
buffers
being
used
prefer
to
alias
them
as
LAST
and
GOLDEN
since
the
AV1
-
/
/
bitstream
format
has
dedicated
fields
for
them
.
See
last_frame_idx
and
-
/
/
golden_frame_idx
in
the
av1
spec
-
/
/
https
:
/
/
aomediacodec
.
github
.
io
/
av1
-
spec
/
av1
-
spec
.
pdf
.
-
-
/
/
Libaom
is
also
compiled
for
RTC
which
limits
the
number
of
references
to
-
/
/
at
most
three
and
they
must
be
aliased
as
LAST
GOLDEN
and
ALTREF
.
Also
-
/
/
note
that
libaom
favors
LAST
the
most
and
GOLDEN
second
most
so
buffers
-
/
/
should
be
specified
in
order
of
how
useful
they
are
for
prediction
.
Libaom
-
/
/
could
be
updated
to
make
LAST
GOLDEN
and
ALTREF
equivalent
but
that
is
-
/
/
not
a
priority
for
now
.
All
aliases
can
be
used
to
update
buffers
.
-
/
/
TD
:
Automatically
select
LAST
GOLDEN
and
ALTREF
depending
on
previous
-
/
/
buffer
usage
.
-
static
constexpr
int
kPreferedAlias
[
]
=
{
0
/
/
LAST
-
3
/
/
GOLDEN
-
6
/
/
ALTREF
-
1
2
4
5
}
;
-
-
aom_svc_ref_frame_config_t
ref_frame_config
=
{
}
;
-
-
int
alias_index
=
0
;
-
if
(
!
settings
.
reference_buffers
.
empty
(
)
)
{
-
for
(
size_t
i
=
0
;
i
<
settings
.
reference_buffers
.
size
(
)
;
+
+
i
)
{
-
ref_frame_config
.
ref_idx
[
kPreferedAlias
[
alias_index
]
]
=
-
settings
.
reference_buffers
[
i
]
;
-
ref_frame_config
.
reference
[
kPreferedAlias
[
alias_index
]
]
=
1
;
-
alias_index
+
+
;
-
}
-
-
/
/
Delta
frames
must
not
alias
unused
buffers
and
since
start
frames
only
-
/
/
update
some
buffers
it
is
not
safe
to
leave
unused
aliases
to
simply
-
/
/
point
to
buffer
0
.
-
for
(
size_t
i
=
settings
.
reference_buffers
.
size
(
)
;
-
i
<
std
:
:
size
(
ref_frame_config
.
ref_idx
)
;
+
+
i
)
{
-
ref_frame_config
.
ref_idx
[
kPreferedAlias
[
i
]
]
=
-
settings
.
reference_buffers
.
back
(
)
;
-
}
-
}
-
-
if
(
settings
.
update_buffer
)
{
-
if
(
!
absl
:
:
c_linear_search
(
settings
.
reference_buffers
-
*
settings
.
update_buffer
)
)
{
-
ref_frame_config
.
ref_idx
[
kPreferedAlias
[
alias_index
]
]
=
-
*
settings
.
update_buffer
;
-
alias_index
+
+
;
-
}
-
ref_frame_config
.
refresh
[
*
settings
.
update_buffer
]
=
1
;
-
}
-
-
char
buf
[
256
]
;
-
rtc
:
:
SimpleStringBuilder
sb
(
buf
)
;
-
sb
<
<
"
spatial_id
=
"
<
<
settings
.
spatial_id
;
-
sb
<
<
"
ref_idx
=
[
"
;
-
for
(
auto
r
:
ref_frame_config
.
ref_idx
)
{
-
sb
<
<
r
<
<
"
"
;
-
}
-
sb
<
<
"
]
reference
=
[
"
;
-
for
(
auto
r
:
ref_frame_config
.
reference
)
{
-
sb
<
<
r
<
<
"
"
;
-
}
-
sb
<
<
"
]
refresh
=
[
"
;
-
for
(
auto
r
:
ref_frame_config
.
refresh
)
{
-
sb
<
<
r
<
<
"
"
;
-
}
-
sb
<
<
"
]
"
;
-
-
RTC_LOG
(
LS_WARNING
)
<
<
__FUNCTION__
<
<
sb
.
str
(
)
;
-
-
return
ref_frame_config
;
-
}
-
-
aom_svc_params_t
GetSvcParams
(
-
const
webrtc
:
:
VideoFrameBuffer
&
frame_buffer
-
const
std
:
:
vector
<
VideoEncoderInterface
:
:
FrameEncodeSettings
>
&
-
frame_settings
)
{
-
aom_svc_params_t
svc_params
=
{
}
;
-
svc_params
.
number_spatial_layers
=
frame_settings
.
back
(
)
.
spatial_id
+
1
;
-
svc_params
.
number_temporal_layers
=
kMaxTemporalLayers
;
-
-
/
/
TD
:
What
about
svc_params
.
framerate_factor
?
-
/
/
If
framerate_factors
are
left
at
0
then
configured
bitrate
values
will
-
/
/
not
be
picked
up
by
libaom
.
-
for
(
int
tid
=
0
;
tid
<
svc_params
.
number_temporal_layers
;
+
+
tid
)
{
-
svc_params
.
framerate_factor
[
tid
]
=
1
;
-
}
-
-
/
/
If
the
scaling
factor
is
left
at
zero
for
unused
layers
a
division
by
zero
-
/
/
will
happen
inside
libaom
default
all
layers
to
one
.
-
for
(
int
sid
=
0
;
sid
<
svc_params
.
number_spatial_layers
;
+
+
sid
)
{
-
svc_params
.
scaling_factor_num
[
sid
]
=
1
;
-
svc_params
.
scaling_factor_den
[
sid
]
=
1
;
-
}
-
-
for
(
const
VideoEncoderInterface
:
:
FrameEncodeSettings
&
settings
:
-
frame_settings
)
{
-
absl
:
:
optional
<
Rational
>
scaling_factor
=
GetScalingFactor
(
-
{
frame_buffer
.
width
(
)
frame_buffer
.
height
(
)
}
settings
.
resolution
)
;
-
RTC_CHECK
(
scaling_factor
)
;
-
svc_params
.
scaling_factor_num
[
settings
.
spatial_id
]
=
-
scaling_factor
-
>
numerator
;
-
svc_params
.
scaling_factor_den
[
settings
.
spatial_id
]
=
-
scaling_factor
-
>
denominator
;
-
-
const
int
flat_layer_id
=
-
settings
.
spatial_id
*
svc_params
.
number_temporal_layers
+
-
settings
.
temporal_id
;
-
-
RTC_LOG
(
LS_WARNING
)
<
<
__FUNCTION__
<
<
"
flat_layer_id
=
"
<
<
flat_layer_id
-
<
<
"
num
=
"
-
<
<
svc_params
.
scaling_factor_num
[
settings
.
spatial_id
]
-
<
<
"
den
=
"
-
<
<
svc_params
.
scaling_factor_den
[
settings
.
spatial_id
]
;
-
-
absl
:
:
visit
(
-
[
&
]
(
auto
&
&
arg
)
{
-
using
T
=
std
:
:
decay_t
<
decltype
(
arg
)
>
;
-
if
constexpr
(
std
:
:
is_same_v
<
T
Cbr
>
)
{
-
/
/
Libaom
calculates
the
total
bitrate
across
all
spatial
layers
by
-
/
/
summing
the
bitrate
of
the
last
temporal
layer
in
each
spatial
-
/
/
layer
.
This
means
the
bitrate
for
the
top
temporal
layer
always
-
/
/
has
to
be
set
even
if
that
temporal
layer
is
not
being
encoded
.
-
const
int
last_temporal_layer_in_spatial_layer_id
=
-
settings
.
spatial_id
*
svc_params
.
number_temporal_layers
+
-
(
kMaxTemporalLayers
-
1
)
;
-
svc_params
-
.
layer_target_bitrate
[
last_temporal_layer_in_spatial_layer_id
]
=
-
arg
.
target_bitrate
.
kbps
(
)
;
-
-
svc_params
.
layer_target_bitrate
[
flat_layer_id
]
=
-
arg
.
target_bitrate
.
kbps
(
)
;
-
/
/
When
libaom
is
configured
with
AOM_CBR
it
will
still
limit
QP
-
/
/
to
stay
between
min_quantizers
and
max_quantizers
'
.
Set
-
/
/
max_quantizers
to
max
QP
to
avoid
the
encoder
overshooting
.
-
svc_params
.
max_quantizers
[
flat_layer_id
]
=
kMaxQp
;
-
svc_params
.
min_quantizers
[
flat_layer_id
]
=
0
;
-
}
else
if
constexpr
(
std
:
:
is_same_v
<
T
Cqp
>
)
{
-
/
/
When
libaom
is
configured
with
AOM_Q
it
will
still
look
at
the
-
/
/
layer_target_bitrate
to
determine
whether
the
layer
is
disabled
-
/
/
or
not
.
Set
layer_target_bitrate
to
1
so
that
libaom
knows
the
-
/
/
layer
is
active
.
-
svc_params
.
layer_target_bitrate
[
flat_layer_id
]
=
1
;
-
svc_params
.
max_quantizers
[
flat_layer_id
]
=
arg
.
target_qp
;
-
svc_params
.
min_quantizers
[
flat_layer_id
]
=
arg
.
target_qp
;
-
RTC_LOG
(
LS_WARNING
)
<
<
__FUNCTION__
<
<
"
svc_params
.
qp
[
"
-
<
<
flat_layer_id
<
<
"
]
=
"
<
<
arg
.
target_qp
;
-
/
/
TD
:
Does
libaom
look
at
both
max
and
min
?
Shouldn
'
t
it
just
be
-
/
/
one
of
them
-
}
-
}
-
settings
.
rate_options
)
;
-
}
-
-
char
buf
[
512
]
;
-
rtc
:
:
SimpleStringBuilder
sb
(
buf
)
;
-
sb
<
<
"
GetSvcParams
"
<
<
"
layer
bitrates
kbps
"
;
-
for
(
int
s
=
0
;
s
<
svc_params
.
number_spatial_layers
;
+
+
s
)
{
-
sb
<
<
"
S
"
<
<
s
<
<
"
=
[
"
;
-
for
(
int
t
=
0
;
t
<
svc_params
.
number_temporal_layers
;
+
+
t
)
{
-
int
id
=
s
*
svc_params
.
number_temporal_layers
+
t
;
-
sb
<
<
"
T
"
<
<
t
<
<
"
=
"
<
<
svc_params
.
layer_target_bitrate
[
id
]
<
<
"
"
;
-
}
-
sb
<
<
"
]
"
;
-
}
-
-
RTC_LOG
(
LS_WARNING
)
<
<
sb
.
str
(
)
;
-
-
return
svc_params
;
-
}
-
-
void
LibaomAv1Encoder
:
:
Encode
(
-
rtc
:
:
scoped_refptr
<
webrtc
:
:
VideoFrameBuffer
>
frame_buffer
-
const
TemporalUnitSettings
&
tu_settings
-
const
std
:
:
vector
<
FrameEncodeSettings
>
&
frame_settings
-
EncodeResultCallback
encode_result_callback
)
{
-
if
(
!
ValidateEncodeParams
(
*
frame_buffer
tu_settings
frame_settings
-
last_resolution_in_buffer_
cfg_
.
rc_end_usage
)
)
{
-
encode_result_callback
(
{
}
)
;
-
return
;
-
}
-
-
if
(
tu_settings
.
effort_level
!
=
current_effort_level_
)
{
-
/
/
For
RTC
we
use
speed
level
6
to
10
with
8
being
the
default
.
Note
that
-
/
/
low
effort
means
higher
speed
.
-
SET_OR_DO_ERROR_CALLBACK_AND_RETURN
(
AOME_SET_CPUUSED
-
8
-
tu_settings
.
effort_level
)
;
-
current_effort_level_
=
tu_settings
.
effort_level
;
-
}
-
-
if
(
current_content_type_
!
=
tu_settings
.
content_hint
)
{
-
if
(
tu_settings
.
content_hint
=
=
VideoCodecMode
:
:
kScreensharing
)
{
-
/
/
TD
:
Set
speed
11
?
-
SET_OR_DO_ERROR_CALLBACK_AND_RETURN
(
AV1E_SET_TUNE_CONTENT
-
AOM_CONTENT_SCREEN
)
;
-
SET_OR_DO_ERROR_CALLBACK_AND_RETURN
(
AV1E_SET_ENABLE_PALETTE
1
)
;
-
}
else
{
-
SET_OR_DO_ERROR_CALLBACK_AND_RETURN
(
AV1E_SET_TUNE_CONTENT
-
AOM_CONTENT_DEFAULT
)
;
-
SET_OR_DO_ERROR_CALLBACK_AND_RETURN
(
AV1E_SET_ENABLE_PALETTE
0
)
;
-
}
-
current_content_type_
=
tu_settings
.
content_hint
;
-
}
-
-
if
(
cfg_
.
rc_end_usage
=
=
AOM_CBR
)
{
-
DataRate
accum_rate
=
DataRate
:
:
Zero
(
)
;
-
for
(
const
FrameEncodeSettings
&
settings
:
frame_settings
)
{
-
accum_rate
+
=
absl
:
:
get
<
Cbr
>
(
settings
.
rate_options
)
.
target_bitrate
;
-
}
-
cfg_
.
rc_target_bitrate
=
accum_rate
.
kbps
(
)
;
-
RTC_LOG
(
LS_WARNING
)
<
<
__FUNCTION__
-
<
<
"
cfg_
.
rc_target_bitrate
=
"
<
<
cfg_
.
rc_target_bitrate
;
-
}
-
-
if
(
static_cast
<
int
>
(
cfg_
.
g_w
)
!
=
frame_buffer
-
>
width
(
)
|
|
-
static_cast
<
int
>
(
cfg_
.
g_h
)
!
=
frame_buffer
-
>
height
(
)
)
{
-
RTC_LOG
(
LS_WARNING
)
<
<
__FUNCTION__
<
<
"
resolution
changed
from
"
-
<
<
cfg_
.
g_w
<
<
"
x
"
<
<
cfg_
.
g_h
<
<
"
to
"
-
<
<
frame_buffer
-
>
width
(
)
<
<
"
x
"
-
<
<
frame_buffer
-
>
height
(
)
;
-
ThreadTilesAndSuperblockSizeInfo
ttsbi
=
GetThreadingTilesAndSuperblockSize
(
-
frame_buffer
-
>
width
(
)
frame_buffer
-
>
height
(
)
max_number_of_threads_
)
;
-
SET_OR_DO_ERROR_CALLBACK_AND_RETURN
(
AV1E_SET_SUPERBLOCK_SIZE
-
ttsbi
.
superblock_size
)
;
-
SET_OR_DO_ERROR_CALLBACK_AND_RETURN
(
AV1E_SET_TILE_ROWS
-
ttsbi
.
exp_tile_rows
)
;
-
SET_OR_DO_ERROR_CALLBACK_AND_RETURN
(
AV1E_SET_TILE_COLUMNS
-
ttsbi
.
exp_tile_colums
)
;
-
cfg_
.
g_threads
=
ttsbi
.
num_threads
;
-
cfg_
.
g_w
=
frame_buffer
-
>
width
(
)
;
-
cfg_
.
g_h
=
frame_buffer
-
>
height
(
)
;
-
}
-
-
PrepareInputImage
(
*
frame_buffer
image_to_encode_
)
;
-
-
/
/
The
bitrates
caluclated
internally
in
libaom
when
AV1E_SET_SVC_PARAMS
is
-
/
/
called
depends
on
the
currently
configured
cfg_
.
rc_target_bitrate
.
If
the
-
/
/
total
target
bitrate
is
not
updated
first
a
division
by
zero
could
happen
.
-
if
(
aom_codec_err_t
ret
=
aom_codec_enc_config_set
(
&
ctx_
&
cfg_
)
;
-
ret
!
=
AOM_CODEC_OK
)
{
-
RTC_LOG
(
LS_ERROR
)
<
<
"
aom_codec_enc_config_set
returned
"
<
<
ret
;
-
encode_result_callback
(
{
}
)
;
-
return
;
-
}
-
aom_svc_params_t
svc_params
=
GetSvcParams
(
*
frame_buffer
frame_settings
)
;
-
SET_OR_DO_ERROR_CALLBACK_AND_RETURN
(
AV1E_SET_SVC_PARAMS
&
svc_params
)
;
-
-
/
/
The
libaom
AV1
encoder
requires
that
aom_codec_encode
is
called
for
-
/
/
every
spatial
layer
even
if
no
frame
should
be
encoded
for
that
layer
.
-
std
:
:
array
<
const
FrameEncodeSettings
*
kMaxSpatialLayersWtf
>
-
settings_for_spatial_id
;
-
settings_for_spatial_id
.
fill
(
nullptr
)
;
-
FrameEncodeSettings
settings_for_unused_layer
;
-
for
(
const
FrameEncodeSettings
&
settings
:
frame_settings
)
{
-
settings_for_spatial_id
[
settings
.
spatial_id
]
=
&
settings
;
-
}
-
-
for
(
int
sid
=
frame_settings
[
0
]
.
spatial_id
;
-
sid
<
svc_params
.
number_spatial_layers
;
+
+
sid
)
{
-
const
bool
layer_enabled
=
settings_for_spatial_id
[
sid
]
!
=
nullptr
;
-
const
FrameEncodeSettings
&
settings
=
layer_enabled
-
?
*
settings_for_spatial_id
[
sid
]
-
:
settings_for_unused_layer
;
-
-
aom_svc_layer_id_t
layer_id
=
{
-
.
spatial_layer_id
=
sid
-
.
temporal_layer_id
=
settings
.
temporal_id
-
}
;
-
SET_OR_DO_ERROR_CALLBACK_AND_RETURN
(
AV1E_SET_SVC_LAYER_ID
&
layer_id
)
;
-
aom_svc_ref_frame_config_t
ref_config
=
GetSvcRefFrameConfig
(
settings
)
;
-
SET_OR_DO_ERROR_CALLBACK_AND_RETURN
(
AV1E_SET_SVC_REF_FRAME_CONFIG
-
&
ref_config
)
;
-
-
/
/
TD
:
Why
does
the
libaom
have
both
encode_timestamp_
and
duration
?
-
/
/
TD
:
Duration
can
'
t
be
zero
what
does
it
matter
when
the
layer
is
-
/
/
not
being
encoded
?
-
TimeDelta
duration
=
TimeDelta
:
:
Millis
(
1
)
;
-
if
(
layer_enabled
)
{
-
if
(
const
Cbr
*
cbr
=
absl
:
:
get_if
<
Cbr
>
(
&
settings
.
rate_options
)
)
{
-
duration
=
cbr
-
>
duration
;
-
}
else
{
-
/
/
TD
:
What
should
duration
be
when
Cqp
is
used
?
-
duration
=
TimeDelta
:
:
Millis
(
1
)
;
-
}
-
}
-
-
RTC_LOG
(
LS_WARNING
)
-
<
<
__FUNCTION__
<
<
"
timestamp
=
"
-
<
<
(
tu_settings
.
presentation_timestamp
.
ms
(
)
*
kRtpTicksPerSecond
/
1000
)
-
<
<
"
duration
=
"
<
<
(
duration
.
ms
(
)
*
kRtpTicksPerSecond
/
1000
)
-
<
<
"
type
=
"
-
<
<
(
settings
.
frame_type
=
=
FrameType
:
:
kKeyframe
?
"
key
"
:
"
delta
"
)
;
-
aom_codec_err_t
ret
=
aom_codec_encode
(
-
&
ctx_
&
*
image_to_encode_
tu_settings
.
presentation_timestamp
.
ms
(
)
*
90
-
duration
.
ms
(
)
*
90
-
settings
.
frame_type
=
=
FrameType
:
:
kKeyframe
?
AOM_EFLAG_FORCE_KF
:
0
)
;
-
if
(
ret
!
=
AOM_CODEC_OK
)
{
-
RTC_LOG
(
LS_WARNING
)
<
<
"
aom_codec_encode
returned
"
<
<
ret
;
-
encode_result_callback
(
{
}
)
;
-
return
;
-
}
-
-
if
(
!
layer_enabled
)
{
-
continue
;
-
}
-
-
if
(
settings
.
frame_type
=
=
FrameType
:
:
kKeyframe
)
{
-
last_resolution_in_buffer_
=
{
}
;
-
}
-
-
if
(
settings
.
update_buffer
)
{
-
last_resolution_in_buffer_
[
*
settings
.
update_buffer
]
=
settings
.
resolution
;
-
}
-
-
EncodedData
result
;
-
aom_codec_iter_t
iter
=
nullptr
;
-
while
(
const
aom_codec_cx_pkt_t
*
pkt
=
-
aom_codec_get_cx_data
(
&
ctx_
&
iter
)
)
{
-
if
(
pkt
-
>
kind
=
=
AOM_CODEC_CX_FRAME_PKT
&
&
pkt
-
>
data
.
frame
.
sz
>
0
)
{
-
SET_OR_DO_ERROR_CALLBACK_AND_RETURN
(
AOME_GET_LAST_QUANTIZER_64
-
&
result
.
encoded_qp
)
;
-
result
.
frame_type
=
pkt
-
>
data
.
frame
.
flags
&
AOM_EFLAG_FORCE_KF
-
?
FrameType
:
:
kKeyframe
-
:
FrameType
:
:
kDeltaFrame
;
-
result
.
bitstream_data
=
EncodedImageBuffer
:
:
Create
(
-
static_cast
<
uint8_t
*
>
(
pkt
-
>
data
.
frame
.
buf
)
pkt
-
>
data
.
frame
.
sz
)
;
-
result
.
spatial_id
=
sid
;
-
result
.
referenced_buffers
=
settings
.
reference_buffers
;
-
break
;
-
}
-
}
-
-
if
(
result
.
bitstream_data
=
=
nullptr
)
{
-
/
/
TD
:
How
should
error
callbacks
be
handled
only
call
once
?
-
encode_result_callback
(
{
}
)
;
-
return
;
-
}
else
{
-
encode_result_callback
(
result
)
;
-
}
-
}
-
}
-
}
/
/
namespace
-
-
std
:
:
string
LibaomAv1EncoderFactory
:
:
CodecName
(
)
const
{
-
return
"
AV1
"
;
-
}
-
-
/
/
TD
:
it
should
also
possible
to
expose
SW
/
HW
/
driver
version
.
-
std
:
:
string
LibaomAv1EncoderFactory
:
:
ImplementationName
(
)
const
{
-
return
"
Libaom
"
;
-
}
-
-
std
:
:
map
<
std
:
:
string
std
:
:
string
>
LibaomAv1EncoderFactory
:
:
CodecSpecifics
(
)
-
const
{
-
return
{
}
;
-
}
-
-
VideoEncoderFactoryInterface
:
:
Capabilities
-
LibaomAv1EncoderFactory
:
:
GetEncoderCapabilities
(
)
const
{
-
return
{
-
.
prediction_constraints
=
-
{
.
num_buffers
=
kNumBuffers
-
.
max_references
=
kMaxReferences
-
.
max_temporal_layers
=
kMaxTemporalLayers
-
.
buffer_space_type
=
VideoEncoderFactoryInterface
:
:
Capabilities
:
:
-
PredictionConstraints
:
:
BufferSpaceType
:
:
kSingleKeyframe
-
.
max_spatial_layers
=
kMaxSpatialLayersWtf
-
.
scaling_factors
=
{
kSupportedScalingFactors
.
begin
(
)
-
kSupportedScalingFactors
.
end
(
)
}
-
.
supported_frame_types
=
{
FrameType
:
:
kKeyframe
-
FrameType
:
:
kStartFrame
-
FrameType
:
:
kDeltaFrame
}
}
-
.
input_constraints
=
{
-
.
min
=
{
.
width
=
64
.
height
=
36
}
-
.
max
=
{
.
width
=
3840
.
height
=
2160
}
-
.
pixel_alignment
=
1
-
.
input_formats
=
{
kSupportedInputFormats
.
begin
(
)
-
kSupportedInputFormats
.
end
(
)
}
-
}
-
.
encoding_formats
=
{
{
.
sub_sampling
=
EncodingFormat
:
:
k420
-
.
bit_depth
=
8
}
}
-
.
rate_control
=
-
{
.
qp_range
=
{
0
kMaxQp
}
-
.
rc_modes
=
{
VideoEncoderFactoryInterface
:
:
RateControlMode
:
:
kCbr
-
VideoEncoderFactoryInterface
:
:
RateControlMode
:
:
kCqp
}
}
-
.
performance
=
{
.
min_max_effort_level
=
{
kMinEffortLevel
-
kMaxEffortLevel
}
}
-
}
;
-
}
-
-
std
:
:
unique_ptr
<
VideoEncoderInterface
>
LibaomAv1EncoderFactory
:
:
CreateEncoder
(
-
const
StaticEncoderSettings
&
settings
-
const
std
:
:
map
<
std
:
:
string
std
:
:
string
>
&
encoder_specific_settings
)
{
-
auto
encoder
=
std
:
:
make_unique
<
LibaomAv1Encoder
>
(
)
;
-
if
(
!
encoder
-
>
InitEncode
(
settings
encoder_specific_settings
)
)
{
-
return
nullptr
;
-
}
-
return
encoder
;
-
}
-
-
}
/
/
namespace
webrtc
diff
-
-
git
a
/
api
/
video_codecs
/
libaom_av1_encoder_factory
.
h
b
/
api
/
video_codecs
/
libaom_av1_encoder_factory
.
h
deleted
file
mode
100644
index
df2abb2a3b
.
.
0000000000
-
-
-
a
/
api
/
video_codecs
/
libaom_av1_encoder_factory
.
h
+
+
+
/
dev
/
null
-
1
35
+
0
0
-
/
*
-
*
Copyright
(
c
)
2024
The
WebRTC
project
authors
.
All
Rights
Reserved
.
-
*
-
*
Use
of
this
source
code
is
governed
by
a
BSD
-
style
license
-
*
that
can
be
found
in
the
LICENSE
file
in
the
root
of
the
source
-
*
tree
.
An
additional
intellectual
property
rights
grant
can
be
found
-
*
in
the
file
PATENTS
.
All
contributing
project
authors
may
-
*
be
found
in
the
AUTHORS
file
in
the
root
of
the
source
tree
.
-
*
/
-
-
#
ifndef
API_VIDEO_CODECS_LIBAOM_AV1_ENCODER_FACTORY_H_
-
#
define
API_VIDEO_CODECS_LIBAOM_AV1_ENCODER_FACTORY_H_
-
-
#
include
<
map
>
-
#
include
<
memory
>
-
#
include
<
string
>
-
#
include
<
vector
>
-
-
#
include
"
api
/
video_codecs
/
video_encoder_factory_interface
.
h
"
-
-
namespace
webrtc
{
-
class
LibaomAv1EncoderFactory
final
:
VideoEncoderFactoryInterface
{
-
public
:
-
std
:
:
string
CodecName
(
)
const
override
;
-
std
:
:
string
ImplementationName
(
)
const
override
;
-
std
:
:
map
<
std
:
:
string
std
:
:
string
>
CodecSpecifics
(
)
const
override
;
-
-
Capabilities
GetEncoderCapabilities
(
)
const
override
;
-
std
:
:
unique_ptr
<
VideoEncoderInterface
>
CreateEncoder
(
-
const
StaticEncoderSettings
&
settings
-
const
std
:
:
map
<
std
:
:
string
std
:
:
string
>
&
encoder_specific_settings
)
-
override
;
-
}
;
-
}
/
/
namespace
webrtc
-
#
endif
/
/
API_VIDEO_CODECS_LIBAOM_AV1_ENCODER_FACTORY_H_
diff
-
-
git
a
/
api
/
video_codecs
/
libaom_av1_encoder_factory_test
.
cc
b
/
api
/
video_codecs
/
libaom_av1_encoder_factory_test
.
cc
deleted
file
mode
100644
index
eacb5a7a85
.
.
0000000000
-
-
-
a
/
api
/
video_codecs
/
libaom_av1_encoder_factory_test
.
cc
+
+
+
/
dev
/
null
-
1
822
+
0
0
-
/
*
-
*
Copyright
(
c
)
2024
The
WebRTC
project
authors
.
All
Rights
Reserved
.
-
*
-
*
Use
of
this
source
code
is
governed
by
a
BSD
-
style
license
-
*
that
can
be
found
in
the
LICENSE
file
in
the
root
of
the
source
-
*
tree
.
An
additional
intellectual
property
rights
grant
can
be
found
-
*
in
the
file
PATENTS
.
All
contributing
project
authors
may
-
*
be
found
in
the
AUTHORS
file
in
the
root
of
the
source
tree
.
-
*
/
-
-
#
include
"
api
/
video_codecs
/
libaom_av1_encoder_factory
.
h
"
-
-
#
include
<
cstdio
>
-
#
include
<
utility
>
-
#
include
<
vector
>
-
-
#
include
"
api
/
video
/
i420_buffer
.
h
"
-
#
include
"
api
/
video_codecs
/
video_decoder
.
h
"
-
#
include
"
api
/
video_codecs
/
video_encoder_interface
.
h
"
-
#
include
"
common_video
/
libyuv
/
include
/
webrtc_libyuv
.
h
"
-
#
include
"
modules
/
video_coding
/
codecs
/
av1
/
dav1d_decoder
.
h
"
-
#
include
"
rtc_base
/
logging
.
h
"
-
#
include
"
test
/
gmock
.
h
"
-
#
include
"
test
/
gtest
.
h
"
-
#
include
"
test
/
testsupport
/
file_utils
.
h
"
-
#
include
"
test
/
testsupport
/
frame_reader
.
h
"
-
#
include
"
test
/
testsupport
/
frame_writer
.
h
"
-
-
namespace
webrtc
{
-
namespace
{
-
using
:
:
testing
:
:
_
;
-
using
:
:
testing
:
:
ElementsAre
;
-
using
:
:
testing
:
:
Eq
;
-
using
:
:
testing
:
:
Field
;
-
using
:
:
testing
:
:
Gt
;
-
using
:
:
testing
:
:
IsEmpty
;
-
using
:
:
testing
:
:
Lt
;
-
using
:
:
testing
:
:
MockFunction
;
-
using
:
:
testing
:
:
NotNull
;
-
using
Cbr
=
VideoEncoderInterface
:
:
FrameEncodeSettings
:
:
Cbr
;
-
using
Cqp
=
VideoEncoderInterface
:
:
FrameEncodeSettings
:
:
Cqp
;
-
using
EncodedData
=
VideoEncoderInterface
:
:
EncodedData
;
-
using
EncodeResult
=
VideoEncoderInterface
:
:
EncodeResult
;
-
using
EncodeResultCallback
=
VideoEncoderInterface
:
:
EncodeResultCallback
;
-
using
FrameType
=
VideoEncoderInterface
:
:
FrameType
;
-
-
std
:
:
unique_ptr
<
test
:
:
FrameReader
>
CreateFrameReader
(
)
{
-
return
CreateY4mFrameReader
(
-
test
:
:
ResourcePath
(
"
reference_video_640x360_30fps
"
"
y4m
"
)
-
test
:
:
YuvFrameReaderImpl
:
:
RepeatMode
:
:
kPingPong
)
;
-
}
-
-
std
:
:
string
OutPath
(
)
{
-
std
:
:
string
res
=
test
:
:
OutputPath
(
)
;
-
res
+
=
"
frame_dump
/
"
;
-
RTC_CHECK
(
test
:
:
DirExists
(
res
)
|
|
test
:
:
CreateDir
(
res
)
)
;
-
return
res
;
-
}
-
-
class
EncodeResults
{
-
public
:
-
EncodeResultCallback
CallBack
(
)
{
-
return
[
&
]
(
const
EncodeResult
&
result
)
{
results_
.
push_back
(
result
)
;
}
;
-
}
-
-
EncodedData
*
FrameAt
(
int
index
)
{
-
if
(
index
<
0
|
|
index
>
static_cast
<
int
>
(
results_
.
size
(
)
)
)
{
-
RTC_CHECK
(
false
)
;
-
return
nullptr
;
-
}
-
return
std
:
:
get_if
<
EncodedData
>
(
&
results_
[
index
]
)
;
-
}
-
-
private
:
-
std
:
:
vector
<
EncodeResult
>
results_
;
-
}
;
-
-
class
Av1Decoder
:
public
DecodedImageCallback
{
-
public
:
-
Av1Decoder
(
)
:
Av1Decoder
(
"
"
)
{
}
-
-
explicit
Av1Decoder
(
const
std
:
:
string
&
name
)
-
:
decoder_
(
CreateDav1dDecoder
(
)
)
file_name_
(
name
)
{
-
decoder_
-
>
Configure
(
{
}
)
;
-
decoder_
-
>
RegisterDecodeCompleteCallback
(
this
)
;
-
-
if
(
!
file_name_
.
empty
(
)
)
{
-
std
:
:
string
out
=
OutPath
(
)
;
-
out
+
=
file_name_
;
-
out
+
=
"
_raw
.
av1
"
;
-
RTC_CHECK
(
raw_out_file_
=
fopen
(
out
.
c_str
(
)
"
wb
"
)
)
;
-
RTC_LOG
(
LS_INFO
)
<
<
"
Recording
bitstream
to
"
<
<
out
;
-
}
-
}
-
-
~
Av1Decoder
(
)
{
-
if
(
raw_out_file_
)
{
-
fclose
(
raw_out_file_
)
;
-
}
-
}
-
-
/
/
DecodedImageCallback
-
int32_t
Decoded
(
VideoFrame
&
frame
)
override
{
-
decode_result_
=
std
:
:
make_unique
<
VideoFrame
>
(
std
:
:
move
(
frame
)
)
;
-
return
0
;
-
}
-
-
VideoFrame
Decode
(
const
EncodedData
&
encoded_data
)
{
-
EncodedImage
img
;
-
img
.
SetEncodedData
(
encoded_data
.
bitstream_data
)
;
-
if
(
raw_out_file_
)
{
-
fwrite
(
encoded_data
.
bitstream_data
-
>
data
(
)
1
-
encoded_data
.
bitstream_data
-
>
size
(
)
raw_out_file_
)
;
-
}
-
decoder_
-
>
Decode
(
img
/
*
dont_care
=
*
/
0
)
;
-
VideoFrame
res
(
std
:
:
move
(
*
decode_result_
)
)
;
-
return
res
;
-
}
-
-
private
:
-
std
:
:
unique_ptr
<
VideoDecoder
>
decoder_
;
-
std
:
:
unique_ptr
<
VideoFrame
>
decode_result_
;
-
std
:
:
string
file_name_
;
-
FILE
*
raw_out_file_
=
nullptr
;
-
}
;
-
-
class
FrameEncoderSettingsBuilder
{
-
public
:
-
FrameEncoderSettingsBuilder
&
Key
(
)
{
-
frame_encode_settings_
.
frame_type
=
FrameType
:
:
kKeyframe
;
-
return
*
this
;
-
}
-
-
FrameEncoderSettingsBuilder
&
Start
(
)
{
-
frame_encode_settings_
.
frame_type
=
FrameType
:
:
kStartFrame
;
-
return
*
this
;
-
}
-
-
FrameEncoderSettingsBuilder
&
Delta
(
)
{
-
frame_encode_settings_
.
frame_type
=
FrameType
:
:
kStartFrame
;
-
return
*
this
;
-
}
-
-
FrameEncoderSettingsBuilder
&
Rate
(
-
const
absl
:
:
variant
<
Cqp
Cbr
>
&
rate_options
)
{
-
frame_encode_settings_
.
rate_options
=
rate_options
;
-
return
*
this
;
-
}
-
-
FrameEncoderSettingsBuilder
&
T
(
int
id
)
{
-
frame_encode_settings_
.
temporal_id
=
id
;
-
return
*
this
;
-
}
-
-
FrameEncoderSettingsBuilder
&
S
(
int
id
)
{
-
frame_encode_settings_
.
spatial_id
=
id
;
-
return
*
this
;
-
}
-
-
FrameEncoderSettingsBuilder
&
Res
(
int
width
int
height
)
{
-
frame_encode_settings_
.
resolution
=
{
width
height
}
;
-
return
*
this
;
-
}
-
-
FrameEncoderSettingsBuilder
&
Ref
(
const
std
:
:
vector
<
int
>
&
ref
)
{
-
frame_encode_settings_
.
reference_buffers
=
ref
;
-
return
*
this
;
-
}
-
-
FrameEncoderSettingsBuilder
&
Upd
(
int
upd
)
{
-
frame_encode_settings_
.
update_buffer
=
upd
;
-
return
*
this
;
-
}
-
-
VideoEncoderInterface
:
:
FrameEncodeSettings
Build
(
)
{
-
return
frame_encode_settings_
;
-
}
-
-
private
:
-
VideoEncoderInterface
:
:
FrameEncodeSettings
frame_encode_settings_
;
-
}
;
-
-
using
Fb
=
FrameEncoderSettingsBuilder
;
-
-
/
/
For
reasonable
debug
printout
when
an
EXPECT
fail
.
-
struct
Resolution
{
-
explicit
Resolution
(
const
VideoFrame
&
frame
)
-
:
width
(
frame
.
width
(
)
)
height
(
frame
.
height
(
)
)
{
}
-
-
friend
void
PrintTo
(
const
Resolution
&
res
std
:
:
ostream
*
os
)
{
-
*
os
<
<
"
(
width
:
"
<
<
res
.
width
<
<
"
height
:
"
<
<
res
.
height
<
<
"
)
"
;
-
}
-
-
int
width
;
-
int
height
;
-
}
;
-
-
MATCHER_P2
(
ResolutionIs
width
height
"
"
)
{
-
return
arg
.
width
=
=
width
&
&
arg
.
height
=
=
height
;
-
}
-
-
double
Psnr
(
const
rtc
:
:
scoped_refptr
<
I420BufferInterface
>
&
ref_buffer
-
const
VideoFrame
&
decoded_frame
)
{
-
return
I420PSNR
(
*
ref_buffer
*
decoded_frame
.
video_frame_buffer
(
)
-
>
ToI420
(
)
)
;
-
}
-
-
static
constexpr
VideoEncoderFactoryInterface
:
:
StaticEncoderSettings
-
kCbrEncoderSettings
{
-
.
max_encode_dimensions
=
{
.
width
=
1920
.
height
=
1080
}
-
.
encoding_format
=
{
.
sub_sampling
=
EncodingFormat
:
:
SubSampling
:
:
k420
-
.
bit_depth
=
8
}
-
.
rc_mode
=
-
VideoEncoderFactoryInterface
:
:
StaticEncoderSettings
:
:
Cbr
{
-
.
max_buffer_size
=
TimeDelta
:
:
Millis
(
1000
)
-
.
target_buffer_size
=
TimeDelta
:
:
Millis
(
600
)
}
-
.
max_number_of_threads
=
1
-
}
;
-
-
static
constexpr
VideoEncoderFactoryInterface
:
:
StaticEncoderSettings
-
kCqpEncoderSettings
{
-
.
max_encode_dimensions
=
{
.
width
=
1920
.
height
=
1080
}
-
.
encoding_format
=
{
.
sub_sampling
=
EncodingFormat
:
:
SubSampling
:
:
k420
-
.
bit_depth
=
8
}
-
.
rc_mode
=
VideoEncoderFactoryInterface
:
:
StaticEncoderSettings
:
:
Cqp
(
)
-
.
max_number_of_threads
=
1
-
}
;
-
-
static
constexpr
Cbr
kCbr
{
.
duration
=
TimeDelta
:
:
Millis
(
100
)
-
.
target_bitrate
=
DataRate
:
:
KilobitsPerSec
(
1000
)
}
;
-
-
TEST
(
LibaomAv1EncoderFactory
CodecName
)
{
-
EXPECT_THAT
(
LibaomAv1EncoderFactory
(
)
.
CodecName
(
)
Eq
(
"
AV1
"
)
)
;
-
}
-
-
TEST
(
LibaomAv1EncoderFactory
CodecSpecifics
)
{
-
EXPECT_THAT
(
LibaomAv1EncoderFactory
(
)
.
CodecSpecifics
(
)
IsEmpty
(
)
)
;
-
}
-
-
TEST
(
LibaomAv1EncoderFactory
QpRange
)
{
-
const
std
:
:
pair
<
int
int
>
kMinMaxQp
=
{
0
63
}
;
-
EXPECT_THAT
(
-
LibaomAv1EncoderFactory
(
)
.
GetEncoderCapabilities
(
)
.
rate_control
.
qp_range
-
Eq
(
kMinMaxQp
)
)
;
-
}
-
-
TEST
(
LibaomAv1Encoder
KeyframeUpdatesSpecifiedBuffer
)
{
-
auto
frame_reader
=
CreateFrameReader
(
)
;
-
auto
enc
=
LibaomAv1EncoderFactory
(
)
.
CreateEncoder
(
kCbrEncoderSettings
{
}
)
;
-
EncodeResults
res
;
-
Av1Decoder
dec
;
-
-
auto
raw_key
=
frame_reader
-
>
PullFrame
(
)
;
-
auto
raw_delta
=
frame_reader
-
>
PullFrame
(
)
;
-
-
enc
-
>
Encode
(
raw_key
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
0
)
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
640
360
)
.
Upd
(
5
)
.
Key
(
)
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
ASSERT_THAT
(
res
.
FrameAt
(
0
)
NotNull
(
)
)
;
-
VideoFrame
decoded_key
=
dec
.
Decode
(
*
res
.
FrameAt
(
0
)
)
;
-
EXPECT_THAT
(
Resolution
(
decoded_key
)
ResolutionIs
(
640
360
)
)
;
-
EXPECT_THAT
(
Psnr
(
raw_key
decoded_key
)
Gt
(
40
)
)
;
-
-
enc
-
>
Encode
(
raw_delta
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
100
)
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
640
360
)
.
Ref
(
{
0
}
)
.
Build
(
)
}
res
.
CallBack
(
)
)
;
-
ASSERT_THAT
(
res
.
FrameAt
(
1
)
Eq
(
nullptr
)
)
;
-
}
-
-
TEST
(
LibaomAv1Encoder
MidTemporalUnitKeyframeResetsBuffers
)
{
-
auto
frame_reader
=
CreateFrameReader
(
)
;
-
auto
enc
=
LibaomAv1EncoderFactory
(
)
.
CreateEncoder
(
kCbrEncoderSettings
{
}
)
;
-
EncodeResults
res
;
-
Av1Decoder
dec
;
-
-
enc
-
>
Encode
(
frame_reader
-
>
PullFrame
(
)
-
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
0
)
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
160
90
)
.
S
(
0
)
.
Upd
(
0
)
.
Key
(
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
320
180
)
.
S
(
1
)
.
Ref
(
{
0
}
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
640
360
)
.
S
(
2
)
.
Ref
(
{
0
}
)
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
ASSERT_THAT
(
res
.
FrameAt
(
2
)
NotNull
(
)
)
;
-
-
enc
-
>
Encode
(
frame_reader
-
>
PullFrame
(
)
-
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
100
)
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
160
90
)
.
S
(
0
)
.
Upd
(
0
)
.
Ref
(
{
0
}
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
320
180
)
.
S
(
1
)
.
Upd
(
1
)
.
Key
(
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
640
360
)
.
S
(
2
)
.
Ref
(
{
0
}
)
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
ASSERT_THAT
(
res
.
FrameAt
(
3
)
Eq
(
nullptr
)
)
;
-
}
-
-
TEST
(
LibaomAv1Encoder
ResolutionSwitching
)
{
-
auto
frame_reader
=
CreateFrameReader
(
)
;
-
auto
enc
=
LibaomAv1EncoderFactory
(
)
.
CreateEncoder
(
kCbrEncoderSettings
{
}
)
;
-
EncodeResults
res
;
-
-
rtc
:
:
scoped_refptr
<
I420Buffer
>
in0
=
frame_reader
-
>
PullFrame
(
)
;
-
enc
-
>
Encode
(
in0
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
0
)
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
320
180
)
.
Upd
(
0
)
.
Key
(
)
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
-
rtc
:
:
scoped_refptr
<
I420Buffer
>
in1
=
frame_reader
-
>
PullFrame
(
)
;
-
enc
-
>
Encode
(
in1
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
100
)
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
640
360
)
.
Ref
(
{
0
}
)
.
Build
(
)
}
res
.
CallBack
(
)
)
;
-
-
rtc
:
:
scoped_refptr
<
I420Buffer
>
in2
=
frame_reader
-
>
PullFrame
(
)
;
-
enc
-
>
Encode
(
in2
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
200
)
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
160
90
)
.
Ref
(
{
0
}
)
.
Build
(
)
}
res
.
CallBack
(
)
)
;
-
-
EXPECT_THAT
(
res
.
FrameAt
(
0
)
Field
(
&
EncodedData
:
:
spatial_id
0
)
)
;
-
EXPECT_THAT
(
res
.
FrameAt
(
1
)
Field
(
&
EncodedData
:
:
spatial_id
0
)
)
;
-
EXPECT_THAT
(
res
.
FrameAt
(
2
)
Field
(
&
EncodedData
:
:
spatial_id
0
)
)
;
-
-
Av1Decoder
dec
;
-
VideoFrame
f0
=
dec
.
Decode
(
*
res
.
FrameAt
(
0
)
)
;
-
EXPECT_THAT
(
Resolution
(
f0
)
ResolutionIs
(
320
180
)
)
;
-
/
/
TD
:
-
/
/
EXPECT_THAT
(
Psnr
(
in0
f0
)
Gt
(
40
)
)
;
-
-
VideoFrame
f1
=
dec
.
Decode
(
*
res
.
FrameAt
(
1
)
)
;
-
EXPECT_THAT
(
Resolution
(
f1
)
ResolutionIs
(
640
360
)
)
;
-
EXPECT_THAT
(
Psnr
(
in1
f1
)
Gt
(
40
)
)
;
-
-
VideoFrame
f2
=
dec
.
Decode
(
*
res
.
FrameAt
(
2
)
)
;
-
EXPECT_THAT
(
Resolution
(
f2
)
ResolutionIs
(
160
90
)
)
;
-
/
/
TD
:
-
/
/
EXPECT_THAT
(
Psnr
(
in2
f2
)
Gt
(
40
)
)
;
-
}
-
-
TEST
(
LibaomAv1Encoder
InputResolutionSwitching
)
{
-
auto
frame_reader
=
CreateFrameReader
(
)
;
-
auto
enc
=
LibaomAv1EncoderFactory
(
)
.
CreateEncoder
(
kCbrEncoderSettings
{
}
)
;
-
EncodeResults
res
;
-
-
rtc
:
:
scoped_refptr
<
I420Buffer
>
in0
=
frame_reader
-
>
PullFrame
(
)
;
-
enc
-
>
Encode
(
in0
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
0
)
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
160
90
)
.
Upd
(
0
)
.
Key
(
)
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
-
rtc
:
:
scoped_refptr
<
I420Buffer
>
in1
=
frame_reader
-
>
PullFrame
(
-
/
*
frame_num
=
*
/
nullptr
-
/
*
resolution
=
*
/
{
320
180
}
-
/
*
framerate_scale
=
*
/
{
1
1
}
)
;
-
enc
-
>
Encode
(
in1
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
100
)
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
160
90
)
.
Ref
(
{
0
}
)
.
Build
(
)
}
res
.
CallBack
(
)
)
;
-
-
rtc
:
:
scoped_refptr
<
I420Buffer
>
in2
=
frame_reader
-
>
PullFrame
(
-
/
*
frame_num
=
*
/
nullptr
-
/
*
resolution
=
*
/
{
160
90
}
-
/
*
framerate_scale
=
*
/
{
1
1
}
)
;
-
enc
-
>
Encode
(
in2
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
200
)
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
160
90
)
.
Ref
(
{
0
}
)
.
Build
(
)
}
res
.
CallBack
(
)
)
;
-
-
EXPECT_THAT
(
res
.
FrameAt
(
0
)
Field
(
&
EncodedData
:
:
spatial_id
0
)
)
;
-
EXPECT_THAT
(
res
.
FrameAt
(
1
)
Field
(
&
EncodedData
:
:
spatial_id
0
)
)
;
-
EXPECT_THAT
(
res
.
FrameAt
(
2
)
Field
(
&
EncodedData
:
:
spatial_id
0
)
)
;
-
-
Av1Decoder
dec
;
-
VideoFrame
f0
=
dec
.
Decode
(
*
res
.
FrameAt
(
0
)
)
;
-
EXPECT_THAT
(
Resolution
(
f0
)
ResolutionIs
(
160
90
)
)
;
-
/
/
TD
:
-
/
/
EXPECT_THAT
(
Psnr
(
in0
f0
)
Gt
(
40
)
)
;
-
-
VideoFrame
f1
=
dec
.
Decode
(
*
res
.
FrameAt
(
1
)
)
;
-
EXPECT_THAT
(
Resolution
(
f1
)
ResolutionIs
(
160
90
)
)
;
-
/
/
TD
:
-
/
/
EXPECT_THAT
(
Psnr
(
in1
f1
)
Gt
(
40
)
)
;
-
-
VideoFrame
f2
=
dec
.
Decode
(
*
res
.
FrameAt
(
2
)
)
;
-
EXPECT_THAT
(
Resolution
(
f2
)
ResolutionIs
(
160
90
)
)
;
-
EXPECT_THAT
(
Psnr
(
in2
f2
)
Gt
(
40
)
)
;
-
}
-
-
TEST
(
LibaomAv1Encoder
TempoSpatial
)
{
-
auto
frame_reader
=
CreateFrameReader
(
)
;
-
auto
enc
=
LibaomAv1EncoderFactory
(
)
.
CreateEncoder
(
kCbrEncoderSettings
{
}
)
;
-
EncodeResults
res
;
-
-
const
Cbr
k10Fps
{
.
duration
=
TimeDelta
:
:
Millis
(
100
)
-
.
target_bitrate
=
DataRate
:
:
KilobitsPerSec
(
500
)
}
;
-
const
Cbr
k20Fps
{
.
duration
=
TimeDelta
:
:
Millis
(
50
)
-
.
target_bitrate
=
DataRate
:
:
KilobitsPerSec
(
500
)
}
;
-
-
enc
-
>
Encode
(
frame_reader
-
>
PullFrame
(
)
-
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
0
)
}
-
{
Fb
(
)
.
Rate
(
k10Fps
)
.
Res
(
160
90
)
.
S
(
0
)
.
Upd
(
0
)
.
Key
(
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
k10Fps
)
.
Res
(
320
180
)
.
S
(
1
)
.
Ref
(
{
0
}
)
.
Upd
(
1
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
k20Fps
)
.
Res
(
640
360
)
.
S
(
2
)
.
Ref
(
{
1
}
)
.
Upd
(
2
)
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
-
enc
-
>
Encode
(
frame_reader
-
>
PullFrame
(
)
-
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
50
)
}
-
{
Fb
(
)
.
Rate
(
k20Fps
)
.
Res
(
640
360
)
.
S
(
2
)
.
Ref
(
{
2
}
)
.
Upd
(
2
)
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
-
rtc
:
:
scoped_refptr
<
I420Buffer
>
frame
=
frame_reader
-
>
PullFrame
(
)
;
-
enc
-
>
Encode
(
frame
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
100
)
}
-
{
Fb
(
)
.
Rate
(
k10Fps
)
.
Res
(
160
90
)
.
S
(
0
)
.
Ref
(
{
0
}
)
.
Upd
(
0
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
k10Fps
)
.
Res
(
320
180
)
.
S
(
1
)
.
Ref
(
{
0
1
}
)
.
Upd
(
1
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
k20Fps
)
.
Res
(
640
360
)
.
S
(
2
)
.
Ref
(
{
1
2
}
)
.
Upd
(
2
)
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
-
Av1Decoder
dec
;
-
EXPECT_THAT
(
Resolution
(
dec
.
Decode
(
*
res
.
FrameAt
(
0
)
)
)
ResolutionIs
(
160
90
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec
.
Decode
(
*
res
.
FrameAt
(
1
)
)
)
ResolutionIs
(
320
180
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec
.
Decode
(
*
res
.
FrameAt
(
2
)
)
)
ResolutionIs
(
640
360
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec
.
Decode
(
*
res
.
FrameAt
(
3
)
)
)
ResolutionIs
(
640
360
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec
.
Decode
(
*
res
.
FrameAt
(
4
)
)
)
ResolutionIs
(
160
90
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec
.
Decode
(
*
res
.
FrameAt
(
5
)
)
)
ResolutionIs
(
320
180
)
)
;
-
-
VideoFrame
f
=
dec
.
Decode
(
*
res
.
FrameAt
(
6
)
)
;
-
EXPECT_THAT
(
Resolution
(
f
)
ResolutionIs
(
640
360
)
)
;
-
-
EXPECT_THAT
(
Psnr
(
frame
f
)
Gt
(
40
)
)
;
-
}
-
-
TEST
(
DISABLED_LibaomAv1Encoder
InvertedTempoSpatial
)
{
-
auto
frame_reader
=
CreateFrameReader
(
)
;
-
auto
enc
=
LibaomAv1EncoderFactory
(
)
.
CreateEncoder
(
kCbrEncoderSettings
{
}
)
;
-
EncodeResults
res
;
-
-
enc
-
>
Encode
(
frame_reader
-
>
PullFrame
(
)
-
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
0
)
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
320
180
)
.
S
(
0
)
.
Upd
(
0
)
.
Key
(
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
640
360
)
.
S
(
1
)
.
Ref
(
{
0
}
)
.
Upd
(
1
)
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
-
enc
-
>
Encode
(
frame_reader
-
>
PullFrame
(
)
-
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
100
)
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
320
180
)
.
S
(
0
)
.
Ref
(
{
0
}
)
.
Upd
(
0
)
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
-
rtc
:
:
scoped_refptr
<
I420Buffer
>
frame
=
frame_reader
-
>
PullFrame
(
)
;
-
enc
-
>
Encode
(
frame
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
200
)
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
320
180
)
.
S
(
0
)
.
Ref
(
{
0
}
)
.
Upd
(
0
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
640
360
)
.
S
(
1
)
.
Ref
(
{
1
0
}
)
.
Upd
(
1
)
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
-
Av1Decoder
dec
;
-
EXPECT_THAT
(
Resolution
(
dec
.
Decode
(
*
res
.
FrameAt
(
0
)
)
)
ResolutionIs
(
320
180
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec
.
Decode
(
*
res
.
FrameAt
(
1
)
)
)
ResolutionIs
(
640
360
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec
.
Decode
(
*
res
.
FrameAt
(
2
)
)
)
ResolutionIs
(
320
180
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec
.
Decode
(
*
res
.
FrameAt
(
3
)
)
)
ResolutionIs
(
320
180
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec
.
Decode
(
*
res
.
FrameAt
(
4
)
)
)
ResolutionIs
(
640
360
)
)
;
-
}
-
-
TEST
(
LibaomAv1Encoder
SkipMidLayer
)
{
-
auto
frame_reader
=
CreateFrameReader
(
)
;
-
auto
enc
=
LibaomAv1EncoderFactory
(
)
.
CreateEncoder
(
kCbrEncoderSettings
{
}
)
;
-
EncodeResults
res
;
-
-
enc
-
>
Encode
(
frame_reader
-
>
PullFrame
(
)
-
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
0
)
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
160
90
)
.
S
(
0
)
.
Upd
(
0
)
.
Key
(
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
320
180
)
.
S
(
1
)
.
Ref
(
{
0
}
)
.
Upd
(
1
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
640
360
)
.
S
(
2
)
.
Ref
(
{
1
}
)
.
Upd
(
2
)
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
-
enc
-
>
Encode
(
frame_reader
-
>
PullFrame
(
)
-
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
100
)
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
160
90
)
.
S
(
0
)
.
Ref
(
{
0
}
)
.
Upd
(
0
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
640
360
)
.
S
(
2
)
.
Ref
(
{
2
}
)
.
Upd
(
2
)
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
-
rtc
:
:
scoped_refptr
<
I420Buffer
>
frame
=
frame_reader
-
>
PullFrame
(
)
;
-
enc
-
>
Encode
(
frame
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
200
)
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
160
90
)
.
S
(
0
)
.
Ref
(
{
0
}
)
.
Upd
(
0
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
320
180
)
.
S
(
1
)
.
Ref
(
{
0
1
}
)
.
Upd
(
1
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
640
360
)
.
S
(
2
)
.
Ref
(
{
1
2
}
)
.
Upd
(
2
)
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
-
Av1Decoder
dec
;
-
EXPECT_THAT
(
Resolution
(
dec
.
Decode
(
*
res
.
FrameAt
(
0
)
)
)
ResolutionIs
(
160
90
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec
.
Decode
(
*
res
.
FrameAt
(
1
)
)
)
ResolutionIs
(
320
180
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec
.
Decode
(
*
res
.
FrameAt
(
2
)
)
)
ResolutionIs
(
640
360
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec
.
Decode
(
*
res
.
FrameAt
(
3
)
)
)
ResolutionIs
(
160
90
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec
.
Decode
(
*
res
.
FrameAt
(
4
)
)
)
ResolutionIs
(
640
360
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec
.
Decode
(
*
res
.
FrameAt
(
5
)
)
)
ResolutionIs
(
160
90
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec
.
Decode
(
*
res
.
FrameAt
(
6
)
)
)
ResolutionIs
(
320
180
)
)
;
-
-
VideoFrame
f
=
dec
.
Decode
(
*
res
.
FrameAt
(
7
)
)
;
-
EXPECT_THAT
(
Resolution
(
f
)
ResolutionIs
(
640
360
)
)
;
-
EXPECT_THAT
(
Psnr
(
frame
f
)
Gt
(
40
)
)
;
-
}
-
-
TEST
(
LibaomAv1Encoder
L3T1
)
{
-
auto
frame_reader
=
CreateFrameReader
(
)
;
-
auto
enc
=
LibaomAv1EncoderFactory
(
)
.
CreateEncoder
(
kCbrEncoderSettings
{
}
)
;
-
EncodeResults
res
;
-
-
Av1Decoder
dec
;
-
-
enc
-
>
Encode
(
frame_reader
-
>
PullFrame
(
)
-
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
0
)
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
160
90
)
.
S
(
0
)
.
Upd
(
0
)
.
Key
(
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
320
180
)
.
S
(
1
)
.
Ref
(
{
0
}
)
.
Upd
(
1
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
640
360
)
.
S
(
2
)
.
Ref
(
{
1
}
)
.
Upd
(
2
)
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
-
EXPECT_THAT
(
Resolution
(
dec
.
Decode
(
*
res
.
FrameAt
(
0
)
)
)
ResolutionIs
(
160
90
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec
.
Decode
(
*
res
.
FrameAt
(
1
)
)
)
ResolutionIs
(
320
180
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec
.
Decode
(
*
res
.
FrameAt
(
2
)
)
)
ResolutionIs
(
640
360
)
)
;
-
-
auto
tu1_frame
=
frame_reader
-
>
PullFrame
(
)
;
-
enc
-
>
Encode
(
tu1_frame
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
100
)
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
160
90
)
.
S
(
0
)
.
Ref
(
{
0
}
)
.
Upd
(
0
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
320
180
)
.
S
(
1
)
.
Ref
(
{
1
0
}
)
.
Upd
(
1
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
640
360
)
.
S
(
2
)
.
Ref
(
{
2
1
}
)
.
Upd
(
2
)
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
-
EXPECT_THAT
(
Resolution
(
dec
.
Decode
(
*
res
.
FrameAt
(
3
)
)
)
ResolutionIs
(
160
90
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec
.
Decode
(
*
res
.
FrameAt
(
4
)
)
)
ResolutionIs
(
320
180
)
)
;
-
-
VideoFrame
f_tu1
=
dec
.
Decode
(
*
res
.
FrameAt
(
5
)
)
;
-
EXPECT_THAT
(
Resolution
(
f_tu1
)
ResolutionIs
(
640
360
)
)
;
-
EXPECT_THAT
(
Psnr
(
tu1_frame
f_tu1
)
Gt
(
40
)
)
;
-
-
auto
tu2_frame
=
frame_reader
-
>
PullFrame
(
)
;
-
enc
-
>
Encode
(
tu2_frame
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
200
)
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
160
90
)
.
S
(
0
)
.
Ref
(
{
0
}
)
.
Upd
(
0
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
320
180
)
.
S
(
1
)
.
Ref
(
{
1
0
}
)
.
Upd
(
1
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
640
360
)
.
S
(
2
)
.
Ref
(
{
2
1
}
)
.
Upd
(
2
)
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
-
EXPECT_THAT
(
Resolution
(
dec
.
Decode
(
*
res
.
FrameAt
(
6
)
)
)
ResolutionIs
(
160
90
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec
.
Decode
(
*
res
.
FrameAt
(
7
)
)
)
ResolutionIs
(
320
180
)
)
;
-
-
VideoFrame
f_tu2
=
dec
.
Decode
(
*
res
.
FrameAt
(
8
)
)
;
-
EXPECT_THAT
(
Resolution
(
f_tu2
)
ResolutionIs
(
640
360
)
)
;
-
EXPECT_THAT
(
Psnr
(
tu2_frame
f_tu2
)
Gt
(
40
)
)
;
-
}
-
-
TEST
(
LibaomAv1Encoder
L3T1_KEY
)
{
-
auto
frame_reader
=
CreateFrameReader
(
)
;
-
auto
enc
=
LibaomAv1EncoderFactory
(
)
.
CreateEncoder
(
kCbrEncoderSettings
{
}
)
;
-
EncodeResults
res
;
-
-
Av1Decoder
dec_s0
;
-
Av1Decoder
dec_s1
;
-
Av1Decoder
dec_s2
;
-
-
enc
-
>
Encode
(
frame_reader
-
>
PullFrame
(
)
-
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
0
)
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
160
90
)
.
S
(
0
)
.
Upd
(
0
)
.
Key
(
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
320
180
)
.
S
(
1
)
.
Ref
(
{
0
}
)
.
Upd
(
1
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
640
360
)
.
S
(
2
)
.
Ref
(
{
1
}
)
.
Upd
(
2
)
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
-
EXPECT_THAT
(
Resolution
(
dec_s0
.
Decode
(
*
res
.
FrameAt
(
0
)
)
)
-
ResolutionIs
(
160
90
)
)
;
-
-
dec_s1
.
Decode
(
*
res
.
FrameAt
(
0
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec_s1
.
Decode
(
*
res
.
FrameAt
(
1
)
)
)
-
ResolutionIs
(
320
180
)
)
;
-
-
dec_s2
.
Decode
(
*
res
.
FrameAt
(
0
)
)
;
-
dec_s2
.
Decode
(
*
res
.
FrameAt
(
1
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec_s2
.
Decode
(
*
res
.
FrameAt
(
2
)
)
)
-
ResolutionIs
(
640
360
)
)
;
-
-
enc
-
>
Encode
(
frame_reader
-
>
PullFrame
(
)
-
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
100
)
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
160
90
)
.
S
(
0
)
.
Ref
(
{
0
}
)
.
Upd
(
0
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
320
180
)
.
S
(
1
)
.
Ref
(
{
1
}
)
.
Upd
(
1
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
640
360
)
.
S
(
2
)
.
Ref
(
{
2
}
)
.
Upd
(
2
)
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
-
EXPECT_THAT
(
Resolution
(
dec_s0
.
Decode
(
*
res
.
FrameAt
(
3
)
)
)
-
ResolutionIs
(
160
90
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec_s1
.
Decode
(
*
res
.
FrameAt
(
4
)
)
)
-
ResolutionIs
(
320
180
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec_s2
.
Decode
(
*
res
.
FrameAt
(
5
)
)
)
-
ResolutionIs
(
640
360
)
)
;
-
-
enc
-
>
Encode
(
frame_reader
-
>
PullFrame
(
)
-
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
200
)
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
160
90
)
.
S
(
0
)
.
Ref
(
{
0
}
)
.
Upd
(
0
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
320
180
)
.
S
(
1
)
.
Ref
(
{
1
}
)
.
Upd
(
1
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
640
360
)
.
S
(
2
)
.
Ref
(
{
2
}
)
.
Upd
(
2
)
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
-
EXPECT_THAT
(
Resolution
(
dec_s0
.
Decode
(
*
res
.
FrameAt
(
6
)
)
)
-
ResolutionIs
(
160
90
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec_s1
.
Decode
(
*
res
.
FrameAt
(
7
)
)
)
-
ResolutionIs
(
320
180
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec_s2
.
Decode
(
*
res
.
FrameAt
(
8
)
)
)
-
ResolutionIs
(
640
360
)
)
;
-
}
-
-
TEST
(
LibaomAv1Encoder
S3T1
)
{
-
auto
frame_reader
=
CreateFrameReader
(
)
;
-
auto
enc
=
LibaomAv1EncoderFactory
(
)
.
CreateEncoder
(
kCbrEncoderSettings
{
}
)
;
-
EncodeResults
res
;
-
-
Av1Decoder
dec_s0
;
-
Av1Decoder
dec_s1
;
-
Av1Decoder
dec_s2
;
-
-
enc
-
>
Encode
(
frame_reader
-
>
PullFrame
(
)
-
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
0
)
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
160
90
)
.
S
(
0
)
.
Start
(
)
.
Upd
(
0
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
320
180
)
.
S
(
1
)
.
Start
(
)
.
Upd
(
1
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
640
360
)
.
S
(
2
)
.
Start
(
)
.
Upd
(
2
)
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec_s0
.
Decode
(
*
res
.
FrameAt
(
0
)
)
)
-
ResolutionIs
(
160
90
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec_s1
.
Decode
(
*
res
.
FrameAt
(
1
)
)
)
-
ResolutionIs
(
320
180
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec_s2
.
Decode
(
*
res
.
FrameAt
(
2
)
)
)
-
ResolutionIs
(
640
360
)
)
;
-
-
enc
-
>
Encode
(
frame_reader
-
>
PullFrame
(
)
-
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
100
)
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
160
90
)
.
S
(
0
)
.
Ref
(
{
0
}
)
.
Upd
(
0
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
320
180
)
.
S
(
1
)
.
Ref
(
{
1
}
)
.
Upd
(
1
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
640
360
)
.
S
(
2
)
.
Ref
(
{
2
}
)
.
Upd
(
2
)
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
-
EXPECT_THAT
(
Resolution
(
dec_s0
.
Decode
(
*
res
.
FrameAt
(
3
)
)
)
-
ResolutionIs
(
160
90
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec_s1
.
Decode
(
*
res
.
FrameAt
(
4
)
)
)
-
ResolutionIs
(
320
180
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec_s2
.
Decode
(
*
res
.
FrameAt
(
5
)
)
)
-
ResolutionIs
(
640
360
)
)
;
-
-
enc
-
>
Encode
(
frame_reader
-
>
PullFrame
(
)
-
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
200
)
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
160
90
)
.
S
(
0
)
.
Ref
(
{
0
}
)
.
Upd
(
0
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
320
180
)
.
S
(
1
)
.
Ref
(
{
1
}
)
.
Upd
(
1
)
.
Build
(
)
-
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
640
360
)
.
S
(
2
)
.
Ref
(
{
2
}
)
.
Upd
(
2
)
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
-
EXPECT_THAT
(
Resolution
(
dec_s0
.
Decode
(
*
res
.
FrameAt
(
6
)
)
)
-
ResolutionIs
(
160
90
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec_s1
.
Decode
(
*
res
.
FrameAt
(
7
)
)
)
-
ResolutionIs
(
320
180
)
)
;
-
EXPECT_THAT
(
Resolution
(
dec_s2
.
Decode
(
*
res
.
FrameAt
(
8
)
)
)
-
ResolutionIs
(
640
360
)
)
;
-
}
-
-
TEST
(
LibaomAv1Encoder
HigherEffortLevelYieldsHigherQualityFrames
)
{
-
auto
frame_in
=
CreateFrameReader
(
)
-
>
PullFrame
(
)
;
-
std
:
:
pair
<
int
int
>
effort_range
=
LibaomAv1EncoderFactory
(
)
-
.
GetEncoderCapabilities
(
)
-
.
performance
.
min_max_effort_level
;
-
/
/
Cbr
rc
{
.
duration
=
TimeDelta
:
:
Millis
(
100
)
-
/
/
.
target_bitrate
=
DataRate
:
:
KilobitsPerSec
(
100
)
}
;
-
absl
:
:
optional
<
double
>
psnr_last
;
-
Av1Decoder
dec
;
-
-
for
(
int
i
=
effort_range
.
first
;
i
<
=
effort_range
.
second
;
+
+
i
)
{
-
auto
enc
=
LibaomAv1EncoderFactory
(
)
.
CreateEncoder
(
kCbrEncoderSettings
{
}
)
;
-
EncodeResults
res
;
-
enc
-
>
Encode
(
-
frame_in
-
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
0
)
.
effort_level
=
i
}
-
{
Fb
(
)
.
Rate
(
kCbr
)
.
Res
(
640
360
)
.
Upd
(
0
)
.
Key
(
)
.
Build
(
)
}
res
.
CallBack
(
)
)
;
-
double
psnr
=
Psnr
(
frame_in
dec
.
Decode
(
*
res
.
FrameAt
(
0
)
)
)
;
-
EXPECT_THAT
(
psnr
Gt
(
psnr_last
)
)
;
-
psnr_last
=
psnr
;
-
}
-
}
-
-
TEST
(
LibaomAv1Encoder
KeyframeAndStartrameAreApproximatelyEqual
)
{
-
int
max_spatial_layers
=
LibaomAv1EncoderFactory
(
)
-
.
GetEncoderCapabilities
(
)
-
.
prediction_constraints
.
max_spatial_layers
;
-
const
Cbr
kRate
{
.
duration
=
TimeDelta
:
:
Millis
(
100
)
-
.
target_bitrate
=
DataRate
:
:
KilobitsPerSec
(
500
)
}
;
-
-
for
(
int
sid
=
0
;
sid
<
max_spatial_layers
;
+
+
sid
)
{
-
std
:
:
string
key_name
=
"
cbr_key_sl_
"
;
-
key_name
+
=
std
:
:
to_string
(
sid
)
;
-
Av1Decoder
dec_key
(
key_name
)
;
-
-
std
:
:
string
start_name
=
"
cbr_start_sl_
"
;
-
start_name
+
=
std
:
:
to_string
(
sid
)
;
-
Av1Decoder
dec_start
(
start_name
)
;
-
-
auto
frame_reader
=
CreateFrameReader
(
)
;
-
auto
enc_key
=
-
LibaomAv1EncoderFactory
(
)
.
CreateEncoder
(
kCbrEncoderSettings
{
}
)
;
-
auto
enc_start
=
-
LibaomAv1EncoderFactory
(
)
.
CreateEncoder
(
kCbrEncoderSettings
{
}
)
;
-
DataSize
total_size_key
=
DataSize
:
:
Zero
(
)
;
-
DataSize
total_size_start
=
DataSize
:
:
Zero
(
)
;
-
TimeDelta
total_duration
=
TimeDelta
:
:
Zero
(
)
;
-
EncodeResults
res_key
;
-
EncodeResults
res_start
;
-
auto
frame_in
=
frame_reader
-
>
PullFrame
(
)
;
-
enc_key
-
>
Encode
(
-
frame_in
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
0
)
}
-
{
Fb
(
)
.
Rate
(
kRate
)
.
Res
(
640
360
)
.
S
(
sid
)
.
Upd
(
0
)
.
Key
(
)
.
Build
(
)
}
-
res_key
.
CallBack
(
)
)
;
-
enc_start
-
>
Encode
(
-
frame_in
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
0
)
}
-
{
Fb
(
)
.
Rate
(
kRate
)
.
Res
(
640
360
)
.
S
(
sid
)
.
Start
(
)
.
Upd
(
0
)
.
Build
(
)
}
-
res_start
.
CallBack
(
)
)
;
-
total_size_key
+
=
-
DataSize
:
:
Bytes
(
res_key
.
FrameAt
(
0
)
-
>
bitstream_data
-
>
size
(
)
)
;
-
total_size_start
+
=
-
DataSize
:
:
Bytes
(
res_start
.
FrameAt
(
0
)
-
>
bitstream_data
-
>
size
(
)
)
;
-
total_duration
+
=
kRate
.
duration
;
-
dec_key
.
Decode
(
*
res_key
.
FrameAt
(
0
)
)
;
-
dec_start
.
Decode
(
*
res_start
.
FrameAt
(
0
)
)
;
-
-
EXPECT_NEAR
(
total_size_key
.
bytes
(
)
total_size_start
.
bytes
(
)
-
0
.
1
*
total_size_key
.
bytes
(
)
)
;
-
-
for
(
int
f
=
1
;
f
<
10
;
+
+
f
)
{
-
frame_in
=
frame_reader
-
>
PullFrame
(
)
;
-
enc_key
-
>
Encode
(
-
frame_in
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
f
*
100
)
}
-
{
Fb
(
)
.
Rate
(
kRate
)
.
Res
(
640
360
)
.
S
(
sid
)
.
Ref
(
{
0
}
)
.
Upd
(
0
)
.
Build
(
)
}
-
res_key
.
CallBack
(
)
)
;
-
enc_start
-
>
Encode
(
-
frame_in
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
f
*
100
)
}
-
{
Fb
(
)
.
Rate
(
kRate
)
.
Res
(
640
360
)
.
S
(
sid
)
.
Ref
(
{
0
}
)
.
Upd
(
0
)
.
Build
(
)
}
-
res_start
.
CallBack
(
)
)
;
-
total_size_key
+
=
-
DataSize
:
:
Bytes
(
res_key
.
FrameAt
(
f
)
-
>
bitstream_data
-
>
size
(
)
)
;
-
total_size_start
+
=
-
DataSize
:
:
Bytes
(
res_start
.
FrameAt
(
f
)
-
>
bitstream_data
-
>
size
(
)
)
;
-
total_duration
+
=
kRate
.
duration
;
-
dec_key
.
Decode
(
*
res_key
.
FrameAt
(
f
)
)
;
-
dec_start
.
Decode
(
*
res_start
.
FrameAt
(
f
)
)
;
-
}
-
-
double
key_encode_kbps
=
(
total_size_key
/
total_duration
)
.
kbps
(
)
;
-
double
start_encode_kbps
=
(
total_size_start
/
total_duration
)
.
kbps
(
)
;
-
-
EXPECT_NEAR
(
key_encode_kbps
start_encode_kbps
start_encode_kbps
*
0
.
05
)
;
-
}
-
}
-
-
TEST
(
LibaomAv1Encoder
BitrateConsistentAcrossSpatialLayers
)
{
-
int
max_spatial_layers
=
LibaomAv1EncoderFactory
(
)
-
.
GetEncoderCapabilities
(
)
-
.
prediction_constraints
.
max_spatial_layers
;
-
const
Cbr
kRate
{
.
duration
=
TimeDelta
:
:
Millis
(
100
)
-
.
target_bitrate
=
DataRate
:
:
KilobitsPerSec
(
500
)
}
;
-
-
for
(
int
sid
=
0
;
sid
<
max_spatial_layers
;
+
+
sid
)
{
-
std
:
:
string
out_name
=
"
cbr_sl_
"
;
-
out_name
+
=
std
:
:
to_string
(
sid
)
;
-
Av1Decoder
dec
(
out_name
)
;
-
-
auto
frame_reader
=
CreateFrameReader
(
)
;
-
auto
enc
=
LibaomAv1EncoderFactory
(
)
.
CreateEncoder
(
kCbrEncoderSettings
{
}
)
;
-
DataSize
total_size
=
DataSize
:
:
Zero
(
)
;
-
TimeDelta
total_duration
=
TimeDelta
:
:
Zero
(
)
;
-
EncodeResults
res
;
-
enc
-
>
Encode
(
frame_reader
-
>
PullFrame
(
)
-
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
0
)
}
-
{
Fb
(
)
.
Rate
(
kRate
)
.
Res
(
640
360
)
.
S
(
sid
)
.
Upd
(
0
)
.
Key
(
)
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
total_size
+
=
DataSize
:
:
Bytes
(
res
.
FrameAt
(
0
)
-
>
bitstream_data
-
>
size
(
)
)
;
-
total_duration
+
=
kRate
.
duration
;
-
dec
.
Decode
(
*
res
.
FrameAt
(
0
)
)
;
-
-
for
(
int
f
=
1
;
f
<
30
;
+
+
f
)
{
-
enc
-
>
Encode
(
-
frame_reader
-
>
PullFrame
(
)
-
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
f
*
100
)
}
-
{
Fb
(
)
.
Rate
(
kRate
)
.
Res
(
640
360
)
.
S
(
sid
)
.
Ref
(
{
0
}
)
.
Upd
(
0
)
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
total_size
+
=
DataSize
:
:
Bytes
(
res
.
FrameAt
(
f
)
-
>
bitstream_data
-
>
size
(
)
)
;
-
total_duration
+
=
kRate
.
duration
;
-
dec
.
Decode
(
*
res
.
FrameAt
(
f
)
)
;
-
}
-
-
double
encode_kbps
=
(
total_size
/
total_duration
)
.
kbps
(
)
;
-
double
target_kbps
=
kRate
.
target_bitrate
.
kbps
(
)
;
-
-
EXPECT_NEAR
(
encode_kbps
target_kbps
target_kbps
*
0
.
1
)
;
-
}
-
}
-
-
TEST
(
LibaomAv1Encoder
ConstantQp
)
{
-
int
max_spatial_layers
=
LibaomAv1EncoderFactory
(
)
-
.
GetEncoderCapabilities
(
)
-
.
prediction_constraints
.
max_spatial_layers
;
-
constexpr
int
kQp
=
30
;
-
for
(
int
sid
=
0
;
sid
<
max_spatial_layers
;
+
+
sid
)
{
-
auto
enc
=
LibaomAv1EncoderFactory
(
)
.
CreateEncoder
(
kCqpEncoderSettings
{
}
)
;
-
std
:
:
string
out_name
=
"
cqp_sl_
"
;
-
out_name
+
=
std
:
:
to_string
(
sid
)
;
-
Av1Decoder
dec
(
out_name
)
;
-
DataSize
total_size
=
DataSize
:
:
Zero
(
)
;
-
auto
frame_reader
=
CreateFrameReader
(
)
;
-
EncodeResults
res
;
-
-
enc
-
>
Encode
(
frame_reader
-
>
PullFrame
(
)
-
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
0
)
}
-
{
Fb
(
)
.
Rate
(
Cqp
{
.
target_qp
=
kQp
}
)
-
.
Res
(
640
360
)
-
.
S
(
sid
)
-
.
Upd
(
0
)
-
.
Key
(
)
-
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
EXPECT_THAT
(
res
.
FrameAt
(
0
)
-
>
encoded_qp
Eq
(
kQp
)
)
;
-
total_size
+
=
DataSize
:
:
Bytes
(
res
.
FrameAt
(
0
)
-
>
bitstream_data
-
>
size
(
)
)
;
-
dec
.
Decode
(
*
res
.
FrameAt
(
0
)
)
;
-
-
for
(
int
f
=
1
;
f
<
10
;
+
+
f
)
{
-
enc
-
>
Encode
(
frame_reader
-
>
PullFrame
(
)
-
{
.
presentation_timestamp
=
Timestamp
:
:
Millis
(
f
*
100
)
}
-
{
Fb
(
)
.
Rate
(
Cqp
{
.
target_qp
=
kQp
-
f
}
)
-
.
Res
(
640
360
)
-
.
S
(
sid
)
-
.
Ref
(
{
0
}
)
-
.
Upd
(
0
)
-
.
Build
(
)
}
-
res
.
CallBack
(
)
)
;
-
EXPECT_THAT
(
res
.
FrameAt
(
f
)
-
>
encoded_qp
Eq
(
kQp
-
f
)
)
;
-
dec
.
Decode
(
*
res
.
FrameAt
(
f
)
)
;
-
}
-
}
-
}
-
-
}
/
/
namespace
-
}
/
/
namespace
webrtc
diff
-
-
git
a
/
api
/
video_codecs
/
simple_encoder_wrapper
.
cc
b
/
api
/
video_codecs
/
simple_encoder_wrapper
.
cc
deleted
file
mode
100644
index
bb2eda6afb
.
.
0000000000
-
-
-
a
/
api
/
video_codecs
/
simple_encoder_wrapper
.
cc
+
+
+
/
dev
/
null
-
1
216
+
0
0
-
/
*
-
*
Copyright
(
c
)
2024
The
WebRTC
project
authors
.
All
Rights
Reserved
.
-
*
-
*
Use
of
this
source
code
is
governed
by
a
BSD
-
style
license
-
*
that
can
be
found
in
the
LICENSE
file
in
the
root
of
the
source
-
*
tree
.
An
additional
intellectual
property
rights
grant
can
be
found
-
*
in
the
file
PATENTS
.
All
contributing
project
authors
may
-
*
be
found
in
the
AUTHORS
file
in
the
root
of
the
source
tree
.
-
*
/
-
-
#
include
"
api
/
video_codecs
/
simple_encoder_wrapper
.
h
"
-
-
#
include
<
algorithm
>
-
#
include
<
memory
>
-
#
include
<
string
>
-
#
include
<
utility
>
-
#
include
<
vector
>
-
-
#
include
"
absl
/
algorithm
/
container
.
h
"
-
#
include
"
api
/
video_codecs
/
scalability_mode
.
h
"
-
#
include
"
api
/
video_codecs
/
scalability_mode_helper
.
h
"
-
#
include
"
api
/
video_codecs
/
video_encoder_factory_interface
.
h
"
-
#
include
"
api
/
video_codecs
/
video_encoder_interface
.
h
"
-
#
include
"
modules
/
video_coding
/
svc
/
create_scalability_structure
.
h
"
-
-
namespace
webrtc
{
-
using
PredictionConstraints
=
-
VideoEncoderFactoryInterface
:
:
Capabilities
:
:
PredictionConstraints
;
-
using
FrameEncodeSettings
=
VideoEncoderInterface
:
:
FrameEncodeSettings
;
-
-
namespace
{
-
enum
class
Inter
{
kS
kL
kKey
}
;
-
enum
class
Scaling
{
k1_2
k2_3
}
;
-
std
:
:
string
SvcToString
(
int
spatial_layers
-
int
temporal_layers
-
Inter
inter
-
Scaling
scaling
)
{
-
RTC_CHECK
(
spatial_layers
>
1
|
|
inter
=
=
Inter
:
:
kL
)
;
-
std
:
:
string
res
;
-
res
+
=
inter
=
=
Inter
:
:
kS
?
"
S
"
:
"
L
"
;
-
res
+
=
std
:
:
to_string
(
spatial_layers
)
;
-
res
+
=
"
T
"
;
-
res
+
=
std
:
:
to_string
(
temporal_layers
)
;
-
if
(
scaling
=
=
Scaling
:
:
k2_3
)
{
-
res
+
=
"
h
"
;
-
}
-
if
(
inter
=
=
Inter
:
:
kKey
)
{
-
res
+
=
"
_KEY
"
;
-
}
-
-
return
res
;
-
}
-
}
/
/
namespace
-
-
/
/
static
-
std
:
:
vector
<
std
:
:
string
>
SimpleEncoderWrapper
:
:
SupportedWebrtcSvcModes
(
-
const
PredictionConstraints
&
prediction_constraints
)
{
-
std
:
:
vector
<
std
:
:
string
>
res
;
-
-
const
int
max_spatial_layers
=
-
std
:
:
min
(
3
prediction_constraints
.
max_spatial_layers
)
;
-
const
int
max_temporal_layers
=
-
std
:
:
min
(
3
prediction_constraints
.
max_temporal_layers
)
;
-
const
bool
scale_by_half
=
absl
:
:
c_linear_search
(
-
prediction_constraints
.
scaling_factors
Rational
{
1
2
}
)
;
-
const
bool
scale_by_two_thirds
=
absl
:
:
c_linear_search
(
-
prediction_constraints
.
scaling_factors
Rational
{
2
3
}
)
;
-
const
bool
inter_layer
=
-
prediction_constraints
.
max_references
>
1
&
&
-
prediction_constraints
.
buffer_space_type
!
=
-
PredictionConstraints
:
:
BufferSpaceType
:
:
kMultiInstance
;
-
-
for
(
int
s
=
1
;
s
<
=
max_spatial_layers
;
+
+
s
)
{
-
for
(
int
t
=
1
;
t
<
=
max_temporal_layers
;
+
+
t
)
{
-
if
(
prediction_constraints
.
num_buffers
>
(
(
std
:
:
max
(
1
t
-
1
)
*
s
)
-
1
)
)
{
-
if
(
s
=
=
1
|
|
inter_layer
)
{
-
res
.
push_back
(
SvcToString
(
s
t
Inter
:
:
kL
Scaling
:
:
k1_2
)
)
;
-
if
(
s
=
=
1
)
{
-
continue
;
-
}
-
}
-
if
(
scale_by_half
)
{
-
res
.
push_back
(
SvcToString
(
s
t
Inter
:
:
kS
Scaling
:
:
k1_2
)
)
;
-
if
(
inter_layer
)
{
-
res
.
push_back
(
SvcToString
(
s
t
Inter
:
:
kKey
Scaling
:
:
k1_2
)
)
;
-
}
-
}
-
if
(
scale_by_two_thirds
)
{
-
res
.
push_back
(
SvcToString
(
s
t
Inter
:
:
kS
Scaling
:
:
k2_3
)
)
;
-
if
(
inter_layer
)
{
-
res
.
push_back
(
SvcToString
(
s
t
Inter
:
:
kKey
Scaling
:
:
k2_3
)
)
;
-
res
.
push_back
(
SvcToString
(
s
t
Inter
:
:
kL
Scaling
:
:
k2_3
)
)
;
-
}
-
}
-
}
-
}
-
}
-
-
return
res
;
-
}
-
-
/
/
static
-
std
:
:
unique_ptr
<
SimpleEncoderWrapper
>
SimpleEncoderWrapper
:
:
Create
(
-
std
:
:
unique_ptr
<
VideoEncoderInterface
>
encoder
-
absl
:
:
string_view
scalability_mode
)
{
-
if
(
!
encoder
)
{
-
return
nullptr
;
-
}
-
-
absl
:
:
optional
<
ScalabilityMode
>
sm
=
-
ScalabilityModeStringToEnum
(
scalability_mode
)
;
-
if
(
!
sm
)
{
-
return
nullptr
;
-
}
-
-
std
:
:
unique_ptr
<
ScalableVideoController
>
svc_controller
=
-
CreateScalabilityStructure
(
*
sm
)
;
-
if
(
!
svc_controller
)
{
-
return
nullptr
;
-
}
-
-
return
std
:
:
make_unique
<
SimpleEncoderWrapper
>
(
std
:
:
move
(
encoder
)
-
std
:
:
move
(
svc_controller
)
)
;
-
}
-
-
SimpleEncoderWrapper
:
:
SimpleEncoderWrapper
(
-
std
:
:
unique_ptr
<
VideoEncoderInterface
>
encoder
-
std
:
:
unique_ptr
<
ScalableVideoController
>
svc_controller
)
-
:
encoder_
(
std
:
:
move
(
encoder
)
)
-
svc_controller_
(
std
:
:
move
(
svc_controller
)
)
-
layer_configs_
(
svc_controller_
-
>
StreamConfig
(
)
)
{
}
-
-
void
SimpleEncoderWrapper
:
:
SetEncodeQp
(
int
qp
)
{
-
target_qp_
=
qp
;
-
}
-
-
void
SimpleEncoderWrapper
:
:
SetEncodeFps
(
int
fps
)
{
-
fps_
=
fps
;
-
}
-
-
void
SimpleEncoderWrapper
:
:
Encode
(
-
rtc
:
:
scoped_refptr
<
webrtc
:
:
VideoFrameBuffer
>
frame_buffer
-
bool
force_keyframe
-
EncodeResultCallback
callback
)
{
-
std
:
:
vector
<
ScalableVideoController
:
:
LayerFrameConfig
>
configs
=
-
svc_controller_
-
>
NextFrameConfig
(
force_keyframe
)
;
-
std
:
:
vector
<
FrameEncodeSettings
>
encode_settings
;
-
std
:
:
vector
<
GenericFrameInfo
>
frame_infos
;
-
-
bool
include_dependency_structure
=
false
;
-
-
for
(
size_t
s
=
0
;
s
<
configs
.
size
(
)
;
+
+
s
)
{
-
const
ScalableVideoController
:
:
LayerFrameConfig
&
config
=
configs
[
s
]
;
-
frame_infos
.
push_back
(
svc_controller_
-
>
OnEncodeDone
(
config
)
)
;
-
FrameEncodeSettings
&
settings
=
encode_settings
.
emplace_back
(
)
;
-
settings
.
rate_options
=
VideoEncoderInterface
:
:
FrameEncodeSettings
:
:
Cqp
{
-
.
target_qp
=
target_qp_
}
;
-
settings
.
spatial_id
=
config
.
SpatialId
(
)
;
-
settings
.
temporal_id
=
config
.
TemporalId
(
)
;
-
const
int
num
=
layer_configs_
.
scaling_factor_num
[
s
]
;
-
const
int
den
=
layer_configs_
.
scaling_factor_den
[
s
]
;
-
settings
.
resolution
=
{
(
frame_buffer
-
>
width
(
)
*
num
/
den
)
-
(
frame_buffer
-
>
height
(
)
*
num
/
den
)
}
;
-
-
bool
buffer_updated
=
false
;
-
for
(
const
CodecBufferUsage
&
buffer
:
config
.
Buffers
(
)
)
{
-
if
(
buffer
.
referenced
)
{
-
settings
.
reference_buffers
.
push_back
(
buffer
.
id
)
;
-
}
-
if
(
buffer
.
updated
)
{
-
RTC_CHECK
(
!
buffer_updated
)
;
-
settings
.
update_buffer
=
buffer
.
id
;
-
buffer_updated
=
true
;
-
}
-
}
-
-
if
(
settings
.
reference_buffers
.
empty
(
)
)
{
-
settings
.
frame_type
=
FrameType
:
:
kKeyframe
;
-
include_dependency_structure
=
true
;
-
}
-
}
-
-
absl
:
:
optional
<
FrameDependencyStructure
>
dependency_structure
;
-
if
(
include_dependency_structure
)
{
-
dependency_structure
=
svc_controller_
-
>
DependencyStructure
(
)
;
-
}
-
-
VideoEncoderInterface
:
:
EncodeResultCallback
callback_internal
=
-
[
cb
=
std
:
:
move
(
callback
)
ds
=
std
:
:
move
(
dependency_structure
)
-
infos
=
std
:
:
move
(
frame_infos
)
]
(
-
const
VideoEncoderInterface
:
:
EncodeResult
&
result
)
mutable
{
-
auto
*
data
=
std
:
:
get_if
<
VideoEncoderInterface
:
:
EncodedData
>
(
&
result
)
;
-
EncodeResult
res
;
-
if
(
!
data
|
|
data
-
>
spatial_id
>
=
static_cast
<
int
>
(
infos
.
size
(
)
)
)
{
-
res
.
oh_no
=
true
;
-
cb
(
res
)
;
-
return
;
-
}
-
-
res
.
frame_type
=
data
-
>
frame_type
;
-
res
.
bitstream_data
=
std
:
:
move
(
data
-
>
bitstream_data
)
;
-
res
.
generic_frame_info
=
infos
[
data
-
>
spatial_id
]
;
-
if
(
data
-
>
referenced_buffers
.
empty
(
)
)
{
-
/
/
Keyframe
-
res
.
dependency_structure
=
ds
;
-
}
-
cb
(
res
)
;
-
}
;
-
-
encoder_
-
>
Encode
(
std
:
:
move
(
frame_buffer
)
-
{
.
presentation_timestamp
=
presentation_timestamp_
}
-
encode_settings
std
:
:
move
(
callback_internal
)
)
;
-
presentation_timestamp_
+
=
1
/
Frequency
:
:
Hertz
(
fps_
)
;
-
}
-
-
}
/
/
namespace
webrtc
diff
-
-
git
a
/
api
/
video_codecs
/
simple_encoder_wrapper
.
h
b
/
api
/
video_codecs
/
simple_encoder_wrapper
.
h
deleted
file
mode
100644
index
4d11020924
.
.
0000000000
-
-
-
a
/
api
/
video_codecs
/
simple_encoder_wrapper
.
h
+
+
+
/
dev
/
null
-
1
71
+
0
0
-
/
*
-
*
Copyright
(
c
)
2024
The
WebRTC
project
authors
.
All
Rights
Reserved
.
-
*
-
*
Use
of
this
source
code
is
governed
by
a
BSD
-
style
license
-
*
that
can
be
found
in
the
LICENSE
file
in
the
root
of
the
source
-
*
tree
.
An
additional
intellectual
property
rights
grant
can
be
found
-
*
in
the
file
PATENTS
.
All
contributing
project
authors
may
-
*
be
found
in
the
AUTHORS
file
in
the
root
of
the
source
tree
.
-
*
/
-
-
#
ifndef
API_VIDEO_CODECS_SIMPLE_ENCODER_WRAPPER_H_
-
#
define
API_VIDEO_CODECS_SIMPLE_ENCODER_WRAPPER_H_
-
-
#
include
<
memory
>
-
#
include
<
string
>
-
#
include
<
vector
>
-
-
#
include
"
absl
/
functional
/
any_invocable
.
h
"
-
#
include
"
api
/
units
/
data_rate
.
h
"
-
#
include
"
api
/
video_codecs
/
video_encoder_factory_interface
.
h
"
-
#
include
"
api
/
video_codecs
/
video_encoder_interface
.
h
"
-
#
include
"
common_video
/
generic_frame_descriptor
/
generic_frame_info
.
h
"
-
#
include
"
modules
/
video_coding
/
svc
/
create_scalability_structure
.
h
"
-
-
namespace
webrtc
{
-
class
SimpleEncoderWrapper
{
-
public
:
-
struct
EncodeResult
{
-
bool
oh_no
=
false
;
-
rtc
:
:
scoped_refptr
<
EncodedImageBufferInterface
>
bitstream_data
;
-
FrameType
frame_type
;
-
GenericFrameInfo
generic_frame_info
;
-
absl
:
:
optional
<
FrameDependencyStructure
>
dependency_structure
;
-
}
;
-
-
using
EncodeResultCallback
=
-
absl
:
:
AnyInvocable
<
void
(
const
EncodeResult
&
result
)
>
;
-
-
static
std
:
:
vector
<
std
:
:
string
>
SupportedWebrtcSvcModes
(
-
const
VideoEncoderFactoryInterface
:
:
Capabilities
:
:
PredictionConstraints
&
-
prediction_constraints
)
;
-
-
static
std
:
:
unique_ptr
<
SimpleEncoderWrapper
>
Create
(
-
std
:
:
unique_ptr
<
VideoEncoderInterface
>
encoder
-
absl
:
:
string_view
scalability_mode
)
;
-
-
/
/
Should
be
private
use
the
Create
function
instead
.
-
SimpleEncoderWrapper
(
std
:
:
unique_ptr
<
VideoEncoderInterface
>
encoder
-
std
:
:
unique_ptr
<
ScalableVideoController
>
svc_controller
)
;
-
-
/
/
We
should
really
only
support
CBR
but
then
we
have
to
think
about
layer
-
/
/
allocations
.
.
.
eh
.
.
.
For
this
PoC
just
use
CQP
.
-
void
SetEncodeQp
(
int
qp
)
;
-
-
void
SetEncodeFps
(
int
fps
)
;
-
-
void
Encode
(
rtc
:
:
scoped_refptr
<
webrtc
:
:
VideoFrameBuffer
>
frame_buffer
-
bool
force_keyframe
-
EncodeResultCallback
callback
)
;
-
-
private
:
-
std
:
:
unique_ptr
<
VideoEncoderInterface
>
encoder_
;
-
std
:
:
unique_ptr
<
ScalableVideoController
>
svc_controller_
;
-
ScalableVideoController
:
:
StreamLayersConfig
layer_configs_
;
-
int
target_qp_
=
0
;
-
int
fps_
=
0
;
-
Timestamp
presentation_timestamp_
=
Timestamp
:
:
Zero
(
)
;
-
}
;
-
-
}
/
/
namespace
webrtc
-
#
endif
/
/
API_VIDEO_CODECS_SIMPLE_ENCODER_WRAPPER_H_
diff
-
-
git
a
/
api
/
video_codecs
/
simple_encoder_wrapper_unittests
.
cc
b
/
api
/
video_codecs
/
simple_encoder_wrapper_unittests
.
cc
deleted
file
mode
100644
index
3e72371c72
.
.
0000000000
-
-
-
a
/
api
/
video_codecs
/
simple_encoder_wrapper_unittests
.
cc
+
+
+
/
dev
/
null
-
1
302
+
0
0
-
/
*
-
*
Copyright
(
c
)
2024
The
WebRTC
project
authors
.
All
Rights
Reserved
.
-
*
-
*
Use
of
this
source
code
is
governed
by
a
BSD
-
style
license
-
*
that
can
be
found
in
the
LICENSE
file
in
the
root
of
the
source
-
*
tree
.
An
additional
intellectual
property
rights
grant
can
be
found
-
*
in
the
file
PATENTS
.
All
contributing
project
authors
may
-
*
be
found
in
the
AUTHORS
file
in
the
root
of
the
source
tree
.
-
*
/
-
-
#
include
"
api
/
video_codecs
/
simple_encoder_wrapper
.
h
"
-
-
#
include
"
api
/
video
/
i420_buffer
.
h
"
-
#
include
"
api
/
video_codecs
/
libaom_av1_encoder_factory
.
h
"
-
#
include
"
api
/
video_codecs
/
video_encoder_interface
.
h
"
-
#
include
"
test
/
gmock
.
h
"
-
#
include
"
test
/
gtest
.
h
"
-
#
include
"
test
/
testsupport
/
file_utils
.
h
"
-
#
include
"
test
/
testsupport
/
frame_reader
.
h
"
-
-
namespace
webrtc
{
-
-
using
:
:
testing
:
:
Eq
;
-
using
:
:
testing
:
:
Gt
;
-
using
:
:
testing
:
:
IsEmpty
;
-
using
:
:
testing
:
:
Ne
;
-
using
:
:
testing
:
:
Not
;
-
using
:
:
testing
:
:
NotNull
;
-
using
:
:
testing
:
:
UnorderedElementsAre
;
-
using
PredictionConstraints
=
-
VideoEncoderFactoryInterface
:
:
Capabilities
:
:
PredictionConstraints
;
-
-
namespace
{
-
-
std
:
:
unique_ptr
<
test
:
:
FrameReader
>
CreateFrameReader
(
)
{
-
return
CreateY4mFrameReader
(
-
test
:
:
ResourcePath
(
"
reference_video_640x360_30fps
"
"
y4m
"
)
-
test
:
:
YuvFrameReaderImpl
:
:
RepeatMode
:
:
kPingPong
)
;
-
}
-
-
TEST
(
SimpleEncoderWrapper
SupportedSvcModesOnlyL1T1
)
{
-
PredictionConstraints
constraints
=
{
-
.
num_buffers
=
2
-
.
max_references
=
2
-
.
max_temporal_layers
=
1
-
.
buffer_space_type
=
-
PredictionConstraints
:
:
BufferSpaceType
:
:
kSingleKeyframe
-
.
max_spatial_layers
=
1
-
.
scaling_factors
=
{
{
1
1
}
}
-
}
;
-
-
EXPECT_THAT
(
SimpleEncoderWrapper
:
:
SupportedWebrtcSvcModes
(
constraints
)
-
UnorderedElementsAre
(
"
L1T1
"
)
)
;
-
}
-
-
TEST
(
SimpleEncoderWrapper
SupportedSvcModesUpToL1T3
)
{
-
PredictionConstraints
constraints
=
{
-
.
num_buffers
=
8
-
.
max_references
=
1
-
.
max_temporal_layers
=
3
-
.
buffer_space_type
=
-
PredictionConstraints
:
:
BufferSpaceType
:
:
kSingleKeyframe
-
.
max_spatial_layers
=
1
-
.
scaling_factors
=
{
{
1
1
}
{
1
2
}
}
-
}
;
-
-
EXPECT_THAT
(
SimpleEncoderWrapper
:
:
SupportedWebrtcSvcModes
(
constraints
)
-
UnorderedElementsAre
(
"
L1T1
"
"
L1T2
"
"
L1T3
"
)
)
;
-
}
-
-
TEST
(
SimpleEncoderWrapper
SupportedSvcModesUpToL3T3Key
)
{
-
PredictionConstraints
constraints
=
{
-
.
num_buffers
=
8
-
.
max_references
=
2
-
.
max_temporal_layers
=
3
-
.
buffer_space_type
=
-
PredictionConstraints
:
:
BufferSpaceType
:
:
kSingleKeyframe
-
.
max_spatial_layers
=
3
-
.
scaling_factors
=
{
{
1
1
}
{
1
2
}
}
-
}
;
-
-
EXPECT_THAT
(
-
SimpleEncoderWrapper
:
:
SupportedWebrtcSvcModes
(
constraints
)
-
UnorderedElementsAre
(
"
L1T1
"
"
L1T2
"
"
L1T3
"
"
L2T1
"
"
L2T1_KEY
"
"
L2T2
"
-
"
L2T2_KEY
"
"
L2T3
"
"
L2T3_KEY
"
"
L3T1
"
"
L3T1_KEY
"
-
"
L3T2
"
"
L3T2_KEY
"
"
L3T3
"
"
L3T3_KEY
"
"
S2T1
"
-
"
S2T2
"
"
S2T3
"
"
S3T1
"
"
S3T2
"
"
S3T3
"
)
)
;
-
}
-
-
TEST
(
SimpleEncoderWrapper
SupportedSvcModesUpToS3T3
)
{
-
PredictionConstraints
constraints
=
{
-
.
num_buffers
=
8
-
.
max_references
=
2
-
.
max_temporal_layers
=
3
-
.
buffer_space_type
=
-
PredictionConstraints
:
:
BufferSpaceType
:
:
kMultiInstance
-
.
max_spatial_layers
=
3
-
.
scaling_factors
=
{
{
1
1
}
{
1
2
}
}
-
}
;
-
-
EXPECT_THAT
(
SimpleEncoderWrapper
:
:
SupportedWebrtcSvcModes
(
constraints
)
-
UnorderedElementsAre
(
"
L1T1
"
"
L1T2
"
"
L1T3
"
"
S2T1
"
"
S2T2
"
-
"
S2T3
"
"
S3T1
"
"
S3T2
"
"
S3T3
"
)
)
;
-
}
-
-
TEST
(
SimpleEncoderWrapper
SupportedSvcModesUpToL3T3KeyWithHScaling
)
{
-
PredictionConstraints
constraints
=
{
-
.
num_buffers
=
8
-
.
max_references
=
2
-
.
max_temporal_layers
=
3
-
.
buffer_space_type
=
-
PredictionConstraints
:
:
BufferSpaceType
:
:
kSingleKeyframe
-
.
max_spatial_layers
=
3
-
.
scaling_factors
=
{
{
1
1
}
{
1
2
}
{
2
3
}
}
-
}
;
-
-
EXPECT_THAT
(
-
SimpleEncoderWrapper
:
:
SupportedWebrtcSvcModes
(
constraints
)
-
UnorderedElementsAre
(
-
"
L1T1
"
"
L1T2
"
"
L1T3
"
"
L2T1
"
"
L2T1h
"
"
L2T1_KEY
"
"
L2T1h_KEY
"
-
"
L2T2
"
"
L2T2h
"
"
L2T2_KEY
"
"
L2T2h_KEY
"
"
L2T3
"
"
L2T3h
"
"
L2T3_KEY
"
-
"
L2T3h_KEY
"
"
L3T1
"
"
L3T1h
"
"
L3T1_KEY
"
"
L3T1h_KEY
"
"
L3T2
"
-
"
L3T2h
"
"
L3T2_KEY
"
"
L3T2h_KEY
"
"
L3T3
"
"
L3T3h
"
"
L3T3_KEY
"
-
"
L3T3h_KEY
"
"
S2T1
"
"
S2T1h
"
"
S2T2
"
"
S2T2h
"
"
S2T3
"
"
S2T3h
"
-
"
S3T1
"
"
S3T1h
"
"
S3T2
"
"
S3T2h
"
"
S3T3
"
"
S3T3h
"
)
)
;
-
}
-
-
/
/
TD
:
The
encoder
wrapper
shouldn
'
t
really
use
an
actual
encoder
implementation
-
/
/
for
testing
but
hey
this
is
just
a
PoC
.
-
TEST
(
SimpleEncoderWrapper
EncodeL1T1
)
{
-
auto
encoder
=
LibaomAv1EncoderFactory
(
)
.
CreateEncoder
(
-
{
.
max_encode_dimensions
=
{
1080
720
}
-
.
encoding_format
=
{
.
sub_sampling
=
EncodingFormat
:
:
k420
-
.
bit_depth
=
8
}
-
.
rc_mode
=
VideoEncoderFactoryInterface
:
:
StaticEncoderSettings
:
:
Cqp
(
)
-
.
max_number_of_threads
=
1
}
-
{
}
)
;
-
-
std
:
:
unique_ptr
<
SimpleEncoderWrapper
>
simple_encoder
=
-
SimpleEncoderWrapper
:
:
Create
(
std
:
:
move
(
encoder
)
"
L1T1
"
)
;
-
-
ASSERT_THAT
(
simple_encoder
NotNull
(
)
)
;
-
-
simple_encoder
-
>
SetEncodeQp
(
30
)
;
-
simple_encoder
-
>
SetEncodeFps
(
15
)
;
-
auto
frame_reader
=
CreateFrameReader
(
)
;
-
-
int
num_callbacks
=
0
;
-
simple_encoder
-
>
Encode
(
-
frame_reader
-
>
PullFrame
(
)
/
*
force_keyframe
=
*
/
true
-
[
&
]
(
const
SimpleEncoderWrapper
:
:
EncodeResult
&
result
)
{
-
+
+
num_callbacks
;
-
ASSERT_THAT
(
result
.
oh_no
Eq
(
false
)
)
;
-
EXPECT_THAT
(
result
.
dependency_structure
Ne
(
absl
:
:
nullopt
)
)
;
-
EXPECT_THAT
(
result
.
bitstream_data
NotNull
(
)
)
;
-
EXPECT_THAT
(
result
.
frame_type
Eq
(
FrameType
:
:
kKeyframe
)
)
;
-
EXPECT_THAT
(
result
.
generic_frame_info
.
spatial_id
Eq
(
0
)
)
;
-
EXPECT_THAT
(
result
.
generic_frame_info
.
temporal_id
Eq
(
0
)
)
;
-
}
)
;
-
-
simple_encoder
-
>
Encode
(
-
frame_reader
-
>
PullFrame
(
)
/
*
force_keyframe
=
*
/
false
-
[
&
]
(
const
SimpleEncoderWrapper
:
:
EncodeResult
&
result
)
{
-
+
+
num_callbacks
;
-
ASSERT_THAT
(
result
.
oh_no
Eq
(
false
)
)
;
-
EXPECT_THAT
(
result
.
dependency_structure
Eq
(
absl
:
:
nullopt
)
)
;
-
EXPECT_THAT
(
result
.
bitstream_data
NotNull
(
)
)
;
-
EXPECT_THAT
(
result
.
frame_type
Eq
(
FrameType
:
:
kDeltaFrame
)
)
;
-
EXPECT_THAT
(
result
.
generic_frame_info
.
spatial_id
Eq
(
0
)
)
;
-
EXPECT_THAT
(
result
.
generic_frame_info
.
temporal_id
Eq
(
0
)
)
;
-
}
)
;
-
}
-
-
TEST
(
SimpleEncoderWrapper
EncodeL2T2_KEY
)
{
-
auto
encoder
=
LibaomAv1EncoderFactory
(
)
.
CreateEncoder
(
-
{
.
max_encode_dimensions
=
{
1080
720
}
-
.
encoding_format
=
{
.
sub_sampling
=
EncodingFormat
:
:
k420
-
.
bit_depth
=
8
}
-
.
rc_mode
=
VideoEncoderFactoryInterface
:
:
StaticEncoderSettings
:
:
Cqp
(
)
-
.
max_number_of_threads
=
1
}
-
{
}
)
;
-
-
std
:
:
unique_ptr
<
SimpleEncoderWrapper
>
simple_encoder
=
-
SimpleEncoderWrapper
:
:
Create
(
std
:
:
move
(
encoder
)
"
L2T2_KEY
"
)
;
-
-
ASSERT_THAT
(
simple_encoder
NotNull
(
)
)
;
-
-
simple_encoder
-
>
SetEncodeQp
(
30
)
;
-
simple_encoder
-
>
SetEncodeFps
(
15
)
;
-
auto
frame_reader
=
CreateFrameReader
(
)
;
-
-
int
num_callbacks
=
0
;
-
simple_encoder
-
>
Encode
(
-
frame_reader
-
>
PullFrame
(
)
/
*
force_keyframe
=
*
/
true
-
[
&
]
(
const
SimpleEncoderWrapper
:
:
EncodeResult
&
result
)
{
-
ASSERT_THAT
(
result
.
oh_no
Eq
(
false
)
)
;
-
if
(
result
.
generic_frame_info
.
spatial_id
=
=
0
)
{
-
+
+
num_callbacks
;
-
EXPECT_THAT
(
result
.
dependency_structure
Ne
(
absl
:
:
nullopt
)
)
;
-
EXPECT_THAT
(
result
.
bitstream_data
NotNull
(
)
)
;
-
EXPECT_THAT
(
result
.
frame_type
Eq
(
FrameType
:
:
kKeyframe
)
)
;
-
EXPECT_THAT
(
result
.
generic_frame_info
.
temporal_id
Eq
(
0
)
)
;
-
}
else
if
(
result
.
generic_frame_info
.
spatial_id
=
=
1
)
{
-
+
+
num_callbacks
;
-
EXPECT_THAT
(
result
.
dependency_structure
Eq
(
absl
:
:
nullopt
)
)
;
-
EXPECT_THAT
(
result
.
bitstream_data
NotNull
(
)
)
;
-
EXPECT_THAT
(
result
.
frame_type
Eq
(
FrameType
:
:
kDeltaFrame
)
)
;
-
EXPECT_THAT
(
result
.
generic_frame_info
.
temporal_id
Eq
(
0
)
)
;
-
}
-
}
)
;
-
-
simple_encoder
-
>
Encode
(
-
frame_reader
-
>
PullFrame
(
)
/
*
force_keyframe
=
*
/
false
-
[
&
]
(
const
SimpleEncoderWrapper
:
:
EncodeResult
&
result
)
{
-
ASSERT_THAT
(
result
.
oh_no
Eq
(
false
)
)
;
-
if
(
result
.
generic_frame_info
.
spatial_id
=
=
0
)
{
-
+
+
num_callbacks
;
-
EXPECT_THAT
(
result
.
dependency_structure
Eq
(
absl
:
:
nullopt
)
)
;
-
EXPECT_THAT
(
result
.
bitstream_data
NotNull
(
)
)
;
-
EXPECT_THAT
(
result
.
frame_type
Eq
(
FrameType
:
:
kDeltaFrame
)
)
;
-
EXPECT_THAT
(
result
.
generic_frame_info
.
temporal_id
Eq
(
1
)
)
;
-
}
else
if
(
result
.
generic_frame_info
.
spatial_id
=
=
1
)
{
-
+
+
num_callbacks
;
-
EXPECT_THAT
(
result
.
dependency_structure
Eq
(
absl
:
:
nullopt
)
)
;
-
EXPECT_THAT
(
result
.
bitstream_data
NotNull
(
)
)
;
-
EXPECT_THAT
(
result
.
frame_type
Eq
(
FrameType
:
:
kDeltaFrame
)
)
;
-
EXPECT_THAT
(
result
.
generic_frame_info
.
temporal_id
Eq
(
1
)
)
;
-
}
-
}
)
;
-
-
EXPECT_THAT
(
num_callbacks
Eq
(
4
)
)
;
-
}
-
-
TEST
(
SimpleEncoderWrapper
EncodeL1T3ForceKeyframe
)
{
-
auto
encoder
=
LibaomAv1EncoderFactory
(
)
.
CreateEncoder
(
-
{
.
max_encode_dimensions
=
{
1080
720
}
-
.
encoding_format
=
{
.
sub_sampling
=
EncodingFormat
:
:
k420
-
.
bit_depth
=
8
}
-
.
rc_mode
=
VideoEncoderFactoryInterface
:
:
StaticEncoderSettings
:
:
Cqp
(
)
-
.
max_number_of_threads
=
1
}
-
{
}
)
;
-
-
std
:
:
unique_ptr
<
SimpleEncoderWrapper
>
simple_encoder
=
-
SimpleEncoderWrapper
:
:
Create
(
std
:
:
move
(
encoder
)
"
L1T3
"
)
;
-
-
ASSERT_THAT
(
simple_encoder
NotNull
(
)
)
;
-
-
simple_encoder
-
>
SetEncodeQp
(
30
)
;
-
simple_encoder
-
>
SetEncodeFps
(
15
)
;
-
auto
frame_reader
=
CreateFrameReader
(
)
;
-
-
int
num_callbacks
=
0
;
-
simple_encoder
-
>
Encode
(
-
frame_reader
-
>
PullFrame
(
)
/
*
force_keyframe
=
*
/
true
-
[
&
]
(
const
SimpleEncoderWrapper
:
:
EncodeResult
&
result
)
{
-
+
+
num_callbacks
;
-
ASSERT_THAT
(
result
.
oh_no
Eq
(
false
)
)
;
-
EXPECT_THAT
(
result
.
frame_type
Eq
(
FrameType
:
:
kKeyframe
)
)
;
-
EXPECT_THAT
(
result
.
generic_frame_info
.
temporal_id
Eq
(
0
)
)
;
-
}
)
;
-
-
simple_encoder
-
>
Encode
(
-
frame_reader
-
>
PullFrame
(
)
/
*
force_keyframe
=
*
/
false
-
[
&
]
(
const
SimpleEncoderWrapper
:
:
EncodeResult
&
result
)
{
-
+
+
num_callbacks
;
-
ASSERT_THAT
(
result
.
oh_no
Eq
(
false
)
)
;
-
EXPECT_THAT
(
result
.
frame_type
Eq
(
FrameType
:
:
kDeltaFrame
)
)
;
-
EXPECT_THAT
(
result
.
generic_frame_info
.
temporal_id
Eq
(
2
)
)
;
-
}
)
;
-
-
simple_encoder
-
>
Encode
(
-
frame_reader
-
>
PullFrame
(
)
/
*
force_keyframe
=
*
/
false
-
[
&
]
(
const
SimpleEncoderWrapper
:
:
EncodeResult
&
result
)
{
-
+
+
num_callbacks
;
-
ASSERT_THAT
(
result
.
oh_no
Eq
(
false
)
)
;
-
EXPECT_THAT
(
result
.
frame_type
Eq
(
FrameType
:
:
kDeltaFrame
)
)
;
-
EXPECT_THAT
(
result
.
generic_frame_info
.
temporal_id
Eq
(
1
)
)
;
-
}
)
;
-
-
simple_encoder
-
>
Encode
(
-
frame_reader
-
>
PullFrame
(
)
/
*
force_keyframe
=
*
/
true
-
[
&
]
(
const
SimpleEncoderWrapper
:
:
EncodeResult
&
result
)
{
-
+
+
num_callbacks
;
-
ASSERT_THAT
(
result
.
oh_no
Eq
(
false
)
)
;
-
EXPECT_THAT
(
result
.
frame_type
Eq
(
FrameType
:
:
kKeyframe
)
)
;
-
EXPECT_THAT
(
result
.
generic_frame_info
.
temporal_id
Eq
(
0
)
)
;
-
}
)
;
-
-
simple_encoder
-
>
Encode
(
-
frame_reader
-
>
PullFrame
(
)
/
*
force_keyframe
=
*
/
false
-
[
&
]
(
const
SimpleEncoderWrapper
:
:
EncodeResult
&
result
)
{
-
+
+
num_callbacks
;
-
ASSERT_THAT
(
result
.
oh_no
Eq
(
false
)
)
;
-
EXPECT_THAT
(
result
.
frame_type
Eq
(
FrameType
:
:
kDeltaFrame
)
)
;
-
EXPECT_THAT
(
result
.
generic_frame_info
.
temporal_id
Eq
(
2
)
)
;
-
}
)
;
-
-
EXPECT_THAT
(
num_callbacks
Eq
(
5
)
)
;
-
}
-
-
}
/
/
namespace
-
}
/
/
namespace
webrtc
diff
-
-
git
a
/
api
/
video_codecs
/
video_encoder_factory_interface
.
h
b
/
api
/
video_codecs
/
video_encoder_factory_interface
.
h
deleted
file
mode
100644
index
63b21d4ce0
.
.
0000000000
-
-
-
a
/
api
/
video_codecs
/
video_encoder_factory_interface
.
h
+
+
+
/
dev
/
null
-
1
104
+
0
0
-
/
*
-
*
Copyright
(
c
)
2024
The
WebRTC
project
authors
.
All
Rights
Reserved
.
-
*
-
*
Use
of
this
source
code
is
governed
by
a
BSD
-
style
license
-
*
that
can
be
found
in
the
LICENSE
file
in
the
root
of
the
source
-
*
tree
.
An
additional
intellectual
property
rights
grant
can
be
found
-
*
in
the
file
PATENTS
.
All
contributing
project
authors
may
-
*
be
found
in
the
AUTHORS
file
in
the
root
of
the
source
tree
.
-
*
/
-
-
#
ifndef
API_VIDEO_CODECS_VIDEO_ENCODER_FACTORY_INTERFACE_H_
-
#
define
API_VIDEO_CODECS_VIDEO_ENCODER_FACTORY_INTERFACE_H_
-
-
#
include
<
map
>
-
#
include
<
memory
>
-
#
include
<
set
>
-
#
include
<
string
>
-
#
include
<
utility
>
-
#
include
<
vector
>
-
-
#
include
"
absl
/
types
/
optional
.
h
"
-
#
include
"
absl
/
types
/
variant
.
h
"
-
#
include
"
api
/
units
/
time_delta
.
h
"
-
#
include
"
api
/
video
/
resolution
.
h
"
-
#
include
"
api
/
video_codecs
/
video_encoder_interface
.
h
"
-
#
include
"
api
/
video_codecs
/
video_encoding_general
.
h
"
-
#
include
"
rtc_base
/
numerics
/
rational
.
h
"
-
-
namespace
webrtc
{
-
using
FrameType
=
VideoEncoderInterface
:
:
FrameType
;
-
-
/
/
NOTE
:
This
class
is
still
under
development
and
may
change
without
notice
.
-
class
VideoEncoderFactoryInterface
{
-
public
:
-
enum
class
RateControlMode
{
kCqp
kCbr
}
;
-
-
struct
Capabilities
{
-
struct
PredictionConstraints
{
-
enum
class
BufferSpaceType
{
-
kMultiInstance
/
/
multiple
independent
sets
of
buffers
-
kMultiKeyframe
/
/
single
set
of
buffers
but
can
store
multiple
-
/
/
keyframes
simultaneously
.
-
kSingleKeyframe
/
/
single
set
of
buffers
can
only
store
one
keyframe
-
/
/
at
a
time
.
-
}
;
-
-
int
num_buffers
;
-
int
max_references
;
-
int
max_temporal_layers
;
-
-
BufferSpaceType
buffer_space_type
;
-
int
max_spatial_layers
;
-
std
:
:
vector
<
Rational
>
scaling_factors
;
-
-
std
:
:
vector
<
FrameType
>
supported_frame_types
;
-
}
prediction_constraints
;
-
-
struct
InputConstraints
{
-
Resolution
min
;
-
Resolution
max
;
-
int
pixel_alignment
;
-
std
:
:
vector
<
VideoFrameBuffer
:
:
Type
>
input_formats
;
-
}
input_constraints
;
-
-
std
:
:
vector
<
EncodingFormat
>
encoding_formats
;
-
-
struct
BitrateControl
{
-
std
:
:
pair
<
int
int
>
qp_range
;
-
std
:
:
vector
<
RateControlMode
>
rc_modes
;
-
}
rate_control
;
-
-
struct
Performance
{
-
std
:
:
pair
<
int
int
>
min_max_effort_level
;
-
}
performance
;
-
}
;
-
-
struct
StaticEncoderSettings
{
-
struct
Cqp
{
}
;
-
struct
Cbr
{
-
/
/
TD
:
Should
there
be
an
intial
buffer
size
?
-
TimeDelta
max_buffer_size
;
-
TimeDelta
target_buffer_size
;
-
}
;
-
-
Resolution
max_encode_dimensions
;
-
EncodingFormat
encoding_format
;
-
absl
:
:
variant
<
Cqp
Cbr
>
rc_mode
;
-
int
max_number_of_threads
;
-
}
;
-
-
virtual
~
VideoEncoderFactoryInterface
(
)
=
default
;
-
-
virtual
std
:
:
string
CodecName
(
)
const
=
0
;
-
virtual
std
:
:
string
ImplementationName
(
)
const
=
0
;
-
virtual
std
:
:
map
<
std
:
:
string
std
:
:
string
>
CodecSpecifics
(
)
const
=
0
;
-
-
virtual
Capabilities
GetEncoderCapabilities
(
)
const
=
0
;
-
virtual
std
:
:
unique_ptr
<
VideoEncoderInterface
>
CreateEncoder
(
-
const
StaticEncoderSettings
&
settings
-
const
std
:
:
map
<
std
:
:
string
std
:
:
string
>
&
encoder_specific_settings
)
=
0
;
-
}
;
-
-
}
/
/
namespace
webrtc
-
#
endif
/
/
API_VIDEO_CODECS_VIDEO_ENCODER_FACTORY_INTERFACE_H_
diff
-
-
git
a
/
api
/
video_codecs
/
video_encoder_interface
.
h
b
/
api
/
video_codecs
/
video_encoder_interface
.
h
deleted
file
mode
100644
index
9d0ce970ef
.
.
0000000000
-
-
-
a
/
api
/
video_codecs
/
video_encoder_interface
.
h
+
+
+
/
dev
/
null
-
1
89
+
0
0
-
/
*
-
*
Copyright
(
c
)
2023
The
WebRTC
project
authors
.
All
Rights
Reserved
.
-
*
-
*
Use
of
this
source
code
is
governed
by
a
BSD
-
style
license
-
*
that
can
be
found
in
the
LICENSE
file
in
the
root
of
the
source
-
*
tree
.
An
additional
intellectual
property
rights
grant
can
be
found
-
*
in
the
file
PATENTS
.
All
contributing
project
authors
may
-
*
be
found
in
the
AUTHORS
file
in
the
root
of
the
source
tree
.
-
*
/
-
-
#
ifndef
API_VIDEO_CODECS_VIDEO_ENCODER_INTERFACE_H_
-
#
define
API_VIDEO_CODECS_VIDEO_ENCODER_INTERFACE_H_
-
-
#
include
<
map
>
-
#
include
<
memory
>
-
/
/
#
include
<
unordered_set
>
-
#
include
<
string
>
-
#
include
<
utility
>
-
#
include
<
vector
>
-
-
#
include
"
absl
/
functional
/
any_invocable
.
h
"
-
#
include
"
absl
/
types
/
optional
.
h
"
-
#
include
"
absl
/
types
/
variant
.
h
"
-
#
include
"
api
/
units
/
data_rate
.
h
"
-
#
include
"
api
/
units
/
time_delta
.
h
"
-
#
include
"
api
/
units
/
timestamp
.
h
"
-
#
include
"
api
/
video
/
encoded_image
.
h
"
-
#
include
"
api
/
video
/
resolution
.
h
"
-
#
include
"
api
/
video
/
video_frame
.
h
"
-
#
include
"
api
/
video_codecs
/
video_codec
.
h
"
-
#
include
"
api
/
video_codecs
/
video_encoding_general
.
h
"
-
#
include
"
rtc_base
/
numerics
/
rational
.
h
"
-
-
namespace
webrtc
{
-
/
/
NOTE
:
This
class
is
still
under
development
and
may
change
without
notice
.
-
class
VideoEncoderInterface
{
-
public
:
-
virtual
~
VideoEncoderInterface
(
)
=
default
;
-
enum
class
FrameType
{
kKeyframe
kStartFrame
kDeltaFrame
}
;
-
-
struct
TemporalUnitSettings
{
-
VideoCodecMode
content_hint
=
VideoCodecMode
:
:
kRealtimeVideo
;
-
Timestamp
presentation_timestamp
;
-
int
effort_level
=
0
;
-
}
;
-
-
struct
FrameEncodeSettings
{
-
struct
Cbr
{
-
TimeDelta
duration
;
-
DataRate
target_bitrate
;
-
}
;
-
-
struct
Cqp
{
-
int
target_qp
;
-
}
;
-
-
absl
:
:
variant
<
Cqp
Cbr
>
rate_options
;
-
-
FrameType
frame_type
=
FrameType
:
:
kDeltaFrame
;
-
int
temporal_id
=
0
;
-
int
spatial_id
=
0
;
-
Resolution
resolution
;
-
std
:
:
vector
<
int
>
reference_buffers
;
-
absl
:
:
optional
<
int
>
update_buffer
;
-
}
;
-
-
/
/
Results
from
calling
Encode
.
Called
once
for
each
configured
frame
.
-
struct
EncodingError
{
}
;
-
-
struct
EncodedData
{
-
rtc
:
:
scoped_refptr
<
EncodedImageBufferInterface
>
bitstream_data
;
-
FrameType
frame_type
;
-
int
spatial_id
;
-
int
encoded_qp
;
-
std
:
:
vector
<
int
>
referenced_buffers
;
-
}
;
-
-
using
EncodeResult
=
std
:
:
variant
<
EncodingError
EncodedData
>
;
-
using
EncodeResultCallback
=
-
absl
:
:
AnyInvocable
<
void
(
const
EncodeResult
&
result
)
>
;
-
-
virtual
void
Encode
(
rtc
:
:
scoped_refptr
<
webrtc
:
:
VideoFrameBuffer
>
frame_buffer
-
const
TemporalUnitSettings
&
settings
-
const
std
:
:
vector
<
FrameEncodeSettings
>
&
frame_settings
-
EncodeResultCallback
encode_result_callback
)
=
0
;
-
}
;
-
-
}
/
/
namespace
webrtc
-
#
endif
/
/
API_VIDEO_CODECS_VIDEO_ENCODER_INTERFACE_H_
diff
-
-
git
a
/
api
/
video_codecs
/
video_encoding_general
.
h
b
/
api
/
video_codecs
/
video_encoding_general
.
h
deleted
file
mode
100644
index
171e211dba
.
.
0000000000
-
-
-
a
/
api
/
video_codecs
/
video_encoding_general
.
h
+
+
+
/
dev
/
null
-
1
23
+
0
0
-
/
*
-
*
Copyright
(
c
)
2023
The
WebRTC
project
authors
.
All
Rights
Reserved
.
-
*
-
*
Use
of
this
source
code
is
governed
by
a
BSD
-
style
license
-
*
that
can
be
found
in
the
LICENSE
file
in
the
root
of
the
source
-
*
tree
.
An
additional
intellectual
property
rights
grant
can
be
found
-
*
in
the
file
PATENTS
.
All
contributing
project
authors
may
-
*
be
found
in
the
AUTHORS
file
in
the
root
of
the
source
tree
.
-
*
/
-
-
#
ifndef
API_VIDEO_CODECS_VIDEO_ENCODING_GENERAL_H_
-
#
define
API_VIDEO_CODECS_VIDEO_ENCODING_GENERAL_H_
-
-
namespace
webrtc
{
-
-
struct
EncodingFormat
{
-
enum
SubSampling
{
k420
k422
k444
}
;
-
SubSampling
sub_sampling
;
-
int
bit_depth
;
-
}
;
-
-
}
/
/
namespace
webrtc
-
#
endif
/
/
API_VIDEO_CODECS_VIDEO_ENCODING_GENERAL_H_
diff
-
-
git
a
/
rtc_base
/
BUILD
.
gn
b
/
rtc_base
/
BUILD
.
gn
index
e69931d4ac
.
.
6d52046ca0
100644
-
-
-
a
/
rtc_base
/
BUILD
.
gn
+
+
+
b
/
rtc_base
/
BUILD
.
gn
-
806
7
+
806
6
rtc_library
(
"
rtc_numerics
"
)
{
"
numerics
/
moving_average
.
h
"
"
numerics
/
moving_percentile_filter
.
h
"
"
numerics
/
percentile_filter
.
h
"
-
"
numerics
/
rational
.
h
"
"
numerics
/
running_statistics
.
h
"
"
numerics
/
sequence_number_unwrapper
.
h
"
"
numerics
/
sequence_number_util
.
h
"
diff
-
-
git
a
/
rtc_base
/
numerics
/
rational
.
h
b
/
rtc_base
/
numerics
/
rational
.
h
deleted
file
mode
100644
index
32f0cb1597
.
.
0000000000
-
-
-
a
/
rtc_base
/
numerics
/
rational
.
h
+
+
+
/
dev
/
null
-
1
28
+
0
0
-
/
*
-
*
Copyright
2024
The
WebRTC
Project
Authors
.
All
rights
reserved
.
-
*
-
*
Use
of
this
source
code
is
governed
by
a
BSD
-
style
license
-
*
that
can
be
found
in
the
LICENSE
file
in
the
root
of
the
source
-
*
tree
.
An
additional
intellectual
property
rights
grant
can
be
found
-
*
in
the
file
PATENTS
.
All
contributing
project
authors
may
-
*
be
found
in
the
AUTHORS
file
in
the
root
of
the
source
tree
.
-
*
/
-
-
#
ifndef
RTC_BASE_NUMERICS_RATIONAL_H_
-
#
define
RTC_BASE_NUMERICS_RATIONAL_H_
-
-
namespace
webrtc
{
-
-
/
/
This
is
the
worst
implementation
of
a
rational
.
.
.
-
struct
Rational
{
-
int
numerator
;
-
int
denominator
;
-
-
bool
operator
=
=
(
const
Rational
&
other
)
const
{
-
return
numerator
=
=
other
.
numerator
&
&
denominator
=
=
other
.
denominator
;
-
}
-
}
;
-
-
}
/
/
namespace
webrtc
-
-
#
endif
/
/
RTC_BASE_NUMERICS_RATIONAL_H_
