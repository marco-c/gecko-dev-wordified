From
:
Daniel
Baker
<
dbaker
mozilla
.
com
>
Date
:
Mon
27
Oct
2025
16
:
59
:
03
-
0600
Subject
:
(
tmp
-
cherry
-
pick
)
Revert
"
Propagate
clock
into
BasicIceController
"
(
0bac8c3d11
)
This
reverts
commit
16b12af18f5cc9f5d16f4c8e5372c6d31a81948e
.
Reason
for
revert
:
breaks
roll
into
chromium
Bug
:
webrtc
:
42223992
Original
change
'
s
description
:
>
Propagate
clock
into
BasicIceController
>
>
Bug
:
webrtc
:
42223992
>
Change
-
Id
:
I15e4d1a8c692e8a04f50d0f0b51cabecc584b0ab
>
Reviewed
-
on
:
https
:
/
/
webrtc
-
review
.
googlesource
.
com
/
c
/
src
/
+
/
407100
>
Reviewed
-
by
:
Per
Kjellander
<
perkj
webrtc
.
org
>
>
Commit
-
Queue
:
Danil
Chapovalov
<
danilchap
webrtc
.
org
>
>
Cr
-
Commit
-
Position
:
refs
/
heads
/
main
{
#
45508
}
Bug
:
webrtc
:
42223992
No
-
Presubmit
:
true
No
-
Tree
-
Checks
:
true
No
-
Try
:
true
Change
-
Id
:
I4de8a8541b8f54ad1d7783febcdf74ef189c967e
Reviewed
-
on
:
https
:
/
/
webrtc
-
review
.
googlesource
.
com
/
c
/
src
/
+
/
407421
Commit
-
Queue
:
Harald
Alvestrand
<
hta
webrtc
.
org
>
Auto
-
Submit
:
Danil
Chapovalov
<
danilchap
webrtc
.
org
>
Reviewed
-
by
:
Harald
Alvestrand
<
hta
webrtc
.
org
>
Cr
-
Commit
-
Position
:
refs
/
heads
/
main
{
#
45518
}
-
-
-
p2p
/
BUILD
.
gn
|
4
-
-
p2p
/
base
/
basic_ice_controller
.
cc
|
67
+
+
+
+
+
+
+
+
+
-
-
-
-
-
-
-
-
-
-
p2p
/
base
/
basic_ice_controller
.
h
|
16
+
+
-
-
-
p2p
/
base
/
ice_controller_factory_interface
.
h
|
2
-
p2p
/
base
/
p2p_transport_channel
.
cc
|
1
-
.
.
.
wrapping_active_ice_controller_unittest
.
cc
|
38
+
+
+
+
+
+
+
-
-
-
-
6
files
changed
61
insertions
(
+
)
67
deletions
(
-
)
diff
-
-
git
a
/
p2p
/
BUILD
.
gn
b
/
p2p
/
BUILD
.
gn
index
2baa0e2339
.
.
ba483b710e
100644
-
-
-
a
/
p2p
/
BUILD
.
gn
+
+
+
b
/
p2p
/
BUILD
.
gn
-
81
10
+
81
7
rtc_library
(
"
basic_ice_controller
"
)
{
"
:
transport_description
"
"
.
.
/
api
:
array_view
"
"
.
.
/
api
:
candidate
"
-
"
.
.
/
api
/
environment
"
"
.
.
/
api
/
transport
:
enums
"
-
"
.
.
/
api
/
units
:
time_delta
"
-
"
.
.
/
api
/
units
:
timestamp
"
"
.
.
/
rtc_base
:
checks
"
"
.
.
/
rtc_base
:
ip_address
"
"
.
.
/
rtc_base
:
logging
"
-
389
7
+
386
6
rtc_source_set
(
"
ice_controller_factory_interface
"
)
{
"
:
ice_transport_internal
"
"
:
p2p_transport_channel_ice_field_trials
"
"
:
transport_description
"
-
"
.
.
/
api
/
environment
"
]
}
diff
-
-
git
a
/
p2p
/
base
/
basic_ice_controller
.
cc
b
/
p2p
/
base
/
basic_ice_controller
.
cc
index
8da13f52ae
.
.
ca8f8266ab
100644
-
-
-
a
/
p2p
/
base
/
basic_ice_controller
.
cc
+
+
+
b
/
p2p
/
base
/
basic_ice_controller
.
cc
-
22
8
+
22
6
#
include
"
absl
/
algorithm
/
container
.
h
"
#
include
"
api
/
candidate
.
h
"
#
include
"
api
/
transport
/
enums
.
h
"
-
#
include
"
api
/
units
/
time_delta
.
h
"
-
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
p2p
/
base
/
connection
.
h
"
#
include
"
p2p
/
base
/
connection_info
.
h
"
#
include
"
p2p
/
base
/
ice_controller_factory_interface
.
h
"
-
38
6
+
36
7
#
include
"
rtc_base
/
net_helper
.
h
"
#
include
"
rtc_base
/
network
.
h
"
#
include
"
rtc_base
/
network_constants
.
h
"
+
#
include
"
rtc_base
/
time_utils
.
h
"
namespace
{
-
87
8
+
86
7
int
CompareCandidatePairsByNetworkPreference
(
namespace
webrtc
{
BasicIceController
:
:
BasicIceController
(
const
IceControllerFactoryArgs
&
args
)
-
:
env_
(
args
.
env
)
-
ice_transport_state_func_
(
args
.
ice_transport_state_func
)
+
:
ice_transport_state_func_
(
args
.
ice_transport_state_func
)
ice_role_func_
(
args
.
ice_role_func
)
is_connection_pruned_func_
(
args
.
is_connection_pruned_func
)
field_trials_
(
args
.
ice_field_trials
)
{
}
-
118
7
+
116
7
void
BasicIceController
:
:
OnConnectionDestroyed
(
const
Connection
*
connection
)
{
}
bool
BasicIceController
:
:
HasPingableConnection
(
)
const
{
-
Timestamp
now
=
Connection
:
:
AlignTime
(
env_
.
clock
(
)
.
CurrentTime
(
)
)
;
+
int64_t
now
=
TimeMillis
(
)
;
return
absl
:
:
c_any_of
(
connections_
[
this
now
]
(
const
Connection
*
c
)
{
return
IsPingable
(
c
now
)
;
}
)
;
-
139
8
+
137
7
IceControllerInterface
:
:
PingResult
BasicIceController
:
:
SelectConnectionToPing
(
:
strong_ping_interval
(
)
;
const
Connection
*
conn
=
nullptr
;
-
if
(
Connection
:
:
AlignTime
(
env_
.
clock
(
)
.
CurrentTime
(
)
)
.
ms
(
)
>
=
-
last_ping_sent_ms
+
ping_interval
)
{
+
if
(
TimeMillis
(
)
>
=
last_ping_sent_ms
+
ping_interval
)
{
conn
=
FindNextPingableConnection
(
)
;
}
PingResult
res
(
conn
std
:
:
min
(
ping_interval
check_receiving_interval
(
)
)
)
;
-
155
7
+
152
7
void
BasicIceController
:
:
MarkConnectionPinged
(
const
Connection
*
conn
)
{
/
/
Returns
the
next
pingable
connection
to
ping
.
const
Connection
*
BasicIceController
:
:
FindNextPingableConnection
(
)
{
-
Timestamp
now
=
Connection
:
:
AlignTime
(
env_
.
clock
(
)
.
CurrentTime
(
)
)
;
+
int64_t
now
=
TimeMillis
(
)
;
/
/
Rule
1
:
Selected
connection
takes
priority
over
non
-
selected
ones
.
if
(
selected_connection_
&
&
selected_connection_
-
>
connected
(
)
&
&
-
241
7
+
238
7
const
Connection
*
BasicIceController
:
:
FindNextPingableConnection
(
)
{
/
/
(
last_ping_received
>
last_ping_sent
)
.
But
we
shouldn
'
t
do
/
/
triggered
checks
if
the
connection
is
already
writable
.
const
Connection
*
BasicIceController
:
:
FindOldestConnectionNeedingTriggeredCheck
(
-
Timestamp
now
)
{
+
int64_t
now
)
{
const
Connection
*
oldest_needing_triggered_check
=
nullptr
;
for
(
auto
*
conn
:
connections_
)
{
if
(
!
IsPingable
(
conn
now
)
)
{
-
267
24
+
264
24
const
Connection
*
BasicIceController
:
:
FindOldestConnectionNeedingTriggeredCheck
(
bool
BasicIceController
:
:
WritableConnectionPastPingInterval
(
const
Connection
*
conn
-
Timestamp
now
)
const
{
-
TimeDelta
interval
=
CalculateActiveWritablePingInterval
(
conn
now
)
;
-
return
conn
-
>
LastPingSent
(
)
+
interval
<
=
now
;
+
int64_t
now
)
const
{
+
int
interval
=
CalculateActiveWritablePingInterval
(
conn
now
)
;
+
return
conn
-
>
last_ping_sent
(
)
+
interval
<
=
now
;
}
-
TimeDelta
BasicIceController
:
:
CalculateActiveWritablePingInterval
(
+
int
BasicIceController
:
:
CalculateActiveWritablePingInterval
(
const
Connection
*
conn
-
Timestamp
now
)
const
{
+
int64_t
now
)
const
{
/
/
Ping
each
connection
at
a
higher
rate
at
least
/
/
MIN_PINGS_AT_WEAK_PING_INTERVAL
times
.
if
(
conn
-
>
num_pings_sent
(
)
<
MIN_PINGS_AT_WEAK_PING_INTERVAL
)
{
-
return
TimeDelta
:
:
Millis
(
weak_ping_interval
(
)
)
;
+
return
weak_ping_interval
(
)
;
}
-
TimeDelta
stable_interval
=
TimeDelta
:
:
Millis
(
-
config_
.
stable_writable_connection_ping_interval_or_default
(
)
)
;
-
TimeDelta
weak_or_stablizing_interval
=
std
:
:
min
(
-
stable_interval
kWeakOrStabilizingWritableConnectionPingInterval
)
;
+
int
stable_interval
=
+
config_
.
stable_writable_connection_ping_interval_or_default
(
)
;
+
int
weak_or_stablizing_interval
=
std
:
:
min
(
+
stable_interval
WEAK_OR_STABILIZING_WRITABLE_CONNECTION_PING_INTERVAL
)
;
/
/
If
the
channel
is
weak
or
the
connection
is
not
stable
yet
use
the
/
/
weak_or_stablizing_interval
.
return
(
!
weak
(
)
&
&
conn
-
>
stable
(
now
)
)
?
stable_interval
-
294
8
+
291
7
TimeDelta
BasicIceController
:
:
CalculateActiveWritablePingInterval
(
/
/
Is
the
connection
in
a
state
for
us
to
even
consider
pinging
the
other
side
?
/
/
We
consider
a
connection
pingable
even
if
it
'
s
not
connected
because
that
'
s
/
/
how
a
TCP
connection
is
kicked
into
reconnecting
on
the
active
side
.
-
bool
BasicIceController
:
:
IsPingable
(
const
Connection
*
conn
-
Timestamp
now
)
const
{
+
bool
BasicIceController
:
:
IsPingable
(
const
Connection
*
conn
int64_t
now
)
const
{
const
Candidate
&
remote
=
conn
-
>
remote_candidate
(
)
;
/
/
We
should
never
get
this
far
with
an
empty
remote
ufrag
.
RTC_DCHECK
(
!
remote
.
username
(
)
.
empty
(
)
)
;
-
331
10
+
327
8
bool
BasicIceController
:
:
IsPingable
(
const
Connection
*
conn
/
/
or
not
but
backup
connections
are
pinged
at
a
slower
rate
.
if
(
IsBackupConnection
(
conn
)
)
{
return
conn
-
>
rtt_samples
(
)
=
=
0
|
|
-
(
now
>
=
-
conn
-
>
LastPingResponseReceived
(
)
+
-
TimeDelta
:
:
Millis
(
-
config_
.
backup_connection_ping_interval_or_default
(
)
)
)
;
+
(
now
>
=
conn
-
>
last_ping_response_received
(
)
+
+
config_
.
backup_connection_ping_interval_or_default
(
)
)
;
}
/
/
Don
'
t
ping
inactive
non
-
backup
connections
.
if
(
!
conn
-
>
active
(
)
)
{
-
458
7
+
452
7
BasicIceController
:
:
HandleInitialSelectDampening
(
return
{
.
connection
=
new_connection
}
;
}
-
Timestamp
now
=
Connection
:
:
AlignTime
(
env_
.
clock
(
)
.
CurrentTime
(
)
)
;
+
int64_t
now
=
TimeMillis
(
)
;
int64_t
max_delay
=
0
;
if
(
new_connection
-
>
last_ping_received
(
)
>
0
&
&
field_trials_
-
>
initial_select_dampening_ping_received
.
has_value
(
)
)
{
-
467
24
+
461
26
BasicIceController
:
:
HandleInitialSelectDampening
(
max_delay
=
*
field_trials_
-
>
initial_select_dampening
;
}
-
Timestamp
start_wait
=
initial_select_timestamp_
.
value_or
(
now
)
;
-
Timestamp
max_wait_until
=
start_wait
+
TimeDelta
:
:
Millis
(
max_delay
)
;
+
int64_t
start_wait
=
+
initial_select_timestamp_ms_
=
=
0
?
now
:
initial_select_timestamp_ms_
;
+
int64_t
max_wait_until
=
start_wait
+
max_delay
;
if
(
now
>
=
max_wait_until
)
{
RTC_LOG
(
LS_INFO
)
<
<
"
reset
initial_select_timestamp_
=
"
-
<
<
initial_select_timestamp_
.
value_or
(
Timestamp
:
:
Zero
(
)
)
-
<
<
"
selection
delayed
by
:
"
<
<
(
now
-
start_wait
)
;
-
initial_select_timestamp_
=
std
:
:
nullopt
;
+
<
<
initial_select_timestamp_ms_
+
<
<
"
selection
delayed
by
:
"
<
<
(
now
-
start_wait
)
<
<
"
ms
"
;
+
initial_select_timestamp_ms_
=
0
;
return
{
.
connection
=
new_connection
}
;
}
/
/
We
are
not
yet
ready
to
select
first
connection
.
.
.
-
if
(
!
initial_select_timestamp_
.
has_value
(
)
)
{
+
if
(
initial_select_timestamp_ms_
=
=
0
)
{
/
/
Set
timestamp
on
first
time
.
.
.
/
/
but
run
the
delayed
invokation
everytime
to
/
/
avoid
possibility
that
we
miss
it
.
-
initial_select_timestamp_
=
now
;
-
RTC_LOG
(
LS_INFO
)
<
<
"
set
initial_select_timestamp_
=
"
<
<
now
;
+
initial_select_timestamp_ms_
=
now
;
+
RTC_LOG
(
LS_INFO
)
<
<
"
set
initial_select_timestamp_ms_
=
"
+
<
<
initial_select_timestamp_ms_
;
}
int
min_delay
=
max_delay
;
-
523
8
+
519
7
IceControllerInterface
:
:
SwitchResult
BasicIceController
:
:
ShouldSwitchConnection
(
bool
missed_receiving_unchanged_threshold
=
false
;
std
:
:
optional
<
int64_t
>
receiving_unchanged_threshold
(
-
Connection
:
:
AlignTime
(
env_
.
clock
(
)
.
CurrentTime
(
)
)
.
ms
(
)
-
-
config_
.
receiving_switching_delay_or_default
(
)
)
;
+
TimeMillis
(
)
-
config_
.
receiving_switching_delay_or_default
(
)
)
;
int
cmp
=
CompareConnections
(
selected_connection_
new_connection
receiving_unchanged_threshold
&
missed_receiving_unchanged_threshold
)
;
diff
-
-
git
a
/
p2p
/
base
/
basic_ice_controller
.
h
b
/
p2p
/
base
/
basic_ice_controller
.
h
index
66a0402f5f
.
.
b2aa3c3cee
100644
-
-
-
a
/
p2p
/
base
/
basic_ice_controller
.
h
+
+
+
b
/
p2p
/
base
/
basic_ice_controller
.
h
-
20
9
+
20
6
#
include
<
vector
>
#
include
"
api
/
array_view
.
h
"
-
#
include
"
api
/
environment
/
environment
.
h
"
-
#
include
"
api
/
units
/
time_delta
.
h
"
-
#
include
"
api
/
units
/
timestamp
.
h
"
#
include
"
p2p
/
base
/
connection
.
h
"
#
include
"
p2p
/
base
/
ice_controller_factory_interface
.
h
"
#
include
"
p2p
/
base
/
ice_controller_interface
.
h
"
-
94
7
+
91
7
class
BasicIceController
:
public
IceControllerInterface
{
config_
.
receiving_timeout_or_default
(
)
/
10
)
;
}
-
const
Connection
*
FindOldestConnectionNeedingTriggeredCheck
(
Timestamp
now
)
;
+
const
Connection
*
FindOldestConnectionNeedingTriggeredCheck
(
int64_t
now
)
;
/
/
Between
conn1
and
conn2
this
function
returns
the
one
which
should
/
/
be
pinged
first
.
const
Connection
*
MorePingable
(
const
Connection
*
conn1
-
107
14
+
104
14
class
BasicIceController
:
public
IceControllerInterface
{
const
Connection
*
LeastRecentlyPinged
(
const
Connection
*
conn1
const
Connection
*
conn2
)
;
-
bool
IsPingable
(
const
Connection
*
conn
Timestamp
now
)
const
;
+
bool
IsPingable
(
const
Connection
*
conn
int64_t
now
)
const
;
bool
IsBackupConnection
(
const
Connection
*
conn
)
const
;
/
/
Whether
a
writable
connection
is
past
its
ping
interval
and
needs
to
be
/
/
pinged
again
.
bool
WritableConnectionPastPingInterval
(
const
Connection
*
conn
-
Timestamp
now
)
const
;
-
TimeDelta
CalculateActiveWritablePingInterval
(
const
Connection
*
conn
-
Timestamp
now
)
const
;
+
int64_t
now
)
const
;
+
int
CalculateActiveWritablePingInterval
(
const
Connection
*
conn
+
int64_t
now
)
const
;
std
:
:
map
<
const
Network
*
const
Connection
*
>
GetBestConnectionByNetwork
(
)
const
;
-
155
7
+
152
6
class
BasicIceController
:
public
IceControllerInterface
{
SwitchResult
HandleInitialSelectDampening
(
IceSwitchReason
reason
const
Connection
*
new_connection
)
;
-
const
Environment
env_
;
std
:
:
function
<
IceTransportStateInternal
(
)
>
ice_transport_state_func_
;
std
:
:
function
<
IceRole
(
)
>
ice_role_func_
;
std
:
:
function
<
bool
(
const
Connection
*
)
>
is_connection_pruned_func_
;
-
174
7
+
170
7
class
BasicIceController
:
public
IceControllerInterface
{
std
:
:
set
<
const
Connection
*
>
unpinged_connections_
;
/
/
Timestamp
for
when
we
got
the
first
selectable
connection
.
-
std
:
:
optional
<
Timestamp
>
initial_select_timestamp_
;
+
int64_t
initial_select_timestamp_ms_
=
0
;
}
;
}
/
/
namespace
webrtc
diff
-
-
git
a
/
p2p
/
base
/
ice_controller_factory_interface
.
h
b
/
p2p
/
base
/
ice_controller_factory_interface
.
h
index
966d3e3542
.
.
2f8754e3aa
100644
-
-
-
a
/
p2p
/
base
/
ice_controller_factory_interface
.
h
+
+
+
b
/
p2p
/
base
/
ice_controller_factory_interface
.
h
-
15
7
+
15
6
#
include
<
memory
>
#
include
<
string
>
-
#
include
"
api
/
environment
/
environment
.
h
"
#
include
"
p2p
/
base
/
connection
.
h
"
#
include
"
p2p
/
base
/
ice_controller_interface
.
h
"
#
include
"
p2p
/
base
/
ice_transport_internal
.
h
"
-
26
7
+
25
6
namespace
webrtc
{
/
/
struct
with
arguments
to
IceControllerFactoryInterface
:
:
Create
struct
IceControllerFactoryArgs
{
-
Environment
env
;
std
:
:
function
<
IceTransportStateInternal
(
)
>
ice_transport_state_func
;
std
:
:
function
<
IceRole
(
)
>
ice_role_func
;
std
:
:
function
<
bool
(
const
Connection
*
)
>
is_connection_pruned_func
;
diff
-
-
git
a
/
p2p
/
base
/
p2p_transport_channel
.
cc
b
/
p2p
/
base
/
p2p_transport_channel
.
cc
index
82d854fe1d
.
.
eee1092080
100644
-
-
-
a
/
p2p
/
base
/
p2p_transport_channel
.
cc
+
+
+
b
/
p2p
/
base
/
p2p_transport_channel
.
cc
-
215
7
+
215
6
P2PTransportChannel
:
:
P2PTransportChannel
(
ParseFieldTrials
(
env_
.
field_trials
(
)
)
;
IceControllerFactoryArgs
args
{
-
.
env
=
env_
.
ice_transport_state_func
=
[
this
]
{
return
GetState
(
)
;
}
.
ice_role_func
=
[
this
]
{
return
GetIceRole
(
)
;
}
.
is_connection_pruned_func
=
diff
-
-
git
a
/
p2p
/
base
/
wrapping_active_ice_controller_unittest
.
cc
b
/
p2p
/
base
/
wrapping_active_ice_controller_unittest
.
cc
index
8b5601358b
.
.
074f3b6474
100644
-
-
-
a
/
p2p
/
base
/
wrapping_active_ice_controller_unittest
.
cc
+
+
+
b
/
p2p
/
base
/
wrapping_active_ice_controller_unittest
.
cc
-
26
13
+
26
24
#
include
"
rtc_base
/
event
.
h
"
#
include
"
rtc_base
/
fake_clock
.
h
"
#
include
"
rtc_base
/
thread
.
h
"
-
#
include
"
test
/
create_test_environment
.
h
"
#
include
"
test
/
gmock
.
h
"
#
include
"
test
/
gtest
.
h
"
-
namespace
webrtc
{
namespace
{
+
using
:
:
webrtc
:
:
Connection
;
+
using
:
:
webrtc
:
:
IceConfig
;
+
using
:
:
webrtc
:
:
IceControllerFactoryArgs
;
+
using
:
:
webrtc
:
:
IceControllerInterface
;
+
using
:
:
webrtc
:
:
IceMode
;
+
using
:
:
webrtc
:
:
IceRecheckEvent
;
+
using
:
:
webrtc
:
:
IceSwitchReason
;
+
using
:
:
webrtc
:
:
MockIceAgent
;
+
using
:
:
webrtc
:
:
MockIceController
;
+
using
:
:
webrtc
:
:
MockIceControllerFactory
;
+
using
:
:
webrtc
:
:
NominationMode
;
+
using
:
:
webrtc
:
:
WrappingActiveIceController
;
+
using
:
:
testing
:
:
_
;
using
:
:
testing
:
:
ElementsAreArray
;
using
:
:
testing
:
:
IsEmpty
;
-
41
6
+
52
11
using
:
:
testing
:
:
Ref
;
using
:
:
testing
:
:
Return
;
using
:
:
testing
:
:
Sequence
;
+
using
:
:
webrtc
:
:
AutoThread
;
+
using
:
:
webrtc
:
:
Event
;
+
using
:
:
webrtc
:
:
ScopedFakeClock
;
+
using
:
:
webrtc
:
:
TimeDelta
;
+
using
NiceMockIceController
=
NiceMock
<
MockIceController
>
;
const
Connection
*
kConnection
=
reinterpret_cast
<
const
Connection
*
>
(
0xabcd
)
;
-
56
7
+
72
7
constexpr
TimeDelta
kTick
=
TimeDelta
:
:
Millis
(
1
)
;
TEST
(
WrappingActiveIceControllerTest
CreateLegacyIceControllerFromFactory
)
{
AutoThread
main
;
MockIceAgent
agent
;
-
IceControllerFactoryArgs
args
=
{
.
env
=
CreateTestEnvironment
(
)
}
;
+
IceControllerFactoryArgs
args
;
MockIceControllerFactory
legacy_controller_factory
;
EXPECT_CALL
(
legacy_controller_factory
RecordIceControllerCreated
(
)
)
.
Times
(
1
)
;
WrappingActiveIceController
controller
(
&
agent
&
legacy_controller_factory
-
67
8
+
83
7
TEST
(
WrappingActiveIceControllerTest
PassthroughIceControllerInterface
)
{
AutoThread
main
;
MockIceAgent
agent
;
std
:
:
unique_ptr
<
MockIceController
>
will_move
=
-
std
:
:
make_unique
<
MockIceController
>
(
-
IceControllerFactoryArgs
{
.
env
=
CreateTestEnvironment
(
)
}
)
;
+
std
:
:
make_unique
<
MockIceController
>
(
IceControllerFactoryArgs
{
}
)
;
MockIceController
*
wrapped
=
will_move
.
get
(
)
;
WrappingActiveIceController
controller
(
&
agent
std
:
:
move
(
will_move
)
)
;
-
105
8
+
120
7
TEST
(
WrappingActiveIceControllerTest
HandlesImmediateSwitchRequest
)
{
ScopedFakeClock
clock
;
NiceMock
<
MockIceAgent
>
agent
;
std
:
:
unique_ptr
<
NiceMockIceController
>
will_move
=
-
std
:
:
make_unique
<
NiceMockIceController
>
(
-
IceControllerFactoryArgs
{
.
env
=
CreateTestEnvironment
(
)
}
)
;
+
std
:
:
make_unique
<
NiceMockIceController
>
(
IceControllerFactoryArgs
{
}
)
;
NiceMockIceController
*
wrapped
=
will_move
.
get
(
)
;
WrappingActiveIceController
controller
(
&
agent
std
:
:
move
(
will_move
)
)
;
-
151
8
+
165
7
TEST
(
WrappingActiveIceControllerTest
HandlesImmediateSortAndSwitchRequest
)
{
ScopedFakeClock
clock
;
NiceMock
<
MockIceAgent
>
agent
;
std
:
:
unique_ptr
<
NiceMockIceController
>
will_move
=
-
std
:
:
make_unique
<
NiceMockIceController
>
(
-
IceControllerFactoryArgs
{
.
env
=
CreateTestEnvironment
(
)
}
)
;
+
std
:
:
make_unique
<
NiceMockIceController
>
(
IceControllerFactoryArgs
{
}
)
;
NiceMockIceController
*
wrapped
=
will_move
.
get
(
)
;
WrappingActiveIceController
controller
(
&
agent
std
:
:
move
(
will_move
)
)
;
-
210
8
+
223
7
TEST
(
WrappingActiveIceControllerTest
HandlesSortAndSwitchRequest
)
{
NiceMock
<
MockIceAgent
>
agent
;
std
:
:
unique_ptr
<
NiceMockIceController
>
will_move
=
-
std
:
:
make_unique
<
NiceMockIceController
>
(
-
IceControllerFactoryArgs
{
.
env
=
CreateTestEnvironment
(
)
}
)
;
+
std
:
:
make_unique
<
NiceMockIceController
>
(
IceControllerFactoryArgs
{
}
)
;
NiceMockIceController
*
wrapped
=
will_move
.
get
(
)
;
WrappingActiveIceController
controller
(
&
agent
std
:
:
move
(
will_move
)
)
;
-
256
8
+
268
7
TEST
(
WrappingActiveIceControllerTest
StartPingingAfterSortAndSwitch
)
{
NiceMock
<
MockIceAgent
>
agent
;
std
:
:
unique_ptr
<
NiceMockIceController
>
will_move
=
-
std
:
:
make_unique
<
NiceMockIceController
>
(
-
IceControllerFactoryArgs
{
.
env
=
CreateTestEnvironment
(
)
}
)
;
+
std
:
:
make_unique
<
NiceMockIceController
>
(
IceControllerFactoryArgs
{
}
)
;
NiceMockIceController
*
wrapped
=
will_move
.
get
(
)
;
WrappingActiveIceController
controller
(
&
agent
std
:
:
move
(
will_move
)
)
;
-
308
4
+
319
3
TEST
(
WrappingActiveIceControllerTest
StartPingingAfterSortAndSwitch
)
{
}
}
/
/
namespace
-
}
/
/
namespace
webrtc
