cdocutils
.
nodes
document
q
)
q
}
q
(
U
nametypesq
}
q
(
X
mock
.
patchq
X
&
patching
descriptors
and
proxy
objectsq
NX
where
-
to
-
patchq
X
mock
.
patch
.
stopallq
X
django
setttings
objectq
X
mock
.
patch
.
multipleq
X
nesting
patch
decoratorsq
NX
mock
.
patch
.
objectq
X
patch
.
dictq
NX
test_prefixq
NX
patch
decoratorsq
NX
patch
methods
:
start
and
stopq
NX
patchq
NX
patch
.
objectq
NX
patch
.
multipleq
NX
where
to
patchq
NX
mock
.
patch
.
dictq
X
unittest2q
X
start
-
and
-
stopq
uU
substitution_defsq
}
q
U
parse_messagesq
]
q
U
current_sourceq
NU
decorationq
NU
autofootnote_startq
K
U
nameidsq
}
q
!
(
h
h
h
U
&
patching
-
descriptors
-
and
-
proxy
-
objectsq
"
h
U
where
-
to
-
patchq
#
h
h
h
U
django
-
setttings
-
objectq
h
h
h
U
nesting
-
patch
-
decoratorsq
%
h
h
h
U
patch
-
dictq
&
h
U
test
-
prefixq
'
h
U
patch
-
decoratorsq
(
h
U
patch
-
methods
-
start
-
and
-
stopq
)
h
U
patchq
*
h
U
patch
-
objectq
+
h
U
patch
-
multipleq
h
U
id1q
-
h
h
h
U
unittest2q
.
h
U
start
-
and
-
stopq
/
uU
childrenq0
]
q1cdocutils
.
nodes
section
q2
)
q3
}
q4
(
U
rawsourceq5U
U
parentq6h
U
sourceq7cdocutils
.
nodes
reprunicode
q8X
/
compile
/
mock
/
docs
/
patch
.
txtq9
q
:
}
q
;
bU
tagnameq
<
U
sectionq
=
U
attributesq
>
}
q
?
(
U
dupnamesq
]
qAU
classesqB
]
qCU
backrefsqD
]
qEU
idsqF
]
qGh
(
aU
namesqH
]
qIh
auU
lineqJK
U
documentqKh
h0
]
qL
(
cdocutils
.
nodes
title
qM
)
qN
}
qO
(
h5X
Patch
DecoratorsqPh6h3h7h
:
h
<
U
titleqQh
>
}
qR
(
h
]
qShB
]
qThD
]
qUhF
]
qVhH
]
qWuhJK
hKh
h0
]
qXcdocutils
.
nodes
Text
qYX
Patch
DecoratorsqZ
q
[
}
q
\
(
h5hPh6hNubaubcdocutils
.
nodes
comment
q
]
)
q
^
}
q_
(
h5X
class
SomeClass
(
object
)
:
static_method
=
None
class_method
=
None
attribute
=
None
sys
.
modules
[
'
package
'
]
=
package
=
Mock
(
name
=
'
package
'
)
sys
.
modules
[
'
package
.
module
'
]
=
package
.
module
class
TestCase
(
unittest2
.
TestCase
)
:
def
run
(
self
)
:
result
=
unittest2
.
TestResult
(
)
super
(
unittest2
.
TestCase
self
)
.
run
(
result
)
assert
result
.
wasSuccessful
(
)
q
h6h3h7h
:
h
<
U
commentqah
>
}
qb
(
U
testnodetypeqcX
testsetupqdU
xml
:
spaceqeU
preserveqfhF
]
qghD
]
qhh
]
qihB
]
qjhH
]
qkU
groupsql
]
qmU
defaultqnaU
optionsqo
}
qpuhJK
hKh
h0
]
qqhYX
class
SomeClass
(
object
)
:
static_method
=
None
class_method
=
None
attribute
=
None
sys
.
modules
[
'
package
'
]
=
package
=
Mock
(
name
=
'
package
'
)
sys
.
modules
[
'
package
.
module
'
]
=
package
.
module
class
TestCase
(
unittest2
.
TestCase
)
:
def
run
(
self
)
:
result
=
unittest2
.
TestResult
(
)
super
(
unittest2
.
TestCase
self
)
.
run
(
result
)
assert
result
.
wasSuccessful
(
)
qr
qs
}
qt
(
h5U
h6h
^
ubaubh
]
)
qu
}
qv
(
h5X
patch
.
TEST_PREFIX
=
'
test
'
qwh6h3h7h
:
h
<
hah
>
}
qx
(
U
testnodetypeqyX
testcleanupqzhehfhF
]
q
{
hD
]
q
|
h
]
q
}
hB
]
q
~
hH
]
q
U
groupsq
]
q
hnaho
}
q
uhJK
hKh
h0
]
q
hYX
patch
.
TEST_PREFIX
=
'
test
'
q
q
}
q
(
h5U
h6huubaubcdocutils
.
nodes
paragraph
q
)
q
}
q
(
h5X
The
patch
decorators
are
used
for
patching
objects
only
within
the
scope
of
the
function
they
decorate
.
They
automatically
handle
the
unpatching
for
you
even
if
exceptions
are
raised
.
All
of
these
functions
can
also
be
used
in
with
statements
or
as
class
decorators
.
q
h6h3h7h
:
h
<
U
paragraphq
h
>
}
q
(
h
]
q
hB
]
q
hD
]
q
hF
]
q
hH
]
q
uhJK
hKh
h0
]
q
hYX
The
patch
decorators
are
used
for
patching
objects
only
within
the
scope
of
the
function
they
decorate
.
They
automatically
handle
the
unpatching
for
you
even
if
exceptions
are
raised
.
All
of
these
functions
can
also
be
used
in
with
statements
or
as
class
decorators
.
q
q
}
q
(
h5h
h6h
ubaubh2
)
q
}
q
(
h5U
U
referencedq
K
h6h3h7h
:
h
<
h
=
h
>
}
q
(
h
]
q
hB
]
q
hD
]
q
hF
]
q
h
*
ahH
]
q
h
auhJK
hKh
h0
]
q
(
hM
)
q
}
q
(
h5X
patchq
h6h
h7h
:
h
<
hQh
>
}
q
(
h
]
q
hB
]
q
hD
]
q
hF
]
q
hH
]
q
uhJK
hKh
h0
]
q
hYX
patchq
q
}
q
(
h5h
h6h
ubaubcdocutils
.
nodes
note
q
)
q
}
q
(
h5X
{
patch
is
straightforward
to
use
.
The
key
is
to
do
the
patching
in
the
right
namespace
.
See
the
section
where
to
patch
_
.
q
h6h
h7h
:
h
<
U
noteq
h
>
}
q
(
h
]
q
hB
]
q
hD
]
q
hF
]
q
hH
]
q
uhJNhKh
h0
]
q
h
)
q
}
q
(
h5X
{
patch
is
straightforward
to
use
.
The
key
is
to
do
the
patching
in
the
right
namespace
.
See
the
section
where
to
patch
_
.
q
h6h
h7h
:
h
<
h
h
>
}
q
(
h
]
q
hB
]
q
hD
]
q
hF
]
q
hH
]
q
uhJK
(
h0
]
q
(
cdocutils
.
nodes
title_reference
q
)
q
}
q
(
h5X
patch
q
h
>
}
q
(
h
]
q
hB
]
q
hD
]
q
hF
]
q
hH
]
q
uh6h
h0
]
q
hYX
patchq
q
}
q
(
h5U
h6h
ubah
<
U
title_referenceq
ubhYXb
is
straightforward
to
use
.
The
key
is
to
do
the
patching
in
the
right
namespace
.
See
the
section
q
q
}
q
(
h5Xb
is
straightforward
to
use
.
The
key
is
to
do
the
patching
in
the
right
namespace
.
See
the
section
q
h6h
ubcdocutils
.
nodes
reference
q
)
q
}
q
(
h5X
where
to
patch
_q
U
resolvedq
K
h6h
h
<
U
referenceq
h
>
}
q
(
U
nameq
X
where
to
patchq
hF
]
q
hD
]
q
h
]
q
hB
]
q
hH
]
q
U
refidq
h
-
uh0
]
q
hYX
where
to
patchq
q
}
q
(
h5U
h6h
ubaubhYX
.
q
}
q
(
h5X
.
h6h
ubeubaubcsphinx
.
addnodes
index
q
)
q
}
q
(
h5U
h6h
h7h
:
h
<
U
indexq
h
>
}
q
(
hF
]
q
hD
]
q
h
]
q
hB
]
q
hH
]
q
U
entriesq
]
q
(
U
singleq
X
patch
(
)
(
in
module
mock
)
h
U
tq
auhJNhKh
h0
]
q
ubcsphinx
.
addnodes
desc
q
)
q
}
q
(
h5U
h6h
h7h
:
h
<
U
descq
h
>
}
q
(
U
noindexq
U
domainr
X
pyr
hF
]
r
hD
]
r
h
]
r
hB
]
r
hH
]
r
U
objtyper
X
functionr
U
desctyper
j
uhJNhKh
h0
]
r
(
csphinx
.
addnodes
desc_signature
r
)
r
}
r
(
h5Xn
patch
(
target
new
=
DEFAULT
spec
=
None
create
=
False
spec_set
=
None
autospec
=
None
new_callable
=
None
*
*
kwargs
)
r
h6h
h7h
:
h
<
U
desc_signaturer
h
>
}
r
(
hF
]
r
h
aU
moduler
X
mockr
hD
]
r
h
]
r
hB
]
r
hH
]
r
h
aU
fullnamer
X
patchr
U
classr
U
U
firstr
uhJKnhKh
h0
]
r
(
csphinx
.
addnodes
desc_name
r
)
r
}
r
(
h5j
h6j
h7h
:
h
<
U
desc_namer
h
>
}
r
!
(
h
]
r
"
hB
]
r
#
hD
]
r
hF
]
r
%
hH
]
r
&
uhJKnhKh
h0
]
r
'
hYX
patchr
(
r
)
}
r
*
(
h5U
h6j
ubaubcsphinx
.
addnodes
desc_parameterlist
r
+
)
r
}
r
-
(
h5U
h6j
h7h
:
h
<
U
desc_parameterlistr
.
h
>
}
r
/
(
h
]
r0
hB
]
r1
hD
]
r2
hF
]
r3
hH
]
r4
uhJKnhKh
h0
]
r5
(
csphinx
.
addnodes
desc_parameter
r6
)
r7
}
r8
(
h5X
targetr9
h
>
}
r
:
(
h
]
r
;
hB
]
r
<
hD
]
r
=
hF
]
r
>
hH
]
r
?
uh6j
h0
]
r
hYX
targetrA
rB
}
rC
(
h5U
h6j7
ubah
<
U
desc_parameterrD
ubj6
)
rE
}
rF
(
h5X
new
=
DEFAULTrG
h
>
}
rH
(
h
]
rI
hB
]
rJ
hD
]
rK
hF
]
rL
hH
]
rM
uh6j
h0
]
rN
hYX
new
=
DEFAULTrO
rP
}
rQ
(
h5U
h6jE
ubah
<
jD
ubj6
)
rR
}
rS
(
h5X
spec
=
NonerT
h
>
}
rU
(
h
]
rV
hB
]
rW
hD
]
rX
hF
]
rY
hH
]
rZ
uh6j
h0
]
r
[
hYX
spec
=
Noner
\
r
]
}
r
^
(
h5U
h6jR
ubah
<
jD
ubj6
)
r_
}
r
(
h5X
create
=
Falsera
h
>
}
rb
(
h
]
rc
hB
]
rd
hD
]
re
hF
]
rf
hH
]
rg
uh6j
h0
]
rh
hYX
create
=
Falseri
rj
}
rk
(
h5U
h6j_
ubah
<
jD
ubj6
)
rl
}
rm
(
h5X
spec_set
=
Nonern
h
>
}
ro
(
h
]
rp
hB
]
rq
hD
]
rr
hF
]
rs
hH
]
rt
uh6j
h0
]
ru
hYX
spec_set
=
Nonerv
rw
}
rx
(
h5U
h6jl
ubah
<
jD
ubj6
)
ry
}
rz
(
h5X
autospec
=
Noner
{
h
>
}
r
|
(
h
]
r
}
hB
]
r
~
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
autospec
=
Noner
r
}
r
(
h5U
h6jy
ubah
<
jD
ubj6
)
r
}
r
(
h5X
new_callable
=
Noner
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
new_callable
=
Noner
r
}
r
(
h5U
h6j
ubah
<
jD
ubj6
)
r
}
r
(
h5X
*
*
kwargsr
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
*
*
kwargsr
r
}
r
(
h5U
h6j
ubah
<
jD
ubeubeubcsphinx
.
addnodes
desc_content
r
)
r
}
r
(
h5U
h6h
h7h
:
h
<
U
desc_contentr
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJKnhKh
h0
]
r
(
h
)
r
}
r
(
h5X
patch
acts
as
a
function
decorator
class
decorator
or
a
context
manager
.
Inside
the
body
of
the
function
or
with
statement
the
target
is
patched
with
a
new
object
.
When
the
function
/
with
statement
exits
the
patch
is
undone
.
r
h6j
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJK
-
hKh
h0
]
r
(
h
)
r
}
r
(
h5X
patch
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
patchr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
|
acts
as
a
function
decorator
class
decorator
or
a
context
manager
.
Inside
the
body
of
the
function
or
with
statement
the
r
r
}
r
(
h5X
|
acts
as
a
function
decorator
class
decorator
or
a
context
manager
.
Inside
the
body
of
the
function
or
with
statement
the
r
h6j
ubh
)
r
}
r
(
h5X
target
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
targetr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
is
patched
with
a
r
r
}
r
(
h5X
is
patched
with
a
r
h6j
ubh
)
r
}
r
(
h5X
new
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
newr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYXD
object
.
When
the
function
/
with
statement
exits
the
patch
is
undone
.
r
r
}
r
(
h5XD
object
.
When
the
function
/
with
statement
exits
the
patch
is
undone
.
r
h6j
ubeubh
)
r
}
r
(
h5X
.
If
new
is
omitted
then
the
target
is
replaced
with
a
:
class
:
MagicMock
.
If
patch
is
used
as
a
decorator
and
new
is
omitted
the
created
mock
is
passed
in
as
an
extra
argument
to
the
decorated
function
.
If
patch
is
used
as
a
context
manager
the
created
mock
is
returned
by
the
context
manager
.
r
h6j
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJK2hKh
h0
]
r
(
hYX
If
r
r
}
r
(
h5X
If
r
h6j
ubh
)
r
}
r
(
h5X
new
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
newr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX0
is
omitted
then
the
target
is
replaced
with
a
r
r
}
r
(
h5X0
is
omitted
then
the
target
is
replaced
with
a
r
h6j
ubcsphinx
.
addnodes
pending_xref
r
)
r
}
r
(
h5X
:
class
:
MagicMock
r
h6j
h7h
:
h
<
U
pending_xrefr
h
>
}
r
(
U
reftyper
X
classr
U
refwarnr
U
reftargetr
X
MagicMockr
U
refdomainr
X
pyr
hF
]
r
hD
]
r
U
refexplicitr
h
]
r
hB
]
r
hH
]
r
U
refdocr
U
patchr
U
py
:
classr
NU
py
:
moduler
j
uhJK2h0
]
r
cdocutils
.
nodes
literal
r
)
r
}
r
!
(
h5j
h
>
}
r
"
(
h
]
r
#
hB
]
r
(
U
xrefr
%
j
X
py
-
classr
&
ehD
]
r
'
hF
]
r
(
hH
]
r
)
uh6j
h0
]
r
*
hYX
MagicMockr
+
r
}
r
-
(
h5U
h6j
ubah
<
U
literalr
.
ubaubhYX
.
If
r
/
r0
}
r1
(
h5X
.
If
r2
h6j
ubh
)
r3
}
r4
(
h5X
patch
r5
h
>
}
r6
(
h
]
r7
hB
]
r8
hD
]
r9
hF
]
r
:
hH
]
r
;
uh6j
h0
]
r
<
hYX
patchr
=
r
>
}
r
?
(
h5U
h6j3
ubah
<
h
ubhYX
is
used
as
a
decorator
and
r
rA
}
rB
(
h5X
is
used
as
a
decorator
and
rC
h6j
ubh
)
rD
}
rE
(
h5X
new
rF
h
>
}
rG
(
h
]
rH
hB
]
rI
hD
]
rJ
hF
]
rK
hH
]
rL
uh6j
h0
]
rM
hYX
newrN
rO
}
rP
(
h5U
h6jD
ubah
<
h
ubhYX
^
is
omitted
the
created
mock
is
passed
in
as
an
extra
argument
to
the
decorated
function
.
If
rQ
rR
}
rS
(
h5X
^
is
omitted
the
created
mock
is
passed
in
as
an
extra
argument
to
the
decorated
function
.
If
rT
h6j
ubh
)
rU
}
rV
(
h5X
patch
rW
h
>
}
rX
(
h
]
rY
hB
]
rZ
hD
]
r
[
hF
]
r
\
hH
]
r
]
uh6j
h0
]
r
^
hYX
patchr_
r
}
ra
(
h5U
h6jU
ubah
<
h
ubhYXR
is
used
as
a
context
manager
the
created
mock
is
returned
by
the
context
manager
.
rb
rc
}
rd
(
h5XR
is
used
as
a
context
manager
the
created
mock
is
returned
by
the
context
manager
.
re
h6j
ubeubh
)
rf
}
rg
(
h5XE
target
should
be
a
string
in
the
form
'
package
.
module
.
ClassName
'
.
The
target
is
imported
and
the
specified
object
replaced
with
the
new
object
so
the
target
must
be
importable
from
the
environment
you
are
calling
patch
from
.
The
target
is
imported
when
the
decorated
function
is
executed
not
at
decoration
time
.
rh
h6j
h7h
:
h
<
h
h
>
}
ri
(
h
]
rj
hB
]
rk
hD
]
rl
hF
]
rm
hH
]
rn
uhJK8hKh
h0
]
ro
(
h
)
rp
}
rq
(
h5X
target
rr
h
>
}
rs
(
h
]
rt
hB
]
ru
hD
]
rv
hF
]
rw
hH
]
rx
uh6jf
h0
]
ry
hYX
targetrz
r
{
}
r
|
(
h5U
h6jp
ubah
<
h
ubhYX
should
be
a
string
in
the
form
r
}
r
~
}
r
(
h5X
should
be
a
string
in
the
form
r
h6jf
ubh
)
r
}
r
(
h5X
'
package
.
module
.
ClassName
'
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jf
h0
]
r
hYX
'
package
.
module
.
ClassName
'
r
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
.
The
r
r
}
r
(
h5X
.
The
r
h6jf
ubh
)
r
}
r
(
h5X
target
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jf
h0
]
r
hYX
targetr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX8
is
imported
and
the
specified
object
replaced
with
the
r
r
}
r
(
h5X8
is
imported
and
the
specified
object
replaced
with
the
r
h6jf
ubh
)
r
}
r
(
h5X
new
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jf
h0
]
r
hYX
newr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
object
so
the
r
r
}
r
(
h5X
object
so
the
r
h6jf
ubh
)
r
}
r
(
h5X
target
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jf
h0
]
r
hYX
targetr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX9
must
be
importable
from
the
environment
you
are
calling
r
r
}
r
(
h5X9
must
be
importable
from
the
environment
you
are
calling
r
h6jf
ubh
)
r
}
r
(
h5X
patch
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jf
h0
]
r
hYX
patchr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
^
from
.
The
target
is
imported
when
the
decorated
function
is
executed
not
at
decoration
time
.
r
r
}
r
(
h5X
^
from
.
The
target
is
imported
when
the
decorated
function
is
executed
not
at
decoration
time
.
r
h6jf
ubeubh
)
r
}
r
(
h5Xk
The
spec
and
spec_set
keyword
arguments
are
passed
to
the
MagicMock
if
patch
is
creating
one
for
you
.
r
h6j
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJK
>
hKh
h0
]
r
(
hYX
The
r
r
}
r
(
h5X
The
r
h6j
ubh
)
r
}
r
(
h5X
spec
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
specr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
and
r
r
}
r
(
h5X
and
r
h6j
ubh
)
r
}
r
(
h5X
spec_set
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
spec_setr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
%
keyword
arguments
are
passed
to
the
r
r
}
r
(
h5X
%
keyword
arguments
are
passed
to
the
r
h6j
ubh
)
r
}
r
(
h5X
MagicMock
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
MagicMockr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
"
if
patch
is
creating
one
for
you
.
r
r
}
r
(
h5X
"
if
patch
is
creating
one
for
you
.
r
h6j
ubeubh
)
r
}
r
(
h5X
In
addition
you
can
pass
spec
=
True
or
spec_set
=
True
which
causes
patch
to
pass
in
the
object
being
mocked
as
the
spec
/
spec_set
object
.
r
h6j
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJKAhKh
h0
]
r
(
hYX
In
addition
you
can
pass
r
!
r
"
}
r
#
(
h5X
In
addition
you
can
pass
r
h6j
ubh
)
r
%
}
r
&
(
h5X
spec
=
True
r
'
h
>
}
r
(
(
h
]
r
)
hB
]
r
*
hD
]
r
+
hF
]
r
hH
]
r
-
uh6j
h0
]
r
.
hYX
spec
=
Truer
/
r0
}
r1
(
h5U
h6j
%
ubah
<
h
ubhYX
or
r2
r3
}
r4
(
h5X
or
r5
h6j
ubh
)
r6
}
r7
(
h5X
spec_set
=
True
r8
h
>
}
r9
(
h
]
r
:
hB
]
r
;
hD
]
r
<
hF
]
r
=
hH
]
r
>
uh6j
h0
]
r
?
hYX
spec_set
=
Truer
rA
}
rB
(
h5U
h6j6
ubah
<
h
ubhYXT
which
causes
patch
to
pass
in
the
object
being
mocked
as
the
spec
/
spec_set
object
.
rC
rD
}
rE
(
h5XT
which
causes
patch
to
pass
in
the
object
being
mocked
as
the
spec
/
spec_set
object
.
rF
h6j
ubeubh
)
rG
}
rH
(
h5X
new_callable
allows
you
to
specify
a
different
class
or
callable
object
that
will
be
called
to
create
the
new
object
.
By
default
MagicMock
is
used
.
rI
h6j
h7h
:
h
<
h
h
>
}
rJ
(
h
]
rK
hB
]
rL
hD
]
rM
hF
]
rN
hH
]
rO
uhJKDhKh
h0
]
rP
(
h
)
rQ
}
rR
(
h5X
new_callable
rS
h
>
}
rT
(
h
]
rU
hB
]
rV
hD
]
rW
hF
]
rX
hH
]
rY
uh6jG
h0
]
rZ
hYX
new_callabler
[
r
\
}
r
]
(
h5U
h6jQ
ubah
<
h
ubhYX
allows
you
to
specify
a
different
class
or
callable
object
that
will
be
called
to
create
the
r
^
r_
}
r
(
h5X
allows
you
to
specify
a
different
class
or
callable
object
that
will
be
called
to
create
the
ra
h6jG
ubh
)
rb
}
rc
(
h5X
new
rd
h
>
}
re
(
h
]
rf
hB
]
rg
hD
]
rh
hF
]
ri
hH
]
rj
uh6jG
h0
]
rk
hYX
newrl
rm
}
rn
(
h5U
h6jb
ubah
<
h
ubhYX
object
.
By
default
ro
rp
}
rq
(
h5X
object
.
By
default
rr
h6jG
ubh
)
rs
}
rt
(
h5X
MagicMock
ru
h
>
}
rv
(
h
]
rw
hB
]
rx
hD
]
ry
hF
]
rz
hH
]
r
{
uh6jG
h0
]
r
|
hYX
MagicMockr
}
r
~
}
r
(
h5U
h6js
ubah
<
h
ubhYX
is
used
.
r
r
}
r
(
h5X
is
used
.
r
h6jG
ubeubh
)
r
}
r
(
h5X
;
A
more
powerful
form
of
spec
is
autospec
.
If
you
set
autospec
=
True
then
the
mock
with
be
created
with
a
spec
from
the
object
being
replaced
.
All
attributes
of
the
mock
will
also
have
the
spec
of
the
corresponding
attribute
of
the
object
being
replaced
.
Methods
and
functions
being
mocked
will
have
their
arguments
checked
and
will
raise
a
TypeError
if
they
are
called
with
the
wrong
signature
.
For
mocks
replacing
a
class
their
return
value
(
the
'
instance
'
)
will
have
the
same
spec
as
the
class
.
See
the
:
func
:
create_autospec
function
and
:
ref
:
auto
-
speccing
.
r
h6j
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJKHhKh
h0
]
r
(
hYX
A
more
powerful
form
of
r
r
}
r
(
h5X
A
more
powerful
form
of
r
h6j
ubh
)
r
}
r
(
h5X
spec
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
specr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
is
r
r
}
r
(
h5X
is
r
h6j
ubh
)
r
}
r
(
h5X
autospec
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
autospecr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
.
If
you
set
r
r
}
r
(
h5X
.
If
you
set
r
h6j
ubh
)
r
}
r
(
h5X
autospec
=
True
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
autospec
=
Truer
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
then
the
mock
with
be
created
with
a
spec
from
the
object
being
replaced
.
All
attributes
of
the
mock
will
also
have
the
spec
of
the
corresponding
attribute
of
the
object
being
replaced
.
Methods
and
functions
being
mocked
will
have
their
arguments
checked
and
will
raise
a
r
r
}
r
(
h5X
then
the
mock
with
be
created
with
a
spec
from
the
object
being
replaced
.
All
attributes
of
the
mock
will
also
have
the
spec
of
the
corresponding
attribute
of
the
object
being
replaced
.
Methods
and
functions
being
mocked
will
have
their
arguments
checked
and
will
raise
a
r
h6j
ubh
)
r
}
r
(
h5X
TypeError
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
TypeErrorr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
if
they
are
called
with
the
wrong
signature
.
For
mocks
replacing
a
class
their
return
value
(
the
'
instance
'
)
will
have
the
same
spec
as
the
class
.
See
the
r
r
}
r
(
h5X
if
they
are
called
with
the
wrong
signature
.
For
mocks
replacing
a
class
their
return
value
(
the
'
instance
'
)
will
have
the
same
spec
as
the
class
.
See
the
r
h6j
ubj
)
r
}
r
(
h5X
:
func
:
create_autospec
r
h6j
h7h
:
h
<
j
h
>
}
r
(
U
reftyper
X
funcr
j
j
X
create_autospecr
U
refdomainr
X
pyr
hF
]
r
hD
]
r
U
refexplicitr
h
]
r
hB
]
r
hH
]
r
j
j
j
Nj
j
uhJKHh0
]
r
j
)
r
}
r
(
h5j
h
>
}
r
(
h
]
r
hB
]
r
(
j
%
j
X
py
-
funcr
ehD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
create_autospec
(
)
r
r
}
r
(
h5U
h6j
ubah
<
j
.
ubaubhYX
function
and
r
r
}
r
(
h5X
function
and
r
h6j
ubj
)
r
}
r
(
h5X
:
ref
:
auto
-
speccing
r
h6j
h7h
:
h
<
j
h
>
}
r
(
U
reftyper
X
refr
j
j
X
auto
-
speccingr
U
refdomainr
X
stdr
hF
]
r
hD
]
r
U
refexplicitr
h
]
r
hB
]
r
hH
]
r
j
j
uhJKHh0
]
r
cdocutils
.
nodes
emphasis
r
)
r
}
r
(
h5j
h
>
}
r
(
h
]
r
hB
]
r
(
j
%
j
X
std
-
refr
ehD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
auto
-
speccingr
r
}
r
(
h5U
h6j
ubah
<
U
emphasisr
ubaubhYX
.
r
}
r
(
h5X
.
h6j
ubeubh
)
r
}
r
(
h5X
Instead
of
autospec
=
True
you
can
pass
autospec
=
some_object
to
use
an
arbitrary
object
as
the
spec
instead
of
the
one
being
replaced
.
r
h6j
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJKRhKh
h0
]
r
!
(
hYX
Instead
of
r
"
r
#
}
r
(
h5X
Instead
of
r
%
h6j
ubh
)
r
&
}
r
'
(
h5X
autospec
=
True
r
(
h
>
}
r
)
(
h
]
r
*
hB
]
r
+
hD
]
r
hF
]
r
-
hH
]
r
.
uh6j
h0
]
r
/
hYX
autospec
=
Truer0
r1
}
r2
(
h5U
h6j
&
ubah
<
h
ubhYX
you
can
pass
r3
r4
}
r5
(
h5X
you
can
pass
r6
h6j
ubh
)
r7
}
r8
(
h5X
autospec
=
some_object
r9
h
>
}
r
:
(
h
]
r
;
hB
]
r
<
hD
]
r
=
hF
]
r
>
hH
]
r
?
uh6j
h0
]
r
hYX
autospec
=
some_objectrA
rB
}
rC
(
h5U
h6j7
ubah
<
h
ubhYXJ
to
use
an
arbitrary
object
as
the
spec
instead
of
the
one
being
replaced
.
rD
rE
}
rF
(
h5XJ
to
use
an
arbitrary
object
as
the
spec
instead
of
the
one
being
replaced
.
rG
h6j
ubeubh
)
rH
}
rI
(
h5X
By
default
patch
will
fail
to
replace
attributes
that
don
'
t
exist
.
If
you
pass
in
create
=
True
and
the
attribute
doesn
'
t
exist
patch
will
create
the
attribute
for
you
when
the
patched
function
is
called
and
delete
it
again
afterwards
.
This
is
useful
for
writing
tests
against
attributes
that
your
production
code
creates
at
runtime
.
It
is
off
by
by
default
because
it
can
be
dangerous
.
With
it
switched
on
you
can
write
passing
tests
against
APIs
that
don
'
t
actually
exist
!
rJ
h6j
h7h
:
h
<
h
h
>
}
rK
(
h
]
rL
hB
]
rM
hD
]
rN
hF
]
rO
hH
]
rP
uhJKUhKh
h0
]
rQ
(
hYX
By
default
rR
rS
}
rT
(
h5X
By
default
rU
h6jH
ubh
)
rV
}
rW
(
h5X
patch
rX
h
>
}
rY
(
h
]
rZ
hB
]
r
[
hD
]
r
\
hF
]
r
]
hH
]
r
^
uh6jH
h0
]
r_
hYX
patchr
ra
}
rb
(
h5U
h6jV
ubah
<
h
ubhYXB
will
fail
to
replace
attributes
that
don
'
t
exist
.
If
you
pass
in
rc
rd
}
re
(
h5XB
will
fail
to
replace
attributes
that
don
'
t
exist
.
If
you
pass
in
rf
h6jH
ubh
)
rg
}
rh
(
h5X
create
=
True
ri
h
>
}
rj
(
h
]
rk
hB
]
rl
hD
]
rm
hF
]
rn
hH
]
ro
uh6jH
h0
]
rp
hYX
create
=
Truerq
rr
}
rs
(
h5U
h6jg
ubah
<
h
ubhYX
~
and
the
attribute
doesn
'
t
exist
patch
will
create
the
attribute
for
you
when
the
patched
function
is
called
and
delete
it
again
afterwards
.
This
is
useful
for
writing
tests
against
attributes
that
your
production
code
creates
at
runtime
.
It
is
off
by
by
default
because
it
can
be
dangerous
.
With
it
switched
on
you
can
write
passing
tests
against
APIs
that
don
'
t
actually
exist
!
rt
ru
}
rv
(
h5X
~
and
the
attribute
doesn
'
t
exist
patch
will
create
the
attribute
for
you
when
the
patched
function
is
called
and
delete
it
again
afterwards
.
This
is
useful
for
writing
tests
against
attributes
that
your
production
code
creates
at
runtime
.
It
is
off
by
by
default
because
it
can
be
dangerous
.
With
it
switched
on
you
can
write
passing
tests
against
APIs
that
don
'
t
actually
exist
!
rw
h6jH
ubeubh
)
rx
}
ry
(
h5X
Patch
can
be
used
as
a
TestCase
class
decorator
.
It
works
by
decorating
each
test
method
in
the
class
.
This
reduces
the
boilerplate
code
when
your
test
methods
share
a
common
patchings
set
.
patch
finds
tests
by
looking
for
method
names
that
start
with
patch
.
TEST_PREFIX
.
By
default
this
is
test
which
matches
the
way
unittest
finds
tests
.
You
can
specify
an
alternative
prefix
by
setting
patch
.
TEST_PREFIX
.
rz
h6j
h7h
:
h
<
h
h
>
}
r
{
(
h
]
r
|
hB
]
r
}
hD
]
r
~
hF
]
r
hH
]
r
uhJK
]
hKh
h0
]
r
(
hYX
Patch
can
be
used
as
a
r
r
}
r
(
h5X
Patch
can
be
used
as
a
r
h6jx
ubh
)
r
}
r
(
h5X
TestCase
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jx
h0
]
r
hYX
TestCaser
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
class
decorator
.
It
works
by
decorating
each
test
method
in
the
class
.
This
reduces
the
boilerplate
code
when
your
test
methods
share
a
common
patchings
set
.
r
r
}
r
(
h5X
class
decorator
.
It
works
by
decorating
each
test
method
in
the
class
.
This
reduces
the
boilerplate
code
when
your
test
methods
share
a
common
patchings
set
.
r
h6jx
ubh
)
r
}
r
(
h5X
patch
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jx
h0
]
r
hYX
patchr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX9
finds
tests
by
looking
for
method
names
that
start
with
r
r
}
r
(
h5X9
finds
tests
by
looking
for
method
names
that
start
with
r
h6jx
ubh
)
r
}
r
(
h5X
patch
.
TEST_PREFIX
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jx
h0
]
r
hYX
patch
.
TEST_PREFIXr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
.
By
default
this
is
r
r
}
r
(
h5X
.
By
default
this
is
r
h6jx
ubh
)
r
}
r
(
h5X
test
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jx
h0
]
r
hYX
testr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
which
matches
the
way
r
r
}
r
(
h5X
which
matches
the
way
r
h6jx
ubh
)
r
}
r
(
h5X
unittest
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jx
h0
]
r
hYX
unittestr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
?
finds
tests
.
You
can
specify
an
alternative
prefix
by
setting
r
r
}
r
(
h5X
?
finds
tests
.
You
can
specify
an
alternative
prefix
by
setting
r
h6jx
ubh
)
r
}
r
(
h5X
patch
.
TEST_PREFIX
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jx
h0
]
r
hYX
patch
.
TEST_PREFIXr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
.
r
}
r
(
h5X
.
h6jx
ubeubh
)
r
}
r
(
h5X
Patch
can
be
used
as
a
context
manager
with
the
with
statement
.
Here
the
patching
applies
to
the
indented
block
after
the
with
statement
.
If
you
use
"
as
"
then
the
patched
object
will
be
bound
to
the
name
after
the
"
as
"
;
very
useful
if
patch
is
creating
a
mock
object
for
you
.
r
h6j
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJKdhKh
h0
]
r
(
hYX
Patch
can
be
used
as
a
context
manager
with
the
with
statement
.
Here
the
patching
applies
to
the
indented
block
after
the
with
statement
.
If
you
use
"
as
"
then
the
patched
object
will
be
bound
to
the
name
after
the
"
as
"
;
very
useful
if
r
r
}
r
(
h5X
Patch
can
be
used
as
a
context
manager
with
the
with
statement
.
Here
the
patching
applies
to
the
indented
block
after
the
with
statement
.
If
you
use
"
as
"
then
the
patched
object
will
be
bound
to
the
name
after
the
"
as
"
;
very
useful
if
r
h6j
ubh
)
r
}
r
(
h5X
patch
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
patchr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
#
is
creating
a
mock
object
for
you
.
r
r
}
r
(
h5X
#
is
creating
a
mock
object
for
you
.
r
h6j
ubeubh
)
r
}
r
(
h5Xr
patch
takes
arbitrary
keyword
arguments
.
These
will
be
passed
to
the
Mock
(
or
new_callable
)
on
construction
.
r
h6j
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJKihKh
h0
]
r
(
h
)
r
}
r
(
h5X
patch
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
patchr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
takes
arbitrary
keyword
arguments
.
These
will
be
passed
to
the
r
r
!
}
r
"
(
h5X
takes
arbitrary
keyword
arguments
.
These
will
be
passed
to
the
r
#
h6j
ubh
)
r
}
r
%
(
h5X
Mock
r
&
h
>
}
r
'
(
h
]
r
(
hB
]
r
)
hD
]
r
*
hF
]
r
+
hH
]
r
uh6j
h0
]
r
-
hYX
Mockr
.
r
/
}
r0
(
h5U
h6j
ubah
<
h
ubhYX
(
or
r1
r2
}
r3
(
h5X
(
or
r4
h6j
ubh
)
r5
}
r6
(
h5X
new_callable
r7
h
>
}
r8
(
h
]
r9
hB
]
r
:
hD
]
r
;
hF
]
r
<
hH
]
r
=
uh6j
h0
]
r
>
hYX
new_callabler
?
r
}
rA
(
h5U
h6j5
ubah
<
h
ubhYX
)
on
construction
.
rB
rC
}
rD
(
h5X
)
on
construction
.
rE
h6j
ubeubh
)
rF
}
rG
(
h5Xg
patch
.
dict
(
.
.
.
)
patch
.
multiple
(
.
.
.
)
and
patch
.
object
(
.
.
.
)
are
available
for
alternate
use
-
cases
.
rH
h6j
h7h
:
h
<
h
h
>
}
rI
(
h
]
rJ
hB
]
rK
hD
]
rL
hF
]
rM
hH
]
rN
uhJKlhKh
h0
]
rO
(
h
)
rP
}
rQ
(
h5X
patch
.
dict
(
.
.
.
)
rR
h
>
}
rS
(
h
]
rT
hB
]
rU
hD
]
rV
hF
]
rW
hH
]
rX
uh6jF
h0
]
rY
hYX
patch
.
dict
(
.
.
.
)
rZ
r
[
}
r
\
(
h5U
h6jP
ubah
<
h
ubhYX
r
]
r
^
}
r_
(
h5X
r
h6jF
ubh
)
ra
}
rb
(
h5X
patch
.
multiple
(
.
.
.
)
rc
h
>
}
rd
(
h
]
re
hB
]
rf
hD
]
rg
hF
]
rh
hH
]
ri
uh6jF
h0
]
rj
hYX
patch
.
multiple
(
.
.
.
)
rk
rl
}
rm
(
h5U
h6ja
ubah
<
h
ubhYX
and
rn
ro
}
rp
(
h5X
and
rq
h6jF
ubh
)
rr
}
rs
(
h5X
patch
.
object
(
.
.
.
)
rt
h
>
}
ru
(
h
]
rv
hB
]
rw
hD
]
rx
hF
]
ry
hH
]
rz
uh6jF
h0
]
r
{
hYX
patch
.
object
(
.
.
.
)
r
|
r
}
}
r
~
(
h5U
h6jr
ubah
<
h
ubhYX
'
are
available
for
alternate
use
-
cases
.
r
r
}
r
(
h5X
'
are
available
for
alternate
use
-
cases
.
r
h6jF
ubeubeubeubh
)
r
}
r
(
h5Xd
patch
as
function
decorator
creating
the
mock
for
you
and
passing
it
into
the
decorated
function
:
r
h6h
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJKohKh
h0
]
r
(
h
)
r
}
r
(
h5X
patch
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
patchr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
]
as
function
decorator
creating
the
mock
for
you
and
passing
it
into
the
decorated
function
:
r
r
}
r
(
h5X
]
as
function
decorator
creating
the
mock
for
you
and
passing
it
into
the
decorated
function
:
r
h6j
ubeubcdocutils
.
nodes
literal_block
r
)
r
}
r
(
h5X
>
>
>
patch
(
'
__main__
.
SomeClass
'
)
.
.
.
def
function
(
normal_argument
mock_class
)
:
.
.
.
print
mock_class
is
SomeClass
.
.
.
>
>
>
function
(
None
)
Truer
h6h
h7h
:
h
<
U
literal_blockr
h
>
}
r
(
U
testnodetyper
X
doctestr
hehfhF
]
r
hD
]
r
h
]
r
hB
]
r
hH
]
r
U
groupsr
]
r
hnaho
}
r
uhJKrhKh
h0
]
r
hYX
>
>
>
patch
(
'
__main__
.
SomeClass
'
)
.
.
.
def
function
(
normal_argument
mock_class
)
:
.
.
.
print
mock_class
is
SomeClass
.
.
.
>
>
>
function
(
None
)
Truer
r
}
r
(
h5U
h6j
ubaubh
)
r
}
r
(
h5X
Patching
a
class
replaces
the
class
with
a
MagicMock
*
instance
*
.
If
the
class
is
instantiated
in
the
code
under
test
then
it
will
be
the
:
attr
:
~
Mock
.
return_value
of
the
mock
that
will
be
used
.
r
h6h
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJK
|
hKh
h0
]
r
(
hYX
+
Patching
a
class
replaces
the
class
with
a
r
r
}
r
(
h5X
+
Patching
a
class
replaces
the
class
with
a
r
h6j
ubh
)
r
}
r
(
h5X
MagicMock
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
MagicMockr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
r
}
r
(
h5X
h6j
ubj
)
r
}
r
(
h5X
*
instance
*
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
instancer
r
}
r
(
h5U
h6j
ubah
<
j
ubhYXJ
.
If
the
class
is
instantiated
in
the
code
under
test
then
it
will
be
the
r
r
}
r
(
h5XJ
.
If
the
class
is
instantiated
in
the
code
under
test
then
it
will
be
the
r
h6j
ubj
)
r
}
r
(
h5X
:
attr
:
~
Mock
.
return_value
r
h6j
h7h
:
h
<
j
h
>
}
r
(
U
reftyper
X
attrr
j
j
X
Mock
.
return_valuer
U
refdomainr
X
pyr
hF
]
r
hD
]
r
U
refexplicitr
h
]
r
hB
]
r
hH
]
r
j
j
j
Nj
j
uhJK
|
h0
]
r
j
)
r
}
r
(
h5j
h
>
}
r
(
h
]
r
hB
]
r
(
j
%
j
X
py
-
attrr
ehD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
return_valuer
r
}
r
(
h5U
h6j
ubah
<
j
.
ubaubhYX
of
the
mock
that
will
be
used
.
r
r
}
r
(
h5X
of
the
mock
that
will
be
used
.
r
h6j
ubeubh
)
r
}
r
(
h5X
If
the
class
is
instantiated
multiple
times
you
could
use
:
attr
:
~
Mock
.
side_effect
to
return
a
new
mock
each
time
.
Alternatively
you
can
set
the
return_value
to
be
anything
you
want
.
r
h6h
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJK
hKh
h0
]
r
(
hYX
:
If
the
class
is
instantiated
multiple
times
you
could
use
r
r
}
r
(
h5X
:
If
the
class
is
instantiated
multiple
times
you
could
use
r
h6j
ubj
)
r
}
r
(
h5X
:
attr
:
~
Mock
.
side_effect
r
h6j
h7h
:
h
<
j
h
>
}
r
(
U
reftyper
X
attrr
j
j
X
Mock
.
side_effectr
U
refdomainr
X
pyr
hF
]
r
hD
]
r
U
refexplicitr
h
]
r
hB
]
r
hH
]
r
j
j
j
Nj
j
uhJK
h0
]
r
j
)
r
}
r
(
h5j
h
>
}
r
!
(
h
]
r
"
hB
]
r
#
(
j
%
j
X
py
-
attrr
ehD
]
r
%
hF
]
r
&
hH
]
r
'
uh6j
h0
]
r
(
hYX
side_effectr
)
r
*
}
r
+
(
h5U
h6j
ubah
<
j
.
ubaubhYX
?
to
return
a
new
mock
each
time
.
Alternatively
you
can
set
the
r
r
-
}
r
.
(
h5X
?
to
return
a
new
mock
each
time
.
Alternatively
you
can
set
the
r
/
h6j
ubh
)
r0
}
r1
(
h5X
return_value
r2
h
>
}
r3
(
h
]
r4
hB
]
r5
hD
]
r6
hF
]
r7
hH
]
r8
uh6j
h0
]
r9
hYX
return_valuer
:
r
;
}
r
<
(
h5U
h6j0
ubah
<
h
ubhYX
to
be
anything
you
want
.
r
=
r
>
}
r
?
(
h5X
to
be
anything
you
want
.
r
h6j
ubeubh
)
rA
}
rB
(
h5X
~
To
configure
return
values
on
methods
of
*
instances
*
on
the
patched
class
you
must
do
this
on
the
return_value
.
For
example
:
rC
h6h
h7h
:
h
<
h
h
>
}
rD
(
h
]
rE
hB
]
rF
hD
]
rG
hF
]
rH
hH
]
rI
uhJK
hKh
h0
]
rJ
(
hYX
)
To
configure
return
values
on
methods
of
rK
rL
}
rM
(
h5X
)
To
configure
return
values
on
methods
of
rN
h6jA
ubj
)
rO
}
rP
(
h5X
*
instances
*
rQ
h
>
}
rR
(
h
]
rS
hB
]
rT
hD
]
rU
hF
]
rV
hH
]
rW
uh6jA
h0
]
rX
hYX
instancesrY
rZ
}
r
[
(
h5U
h6jO
ubah
<
j
ubhYX
.
on
the
patched
class
you
must
do
this
on
the
r
\
r
]
}
r
^
(
h5X
.
on
the
patched
class
you
must
do
this
on
the
r_
h6jA
ubh
)
r
}
ra
(
h5X
return_value
rb
h
>
}
rc
(
h
]
rd
hB
]
re
hD
]
rf
hF
]
rg
hH
]
rh
uh6jA
h0
]
ri
hYX
return_valuerj
rk
}
rl
(
h5U
h6j
ubah
<
h
ubhYX
.
For
example
:
rm
rn
}
ro
(
h5X
.
For
example
:
rp
h6jA
ubeubj
)
rq
}
rr
(
h5X
>
>
>
class
Class
(
object
)
:
.
.
.
def
method
(
self
)
:
.
.
.
pass
.
.
.
>
>
>
with
patch
(
'
__main__
.
Class
'
)
as
MockClass
:
.
.
.
instance
=
MockClass
.
return_value
.
.
.
instance
.
method
.
return_value
=
'
foo
'
.
.
.
assert
Class
(
)
is
instance
.
.
.
assert
Class
(
)
.
method
(
)
=
=
'
foo
'
.
.
.
rs
h6h
h7h
:
h
<
j
h
>
}
rt
(
U
testnodetyperu
X
doctestrv
hehfhF
]
rw
hD
]
rx
h
]
ry
hB
]
rz
hH
]
r
{
U
groupsr
|
]
r
}
hnaho
}
r
~
uhJK
hKh
h0
]
r
hYX
>
>
>
class
Class
(
object
)
:
.
.
.
def
method
(
self
)
:
.
.
.
pass
.
.
.
>
>
>
with
patch
(
'
__main__
.
Class
'
)
as
MockClass
:
.
.
.
instance
=
MockClass
.
return_value
.
.
.
instance
.
method
.
return_value
=
'
foo
'
.
.
.
assert
Class
(
)
is
instance
.
.
.
assert
Class
(
)
.
method
(
)
=
=
'
foo
'
.
.
.
r
r
}
r
(
h5U
h6jq
ubaubh
)
r
}
r
(
h5X
If
you
use
spec
or
spec_set
and
patch
is
replacing
a
*
class
*
then
the
return
value
of
the
created
mock
will
have
the
same
spec
.
r
h6h
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJK
hKh
h0
]
r
(
hYX
If
you
use
r
r
}
r
(
h5X
If
you
use
r
h6j
ubh
)
r
}
r
(
h5X
spec
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
specr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
or
r
r
}
r
(
h5X
or
r
h6j
ubh
)
r
}
r
(
h5X
spec_set
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
spec_setr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
and
r
r
}
r
(
h5X
and
r
h6j
ubh
)
r
}
r
(
h5X
patch
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
patchr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
is
replacing
a
r
r
}
r
(
h5X
is
replacing
a
r
h6j
ubj
)
r
}
r
(
h5X
*
class
*
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
classr
r
}
r
(
h5U
h6j
ubah
<
j
ubhYXD
then
the
return
value
of
the
created
mock
will
have
the
same
spec
.
r
r
}
r
(
h5XD
then
the
return
value
of
the
created
mock
will
have
the
same
spec
.
r
h6j
ubeubj
)
r
}
r
(
h5X
>
>
>
Original
=
Class
>
>
>
patcher
=
patch
(
'
__main__
.
Class
'
spec
=
True
)
>
>
>
MockClass
=
patcher
.
start
(
)
>
>
>
instance
=
MockClass
(
)
>
>
>
assert
isinstance
(
instance
Original
)
>
>
>
patcher
.
stop
(
)
r
h6h
h7h
:
h
<
j
h
>
}
r
(
U
testnodetyper
X
doctestr
hehfhF
]
r
hD
]
r
h
]
r
hB
]
r
hH
]
r
U
groupsr
]
r
hnaho
}
r
uhJK
hKh
h0
]
r
hYX
>
>
>
Original
=
Class
>
>
>
patcher
=
patch
(
'
__main__
.
Class
'
spec
=
True
)
>
>
>
MockClass
=
patcher
.
start
(
)
>
>
>
instance
=
MockClass
(
)
>
>
>
assert
isinstance
(
instance
Original
)
>
>
>
patcher
.
stop
(
)
r
r
}
r
(
h5U
h6j
ubaubh
)
r
}
r
(
h5X
The
new_callable
argument
is
useful
where
you
want
to
use
an
alternative
class
to
the
default
:
class
:
MagicMock
for
the
created
mock
.
For
example
if
you
wanted
a
:
class
:
NonCallableMock
to
be
used
:
r
h6h
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJK
hKh
h0
]
r
(
hYX
The
r
r
}
r
(
h5X
The
r
h6j
ubh
)
r
}
r
(
h5X
new_callable
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
new_callabler
r
}
r
(
h5U
h6j
ubah
<
h
ubhYXN
argument
is
useful
where
you
want
to
use
an
alternative
class
to
the
default
r
r
}
r
(
h5XN
argument
is
useful
where
you
want
to
use
an
alternative
class
to
the
default
r
h6j
ubj
)
r
}
r
(
h5X
:
class
:
MagicMock
r
h6j
h7h
:
h
<
j
h
>
}
r
(
U
reftyper
X
classr
j
j
X
MagicMockr
U
refdomainr
X
pyr
hF
]
r
hD
]
r
U
refexplicitr
h
]
r
hB
]
r
hH
]
r
j
j
j
Nj
j
uhJK
h0
]
r
j
)
r
}
r
(
h5j
h
>
}
r
(
h
]
r
hB
]
r
(
j
%
j
X
py
-
classr
ehD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
MagicMockr
r
!
}
r
"
(
h5U
h6j
ubah
<
j
.
ubaubhYX4
for
the
created
mock
.
For
example
if
you
wanted
a
r
#
r
}
r
%
(
h5X4
for
the
created
mock
.
For
example
if
you
wanted
a
r
&
h6j
ubj
)
r
'
}
r
(
(
h5X
:
class
:
NonCallableMock
r
)
h6j
h7h
:
h
<
j
h
>
}
r
*
(
U
reftyper
+
X
classr
j
j
X
NonCallableMockr
-
U
refdomainr
.
X
pyr
/
hF
]
r0
hD
]
r1
U
refexplicitr2
h
]
r3
hB
]
r4
hH
]
r5
j
j
j
Nj
j
uhJK
h0
]
r6
j
)
r7
}
r8
(
h5j
)
h
>
}
r9
(
h
]
r
:
hB
]
r
;
(
j
%
j
/
X
py
-
classr
<
ehD
]
r
=
hF
]
r
>
hH
]
r
?
uh6j
'
h0
]
r
hYX
NonCallableMockrA
rB
}
rC
(
h5U
h6j7
ubah
<
j
.
ubaubhYX
to
be
used
:
rD
rE
}
rF
(
h5X
to
be
used
:
rG
h6j
ubeubj
)
rH
}
rI
(
h5X
>
>
>
thing
=
object
(
)
>
>
>
with
patch
(
'
__main__
.
thing
'
new_callable
=
NonCallableMock
)
as
mock_thing
:
.
.
.
assert
thing
is
mock_thing
.
.
.
thing
(
)
.
.
.
Traceback
(
most
recent
call
last
)
:
.
.
.
TypeError
:
'
NonCallableMock
'
object
is
not
callablerJ
h6h
h7h
:
h
<
j
h
>
}
rK
(
U
testnodetyperL
X
doctestrM
hehfhF
]
rN
hD
]
rO
h
]
rP
hB
]
rQ
hH
]
rR
U
groupsrS
]
rT
hnaho
}
rU
uhJK
hKh
h0
]
rV
hYX
>
>
>
thing
=
object
(
)
>
>
>
with
patch
(
'
__main__
.
thing
'
new_callable
=
NonCallableMock
)
as
mock_thing
:
.
.
.
assert
thing
is
mock_thing
.
.
.
thing
(
)
.
.
.
Traceback
(
most
recent
call
last
)
:
.
.
.
TypeError
:
'
NonCallableMock
'
object
is
not
callablerW
rX
}
rY
(
h5U
h6jH
ubaubh
)
rZ
}
r
[
(
h5XJ
Another
use
case
might
be
to
replace
an
object
with
a
StringIO
instance
:
r
\
h6h
h7h
:
h
<
h
h
>
}
r
]
(
h
]
r
^
hB
]
r_
hD
]
r
hF
]
ra
hH
]
rb
uhJK
hKh
h0
]
rc
(
hYX6
Another
use
case
might
be
to
replace
an
object
with
a
rd
re
}
rf
(
h5X6
Another
use
case
might
be
to
replace
an
object
with
a
rg
h6jZ
ubh
)
rh
}
ri
(
h5X
StringIO
rj
h
>
}
rk
(
h
]
rl
hB
]
rm
hD
]
rn
hF
]
ro
hH
]
rp
uh6jZ
h0
]
rq
hYX
StringIOrr
rs
}
rt
(
h5U
h6jh
ubah
<
h
ubhYX
instance
:
ru
rv
}
rw
(
h5X
instance
:
rx
h6jZ
ubeubj
)
ry
}
rz
(
h5X
>
>
>
from
StringIO
import
StringIO
>
>
>
def
foo
(
)
:
.
.
.
print
'
Something
'
.
.
.
>
>
>
patch
(
'
sys
.
stdout
'
new_callable
=
StringIO
)
.
.
.
def
test
(
mock_stdout
)
:
.
.
.
foo
(
)
.
.
.
assert
mock_stdout
.
getvalue
(
)
=
=
'
Something
\
n
'
.
.
.
>
>
>
test
(
)
r
{
h6h
h7h
:
h
<
j
h
>
}
r
|
(
U
testnodetyper
}
X
doctestr
~
hehfhF
]
r
hD
]
r
h
]
r
hB
]
r
hH
]
r
U
groupsr
]
r
hnaho
}
r
uhJK
hKh
h0
]
r
hYX
>
>
>
from
StringIO
import
StringIO
>
>
>
def
foo
(
)
:
.
.
.
print
'
Something
'
.
.
.
>
>
>
patch
(
'
sys
.
stdout
'
new_callable
=
StringIO
)
.
.
.
def
test
(
mock_stdout
)
:
.
.
.
foo
(
)
.
.
.
assert
mock_stdout
.
getvalue
(
)
=
=
'
Something
\
n
'
.
.
.
>
>
>
test
(
)
r
r
}
r
(
h5U
h6jy
ubaubh
)
r
}
r
(
h5X
When
patch
is
creating
a
mock
for
you
it
is
common
that
the
first
thing
you
need
to
do
is
to
configure
the
mock
.
Some
of
that
configuration
can
be
done
in
the
call
to
patch
.
Any
arbitrary
keywords
you
pass
into
the
call
will
be
used
to
set
attributes
on
the
created
mock
:
r
h6h
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJK
hKh
h0
]
r
(
hYX
When
r
r
}
r
(
h5X
When
r
h6j
ubh
)
r
}
r
(
h5X
patch
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
patchr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
is
creating
a
mock
for
you
it
is
common
that
the
first
thing
you
need
to
do
is
to
configure
the
mock
.
Some
of
that
configuration
can
be
done
in
the
call
to
patch
.
Any
arbitrary
keywords
you
pass
into
the
call
will
be
used
to
set
attributes
on
the
created
mock
:
r
r
}
r
(
h5X
is
creating
a
mock
for
you
it
is
common
that
the
first
thing
you
need
to
do
is
to
configure
the
mock
.
Some
of
that
configuration
can
be
done
in
the
call
to
patch
.
Any
arbitrary
keywords
you
pass
into
the
call
will
be
used
to
set
attributes
on
the
created
mock
:
r
h6j
ubeubj
)
r
}
r
(
h5X
>
>
>
patcher
=
patch
(
'
__main__
.
thing
'
first
=
'
one
'
second
=
'
two
'
)
>
>
>
mock_thing
=
patcher
.
start
(
)
>
>
>
mock_thing
.
first
'
one
'
>
>
>
mock_thing
.
second
'
two
'
r
h6h
h7h
:
h
<
j
h
>
}
r
(
U
testnodetyper
X
doctestr
hehfhF
]
r
hD
]
r
h
]
r
hB
]
r
hH
]
r
U
groupsr
]
r
hnaho
}
r
uhJK
hKh
h0
]
r
hYX
>
>
>
patcher
=
patch
(
'
__main__
.
thing
'
first
=
'
one
'
second
=
'
two
'
)
>
>
>
mock_thing
=
patcher
.
start
(
)
>
>
>
mock_thing
.
first
'
one
'
>
>
>
mock_thing
.
second
'
two
'
r
r
}
r
(
h5U
h6j
ubaubh
)
r
}
r
(
h5XD
As
well
as
attributes
on
the
created
mock
attributes
like
the
:
attr
:
~
Mock
.
return_value
and
:
attr
:
~
Mock
.
side_effect
of
child
mocks
can
also
be
configured
.
These
aren
'
t
syntactically
valid
to
pass
in
directly
as
keyword
arguments
but
a
dictionary
with
these
as
keys
can
still
be
expanded
into
a
patch
call
using
*
*
:
r
h6h
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJK
hKh
h0
]
r
(
hYX
?
As
well
as
attributes
on
the
created
mock
attributes
like
the
r
r
}
r
(
h5X
?
As
well
as
attributes
on
the
created
mock
attributes
like
the
r
h6j
ubj
)
r
}
r
(
h5X
:
attr
:
~
Mock
.
return_value
r
h6j
h7h
:
h
<
j
h
>
}
r
(
U
reftyper
X
attrr
j
j
X
Mock
.
return_valuer
U
refdomainr
X
pyr
hF
]
r
hD
]
r
U
refexplicitr
h
]
r
hB
]
r
hH
]
r
j
j
j
Nj
j
uhJK
h0
]
r
j
)
r
}
r
(
h5j
h
>
}
r
(
h
]
r
hB
]
r
(
j
%
j
X
py
-
attrr
ehD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
return_valuer
r
}
r
(
h5U
h6j
ubah
<
j
.
ubaubhYX
and
r
r
}
r
(
h5X
and
r
h6j
ubj
)
r
}
r
(
h5X
:
attr
:
~
Mock
.
side_effect
r
h6j
h7h
:
h
<
j
h
>
}
r
(
U
reftyper
X
attrr
j
j
X
Mock
.
side_effectr
U
refdomainr
X
pyr
hF
]
r
hD
]
r
U
refexplicitr
h
]
r
hB
]
r
hH
]
r
j
j
j
Nj
j
uhJK
h0
]
r
j
)
r
}
r
(
h5j
h
>
}
r
(
h
]
r
hB
]
r
(
j
%
j
X
py
-
attrr
ehD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
side_effectr
r
}
r
(
h5U
h6j
ubah
<
j
.
ubaubhYX
of
child
mocks
can
also
be
configured
.
These
aren
'
t
syntactically
valid
to
pass
in
directly
as
keyword
arguments
but
a
dictionary
with
these
as
keys
can
still
be
expanded
into
a
r
r
}
r
(
h5X
of
child
mocks
can
also
be
configured
.
These
aren
'
t
syntactically
valid
to
pass
in
directly
as
keyword
arguments
but
a
dictionary
with
these
as
keys
can
still
be
expanded
into
a
r
h6j
ubh
)
r
}
r
(
h5X
patch
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
patchr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
call
using
r
r
}
r
(
h5X
call
using
r
h6j
ubh
)
r
}
r
(
h5X
*
*
r
h
>
}
r
(
h
]
r
!
hB
]
r
"
hD
]
r
#
hF
]
r
hH
]
r
%
uh6j
h0
]
r
&
hYX
*
*
r
'
r
(
}
r
)
(
h5U
h6j
ubah
<
h
ubhYX
:
r
*
}
r
+
(
h5X
:
h6j
ubeubj
)
r
}
r
-
(
h5X
>
>
>
config
=
{
'
method
.
return_value
'
:
3
'
other
.
side_effect
'
:
KeyError
}
>
>
>
patcher
=
patch
(
'
__main__
.
thing
'
*
*
config
)
>
>
>
mock_thing
=
patcher
.
start
(
)
>
>
>
mock_thing
.
method
(
)
3
>
>
>
mock_thing
.
other
(
)
Traceback
(
most
recent
call
last
)
:
.
.
.
KeyErrorr
.
h6h
h7h
:
h
<
j
h
>
}
r
/
(
U
testnodetyper0
X
doctestr1
hehfhF
]
r2
hD
]
r3
h
]
r4
hB
]
r5
hH
]
r6
U
groupsr7
]
r8
hnaho
}
r9
uhJK
hKh
h0
]
r
:
hYX
>
>
>
config
=
{
'
method
.
return_value
'
:
3
'
other
.
side_effect
'
:
KeyError
}
>
>
>
patcher
=
patch
(
'
__main__
.
thing
'
*
*
config
)
>
>
>
mock_thing
=
patcher
.
start
(
)
>
>
>
mock_thing
.
method
(
)
3
>
>
>
mock_thing
.
other
(
)
Traceback
(
most
recent
call
last
)
:
.
.
.
KeyErrorr
;
r
<
}
r
=
(
h5U
h6j
ubaubeubh2
)
r
>
}
r
?
(
h5U
h
K
h6h3h7h
:
h
<
h
=
h
>
}
r
(
h
]
rA
hB
]
rB
hD
]
rC
hF
]
rD
h
+
ahH
]
rE
h
auhJK
hKh
h0
]
rF
(
hM
)
rG
}
rH
(
h5X
patch
.
objectrI
h6j
>
h7h
:
h
<
hQh
>
}
rJ
(
h
]
rK
hB
]
rL
hD
]
rM
hF
]
rN
hH
]
rO
uhJK
hKh
h0
]
rP
hYX
patch
.
objectrQ
rR
}
rS
(
h5jI
h6jG
ubaubh
)
rT
}
rU
(
h5U
h6j
>
h7h
:
h
<
h
h
>
}
rV
(
hF
]
rW
hD
]
rX
h
]
rY
hB
]
rZ
hH
]
r
[
U
entriesr
\
]
r
]
(
h
X
patch
.
object
(
)
(
in
module
mock
)
h
U
tr
^
auhJNhKh
h0
]
r_
ubh
)
r
}
ra
(
h5U
h6j
>
h7h
:
h
<
h
h
>
}
rb
(
h
j
X
pyrc
hF
]
rd
hD
]
re
h
]
rf
hB
]
rg
hH
]
rh
j
X
functionri
j
ji
uhJNhKh
h0
]
rj
(
j
)
rk
}
rl
(
h5X
patch
.
object
(
target
attribute
new
=
DEFAULT
spec
=
None
create
=
False
spec_set
=
None
autospec
=
None
new_callable
=
None
*
*
kwargs
)
rm
h6j
h7h
:
h
<
j
h
>
}
rn
(
hF
]
ro
h
aj
j
hD
]
rp
h
]
rq
hB
]
rr
hH
]
rs
h
aj
X
patch
.
objectrt
j
X
patchru
j
uhJK
hKh
h0
]
rv
(
csphinx
.
addnodes
desc_addname
rw
)
rx
}
ry
(
h5X
patch
.
rz
h6jk
h7h
:
h
<
U
desc_addnamer
{
h
>
}
r
|
(
h
]
r
}
hB
]
r
~
hD
]
r
hF
]
r
hH
]
r
uhJK
hKh
h0
]
r
hYX
patch
.
r
r
}
r
(
h5U
h6jx
ubaubj
)
r
}
r
(
h5X
objectr
h6jk
h7h
:
h
<
j
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJK
hKh
h0
]
r
hYX
objectr
r
}
r
(
h5U
h6j
ubaubj
+
)
r
}
r
(
h5U
h6jk
h7h
:
h
<
j
.
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJK
hKh
h0
]
r
(
j6
)
r
}
r
(
h5X
targetr
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
targetr
r
}
r
(
h5U
h6j
ubah
<
jD
ubj6
)
r
}
r
(
h5X
attributer
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
attributer
r
}
r
(
h5U
h6j
ubah
<
jD
ubj6
)
r
}
r
(
h5X
new
=
DEFAULTr
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
new
=
DEFAULTr
r
}
r
(
h5U
h6j
ubah
<
jD
ubj6
)
r
}
r
(
h5X
spec
=
Noner
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
spec
=
Noner
r
}
r
(
h5U
h6j
ubah
<
jD
ubj6
)
r
}
r
(
h5X
create
=
Falser
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
create
=
Falser
r
}
r
(
h5U
h6j
ubah
<
jD
ubj6
)
r
}
r
(
h5X
spec_set
=
Noner
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
spec_set
=
Noner
r
}
r
(
h5U
h6j
ubah
<
jD
ubj6
)
r
}
r
(
h5X
autospec
=
Noner
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
autospec
=
Noner
r
}
r
(
h5U
h6j
ubah
<
jD
ubj6
)
r
}
r
(
h5X
new_callable
=
Noner
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
new_callable
=
Noner
r
}
r
(
h5U
h6j
ubah
<
jD
ubj6
)
r
}
r
(
h5X
*
*
kwargsr
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
*
*
kwargsr
r
}
r
(
h5U
h6j
ubah
<
jD
ubeubeubj
)
r
}
r
(
h5U
h6j
h7h
:
h
<
j
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJK
hKh
h0
]
r
(
h
)
r
}
r
(
h5XP
patch
the
named
member
(
attribute
)
on
an
object
(
target
)
with
a
mock
object
.
r
h6j
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
!
hH
]
r
"
uhJK
hKh
h0
]
r
#
(
hYX
patch
the
named
member
(
r
r
%
}
r
&
(
h5X
patch
the
named
member
(
r
'
h6j
ubh
)
r
(
}
r
)
(
h5X
attribute
r
*
h
>
}
r
+
(
h
]
r
hB
]
r
-
hD
]
r
.
hF
]
r
/
hH
]
r0
uh6j
h0
]
r1
hYX
attributer2
r3
}
r4
(
h5U
h6j
(
ubah
<
h
ubhYX
)
on
an
object
(
r5
r6
}
r7
(
h5X
)
on
an
object
(
r8
h6j
ubh
)
r9
}
r
:
(
h5X
target
r
;
h
>
}
r
<
(
h
]
r
=
hB
]
r
>
hD
]
r
?
hF
]
r
hH
]
rA
uh6j
h0
]
rB
hYX
targetrC
rD
}
rE
(
h5U
h6j9
ubah
<
h
ubhYX
)
with
a
mock
object
.
rF
rG
}
rH
(
h5X
)
with
a
mock
object
.
rI
h6j
ubeubh
)
rJ
}
rK
(
h5X
.
patch
.
object
can
be
used
as
a
decorator
class
decorator
or
a
context
manager
.
Arguments
new
spec
create
spec_set
autospec
and
new_callable
have
the
same
meaning
as
for
patch
.
Like
patch
patch
.
object
takes
arbitrary
keyword
arguments
for
configuring
the
mock
object
it
creates
.
rL
h6j
h7h
:
h
<
h
h
>
}
rM
(
h
]
rN
hB
]
rO
hD
]
rP
hF
]
rQ
hH
]
rR
uhJK
hKh
h0
]
rS
(
h
)
rT
}
rU
(
h5X
patch
.
object
rV
h
>
}
rW
(
h
]
rX
hB
]
rY
hD
]
rZ
hF
]
r
[
hH
]
r
\
uh6jJ
h0
]
r
]
hYX
patch
.
objectr
^
r_
}
r
(
h5U
h6jT
ubah
<
h
ubhYXM
can
be
used
as
a
decorator
class
decorator
or
a
context
manager
.
Arguments
ra
rb
}
rc
(
h5XM
can
be
used
as
a
decorator
class
decorator
or
a
context
manager
.
Arguments
rd
h6jJ
ubh
)
re
}
rf
(
h5X
new
rg
h
>
}
rh
(
h
]
ri
hB
]
rj
hD
]
rk
hF
]
rl
hH
]
rm
uh6jJ
h0
]
rn
hYX
newro
rp
}
rq
(
h5U
h6je
ubah
<
h
ubhYX
rr
rs
}
rt
(
h5X
ru
h6jJ
ubh
)
rv
}
rw
(
h5X
spec
rx
h
>
}
ry
(
h
]
rz
hB
]
r
{
hD
]
r
|
hF
]
r
}
hH
]
r
~
uh6jJ
h0
]
r
hYX
specr
r
}
r
(
h5U
h6jv
ubah
<
h
ubhYX
r
r
}
r
(
h5X
r
h6jJ
ubh
)
r
}
r
(
h5X
create
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jJ
h0
]
r
hYX
creater
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
r
r
}
r
(
h5X
r
h6jJ
ubh
)
r
}
r
(
h5X
spec_set
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jJ
h0
]
r
hYX
spec_setr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
r
r
}
r
(
h5X
r
h6jJ
ubh
)
r
}
r
(
h5X
autospec
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jJ
h0
]
r
hYX
autospecr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
and
r
r
}
r
(
h5X
and
r
h6jJ
ubh
)
r
}
r
(
h5X
new_callable
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jJ
h0
]
r
hYX
new_callabler
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
have
the
same
meaning
as
for
r
r
}
r
(
h5X
have
the
same
meaning
as
for
r
h6jJ
ubh
)
r
}
r
(
h5X
patch
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jJ
h0
]
r
hYX
patchr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
.
Like
r
r
}
r
(
h5X
.
Like
r
h6jJ
ubh
)
r
}
r
(
h5X
patch
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jJ
h0
]
r
hYX
patchr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
r
r
}
r
(
h5X
r
h6jJ
ubh
)
r
}
r
(
h5X
patch
.
object
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jJ
h0
]
r
hYX
patch
.
objectr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYXN
takes
arbitrary
keyword
arguments
for
configuring
the
mock
object
it
creates
.
r
r
}
r
(
h5XN
takes
arbitrary
keyword
arguments
for
configuring
the
mock
object
it
creates
.
r
h6jJ
ubeubh
)
r
}
r
(
h5Xm
When
used
as
a
class
decorator
patch
.
object
honours
patch
.
TEST_PREFIX
for
choosing
which
methods
to
wrap
.
r
h6j
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJK
hKh
h0
]
r
(
hYX
When
used
as
a
class
decorator
r
r
}
r
(
h5X
When
used
as
a
class
decorator
r
h6j
ubh
)
r
}
r
(
h5X
patch
.
object
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
patch
.
objectr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
honours
r
r
}
r
(
h5X
honours
r
h6j
ubh
)
r
}
r
(
h5X
patch
.
TEST_PREFIX
r
h
>
}
r
(
h
]
r
!
hB
]
r
"
hD
]
r
#
hF
]
r
hH
]
r
%
uh6j
h0
]
r
&
hYX
patch
.
TEST_PREFIXr
'
r
(
}
r
)
(
h5U
h6j
ubah
<
h
ubhYX
for
choosing
which
methods
to
wrap
.
r
*
r
+
}
r
(
h5X
for
choosing
which
methods
to
wrap
.
r
-
h6j
ubeubeubeubh
)
r
.
}
r
/
(
h5X
You
can
either
call
patch
.
object
with
three
arguments
or
two
arguments
.
The
three
argument
form
takes
the
object
to
be
patched
the
attribute
name
and
the
object
to
replace
the
attribute
with
.
r0
h6j
>
h7h
:
h
<
h
h
>
}
r1
(
h
]
r2
hB
]
r3
hD
]
r4
hF
]
r5
hH
]
r6
uhJK
hKh
h0
]
r7
(
hYX
You
can
either
call
r8
r9
}
r
:
(
h5X
You
can
either
call
r
;
h6j
.
ubh
)
r
<
}
r
=
(
h5X
patch
.
object
r
>
h
>
}
r
?
(
h
]
r
hB
]
rA
hD
]
rB
hF
]
rC
hH
]
rD
uh6j
.
h0
]
rE
hYX
patch
.
objectrF
rG
}
rH
(
h5U
h6j
<
ubah
<
h
ubhYX
with
three
arguments
or
two
arguments
.
The
three
argument
form
takes
the
object
to
be
patched
the
attribute
name
and
the
object
to
replace
the
attribute
with
.
rI
rJ
}
rK
(
h5X
with
three
arguments
or
two
arguments
.
The
three
argument
form
takes
the
object
to
be
patched
the
attribute
name
and
the
object
to
replace
the
attribute
with
.
rL
h6j
.
ubeubh
)
rM
}
rN
(
h5X
When
calling
with
the
two
argument
form
you
omit
the
replacement
object
and
a
mock
is
created
for
you
and
passed
in
as
an
extra
argument
to
the
decorated
function
:
rO
h6j
>
h7h
:
h
<
h
h
>
}
rP
(
h
]
rQ
hB
]
rR
hD
]
rS
hF
]
rT
hH
]
rU
uhJK
hKh
h0
]
rV
hYX
When
calling
with
the
two
argument
form
you
omit
the
replacement
object
and
a
mock
is
created
for
you
and
passed
in
as
an
extra
argument
to
the
decorated
function
:
rW
rX
}
rY
(
h5jO
h6jM
ubaubj
)
rZ
}
r
[
(
h5X
>
>
>
patch
.
object
(
SomeClass
'
class_method
'
)
.
.
.
def
test
(
mock_method
)
:
.
.
.
SomeClass
.
class_method
(
3
)
.
.
.
mock_method
.
assert_called_with
(
3
)
.
.
.
>
>
>
test
(
)
r
\
h6j
>
h7h
:
h
<
j
h
>
}
r
]
(
U
testnodetyper
^
X
doctestr_
hehfhF
]
r
hD
]
ra
h
]
rb
hB
]
rc
hH
]
rd
U
groupsre
]
rf
hnaho
}
rg
uhJK
hKh
h0
]
rh
hYX
>
>
>
patch
.
object
(
SomeClass
'
class_method
'
)
.
.
.
def
test
(
mock_method
)
:
.
.
.
SomeClass
.
class_method
(
3
)
.
.
.
mock_method
.
assert_called_with
(
3
)
.
.
.
>
>
>
test
(
)
ri
rj
}
rk
(
h5U
h6jZ
ubaubh
)
rl
}
rm
(
h5Xh
spec
create
and
the
other
arguments
to
patch
.
object
have
the
same
meaning
as
they
do
for
patch
.
rn
h6j
>
h7h
:
h
<
h
h
>
}
ro
(
h
]
rp
hB
]
rq
hD
]
rr
hF
]
rs
hH
]
rt
uhJM
hKh
h0
]
ru
(
h
)
rv
}
rw
(
h5X
spec
rx
h
>
}
ry
(
h
]
rz
hB
]
r
{
hD
]
r
|
hF
]
r
}
hH
]
r
~
uh6jl
h0
]
r
hYX
specr
r
}
r
(
h5U
h6jv
ubah
<
h
ubhYX
r
r
}
r
(
h5X
r
h6jl
ubh
)
r
}
r
(
h5X
create
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jl
h0
]
r
hYX
creater
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
and
the
other
arguments
to
r
r
}
r
(
h5X
and
the
other
arguments
to
r
h6jl
ubh
)
r
}
r
(
h5X
patch
.
object
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jl
h0
]
r
hYX
patch
.
objectr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
&
have
the
same
meaning
as
they
do
for
r
r
}
r
(
h5X
&
have
the
same
meaning
as
they
do
for
r
h6jl
ubh
)
r
}
r
(
h5X
patch
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jl
h0
]
r
hYX
patchr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
.
r
}
r
(
h5X
.
h6jl
ubeubeubh2
)
r
}
r
(
h5U
h6h3h7h
:
h
<
h
=
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
h
&
ahH
]
r
h
auhJM
hKh
h0
]
r
(
hM
)
r
}
r
(
h5X
patch
.
dictr
h6j
h7h
:
h
<
hQh
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJM
hKh
h0
]
r
hYX
patch
.
dictr
r
}
r
(
h5j
h6j
ubaubh
)
r
}
r
(
h5U
h6j
h7h
:
h
<
h
h
>
}
r
(
hF
]
r
hD
]
r
h
]
r
hB
]
r
hH
]
r
U
entriesr
]
r
(
h
X
patch
.
dict
(
)
(
in
module
mock
)
h
U
tr
auhJNhKh
h0
]
r
ubh
)
r
}
r
(
h5U
h6j
h7h
:
h
<
h
h
>
}
r
(
h
j
X
pyr
hF
]
r
hD
]
r
h
]
r
hB
]
r
hH
]
r
j
X
functionr
j
j
uhJNhKh
h0
]
r
(
j
)
r
}
r
(
h5X5
patch
.
dict
(
in_dict
values
=
(
)
clear
=
False
*
*
kwargs
)
r
h6j
h7h
:
h
<
j
h
>
}
r
(
hF
]
r
h
aj
j
hD
]
r
h
]
r
hB
]
r
hH
]
r
h
aj
X
patch
.
dictr
j
X
patchr
j
uhJM
hKh
h0
]
r
(
jw
)
r
}
r
(
h5X
patch
.
r
h6j
h7h
:
h
<
j
{
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJM
hKh
h0
]
r
hYX
patch
.
r
r
}
r
(
h5U
h6j
ubaubj
)
r
}
r
(
h5X
dictr
h6j
h7h
:
h
<
j
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJM
hKh
h0
]
r
hYX
dictr
r
}
r
(
h5U
h6j
ubaubj
+
)
r
}
r
(
h5U
h6j
h7h
:
h
<
j
.
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJM
hKh
h0
]
r
(
j6
)
r
}
r
(
h5X
in_dictr
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
in_dictr
r
}
r
(
h5U
h6j
ubah
<
jD
ubj6
)
r
!
}
r
"
(
h5X
values
=
(
)
r
#
h
>
}
r
(
h
]
r
%
hB
]
r
&
hD
]
r
'
hF
]
r
(
hH
]
r
)
uh6j
h0
]
r
*
hYX
values
=
(
)
r
+
r
}
r
-
(
h5U
h6j
!
ubah
<
jD
ubj6
)
r
.
}
r
/
(
h5X
clear
=
Falser0
h
>
}
r1
(
h
]
r2
hB
]
r3
hD
]
r4
hF
]
r5
hH
]
r6
uh6j
h0
]
r7
hYX
clear
=
Falser8
r9
}
r
:
(
h5U
h6j
.
ubah
<
jD
ubj6
)
r
;
}
r
<
(
h5X
*
*
kwargsr
=
h
>
}
r
>
(
h
]
r
?
hB
]
r
hD
]
rA
hF
]
rB
hH
]
rC
uh6j
h0
]
rD
hYX
*
*
kwargsrE
rF
}
rG
(
h5U
h6j
;
ubah
<
jD
ubeubeubj
)
rH
}
rI
(
h5U
h6j
h7h
:
h
<
j
h
>
}
rJ
(
h
]
rK
hB
]
rL
hD
]
rM
hF
]
rN
hH
]
rO
uhJM
hKh
h0
]
rP
(
h
)
rQ
}
rR
(
h5Xo
Patch
a
dictionary
or
dictionary
like
object
and
restore
the
dictionary
to
its
original
state
after
the
test
.
rS
h6jH
h7h
:
h
<
h
h
>
}
rT
(
h
]
rU
hB
]
rV
hD
]
rW
hF
]
rX
hH
]
rY
uhJM
hKh
h0
]
rZ
hYXo
Patch
a
dictionary
or
dictionary
like
object
and
restore
the
dictionary
to
its
original
state
after
the
test
.
r
[
r
\
}
r
]
(
h5jS
h6jQ
ubaubh
)
r
^
}
r_
(
h5X
in_dict
can
be
a
dictionary
or
a
mapping
like
container
.
If
it
is
a
mapping
then
it
must
at
least
support
getting
setting
and
deleting
items
plus
iterating
over
keys
.
r
h6jH
h7h
:
h
<
h
h
>
}
ra
(
h
]
rb
hB
]
rc
hD
]
rd
hF
]
re
hH
]
rf
uhJM
hKh
h0
]
rg
(
h
)
rh
}
ri
(
h5X
in_dict
rj
h
>
}
rk
(
h
]
rl
hB
]
rm
hD
]
rn
hF
]
ro
hH
]
rp
uh6j
^
h0
]
rq
hYX
in_dictrr
rs
}
rt
(
h5U
h6jh
ubah
<
h
ubhYX
can
be
a
dictionary
or
a
mapping
like
container
.
If
it
is
a
mapping
then
it
must
at
least
support
getting
setting
and
deleting
items
plus
iterating
over
keys
.
ru
rv
}
rw
(
h5X
can
be
a
dictionary
or
a
mapping
like
container
.
If
it
is
a
mapping
then
it
must
at
least
support
getting
setting
and
deleting
items
plus
iterating
over
keys
.
rx
h6j
^
ubeubh
)
ry
}
rz
(
h5Xq
in_dict
can
also
be
a
string
specifying
the
name
of
the
dictionary
which
will
then
be
fetched
by
importing
it
.
r
{
h6jH
h7h
:
h
<
h
h
>
}
r
|
(
h
]
r
}
hB
]
r
~
hD
]
r
hF
]
r
hH
]
r
uhJM
hKh
h0
]
r
(
h
)
r
}
r
(
h5X
in_dict
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jy
h0
]
r
hYX
in_dictr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYXh
can
also
be
a
string
specifying
the
name
of
the
dictionary
which
will
then
be
fetched
by
importing
it
.
r
r
}
r
(
h5Xh
can
also
be
a
string
specifying
the
name
of
the
dictionary
which
will
then
be
fetched
by
importing
it
.
r
h6jy
ubeubh
)
r
}
r
(
h5Xz
values
can
be
a
dictionary
of
values
to
set
in
the
dictionary
.
values
can
also
be
an
iterable
of
(
key
value
)
pairs
.
r
h6jH
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJM
hKh
h0
]
r
(
h
)
r
}
r
(
h5X
values
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
valuesr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX9
can
be
a
dictionary
of
values
to
set
in
the
dictionary
.
r
r
}
r
(
h5X9
can
be
a
dictionary
of
values
to
set
in
the
dictionary
.
r
h6j
ubh
)
r
}
r
(
h5X
values
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
valuesr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
can
also
be
an
iterable
of
r
r
}
r
(
h5X
can
also
be
an
iterable
of
r
h6j
ubh
)
r
}
r
(
h5X
(
key
value
)
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
(
key
value
)
r
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
pairs
.
r
r
}
r
(
h5X
pairs
.
r
h6j
ubeubh
)
r
}
r
(
h5XU
If
clear
is
True
then
the
dictionary
will
be
cleared
before
the
new
values
are
set
.
r
h6jH
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJM
hKh
h0
]
r
(
hYX
If
r
r
}
r
(
h5X
If
r
h6j
ubh
)
r
}
r
(
h5X
clear
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
clearr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYXK
is
True
then
the
dictionary
will
be
cleared
before
the
new
values
are
set
.
r
r
}
r
(
h5XK
is
True
then
the
dictionary
will
be
cleared
before
the
new
values
are
set
.
r
h6j
ubeubh
)
r
}
r
(
h5Xa
patch
.
dict
can
also
be
called
with
arbitrary
keyword
arguments
to
set
values
in
the
dictionary
.
r
h6jH
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJM
hKh
h0
]
r
(
h
)
r
}
r
(
h5X
patch
.
dict
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
patch
.
dictr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYXU
can
also
be
called
with
arbitrary
keyword
arguments
to
set
values
in
the
dictionary
.
r
r
}
r
(
h5XU
can
also
be
called
with
arbitrary
keyword
arguments
to
set
values
in
the
dictionary
.
r
h6j
ubeubh
)
r
}
r
(
h5X
patch
.
dict
can
be
used
as
a
context
manager
decorator
or
class
decorator
.
When
used
as
a
class
decorator
patch
.
dict
honours
patch
.
TEST_PREFIX
for
choosing
which
methods
to
wrap
.
r
h6jH
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJM
hKh
h0
]
r
(
h
)
r
}
r
(
h5X
patch
.
dict
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
patch
.
dictr
r
}
r
!
(
h5U
h6j
ubah
<
h
ubhYX
can
be
used
as
a
context
manager
decorator
or
class
decorator
.
When
used
as
a
class
decorator
r
"
r
#
}
r
(
h5X
can
be
used
as
a
context
manager
decorator
or
class
decorator
.
When
used
as
a
class
decorator
r
%
h6j
ubh
)
r
&
}
r
'
(
h5X
patch
.
dict
r
(
h
>
}
r
)
(
h
]
r
*
hB
]
r
+
hD
]
r
hF
]
r
-
hH
]
r
.
uh6j
h0
]
r
/
hYX
patch
.
dictr0
r1
}
r2
(
h5U
h6j
&
ubah
<
h
ubhYX
honours
r3
r4
}
r5
(
h5X
honours
r6
h6j
ubh
)
r7
}
r8
(
h5X
patch
.
TEST_PREFIX
r9
h
>
}
r
:
(
h
]
r
;
hB
]
r
<
hD
]
r
=
hF
]
r
>
hH
]
r
?
uh6j
h0
]
r
hYX
patch
.
TEST_PREFIXrA
rB
}
rC
(
h5U
h6j7
ubah
<
h
ubhYX
for
choosing
which
methods
to
wrap
.
rD
rE
}
rF
(
h5X
for
choosing
which
methods
to
wrap
.
rG
h6j
ubeubeubeubh
)
rH
}
rI
(
h5X
patch
.
dict
can
be
used
to
add
members
to
a
dictionary
or
simply
let
a
test
change
a
dictionary
and
ensure
the
dictionary
is
restored
when
the
test
ends
.
rJ
h6j
h7h
:
h
<
h
h
>
}
rK
(
h
]
rL
hB
]
rM
hD
]
rN
hF
]
rO
hH
]
rP
uhJM
!
hKh
h0
]
rQ
(
h
)
rR
}
rS
(
h5X
patch
.
dict
rT
h
>
}
rU
(
h
]
rV
hB
]
rW
hD
]
rX
hF
]
rY
hH
]
rZ
uh6jH
h0
]
r
[
hYX
patch
.
dictr
\
r
]
}
r
^
(
h5U
h6jR
ubah
<
h
ubhYX
can
be
used
to
add
members
to
a
dictionary
or
simply
let
a
test
change
a
dictionary
and
ensure
the
dictionary
is
restored
when
the
test
ends
.
r_
r
}
ra
(
h5X
can
be
used
to
add
members
to
a
dictionary
or
simply
let
a
test
change
a
dictionary
and
ensure
the
dictionary
is
restored
when
the
test
ends
.
rb
h6jH
ubeubj
)
rc
}
rd
(
h5X
?
>
>
>
from
mock
import
patch
>
>
>
foo
=
{
}
>
>
>
with
patch
.
dict
(
foo
{
'
newkey
'
:
'
newvalue
'
}
)
:
.
.
.
assert
foo
=
=
{
'
newkey
'
:
'
newvalue
'
}
.
.
.
>
>
>
assert
foo
=
=
{
}
>
>
>
import
os
>
>
>
with
patch
.
dict
(
'
os
.
environ
'
{
'
newkey
'
:
'
newvalue
'
}
)
:
.
.
.
print
os
.
environ
[
'
newkey
'
]
.
.
.
newvalue
>
>
>
assert
'
newkey
'
not
in
os
.
environre
h6j
h7h
:
h
<
j
h
>
}
rf
(
U
testnodetyperg
X
doctestrh
hehfhF
]
ri
hD
]
rj
h
]
rk
hB
]
rl
hH
]
rm
U
groupsrn
]
ro
hnaho
}
rp
uhJM
%
hKh
h0
]
rq
hYX
?
>
>
>
from
mock
import
patch
>
>
>
foo
=
{
}
>
>
>
with
patch
.
dict
(
foo
{
'
newkey
'
:
'
newvalue
'
}
)
:
.
.
.
assert
foo
=
=
{
'
newkey
'
:
'
newvalue
'
}
.
.
.
>
>
>
assert
foo
=
=
{
}
>
>
>
import
os
>
>
>
with
patch
.
dict
(
'
os
.
environ
'
{
'
newkey
'
:
'
newvalue
'
}
)
:
.
.
.
print
os
.
environ
[
'
newkey
'
]
.
.
.
newvalue
>
>
>
assert
'
newkey
'
not
in
os
.
environrr
rs
}
rt
(
h5U
h6jc
ubaubh
)
ru
}
rv
(
h5XN
Keywords
can
be
used
in
the
patch
.
dict
call
to
set
values
in
the
dictionary
:
rw
h6j
h7h
:
h
<
h
h
>
}
rx
(
h
]
ry
hB
]
rz
hD
]
r
{
hF
]
r
|
hH
]
r
}
uhJM5
hKh
h0
]
r
~
(
hYX
Keywords
can
be
used
in
the
r
r
}
r
(
h5X
Keywords
can
be
used
in
the
r
h6ju
ubh
)
r
}
r
(
h5X
patch
.
dict
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6ju
h0
]
r
hYX
patch
.
dictr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
&
call
to
set
values
in
the
dictionary
:
r
r
}
r
(
h5X
&
call
to
set
values
in
the
dictionary
:
r
h6ju
ubeubj
)
r
}
r
(
h5X
>
>
>
mymodule
=
MagicMock
(
)
>
>
>
mymodule
.
function
.
return_value
=
'
fish
'
>
>
>
with
patch
.
dict
(
'
sys
.
modules
'
mymodule
=
mymodule
)
:
.
.
.
import
mymodule
.
.
.
mymodule
.
function
(
'
some
'
'
args
'
)
.
.
.
'
fish
'
r
h6j
h7h
:
h
<
j
h
>
}
r
(
U
testnodetyper
X
doctestr
hehfhF
]
r
hD
]
r
h
]
r
hB
]
r
hH
]
r
U
groupsr
]
r
hnaho
}
r
uhJM7
hKh
h0
]
r
hYX
>
>
>
mymodule
=
MagicMock
(
)
>
>
>
mymodule
.
function
.
return_value
=
'
fish
'
>
>
>
with
patch
.
dict
(
'
sys
.
modules
'
mymodule
=
mymodule
)
:
.
.
.
import
mymodule
.
.
.
mymodule
.
function
(
'
some
'
'
args
'
)
.
.
.
'
fish
'
r
r
}
r
(
h5U
h6j
ubaubh
)
r
}
r
(
h5XB
patch
.
dict
can
be
used
with
dictionary
like
objects
that
aren
'
t
actually
dictionaries
.
At
the
very
minimum
they
must
support
item
getting
setting
deleting
and
either
iteration
or
membership
test
.
This
corresponds
to
the
magic
methods
__getitem__
__setitem__
__delitem__
and
either
__iter__
or
__contains__
.
r
h6j
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJMA
hKh
h0
]
r
(
h
)
r
}
r
(
h5X
patch
.
dict
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
patch
.
dictr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
can
be
used
with
dictionary
like
objects
that
aren
'
t
actually
dictionaries
.
At
the
very
minimum
they
must
support
item
getting
setting
deleting
and
either
iteration
or
membership
test
.
This
corresponds
to
the
magic
methods
r
r
}
r
(
h5X
can
be
used
with
dictionary
like
objects
that
aren
'
t
actually
dictionaries
.
At
the
very
minimum
they
must
support
item
getting
setting
deleting
and
either
iteration
or
membership
test
.
This
corresponds
to
the
magic
methods
r
h6j
ubh
)
r
}
r
(
h5X
__getitem__
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
__getitem__r
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
r
r
}
r
(
h5X
r
h6j
ubh
)
r
}
r
(
h5X
__setitem__
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
__setitem__r
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
r
r
}
r
(
h5X
r
h6j
ubh
)
r
}
r
(
h5X
__delitem__
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
__delitem__r
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
and
either
r
r
}
r
(
h5X
and
either
r
h6j
ubh
)
r
}
r
(
h5X
__iter__
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
__iter__r
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
or
r
r
}
r
(
h5X
or
r
h6j
ubh
)
r
}
r
(
h5X
__contains__
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
__contains__r
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
.
r
}
r
(
h5X
.
h6j
ubeubj
)
r
}
r
(
h5XY
>
>
>
class
Container
(
object
)
:
.
.
.
def
__init__
(
self
)
:
.
.
.
self
.
values
=
{
}
.
.
.
def
__getitem__
(
self
name
)
:
.
.
.
return
self
.
values
[
name
]
.
.
.
def
__setitem__
(
self
name
value
)
:
.
.
.
self
.
values
[
name
]
=
value
.
.
.
def
__delitem__
(
self
name
)
:
.
.
.
del
self
.
values
[
name
]
.
.
.
def
__iter__
(
self
)
:
.
.
.
return
iter
(
self
.
values
)
.
.
.
>
>
>
thing
=
Container
(
)
>
>
>
thing
[
'
one
'
]
=
1
>
>
>
with
patch
.
dict
(
thing
one
=
2
two
=
3
)
:
.
.
.
assert
thing
[
'
one
'
]
=
=
2
.
.
.
assert
thing
[
'
two
'
]
=
=
3
.
.
.
>
>
>
assert
thing
[
'
one
'
]
=
=
1
>
>
>
assert
list
(
thing
)
=
=
[
'
one
'
]
r
h6j
h7h
:
h
<
j
h
>
}
r
(
U
testnodetyper
X
doctestr
hehfhF
]
r
hD
]
r
h
]
r
hB
]
r
hH
]
r
U
groupsr
]
r
hnaho
}
r
!
uhJMG
hKh
h0
]
r
"
hYXY
>
>
>
class
Container
(
object
)
:
.
.
.
def
__init__
(
self
)
:
.
.
.
self
.
values
=
{
}
.
.
.
def
__getitem__
(
self
name
)
:
.
.
.
return
self
.
values
[
name
]
.
.
.
def
__setitem__
(
self
name
value
)
:
.
.
.
self
.
values
[
name
]
=
value
.
.
.
def
__delitem__
(
self
name
)
:
.
.
.
del
self
.
values
[
name
]
.
.
.
def
__iter__
(
self
)
:
.
.
.
return
iter
(
self
.
values
)
.
.
.
>
>
>
thing
=
Container
(
)
>
>
>
thing
[
'
one
'
]
=
1
>
>
>
with
patch
.
dict
(
thing
one
=
2
two
=
3
)
:
.
.
.
assert
thing
[
'
one
'
]
=
=
2
.
.
.
assert
thing
[
'
two
'
]
=
=
3
.
.
.
>
>
>
assert
thing
[
'
one
'
]
=
=
1
>
>
>
assert
list
(
thing
)
=
=
[
'
one
'
]
r
#
r
}
r
%
(
h5U
h6j
ubaubeubh2
)
r
&
}
r
'
(
h5U
h6h3h7h
:
h
<
h
=
h
>
}
r
(
(
h
]
r
)
hB
]
r
*
hD
]
r
+
hF
]
r
h
ahH
]
r
-
h
auhJM
hKh
h0
]
r
.
(
hM
)
r
/
}
r0
(
h5X
patch
.
multipler1
h6j
&
h7h
:
h
<
hQh
>
}
r2
(
h
]
r3
hB
]
r4
hD
]
r5
hF
]
r6
hH
]
r7
uhJM
hKh
h0
]
r8
hYX
patch
.
multipler9
r
:
}
r
;
(
h5j1
h6j
/
ubaubh
)
r
<
}
r
=
(
h5U
h6j
&
h7h
:
h
<
h
h
>
}
r
>
(
hF
]
r
?
hD
]
r
h
]
rA
hB
]
rB
hH
]
rC
U
entriesrD
]
rE
(
h
X
!
patch
.
multiple
(
)
(
in
module
mock
)
h
U
trF
auhJNhKh
h0
]
rG
ubh
)
rH
}
rI
(
h5U
h6j
&
h7h
:
h
<
h
h
>
}
rJ
(
h
j
X
pyrK
hF
]
rL
hD
]
rM
h
]
rN
hB
]
rO
hH
]
rP
j
X
functionrQ
j
jQ
uhJNhKh
h0
]
rR
(
j
)
rS
}
rT
(
h5Xj
patch
.
multiple
(
target
spec
=
None
create
=
False
spec_set
=
None
autospec
=
None
new_callable
=
None
*
*
kwargs
)
rU
h6jH
h7h
:
h
<
j
h
>
}
rV
(
hF
]
rW
h
aj
j
hD
]
rX
h
]
rY
hB
]
rZ
hH
]
r
[
h
aj
X
patch
.
multipler
\
j
X
patchr
]
j
uhJMw
hKh
h0
]
r
^
(
jw
)
r_
}
r
(
h5X
patch
.
ra
h6jS
h7h
:
h
<
j
{
h
>
}
rb
(
h
]
rc
hB
]
rd
hD
]
re
hF
]
rf
hH
]
rg
uhJMw
hKh
h0
]
rh
hYX
patch
.
ri
rj
}
rk
(
h5U
h6j_
ubaubj
)
rl
}
rm
(
h5X
multiplern
h6jS
h7h
:
h
<
j
h
>
}
ro
(
h
]
rp
hB
]
rq
hD
]
rr
hF
]
rs
hH
]
rt
uhJMw
hKh
h0
]
ru
hYX
multiplerv
rw
}
rx
(
h5U
h6jl
ubaubj
+
)
ry
}
rz
(
h5U
h6jS
h7h
:
h
<
j
.
h
>
}
r
{
(
h
]
r
|
hB
]
r
}
hD
]
r
~
hF
]
r
hH
]
r
uhJMw
hKh
h0
]
r
(
j6
)
r
}
r
(
h5X
targetr
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jy
h0
]
r
hYX
targetr
r
}
r
(
h5U
h6j
ubah
<
jD
ubj6
)
r
}
r
(
h5X
spec
=
Noner
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jy
h0
]
r
hYX
spec
=
Noner
r
}
r
(
h5U
h6j
ubah
<
jD
ubj6
)
r
}
r
(
h5X
create
=
Falser
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jy
h0
]
r
hYX
create
=
Falser
r
}
r
(
h5U
h6j
ubah
<
jD
ubj6
)
r
}
r
(
h5X
spec_set
=
Noner
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jy
h0
]
r
hYX
spec_set
=
Noner
r
}
r
(
h5U
h6j
ubah
<
jD
ubj6
)
r
}
r
(
h5X
autospec
=
Noner
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jy
h0
]
r
hYX
autospec
=
Noner
r
}
r
(
h5U
h6j
ubah
<
jD
ubj6
)
r
}
r
(
h5X
new_callable
=
Noner
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jy
h0
]
r
hYX
new_callable
=
Noner
r
}
r
(
h5U
h6j
ubah
<
jD
ubj6
)
r
}
r
(
h5X
*
*
kwargsr
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jy
h0
]
r
hYX
*
*
kwargsr
r
}
r
(
h5U
h6j
ubah
<
jD
ubeubeubj
)
r
}
r
(
h5U
h6jH
h7h
:
h
<
j
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJMw
hKh
h0
]
r
(
h
)
r
}
r
(
h5X
Perform
multiple
patches
in
a
single
call
.
It
takes
the
object
to
be
patched
(
either
as
an
object
or
a
string
to
fetch
the
object
by
importing
)
and
keyword
arguments
for
the
patches
:
:
r
h6j
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJMd
hKh
h0
]
r
hYX
Perform
multiple
patches
in
a
single
call
.
It
takes
the
object
to
be
patched
(
either
as
an
object
or
a
string
to
fetch
the
object
by
importing
)
and
keyword
arguments
for
the
patches
:
r
r
}
r
(
h5X
Perform
multiple
patches
in
a
single
call
.
It
takes
the
object
to
be
patched
(
either
as
an
object
or
a
string
to
fetch
the
object
by
importing
)
and
keyword
arguments
for
the
patches
:
r
h6j
ubaubj
)
r
}
r
(
h5XM
with
patch
.
multiple
(
settings
FIRST_PATCH
=
'
one
'
SECOND_PATCH
=
'
two
'
)
:
.
.
.
r
h6j
h7h
:
h
<
j
h
>
}
r
(
hehfhF
]
r
hD
]
r
h
]
r
hB
]
r
hH
]
r
uhJMh
hKh
h0
]
r
hYXM
with
patch
.
multiple
(
settings
FIRST_PATCH
=
'
one
'
SECOND_PATCH
=
'
two
'
)
:
.
.
.
r
r
}
r
(
h5U
h6j
ubaubh
)
r
}
r
(
h5X
Use
:
data
:
DEFAULT
as
the
value
if
you
want
patch
.
multiple
to
create
mocks
for
you
.
In
this
case
the
created
mocks
are
passed
into
a
decorated
function
by
keyword
and
a
dictionary
is
returned
when
patch
.
multiple
is
used
as
a
context
manager
.
r
h6j
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJMk
hKh
h0
]
r
(
hYX
Use
r
r
}
r
(
h5X
Use
r
h6j
ubj
)
r
}
r
(
h5X
:
data
:
DEFAULT
r
h6j
h7h
:
h
<
j
h
>
}
r
(
U
reftyper
X
datar
j
j
X
DEFAULTr
U
refdomainr
X
pyr
hF
]
r
hD
]
r
U
refexplicitr
h
]
r
hB
]
r
hH
]
r
j
j
j
Nj
j
uhJMk
h0
]
r
j
)
r
}
r
(
h5j
h
>
}
r
!
(
h
]
r
"
hB
]
r
#
(
j
%
j
X
py
-
datar
ehD
]
r
%
hF
]
r
&
hH
]
r
'
uh6j
h0
]
r
(
hYX
DEFAULTr
)
r
*
}
r
+
(
h5U
h6j
ubah
<
j
.
ubaubhYX
as
the
value
if
you
want
r
r
-
}
r
.
(
h5X
as
the
value
if
you
want
r
/
h6j
ubh
)
r0
}
r1
(
h5X
patch
.
multiple
r2
h
>
}
r3
(
h
]
r4
hB
]
r5
hD
]
r6
hF
]
r7
hH
]
r8
uh6j
h0
]
r9
hYX
patch
.
multipler
:
r
;
}
r
<
(
h5U
h6j0
ubah
<
h
ubhYX
to
create
mocks
for
you
.
In
this
case
the
created
mocks
are
passed
into
a
decorated
function
by
keyword
and
a
dictionary
is
returned
when
r
=
r
>
}
r
?
(
h5X
to
create
mocks
for
you
.
In
this
case
the
created
mocks
are
passed
into
a
decorated
function
by
keyword
and
a
dictionary
is
returned
when
r
h6j
ubh
)
rA
}
rB
(
h5X
patch
.
multiple
rC
h
>
}
rD
(
h
]
rE
hB
]
rF
hD
]
rG
hF
]
rH
hH
]
rI
uh6j
h0
]
rJ
hYX
patch
.
multiplerK
rL
}
rM
(
h5U
h6jA
ubah
<
h
ubhYX
is
used
as
a
context
manager
.
rN
rO
}
rP
(
h5X
is
used
as
a
context
manager
.
rQ
h6j
ubeubh
)
rR
}
rS
(
h5X
patch
.
multiple
can
be
used
as
a
decorator
class
decorator
or
a
context
manager
.
The
arguments
spec
spec_set
create
autospec
and
new_callable
have
the
same
meaning
as
for
patch
.
These
arguments
will
be
applied
to
*
all
*
patches
done
by
patch
.
multiple
.
rT
h6j
h7h
:
h
<
h
h
>
}
rU
(
h
]
rV
hB
]
rW
hD
]
rX
hF
]
rY
hH
]
rZ
uhJMp
hKh
h0
]
r
[
(
h
)
r
\
}
r
]
(
h5X
patch
.
multiple
r
^
h
>
}
r_
(
h
]
r
hB
]
ra
hD
]
rb
hF
]
rc
hH
]
rd
uh6jR
h0
]
re
hYX
patch
.
multiplerf
rg
}
rh
(
h5U
h6j
\
ubah
<
h
ubhYXQ
can
be
used
as
a
decorator
class
decorator
or
a
context
manager
.
The
arguments
ri
rj
}
rk
(
h5XQ
can
be
used
as
a
decorator
class
decorator
or
a
context
manager
.
The
arguments
rl
h6jR
ubh
)
rm
}
rn
(
h5X
spec
ro
h
>
}
rp
(
h
]
rq
hB
]
rr
hD
]
rs
hF
]
rt
hH
]
ru
uh6jR
h0
]
rv
hYX
specrw
rx
}
ry
(
h5U
h6jm
ubah
<
h
ubhYX
rz
r
{
}
r
|
(
h5X
r
}
h6jR
ubh
)
r
~
}
r
(
h5X
spec_set
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jR
h0
]
r
hYX
spec_setr
r
}
r
(
h5U
h6j
~
ubah
<
h
ubhYX
r
r
}
r
(
h5X
r
h6jR
ubh
)
r
}
r
(
h5X
create
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jR
h0
]
r
hYX
creater
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
r
r
}
r
(
h5X
r
h6jR
ubh
)
r
}
r
(
h5X
autospec
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jR
h0
]
r
hYX
autospecr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
and
r
r
}
r
(
h5X
and
r
h6jR
ubh
)
r
}
r
(
h5X
new_callable
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jR
h0
]
r
hYX
new_callabler
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
have
the
same
meaning
as
for
r
r
}
r
(
h5X
have
the
same
meaning
as
for
r
h6jR
ubh
)
r
}
r
(
h5X
patch
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jR
h0
]
r
hYX
patchr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
%
.
These
arguments
will
be
applied
to
r
r
}
r
(
h5X
%
.
These
arguments
will
be
applied
to
r
h6jR
ubj
)
r
}
r
(
h5X
*
all
*
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jR
h0
]
r
hYX
allr
r
}
r
(
h5U
h6j
ubah
<
j
ubhYX
patches
done
by
r
r
}
r
(
h5X
patches
done
by
r
h6jR
ubh
)
r
}
r
(
h5X
patch
.
multiple
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6jR
h0
]
r
hYX
patch
.
multipler
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
.
r
}
r
(
h5X
.
h6jR
ubeubh
)
r
}
r
(
h5Xo
When
used
as
a
class
decorator
patch
.
multiple
honours
patch
.
TEST_PREFIX
for
choosing
which
methods
to
wrap
.
r
h6j
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJMu
hKh
h0
]
r
(
hYX
When
used
as
a
class
decorator
r
r
}
r
(
h5X
When
used
as
a
class
decorator
r
h6j
ubh
)
r
}
r
(
h5X
patch
.
multiple
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
patch
.
multipler
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
honours
r
r
}
r
(
h5X
honours
r
h6j
ubh
)
r
}
r
(
h5X
patch
.
TEST_PREFIX
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
patch
.
TEST_PREFIXr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
for
choosing
which
methods
to
wrap
.
r
r
}
r
!
(
h5X
for
choosing
which
methods
to
wrap
.
r
"
h6j
ubeubeubeubh
)
r
#
}
r
(
h5X
If
you
want
patch
.
multiple
to
create
mocks
for
you
then
you
can
use
:
data
:
DEFAULT
as
the
value
.
If
you
use
patch
.
multiple
as
a
decorator
then
the
created
mocks
are
passed
into
the
decorated
function
by
keyword
.
r
%
h6j
&
h7h
:
h
<
h
h
>
}
r
&
(
h
]
r
'
hB
]
r
(
hD
]
r
)
hF
]
r
*
hH
]
r
+
uhJMx
hKh
h0
]
r
(
hYX
If
you
want
r
-
r
.
}
r
/
(
h5X
If
you
want
r0
h6j
#
ubh
)
r1
}
r2
(
h5X
patch
.
multiple
r3
h
>
}
r4
(
h
]
r5
hB
]
r6
hD
]
r7
hF
]
r8
hH
]
r9
uh6j
#
h0
]
r
:
hYX
patch
.
multipler
;
r
<
}
r
=
(
h5U
h6j1
ubah
<
h
ubhYX
+
to
create
mocks
for
you
then
you
can
use
r
>
r
?
}
r
(
h5X
+
to
create
mocks
for
you
then
you
can
use
rA
h6j
#
ubj
)
rB
}
rC
(
h5X
:
data
:
DEFAULT
rD
h6j
#
h7h
:
h
<
j
h
>
}
rE
(
U
reftyperF
X
datarG
j
j
X
DEFAULTrH
U
refdomainrI
X
pyrJ
hF
]
rK
hD
]
rL
U
refexplicitrM
h
]
rN
hB
]
rO
hH
]
rP
j
j
j
Nj
j
uhJMx
h0
]
rQ
j
)
rR
}
rS
(
h5jD
h
>
}
rT
(
h
]
rU
hB
]
rV
(
j
%
jJ
X
py
-
datarW
ehD
]
rX
hF
]
rY
hH
]
rZ
uh6jB
h0
]
r
[
hYX
DEFAULTr
\
r
]
}
r
^
(
h5U
h6jR
ubah
<
j
.
ubaubhYX
as
the
value
.
If
you
use
r_
r
}
ra
(
h5X
as
the
value
.
If
you
use
rb
h6j
#
ubh
)
rc
}
rd
(
h5X
patch
.
multiple
re
h
>
}
rf
(
h
]
rg
hB
]
rh
hD
]
ri
hF
]
rj
hH
]
rk
uh6j
#
h0
]
rl
hYX
patch
.
multiplerm
rn
}
ro
(
h5U
h6jc
ubah
<
h
ubhYXY
as
a
decorator
then
the
created
mocks
are
passed
into
the
decorated
function
by
keyword
.
rp
rq
}
rr
(
h5XY
as
a
decorator
then
the
created
mocks
are
passed
into
the
decorated
function
by
keyword
.
rs
h6j
#
ubeubj
)
rt
}
ru
(
h5X
>
>
>
thing
=
object
(
)
>
>
>
other
=
object
(
)
>
>
>
patch
.
multiple
(
'
__main__
'
thing
=
DEFAULT
other
=
DEFAULT
)
.
.
.
def
test_function
(
thing
other
)
:
.
.
.
assert
isinstance
(
thing
MagicMock
)
.
.
.
assert
isinstance
(
other
MagicMock
)
.
.
.
>
>
>
test_function
(
)
rv
h6j
&
h7h
:
h
<
j
h
>
}
rw
(
U
testnodetyperx
X
doctestry
hehfhF
]
rz
hD
]
r
{
h
]
r
|
hB
]
r
}
hH
]
r
~
U
groupsr
]
r
hnaho
}
r
uhJM
|
hKh
h0
]
r
hYX
>
>
>
thing
=
object
(
)
>
>
>
other
=
object
(
)
>
>
>
patch
.
multiple
(
'
__main__
'
thing
=
DEFAULT
other
=
DEFAULT
)
.
.
.
def
test_function
(
thing
other
)
:
.
.
.
assert
isinstance
(
thing
MagicMock
)
.
.
.
assert
isinstance
(
other
MagicMock
)
.
.
.
>
>
>
test_function
(
)
r
r
}
r
(
h5U
h6jt
ubaubh
)
r
}
r
(
h5X
patch
.
multiple
can
be
nested
with
other
patch
decorators
but
put
arguments
passed
by
keyword
*
after
*
any
of
the
standard
arguments
created
by
patch
:
r
h6j
&
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJM
hKh
h0
]
r
(
h
)
r
}
r
(
h5X
patch
.
multiple
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
patch
.
multipler
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
can
be
nested
with
other
r
r
}
r
(
h5X
can
be
nested
with
other
r
h6j
ubh
)
r
}
r
(
h5X
patch
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
patchr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX1
decorators
but
put
arguments
passed
by
keyword
r
r
}
r
(
h5X1
decorators
but
put
arguments
passed
by
keyword
r
h6j
ubj
)
r
}
r
(
h5X
*
after
*
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
afterr
r
}
r
(
h5U
h6j
ubah
<
j
ubhYX
*
any
of
the
standard
arguments
created
by
r
r
}
r
(
h5X
*
any
of
the
standard
arguments
created
by
r
h6j
ubh
)
r
}
r
(
h5X
patch
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
patchr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
:
r
}
r
(
h5X
:
h6j
ubeubj
)
r
}
r
(
h5X
>
>
>
patch
(
'
sys
.
exit
'
)
.
.
.
patch
.
multiple
(
'
__main__
'
thing
=
DEFAULT
other
=
DEFAULT
)
.
.
.
def
test_function
(
mock_exit
other
thing
)
:
.
.
.
assert
'
other
'
in
repr
(
other
)
.
.
.
assert
'
thing
'
in
repr
(
thing
)
.
.
.
assert
'
exit
'
in
repr
(
mock_exit
)
.
.
.
>
>
>
test_function
(
)
r
h6j
&
h7h
:
h
<
j
h
>
}
r
(
U
testnodetyper
X
doctestr
hehfhF
]
r
hD
]
r
h
]
r
hB
]
r
hH
]
r
U
groupsr
]
r
hnaho
}
r
uhJM
hKh
h0
]
r
hYX
>
>
>
patch
(
'
sys
.
exit
'
)
.
.
.
patch
.
multiple
(
'
__main__
'
thing
=
DEFAULT
other
=
DEFAULT
)
.
.
.
def
test_function
(
mock_exit
other
thing
)
:
.
.
.
assert
'
other
'
in
repr
(
other
)
.
.
.
assert
'
thing
'
in
repr
(
thing
)
.
.
.
assert
'
exit
'
in
repr
(
mock_exit
)
.
.
.
>
>
>
test_function
(
)
r
r
}
r
(
h5U
h6j
ubaubh
)
r
}
r
(
h5X
If
patch
.
multiple
is
used
as
a
context
manager
the
value
returned
by
the
context
manger
is
a
dictionary
where
created
mocks
are
keyed
by
name
:
r
h6j
&
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJM
hKh
h0
]
r
(
hYX
If
r
r
}
r
(
h5X
If
r
h6j
ubh
)
r
}
r
(
h5X
patch
.
multiple
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
patch
.
multipler
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
~
is
used
as
a
context
manager
the
value
returned
by
the
context
manger
is
a
dictionary
where
created
mocks
are
keyed
by
name
:
r
r
}
r
(
h5X
~
is
used
as
a
context
manager
the
value
returned
by
the
context
manger
is
a
dictionary
where
created
mocks
are
keyed
by
name
:
r
h6j
ubeubj
)
r
}
r
(
h5X
>
>
>
with
patch
.
multiple
(
'
__main__
'
thing
=
DEFAULT
other
=
DEFAULT
)
as
values
:
.
.
.
assert
'
other
'
in
repr
(
values
[
'
other
'
]
)
.
.
.
assert
'
thing
'
in
repr
(
values
[
'
thing
'
]
)
.
.
.
assert
values
[
'
thing
'
]
is
thing
.
.
.
assert
values
[
'
other
'
]
is
other
.
.
.
r
h6j
&
h7h
:
h
<
j
h
>
}
r
(
U
testnodetyper
X
doctestr
hehfhF
]
r
hD
]
r
h
]
r
hB
]
r
hH
]
r
U
groupsr
]
r
hnaho
}
r
uhJM
hKh
h0
]
r
hYX
>
>
>
with
patch
.
multiple
(
'
__main__
'
thing
=
DEFAULT
other
=
DEFAULT
)
as
values
:
.
.
.
assert
'
other
'
in
repr
(
values
[
'
other
'
]
)
.
.
.
assert
'
thing
'
in
repr
(
values
[
'
thing
'
]
)
.
.
.
assert
values
[
'
thing
'
]
is
thing
.
.
.
assert
values
[
'
other
'
]
is
other
.
.
.
r
r
}
r
(
h5U
h6j
ubaubcdocutils
.
nodes
target
r
)
r
}
r
(
h5X
.
.
_start
-
and
-
stop
:
r
h6j
&
h7h
:
h
<
U
targetr
h
>
}
r
(
hF
]
r
hD
]
r
h
]
r
hB
]
r
hH
]
r
h
h
/
uhJM
hKh
h0
]
r
ubeubh2
)
r
!
}
r
"
(
h5U
h6h3h7h
:
U
expect_referenced_by_namer
#
}
r
h
j
sh
<
h
=
h
>
}
r
%
(
h
]
r
&
hB
]
r
'
hD
]
r
(
hF
]
r
)
(
h
)
h
/
ehH
]
r
*
(
h
h
euhJM
hKh
U
expect_referenced_by_idr
+
}
r
h
/
j
sh0
]
r
-
(
hM
)
r
.
}
r
/
(
h5X
patch
methods
:
start
and
stopr0
h6j
!
h7h
:
h
<
hQh
>
}
r1
(
h
]
r2
hB
]
r3
hD
]
r4
hF
]
r5
hH
]
r6
uhJM
hKh
h0
]
r7
hYX
patch
methods
:
start
and
stopr8
r9
}
r
:
(
h5j0
h6j
.
ubaubh
)
r
;
}
r
<
(
h5X
All
the
patchers
have
start
and
stop
methods
.
These
make
it
simpler
to
do
patching
in
setUp
methods
or
where
you
want
to
do
multiple
patches
without
nesting
decorators
or
with
statements
.
r
=
h6j
!
h7h
:
h
<
h
h
>
}
r
>
(
h
]
r
?
hB
]
r
hD
]
rA
hF
]
rB
hH
]
rC
uhJM
hKh
h0
]
rD
(
hYX
All
the
patchers
have
rE
rF
}
rG
(
h5X
All
the
patchers
have
rH
h6j
;
ubh
)
rI
}
rJ
(
h5X
start
rK
h
>
}
rL
(
h
]
rM
hB
]
rN
hD
]
rO
hF
]
rP
hH
]
rQ
uh6j
;
h0
]
rR
hYX
startrS
rT
}
rU
(
h5U
h6jI
ubah
<
h
ubhYX
and
rV
rW
}
rX
(
h5X
and
rY
h6j
;
ubh
)
rZ
}
r
[
(
h5X
stop
r
\
h
>
}
r
]
(
h
]
r
^
hB
]
r_
hD
]
r
hF
]
ra
hH
]
rb
uh6j
;
h0
]
rc
hYX
stoprd
re
}
rf
(
h5U
h6jZ
ubah
<
h
ubhYX2
methods
.
These
make
it
simpler
to
do
patching
in
rg
rh
}
ri
(
h5X2
methods
.
These
make
it
simpler
to
do
patching
in
rj
h6j
;
ubh
)
rk
}
rl
(
h5X
setUp
rm
h
>
}
rn
(
h
]
ro
hB
]
rp
hD
]
rq
hF
]
rr
hH
]
rs
uh6j
;
h0
]
rt
hYX
setUpru
rv
}
rw
(
h5U
h6jk
ubah
<
h
ubhYX
methods
or
where
you
want
to
do
multiple
patches
without
nesting
decorators
or
with
statements
.
rx
ry
}
rz
(
h5X
methods
or
where
you
want
to
do
multiple
patches
without
nesting
decorators
or
with
statements
.
r
{
h6j
;
ubeubh
)
r
|
}
r
}
(
h5X
To
use
them
call
patch
patch
.
object
or
patch
.
dict
as
normal
and
keep
a
reference
to
the
returned
patcher
object
.
You
can
then
call
start
to
put
the
patch
in
place
and
stop
to
undo
it
.
r
~
h6j
!
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJM
hKh
h0
]
r
(
hYX
To
use
them
call
r
r
}
r
(
h5X
To
use
them
call
r
h6j
|
ubh
)
r
}
r
(
h5X
patch
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
|
h0
]
r
hYX
patchr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
r
r
}
r
(
h5X
r
h6j
|
ubh
)
r
}
r
(
h5X
patch
.
object
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
|
h0
]
r
hYX
patch
.
objectr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
or
r
r
}
r
(
h5X
or
r
h6j
|
ubh
)
r
}
r
(
h5X
patch
.
dict
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
|
h0
]
r
hYX
patch
.
dictr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX0
as
normal
and
keep
a
reference
to
the
returned
r
r
}
r
(
h5X0
as
normal
and
keep
a
reference
to
the
returned
r
h6j
|
ubh
)
r
}
r
(
h5X
patcher
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
|
h0
]
r
hYX
patcherr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
object
.
You
can
then
call
r
r
}
r
(
h5X
object
.
You
can
then
call
r
h6j
|
ubh
)
r
}
r
(
h5X
start
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
|
h0
]
r
hYX
startr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
to
put
the
patch
in
place
and
r
r
}
r
(
h5X
to
put
the
patch
in
place
and
r
h6j
|
ubh
)
r
}
r
(
h5X
stop
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
|
h0
]
r
hYX
stopr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
to
undo
it
.
r
r
}
r
(
h5X
to
undo
it
.
r
h6j
|
ubeubh
)
r
}
r
(
h5Xj
If
you
are
using
patch
to
create
a
mock
for
you
then
it
will
be
returned
by
the
call
to
patcher
.
start
.
r
h6j
!
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJM
hKh
h0
]
r
(
hYX
If
you
are
using
r
r
}
r
(
h5X
If
you
are
using
r
h6j
ubh
)
r
}
r
(
h5X
patch
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
patchr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYXB
to
create
a
mock
for
you
then
it
will
be
returned
by
the
call
to
r
r
}
r
(
h5XB
to
create
a
mock
for
you
then
it
will
be
returned
by
the
call
to
r
h6j
ubh
)
r
}
r
(
h5X
patcher
.
start
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
patcher
.
startr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
.
r
}
r
(
h5X
.
h6j
ubeubj
)
r
}
r
(
h5XH
>
>
>
patcher
=
patch
(
'
package
.
module
.
ClassName
'
)
>
>
>
from
package
import
module
>
>
>
original
=
module
.
ClassName
>
>
>
new_mock
=
patcher
.
start
(
)
>
>
>
assert
module
.
ClassName
is
not
original
>
>
>
assert
module
.
ClassName
is
new_mock
>
>
>
patcher
.
stop
(
)
>
>
>
assert
module
.
ClassName
is
original
>
>
>
assert
module
.
ClassName
is
not
new_mockr
h6j
!
h7h
:
h
<
j
h
>
}
r
!
(
U
testnodetyper
"
X
doctestr
#
hehfhF
]
r
hD
]
r
%
h
]
r
&
hB
]
r
'
hH
]
r
(
U
groupsr
)
]
r
*
hnaho
}
r
+
uhJM
hKh
h0
]
r
hYXH
>
>
>
patcher
=
patch
(
'
package
.
module
.
ClassName
'
)
>
>
>
from
package
import
module
>
>
>
original
=
module
.
ClassName
>
>
>
new_mock
=
patcher
.
start
(
)
>
>
>
assert
module
.
ClassName
is
not
original
>
>
>
assert
module
.
ClassName
is
new_mock
>
>
>
patcher
.
stop
(
)
>
>
>
assert
module
.
ClassName
is
original
>
>
>
assert
module
.
ClassName
is
not
new_mockr
-
r
.
}
r
/
(
h5U
h6j
ubaubh
)
r0
}
r1
(
h5Xf
A
typical
use
case
for
this
might
be
for
doing
multiple
patches
in
the
setUp
method
of
a
TestCase
:
r2
h6j
!
h7h
:
h
<
h
h
>
}
r3
(
h
]
r4
hB
]
r5
hD
]
r6
hF
]
r7
hH
]
r8
uhJM
hKh
h0
]
r9
(
hYXG
A
typical
use
case
for
this
might
be
for
doing
multiple
patches
in
the
r
:
r
;
}
r
<
(
h5XG
A
typical
use
case
for
this
might
be
for
doing
multiple
patches
in
the
r
=
h6j0
ubh
)
r
>
}
r
?
(
h5X
setUp
r
h
>
}
rA
(
h
]
rB
hB
]
rC
hD
]
rD
hF
]
rE
hH
]
rF
uh6j0
h0
]
rG
hYX
setUprH
rI
}
rJ
(
h5U
h6j
>
ubah
<
h
ubhYX
method
of
a
rK
rL
}
rM
(
h5X
method
of
a
rN
h6j0
ubh
)
rO
}
rP
(
h5X
TestCase
rQ
h
>
}
rR
(
h
]
rS
hB
]
rT
hD
]
rU
hF
]
rV
hH
]
rW
uh6j0
h0
]
rX
hYX
TestCaserY
rZ
}
r
[
(
h5U
h6jO
ubah
<
h
ubhYX
:
r
\
}
r
]
(
h5X
:
h6j0
ubeubj
)
r
^
}
r_
(
h5X9
>
>
>
class
MyTest
(
TestCase
)
:
.
.
.
def
setUp
(
self
)
:
.
.
.
self
.
patcher1
=
patch
(
'
package
.
module
.
Class1
'
)
.
.
.
self
.
patcher2
=
patch
(
'
package
.
module
.
Class2
'
)
.
.
.
self
.
MockClass1
=
self
.
patcher1
.
start
(
)
.
.
.
self
.
MockClass2
=
self
.
patcher2
.
start
(
)
.
.
.
.
.
.
def
tearDown
(
self
)
:
.
.
.
self
.
patcher1
.
stop
(
)
.
.
.
self
.
patcher2
.
stop
(
)
.
.
.
.
.
.
def
test_something
(
self
)
:
.
.
.
assert
package
.
module
.
Class1
is
self
.
MockClass1
.
.
.
assert
package
.
module
.
Class2
is
self
.
MockClass2
.
.
.
>
>
>
MyTest
(
'
test_something
'
)
.
run
(
)
r
h6j
!
h7h
:
h
<
j
h
>
}
ra
(
U
testnodetyperb
X
doctestrc
hehfhF
]
rd
hD
]
re
h
]
rf
hB
]
rg
hH
]
rh
U
groupsri
]
rj
hnaho
}
rk
uhJM
hKh
h0
]
rl
hYX9
>
>
>
class
MyTest
(
TestCase
)
:
.
.
.
def
setUp
(
self
)
:
.
.
.
self
.
patcher1
=
patch
(
'
package
.
module
.
Class1
'
)
.
.
.
self
.
patcher2
=
patch
(
'
package
.
module
.
Class2
'
)
.
.
.
self
.
MockClass1
=
self
.
patcher1
.
start
(
)
.
.
.
self
.
MockClass2
=
self
.
patcher2
.
start
(
)
.
.
.
.
.
.
def
tearDown
(
self
)
:
.
.
.
self
.
patcher1
.
stop
(
)
.
.
.
self
.
patcher2
.
stop
(
)
.
.
.
.
.
.
def
test_something
(
self
)
:
.
.
.
assert
package
.
module
.
Class1
is
self
.
MockClass1
.
.
.
assert
package
.
module
.
Class2
is
self
.
MockClass2
.
.
.
>
>
>
MyTest
(
'
test_something
'
)
.
run
(
)
rm
rn
}
ro
(
h5U
h6j
^
ubaubcdocutils
.
nodes
caution
rp
)
rq
}
rr
(
h5X
If
you
use
this
technique
you
must
ensure
that
the
patching
is
"
undone
"
by
calling
stop
.
This
can
be
fiddlier
than
you
might
think
because
if
an
exception
is
raised
in
the
setUp
then
tearDown
is
not
called
.
unittest2
<
http
:
/
/
pypi
.
python
.
org
/
pypi
/
unittest2
>
_
cleanup
functions
make
this
easier
.
.
.
doctest
:
:
>
>
>
class
MyTest
(
TestCase
)
:
.
.
.
def
setUp
(
self
)
:
.
.
.
patcher
=
patch
(
'
package
.
module
.
Class
'
)
.
.
.
self
.
MockClass
=
patcher
.
start
(
)
.
.
.
self
.
addCleanup
(
patcher
.
stop
)
.
.
.
.
.
.
def
test_something
(
self
)
:
.
.
.
assert
package
.
module
.
Class
is
self
.
MockClass
.
.
.
>
>
>
MyTest
(
'
test_something
'
)
.
run
(
)
As
an
added
bonus
you
no
longer
need
to
keep
a
reference
to
the
patcher
object
.
rs
h6j
!
h7h
:
h
<
U
cautionrt
h
>
}
ru
(
h
]
rv
hB
]
rw
hD
]
rx
hF
]
ry
hH
]
rz
uhJNhKh
h0
]
r
{
(
h
)
r
|
}
r
}
(
h5X
*
If
you
use
this
technique
you
must
ensure
that
the
patching
is
"
undone
"
by
calling
stop
.
This
can
be
fiddlier
than
you
might
think
because
if
an
exception
is
raised
in
the
setUp
then
tearDown
is
not
called
.
unittest2
<
http
:
/
/
pypi
.
python
.
org
/
pypi
/
unittest2
>
_
cleanup
functions
make
this
easier
.
r
~
h6jq
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJM
h0
]
r
(
hYXS
If
you
use
this
technique
you
must
ensure
that
the
patching
is
"
undone
"
by
calling
r
r
}
r
(
h5XS
If
you
use
this
technique
you
must
ensure
that
the
patching
is
"
undone
"
by
calling
r
h6j
|
ubh
)
r
}
r
(
h5X
stop
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
|
h0
]
r
hYX
stopr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYXy
.
This
can
be
fiddlier
than
you
might
think
because
if
an
exception
is
raised
in
the
setUp
then
tearDown
is
not
called
.
r
r
}
r
(
h5Xy
.
This
can
be
fiddlier
than
you
might
think
because
if
an
exception
is
raised
in
the
setUp
then
tearDown
is
not
called
.
r
h6j
|
ubh
)
r
}
r
(
h5X4
unittest2
<
http
:
/
/
pypi
.
python
.
org
/
pypi
/
unittest2
>
_r
h
>
}
r
(
U
namer
X
unittest2r
U
refurir
X
%
http
:
/
/
pypi
.
python
.
org
/
pypi
/
unittest2r
hF
]
r
hD
]
r
h
]
r
hB
]
r
hH
]
r
uh6j
|
h0
]
r
hYX
unittest2r
r
}
r
(
h5U
h6j
ubah
<
h
ubj
)
r
}
r
(
h5X
(
<
http
:
/
/
pypi
.
python
.
org
/
pypi
/
unittest2
>
r
h
K
h6j
|
h
<
j
h
>
}
r
(
U
refurir
j
hF
]
r
h
.
ahD
]
r
h
]
r
hB
]
r
hH
]
r
h
auh0
]
r
ubhYX
cleanup
functions
make
this
easier
.
r
r
}
r
(
h5X
cleanup
functions
make
this
easier
.
r
h6j
|
ubeubj
)
r
}
r
(
h5XF
>
>
>
class
MyTest
(
TestCase
)
:
.
.
.
def
setUp
(
self
)
:
.
.
.
patcher
=
patch
(
'
package
.
module
.
Class
'
)
.
.
.
self
.
MockClass
=
patcher
.
start
(
)
.
.
.
self
.
addCleanup
(
patcher
.
stop
)
.
.
.
.
.
.
def
test_something
(
self
)
:
.
.
.
assert
package
.
module
.
Class
is
self
.
MockClass
.
.
.
>
>
>
MyTest
(
'
test_something
'
)
.
run
(
)
r
h6jq
h7h
:
h
<
j
h
>
}
r
(
U
testnodetyper
X
doctestr
hehfhF
]
r
hD
]
r
h
]
r
hB
]
r
hH
]
r
U
groupsr
]
r
hnaho
}
r
uhJM
h0
]
r
hYXF
>
>
>
class
MyTest
(
TestCase
)
:
.
.
.
def
setUp
(
self
)
:
.
.
.
patcher
=
patch
(
'
package
.
module
.
Class
'
)
.
.
.
self
.
MockClass
=
patcher
.
start
(
)
.
.
.
self
.
addCleanup
(
patcher
.
stop
)
.
.
.
.
.
.
def
test_something
(
self
)
:
.
.
.
assert
package
.
module
.
Class
is
self
.
MockClass
.
.
.
>
>
>
MyTest
(
'
test_something
'
)
.
run
(
)
r
r
}
r
(
h5U
h6j
ubaubh
)
r
}
r
(
h5XQ
As
an
added
bonus
you
no
longer
need
to
keep
a
reference
to
the
patcher
object
.
r
h6jq
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJM
h0
]
r
(
hYX
As
an
added
bonus
you
no
longer
need
to
keep
a
reference
to
the
r
r
}
r
(
h5X
As
an
added
bonus
you
no
longer
need
to
keep
a
reference
to
the
r
h6j
ubh
)
r
}
r
(
h5X
patcher
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
patcherr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
object
.
r
r
}
r
(
h5X
object
.
r
h6j
ubeubeubh
)
r
}
r
(
h5XY
It
is
also
possible
to
stop
all
patches
which
have
been
started
by
using
patch
.
stopall
.
r
h6j
!
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJM
hKh
h0
]
r
(
hYXI
It
is
also
possible
to
stop
all
patches
which
have
been
started
by
using
r
r
}
r
(
h5XI
It
is
also
possible
to
stop
all
patches
which
have
been
started
by
using
r
h6j
ubh
)
r
}
r
(
h5X
patch
.
stopall
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
patch
.
stopallr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
.
r
}
r
(
h5X
.
h6j
ubeubh
)
r
}
r
(
h5U
h6j
!
h7h
:
h
<
h
h
>
}
r
(
hF
]
r
hD
]
r
h
]
r
hB
]
r
hH
]
r
U
entriesr
]
r
(
h
X
patch
.
stopall
(
)
(
in
module
mock
)
h
U
tr
auhJNhKh
h0
]
r
ubh
)
r
}
r
(
h5U
h6j
!
h7h
:
h
<
h
h
>
}
r
(
h
j
X
pyr
hF
]
r
hD
]
r
h
]
r
hB
]
r
hH
]
r
j
X
functionr
j
j
uhJNhKh
h0
]
r
(
j
)
r
}
r
!
(
h5X
patch
.
stopallr
"
h6j
h7h
:
h
<
j
h
>
}
r
#
(
hF
]
r
h
aj
j
hD
]
r
%
h
]
r
&
hB
]
r
'
hH
]
r
(
h
aj
X
patch
.
stopallr
)
j
X
patchr
*
j
uhJM
hKh
h0
]
r
+
(
jw
)
r
}
r
-
(
h5X
patch
.
r
.
h6j
h7h
:
h
<
j
{
h
>
}
r
/
(
h
]
r0
hB
]
r1
hD
]
r2
hF
]
r3
hH
]
r4
uhJM
hKh
h0
]
r5
hYX
patch
.
r6
r7
}
r8
(
h5U
h6j
ubaubj
)
r9
}
r
:
(
h5X
stopallr
;
h6j
h7h
:
h
<
j
h
>
}
r
<
(
h
]
r
=
hB
]
r
>
hD
]
r
?
hF
]
r
hH
]
rA
uhJM
hKh
h0
]
rB
hYX
stopallrC
rD
}
rE
(
h5U
h6j9
ubaubj
+
)
rF
}
rG
(
h5U
h6j
h7h
:
h
<
j
.
h
>
}
rH
(
h
]
rI
hB
]
rJ
hD
]
rK
hF
]
rL
hH
]
rM
uhJM
hKh
h0
]
rN
ubeubj
)
rO
}
rP
(
h5U
h6j
h7h
:
h
<
j
h
>
}
rQ
(
h
]
rR
hB
]
rS
hD
]
rT
hF
]
rU
hH
]
rV
uhJM
hKh
h0
]
rW
h
)
rX
}
rY
(
h5XA
Stop
all
active
patches
.
Only
stops
patches
started
with
start
.
rZ
h6jO
h7h
:
h
<
h
h
>
}
r
[
(
h
]
r
\
hB
]
r
]
hD
]
r
^
hF
]
r_
hH
]
r
uhJM
hKh
h0
]
ra
(
hYX9
Stop
all
active
patches
.
Only
stops
patches
started
with
rb
rc
}
rd
(
h5X9
Stop
all
active
patches
.
Only
stops
patches
started
with
re
h6jX
ubh
)
rf
}
rg
(
h5X
start
rh
h
>
}
ri
(
h
]
rj
hB
]
rk
hD
]
rl
hF
]
rm
hH
]
rn
uh6jX
h0
]
ro
hYX
startrp
rq
}
rr
(
h5U
h6jf
ubah
<
h
ubhYX
.
rs
}
rt
(
h5X
.
h6jX
ubeubaubeubeubh2
)
ru
}
rv
(
h5U
h6h3h7h
:
h
<
h
=
h
>
}
rw
(
h
]
rx
hB
]
ry
hD
]
rz
hF
]
r
{
h
'
ahH
]
r
|
h
auhJM
hKh
h0
]
r
}
(
hM
)
r
~
}
r
(
h5X
TEST_PREFIXr
h6ju
h7h
:
h
<
hQh
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJM
hKh
h0
]
r
hYX
TEST_PREFIXr
r
}
r
(
h5j
h6j
~
ubaubh
)
r
}
r
(
h5X
All
of
the
patchers
can
be
used
as
class
decorators
.
When
used
in
this
way
they
wrap
every
test
method
on
the
class
.
The
patchers
recognise
methods
that
start
with
test
as
being
test
methods
.
This
is
the
same
way
that
the
unittest
.
TestLoader
finds
test
methods
by
default
.
r
h6ju
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJM
hKh
h0
]
r
(
hYX
All
of
the
patchers
can
be
used
as
class
decorators
.
When
used
in
this
way
they
wrap
every
test
method
on
the
class
.
The
patchers
recognise
methods
that
start
with
r
r
}
r
(
h5X
All
of
the
patchers
can
be
used
as
class
decorators
.
When
used
in
this
way
they
wrap
every
test
method
on
the
class
.
The
patchers
recognise
methods
that
start
with
r
h6j
ubh
)
r
}
r
(
h5X
test
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
testr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX6
as
being
test
methods
.
This
is
the
same
way
that
the
r
r
}
r
(
h5X6
as
being
test
methods
.
This
is
the
same
way
that
the
r
h6j
ubh
)
r
}
r
(
h5X
unittest
.
TestLoader
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
unittest
.
TestLoaderr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
finds
test
methods
by
default
.
r
r
}
r
(
h5X
finds
test
methods
by
default
.
r
h6j
ubeubh
)
r
}
r
(
h5X
It
is
possible
that
you
want
to
use
a
different
prefix
for
your
tests
.
You
can
inform
the
patchers
of
the
different
prefix
by
setting
patch
.
TEST_PREFIX
:
r
h6ju
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJM
hKh
h0
]
r
(
hYX
It
is
possible
that
you
want
to
use
a
different
prefix
for
your
tests
.
You
can
inform
the
patchers
of
the
different
prefix
by
setting
r
r
}
r
(
h5X
It
is
possible
that
you
want
to
use
a
different
prefix
for
your
tests
.
You
can
inform
the
patchers
of
the
different
prefix
by
setting
r
h6j
ubh
)
r
}
r
(
h5X
patch
.
TEST_PREFIX
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
patch
.
TEST_PREFIXr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
:
r
}
r
(
h5X
:
h6j
ubeubj
)
r
}
r
(
h5X
>
>
>
patch
.
TEST_PREFIX
=
'
foo
'
>
>
>
value
=
3
>
>
>
>
>
>
patch
(
'
__main__
.
value
'
'
not
three
'
)
.
.
.
class
Thing
(
object
)
:
.
.
.
def
foo_one
(
self
)
:
.
.
.
print
value
.
.
.
def
foo_two
(
self
)
:
.
.
.
print
value
.
.
.
>
>
>
>
>
>
Thing
(
)
.
foo_one
(
)
not
three
>
>
>
Thing
(
)
.
foo_two
(
)
not
three
>
>
>
value
3r
h6ju
h7h
:
h
<
j
h
>
}
r
(
U
testnodetyper
X
doctestr
hehfhF
]
r
hD
]
r
h
]
r
hB
]
r
hH
]
r
U
groupsr
]
r
hnaho
}
r
uhJM
hKh
h0
]
r
hYX
>
>
>
patch
.
TEST_PREFIX
=
'
foo
'
>
>
>
value
=
3
>
>
>
>
>
>
patch
(
'
__main__
.
value
'
'
not
three
'
)
.
.
.
class
Thing
(
object
)
:
.
.
.
def
foo_one
(
self
)
:
.
.
.
print
value
.
.
.
def
foo_two
(
self
)
:
.
.
.
print
value
.
.
.
>
>
>
>
>
>
Thing
(
)
.
foo_one
(
)
not
three
>
>
>
Thing
(
)
.
foo_two
(
)
not
three
>
>
>
value
3r
r
}
r
(
h5U
h6j
ubaubeubh2
)
r
}
r
(
h5U
h6h3h7h
:
h
<
h
=
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
h
%
ahH
]
r
h
auhJM
hKh
h0
]
r
(
hM
)
r
}
r
(
h5X
Nesting
Patch
Decoratorsr
h6j
h7h
:
h
<
hQh
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJM
hKh
h0
]
r
hYX
Nesting
Patch
Decoratorsr
r
}
r
(
h5j
h6j
ubaubh
)
r
}
r
(
h5XT
If
you
want
to
perform
multiple
patches
then
you
can
simply
stack
up
the
decorators
.
r
h6j
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJM
hKh
h0
]
r
hYXT
If
you
want
to
perform
multiple
patches
then
you
can
simply
stack
up
the
decorators
.
r
r
}
r
(
h5j
h6j
ubaubh
)
r
}
r
(
h5X
>
You
can
stack
up
multiple
patch
decorators
using
this
pattern
:
r
h6j
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJM
hKh
h0
]
r
hYX
>
You
can
stack
up
multiple
patch
decorators
using
this
pattern
:
r
r
}
r
(
h5j
h6j
ubaubj
)
r
}
r
(
h5X
>
>
>
patch
.
object
(
SomeClass
'
class_method
'
)
.
.
.
patch
.
object
(
SomeClass
'
static_method
'
)
.
.
.
def
test
(
mock1
mock2
)
:
.
.
.
assert
SomeClass
.
static_method
is
mock1
.
.
.
assert
SomeClass
.
class_method
is
mock2
.
.
.
SomeClass
.
static_method
(
'
foo
'
)
.
.
.
SomeClass
.
class_method
(
'
bar
'
)
.
.
.
return
mock1
mock2
.
.
.
>
>
>
mock1
mock2
=
test
(
)
>
>
>
mock1
.
assert_called_once_with
(
'
foo
'
)
>
>
>
mock2
.
assert_called_once_with
(
'
bar
'
)
r
h6j
h7h
:
h
<
j
h
>
}
r
(
U
testnodetyper
X
doctestr
hehfhF
]
r
hD
]
r
!
h
]
r
"
hB
]
r
#
hH
]
r
U
groupsr
%
]
r
&
hnaho
}
r
'
uhJM
hKh
h0
]
r
(
hYX
>
>
>
patch
.
object
(
SomeClass
'
class_method
'
)
.
.
.
patch
.
object
(
SomeClass
'
static_method
'
)
.
.
.
def
test
(
mock1
mock2
)
:
.
.
.
assert
SomeClass
.
static_method
is
mock1
.
.
.
assert
SomeClass
.
class_method
is
mock2
.
.
.
SomeClass
.
static_method
(
'
foo
'
)
.
.
.
SomeClass
.
class_method
(
'
bar
'
)
.
.
.
return
mock1
mock2
.
.
.
>
>
>
mock1
mock2
=
test
(
)
>
>
>
mock1
.
assert_called_once_with
(
'
foo
'
)
>
>
>
mock2
.
assert_called_once_with
(
'
bar
'
)
r
)
r
*
}
r
+
(
h5U
h6j
ubaubh
)
r
}
r
-
(
h5X
Note
that
the
decorators
are
applied
from
the
bottom
upwards
.
This
is
the
standard
way
that
Python
applies
decorators
.
The
order
of
the
created
mocks
passed
into
your
test
function
matches
this
order
.
r
.
h6j
h7h
:
h
<
h
h
>
}
r
/
(
h
]
r0
hB
]
r1
hD
]
r2
hF
]
r3
hH
]
r4
uhJM
.
hKh
h0
]
r5
hYX
Note
that
the
decorators
are
applied
from
the
bottom
upwards
.
This
is
the
standard
way
that
Python
applies
decorators
.
The
order
of
the
created
mocks
passed
into
your
test
function
matches
this
order
.
r6
r7
}
r8
(
h5j
.
h6j
ubaubh
)
r9
}
r
:
(
h5X
Like
all
context
-
managers
patches
can
be
nested
using
contextlib
'
s
nested
function
;
*
every
*
patching
will
appear
in
the
tuple
after
"
as
"
:
r
;
h6j
h7h
:
h
<
h
h
>
}
r
<
(
h
]
r
=
hB
]
r
>
hD
]
r
?
hF
]
r
hH
]
rA
uhJM2
hKh
h0
]
rB
(
hYXT
Like
all
context
-
managers
patches
can
be
nested
using
contextlib
'
s
nested
function
;
rC
rD
}
rE
(
h5XT
Like
all
context
-
managers
patches
can
be
nested
using
contextlib
'
s
nested
function
;
rF
h6j9
ubj
)
rG
}
rH
(
h5X
*
every
*
rI
h
>
}
rJ
(
h
]
rK
hB
]
rL
hD
]
rM
hF
]
rN
hH
]
rO
uh6j9
h0
]
rP
hYX
everyrQ
rR
}
rS
(
h5U
h6jG
ubah
<
j
ubhYX
.
patching
will
appear
in
the
tuple
after
"
as
"
:
rT
rU
}
rV
(
h5X
.
patching
will
appear
in
the
tuple
after
"
as
"
:
rW
h6j9
ubeubj
)
rX
}
rY
(
h5X
*
>
>
>
from
contextlib
import
nested
>
>
>
with
nested
(
.
.
.
patch
(
'
package
.
module
.
ClassName1
'
)
.
.
.
patch
(
'
package
.
module
.
ClassName2
'
)
.
.
.
)
as
(
MockClass1
MockClass2
)
:
.
.
.
assert
package
.
module
.
ClassName1
is
MockClass1
.
.
.
assert
package
.
module
.
ClassName2
is
MockClass2
.
.
.
rZ
h6j
h7h
:
h
<
j
h
>
}
r
[
(
U
testnodetyper
\
X
doctestr
]
hehfhF
]
r
^
hD
]
r_
h
]
r
hB
]
ra
hH
]
rb
U
groupsrc
]
rd
hnaho
}
re
uhJM5
hKh
h0
]
rf
hYX
*
>
>
>
from
contextlib
import
nested
>
>
>
with
nested
(
.
.
.
patch
(
'
package
.
module
.
ClassName1
'
)
.
.
.
patch
(
'
package
.
module
.
ClassName2
'
)
.
.
.
)
as
(
MockClass1
MockClass2
)
:
.
.
.
assert
package
.
module
.
ClassName1
is
MockClass1
.
.
.
assert
package
.
module
.
ClassName2
is
MockClass2
.
.
.
rg
rh
}
ri
(
h5U
h6jX
ubaubj
)
rj
}
rk
(
h5X
.
.
_where
-
to
-
patch
:
rl
h6j
h7h
:
h
<
j
h
>
}
rm
(
hF
]
rn
hD
]
ro
h
]
rp
hB
]
rq
hH
]
rr
h
h
#
uhJMA
hKh
h0
]
rs
ubeubh2
)
rt
}
ru
(
h5U
h
K
h6h3h7h
:
j
#
}
rv
h
jj
sh
<
h
=
h
>
}
rw
(
h
]
rx
hB
]
ry
hD
]
rz
hF
]
r
{
(
h
#
h
-
ehH
]
r
|
(
h
h
euhJMD
hKh
j
+
}
r
}
h
#
jj
sh0
]
r
~
(
hM
)
r
}
r
(
h5X
Where
to
patchr
h6jt
h7h
:
h
<
hQh
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJMD
hKh
h0
]
r
hYX
Where
to
patchr
r
}
r
(
h5j
h6j
ubaubh
)
r
}
r
(
h5X
patch
works
by
(
temporarily
)
changing
the
object
that
a
*
name
*
points
to
with
another
one
.
There
can
be
many
names
pointing
to
any
individual
object
so
for
patching
to
work
you
must
ensure
that
you
patch
the
name
used
by
the
system
under
test
.
r
h6jt
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJMF
hKh
h0
]
r
(
h
)
r
}
r
(
h5X
patch
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
patchr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX3
works
by
(
temporarily
)
changing
the
object
that
a
r
r
}
r
(
h5X3
works
by
(
temporarily
)
changing
the
object
that
a
r
h6j
ubj
)
r
}
r
(
h5X
*
name
*
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
namer
r
}
r
(
h5U
h6j
ubah
<
j
ubhYX
points
to
with
another
one
.
There
can
be
many
names
pointing
to
any
individual
object
so
for
patching
to
work
you
must
ensure
that
you
patch
the
name
used
by
the
system
under
test
.
r
r
}
r
(
h5X
points
to
with
another
one
.
There
can
be
many
names
pointing
to
any
individual
object
so
for
patching
to
work
you
must
ensure
that
you
patch
the
name
used
by
the
system
under
test
.
r
h6j
ubeubh
)
r
}
r
(
h5X
The
basic
principle
is
that
you
patch
where
an
object
is
*
looked
up
*
which
is
not
necessarily
the
same
place
as
where
it
is
defined
.
A
couple
of
examples
will
help
to
clarify
this
.
r
h6jt
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJMK
hKh
h0
]
r
(
hYX9
The
basic
principle
is
that
you
patch
where
an
object
is
r
r
}
r
(
h5X9
The
basic
principle
is
that
you
patch
where
an
object
is
r
h6j
ubj
)
r
}
r
(
h5X
*
looked
up
*
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
looked
upr
r
}
r
(
h5U
h6j
ubah
<
j
ubhYXq
which
is
not
necessarily
the
same
place
as
where
it
is
defined
.
A
couple
of
examples
will
help
to
clarify
this
.
r
r
}
r
(
h5Xq
which
is
not
necessarily
the
same
place
as
where
it
is
defined
.
A
couple
of
examples
will
help
to
clarify
this
.
r
h6j
ubeubh
)
r
}
r
(
h5XM
Imagine
we
have
a
project
that
we
want
to
test
with
the
following
structure
:
:
r
h6jt
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJMO
hKh
h0
]
r
hYXL
Imagine
we
have
a
project
that
we
want
to
test
with
the
following
structure
:
r
r
}
r
(
h5XL
Imagine
we
have
a
project
that
we
want
to
test
with
the
following
structure
:
r
h6j
ubaubj
)
r
}
r
(
h5Xn
a
.
py
-
>
Defines
SomeClass
b
.
py
-
>
from
a
import
SomeClass
-
>
some_function
instantiates
SomeClassr
h6jt
h7h
:
h
<
j
h
>
}
r
(
hehfhF
]
r
hD
]
r
h
]
r
hB
]
r
hH
]
r
uhJMQ
hKh
h0
]
r
hYXn
a
.
py
-
>
Defines
SomeClass
b
.
py
-
>
from
a
import
SomeClass
-
>
some_function
instantiates
SomeClassr
r
}
r
(
h5U
h6j
ubaubh
)
r
}
r
(
h5X
Now
we
want
to
test
some_function
but
we
want
to
mock
out
SomeClass
using
patch
.
The
problem
is
that
when
we
import
module
b
which
we
will
have
to
do
then
it
imports
SomeClass
from
module
a
.
If
we
use
patch
to
mock
out
a
.
SomeClass
then
it
will
have
no
effect
on
our
test
;
module
b
already
has
a
reference
to
the
*
real
*
SomeClass
and
it
looks
like
our
patching
had
no
effect
.
r
h6jt
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJMX
hKh
h0
]
r
(
hYX
Now
we
want
to
test
r
r
}
r
(
h5X
Now
we
want
to
test
r
h6j
ubh
)
r
}
r
(
h5X
some_function
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
some_functionr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
but
we
want
to
mock
out
r
r
}
r
(
h5X
but
we
want
to
mock
out
r
h6j
ubh
)
r
}
r
(
h5X
SomeClass
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
SomeClassr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
using
r
r
}
r
(
h5X
using
r
!
h6j
ubh
)
r
"
}
r
#
(
h5X
patch
r
h
>
}
r
%
(
h
]
r
&
hB
]
r
'
hD
]
r
(
hF
]
r
)
hH
]
r
*
uh6j
h0
]
r
+
hYX
patchr
r
-
}
r
.
(
h5U
h6j
"
ubah
<
h
ubhYXX
.
The
problem
is
that
when
we
import
module
b
which
we
will
have
to
do
then
it
imports
r
/
r0
}
r1
(
h5XX
.
The
problem
is
that
when
we
import
module
b
which
we
will
have
to
do
then
it
imports
r2
h6j
ubh
)
r3
}
r4
(
h5X
SomeClass
r5
h
>
}
r6
(
h
]
r7
hB
]
r8
hD
]
r9
hF
]
r
:
hH
]
r
;
uh6j
h0
]
r
<
hYX
SomeClassr
=
r
>
}
r
?
(
h5U
h6j3
ubah
<
h
ubhYX
from
module
a
.
If
we
use
r
rA
}
rB
(
h5X
from
module
a
.
If
we
use
rC
h6j
ubh
)
rD
}
rE
(
h5X
patch
rF
h
>
}
rG
(
h
]
rH
hB
]
rI
hD
]
rJ
hF
]
rK
hH
]
rL
uh6j
h0
]
rM
hYX
patchrN
rO
}
rP
(
h5U
h6jD
ubah
<
h
ubhYX
to
mock
out
rQ
rR
}
rS
(
h5X
to
mock
out
rT
h6j
ubh
)
rU
}
rV
(
h5X
a
.
SomeClass
rW
h
>
}
rX
(
h
]
rY
hB
]
rZ
hD
]
r
[
hF
]
r
\
hH
]
r
]
uh6j
h0
]
r
^
hYX
a
.
SomeClassr_
r
}
ra
(
h5U
h6jU
ubah
<
h
ubhYXR
then
it
will
have
no
effect
on
our
test
;
module
b
already
has
a
reference
to
the
rb
rc
}
rd
(
h5XR
then
it
will
have
no
effect
on
our
test
;
module
b
already
has
a
reference
to
the
re
h6j
ubj
)
rf
}
rg
(
h5X
*
real
*
rh
h
>
}
ri
(
h
]
rj
hB
]
rk
hD
]
rl
hF
]
rm
hH
]
rn
uh6j
h0
]
ro
hYX
realrp
rq
}
rr
(
h5U
h6jf
ubah
<
j
ubhYX
rs
}
rt
(
h5X
h6j
ubh
)
ru
}
rv
(
h5X
SomeClass
rw
h
>
}
rx
(
h
]
ry
hB
]
rz
hD
]
r
{
hF
]
r
|
hH
]
r
}
uh6j
h0
]
r
~
hYX
SomeClassr
r
}
r
(
h5U
h6ju
ubah
<
h
ubhYX
.
and
it
looks
like
our
patching
had
no
effect
.
r
r
}
r
(
h5X
.
and
it
looks
like
our
patching
had
no
effect
.
r
h6j
ubeubh
)
r
}
r
(
h5X
The
key
is
to
patch
out
SomeClass
where
it
is
used
(
or
where
it
is
looked
up
)
.
In
this
case
some_function
will
actually
look
up
SomeClass
in
module
b
where
we
have
imported
it
.
The
patching
should
look
like
:
r
h6jt
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJM_
hKh
h0
]
r
(
hYX
The
key
is
to
patch
out
r
r
}
r
(
h5X
The
key
is
to
patch
out
r
h6j
ubh
)
r
}
r
(
h5X
SomeClass
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
SomeClassr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
<
where
it
is
used
(
or
where
it
is
looked
up
)
.
In
this
case
r
r
}
r
(
h5X
<
where
it
is
used
(
or
where
it
is
looked
up
)
.
In
this
case
r
h6j
ubh
)
r
}
r
(
h5X
some_function
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
some_functionr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
will
actually
look
up
r
r
}
r
(
h5X
will
actually
look
up
r
h6j
ubh
)
r
}
r
(
h5X
SomeClass
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
SomeClassr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYXG
in
module
b
where
we
have
imported
it
.
The
patching
should
look
like
:
r
r
}
r
(
h5XG
in
module
b
where
we
have
imported
it
.
The
patching
should
look
like
:
r
h6j
ubeubcdocutils
.
nodes
block_quote
r
)
r
}
r
(
h5U
h6jt
h7h
:
h
<
U
block_quoter
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJNhKh
h0
]
r
h
)
r
}
r
(
h5X
patch
(
'
b
.
SomeClass
'
)
r
h6j
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJMc
h0
]
r
h
)
r
}
r
(
h5j
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
patch
(
'
b
.
SomeClass
'
)
r
r
}
r
(
h5U
h6j
ubah
<
h
ubaubaubh
)
r
}
r
(
h5X7
However
consider
the
alternative
scenario
where
instead
of
from
a
import
SomeClass
module
b
does
import
a
and
some_function
uses
a
.
SomeClass
.
Both
of
these
import
forms
are
common
.
In
this
case
the
class
we
want
to
patch
is
being
looked
up
on
the
a
module
and
so
we
have
to
patch
a
.
SomeClass
instead
:
r
h6jt
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJMe
hKh
h0
]
r
(
hYX
<
However
consider
the
alternative
scenario
where
instead
of
r
r
}
r
(
h5X
<
However
consider
the
alternative
scenario
where
instead
of
r
h6j
ubh
)
r
}
r
(
h5X
from
a
import
SomeClass
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
from
a
import
SomeClassr
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
module
b
does
r
r
}
r
(
h5X
module
b
does
r
h6j
ubh
)
r
}
r
(
h5X
import
a
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
import
ar
r
}
r
(
h5U
h6j
ubah
<
h
ubhYX
and
r
r
}
r
(
h5X
and
r
h6j
ubh
)
r
}
r
(
h5X
some_function
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
!
hYX
some_functionr
"
r
#
}
r
(
h5U
h6j
ubah
<
h
ubhYX
uses
r
%
r
&
}
r
'
(
h5X
uses
r
(
h6j
ubh
)
r
)
}
r
*
(
h5X
a
.
SomeClass
r
+
h
>
}
r
(
h
]
r
-
hB
]
r
.
hD
]
r
/
hF
]
r0
hH
]
r1
uh6j
h0
]
r2
hYX
a
.
SomeClassr3
r4
}
r5
(
h5U
h6j
)
ubah
<
h
ubhYX
.
Both
of
these
import
forms
are
common
.
In
this
case
the
class
we
want
to
patch
is
being
looked
up
on
the
a
module
and
so
we
have
to
patch
r6
r7
}
r8
(
h5X
.
Both
of
these
import
forms
are
common
.
In
this
case
the
class
we
want
to
patch
is
being
looked
up
on
the
a
module
and
so
we
have
to
patch
r9
h6j
ubh
)
r
:
}
r
;
(
h5X
a
.
SomeClass
r
<
h
>
}
r
=
(
h
]
r
>
hB
]
r
?
hD
]
r
hF
]
rA
hH
]
rB
uh6j
h0
]
rC
hYX
a
.
SomeClassrD
rE
}
rF
(
h5U
h6j
:
ubah
<
h
ubhYX
instead
:
rG
rH
}
rI
(
h5X
instead
:
rJ
h6j
ubeubj
)
rK
}
rL
(
h5U
h6jt
h7h
:
h
<
j
h
>
}
rM
(
h
]
rN
hB
]
rO
hD
]
rP
hF
]
rQ
hH
]
rR
uhJNhKh
h0
]
rS
h
)
rT
}
rU
(
h5X
patch
(
'
a
.
SomeClass
'
)
rV
h6jK
h7h
:
h
<
h
h
>
}
rW
(
h
]
rX
hB
]
rY
hD
]
rZ
hF
]
r
[
hH
]
r
\
uhJMj
h0
]
r
]
h
)
r
^
}
r_
(
h5jV
h
>
}
r
(
h
]
ra
hB
]
rb
hD
]
rc
hF
]
rd
hH
]
re
uh6jT
h0
]
rf
hYX
patch
(
'
a
.
SomeClass
'
)
rg
rh
}
ri
(
h5U
h6j
^
ubah
<
h
ubaubaubeubh2
)
rj
}
rk
(
h5U
h6h3h7h
:
h
<
h
=
h
>
}
rl
(
h
]
rm
hB
]
rn
hD
]
ro
hF
]
rp
h
"
ahH
]
rq
h
auhJMn
hKh
h0
]
rr
(
hM
)
rs
}
rt
(
h5X
&
Patching
Descriptors
and
Proxy
Objectsru
h6jj
h7h
:
h
<
hQh
>
}
rv
(
h
]
rw
hB
]
rx
hD
]
ry
hF
]
rz
hH
]
r
{
uhJMn
hKh
h0
]
r
|
hYX
&
Patching
Descriptors
and
Proxy
Objectsr
}
r
~
}
r
(
h5ju
h6js
ubaubh
)
r
}
r
(
h5X
Since
version
0
.
6
.
0
both
patch_
and
patch
.
object_
have
been
able
to
correctly
patch
and
restore
descriptors
:
class
methods
static
methods
and
properties
.
You
should
patch
these
on
the
*
class
*
rather
than
an
instance
.
r
h6jj
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJMp
hKh
h0
]
r
(
hYX
Since
version
0
.
6
.
0
both
r
r
}
r
(
h5X
Since
version
0
.
6
.
0
both
r
h6j
ubh
)
r
}
r
(
h5X
patch_r
h
K
h6j
h
<
h
h
>
}
r
(
U
namer
X
patchr
hF
]
r
hD
]
r
h
]
r
hB
]
r
hH
]
r
h
h
*
uh0
]
r
hYX
patchr
r
}
r
(
h5U
h6j
ubaubhYX
and
r
r
}
r
(
h5X
and
r
h6j
ubh
)
r
}
r
(
h5X
patch
.
object_r
h
K
h6j
h
<
h
h
>
}
r
(
U
namer
X
patch
.
objectr
hF
]
r
hD
]
r
h
]
r
hB
]
r
hH
]
r
h
h
+
uh0
]
r
hYX
patch
.
objectr
r
}
r
(
h5U
h6j
ubaubhYX
have
been
able
to
correctly
patch
and
restore
descriptors
:
class
methods
static
methods
and
properties
.
You
should
patch
these
on
the
r
r
}
r
(
h5X
have
been
able
to
correctly
patch
and
restore
descriptors
:
class
methods
static
methods
and
properties
.
You
should
patch
these
on
the
r
h6j
ubj
)
r
}
r
(
h5X
*
class
*
r
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX
classr
r
}
r
(
h5U
h6j
ubah
<
j
ubhYX
rather
than
an
instance
.
r
r
}
r
(
h5X
rather
than
an
instance
.
r
h6j
ubeubh
)
r
}
r
(
h5X
Since
version
0
.
7
.
0
patch_
and
patch
.
object_
work
correctly
with
some
objects
that
proxy
attribute
access
like
the
django
setttings
object
<
http
:
/
/
www
.
voidspace
.
org
.
uk
/
python
/
weblog
/
arch_d7_2010_12_04
.
shtml
#
e1198
>
_
.
r
h6jj
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJMt
hKh
h0
]
r
(
hYX
Since
version
0
.
7
.
0
r
r
}
r
(
h5X
Since
version
0
.
7
.
0
r
h6j
ubh
)
r
}
r
(
h5X
patch_r
h
K
h6j
h
<
h
h
>
}
r
(
U
namer
X
patchr
hF
]
r
hD
]
r
h
]
r
hB
]
r
hH
]
r
h
h
*
uh0
]
r
hYX
patchr
r
}
r
(
h5U
h6j
ubaubhYX
and
r
r
}
r
(
h5X
and
r
h6j
ubh
)
r
}
r
(
h5X
patch
.
object_r
h
K
h6j
h
<
h
h
>
}
r
(
U
namer
X
patch
.
objectr
hF
]
r
hD
]
r
h
]
r
hB
]
r
hH
]
r
h
h
+
uh0
]
r
hYX
patch
.
objectr
r
}
r
(
h5U
h6j
ubaubhYXH
work
correctly
with
some
objects
that
proxy
attribute
access
like
the
r
r
}
r
(
h5XH
work
correctly
with
some
objects
that
proxy
attribute
access
like
the
r
h6j
ubh
)
r
}
r
(
h5Xe
django
setttings
object
<
http
:
/
/
www
.
voidspace
.
org
.
uk
/
python
/
weblog
/
arch_d7_2010_12_04
.
shtml
#
e1198
>
_r
h
>
}
r
(
U
namer
X
django
setttings
objectr
j
XH
http
:
/
/
www
.
voidspace
.
org
.
uk
/
python
/
weblog
/
arch_d7_2010_12_04
.
shtml
#
e1198r
hF
]
r
hD
]
r
h
]
r
hB
]
r
hH
]
r
uh6j
h0
]
r
hYX
django
setttings
objectr
r
}
r
(
h5U
h6j
ubah
<
h
ubj
)
r
}
r
(
h5XK
<
http
:
/
/
www
.
voidspace
.
org
.
uk
/
python
/
weblog
/
arch_d7_2010_12_04
.
shtml
#
e1198
>
r
h
K
h6j
h
<
j
h
>
}
r
(
U
refurir
j
hF
]
r
h
ahD
]
r
h
]
r
hB
]
r
hH
]
r
h
auh0
]
r
ubhYX
.
r
}
r
(
h5X
.
h6j
ubeubh
)
r
}
r
(
h5X
In
django
import
settings
and
from
django
.
conf
import
settings
return
different
objects
.
If
you
are
using
libraries
/
apps
that
do
both
you
may
have
to
patch
both
.
Grrr
.
.
.
r
h6jj
h7h
:
h
<
h
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uhJNhKh
h0
]
r
h
)
r
}
r
!
(
h5X
In
django
import
settings
and
from
django
.
conf
import
settings
return
different
objects
.
If
you
are
using
libraries
/
apps
that
do
both
you
may
have
to
patch
both
.
Grrr
.
.
.
r
"
h6j
h7h
:
h
<
h
h
>
}
r
#
(
h
]
r
hB
]
r
%
hD
]
r
&
hF
]
r
'
hH
]
r
(
uhJMz
h0
]
r
)
(
hYX
In
django
r
*
r
+
}
r
(
h5X
In
django
r
-
h6j
ubh
)
r
.
}
r
/
(
h5X
import
settings
r0
h
>
}
r1
(
h
]
r2
hB
]
r3
hD
]
r4
hF
]
r5
hH
]
r6
uh6j
h0
]
r7
hYX
import
settingsr8
r9
}
r
:
(
h5U
h6j
.
ubah
<
h
ubhYX
and
r
;
r
<
}
r
=
(
h5X
and
r
>
h6j
ubh
)
r
?
}
r
(
h5X
"
from
django
.
conf
import
settings
rA
h
>
}
rB
(
h
]
rC
hB
]
rD
hD
]
rE
hF
]
rF
hH
]
rG
uh6j
h0
]
rH
hYX
from
django
.
conf
import
settingsrI
rJ
}
rK
(
h5U
h6j
?
ubah
<
h
ubhYXm
return
different
objects
.
If
you
are
using
libraries
/
apps
that
do
both
you
may
have
to
patch
both
.
Grrr
.
.
.
rL
rM
}
rN
(
h5Xm
return
different
objects
.
If
you
are
using
libraries
/
apps
that
do
both
you
may
have
to
patch
both
.
Grrr
.
.
.
rO
h6j
ubeubaubeubeubah5U
U
transformerrP
NU
footnote_refsrQ
}
rR
U
refnamesrS
}
rT
(
X
patch
.
objectrU
]
rV
(
j
j
eX
where
to
patchrW
]
rX
h
aX
patchrY
]
rZ
(
j
j
euU
symbol_footnotesr
[
]
r
\
U
autofootnote_refsr
]
]
r
^
U
symbol_footnote_refsr_
]
r
U
citationsra
]
rb
hKh
U
current_linerc
NU
transform_messagesrd
]
re
(
cdocutils
.
nodes
system_message
rf
)
rg
}
rh
(
h5U
h
>
}
ri
(
h
]
rj
U
levelrk
K
hF
]
rl
hD
]
rm
U
sourcern
h
:
hB
]
ro
hH
]
rp
U
linerq
M
U
typerr
U
INFOrs
uh0
]
rt
h
)
ru
}
rv
(
h5U
h
>
}
rw
(
h
]
rx
hB
]
ry
hD
]
rz
hF
]
r
{
hH
]
r
|
uh6jg
h0
]
r
}
hYX4
Hyperlink
target
"
start
-
and
-
stop
"
is
not
referenced
.
r
~
r
}
r
(
h5U
h6ju
ubah
<
h
ubah
<
U
system_messager
ubjf
)
r
}
r
(
h5U
h
>
}
r
(
h
]
r
U
levelr
K
hF
]
r
hD
]
r
U
sourcer
h
:
hB
]
r
hH
]
r
U
liner
MA
U
typer
js
uh0
]
r
h
)
r
}
r
(
h5U
h
>
}
r
(
h
]
r
hB
]
r
hD
]
r
hF
]
r
hH
]
r
uh6j
h0
]
r
hYX4
Hyperlink
target
"
where
-
to
-
patch
"
is
not
referenced
.
r
r
}
r
(
h5U
h6j
ubah
<
h
ubah
<
j
ubeU
reporterr
NU
id_startr
K
U
autofootnotesr
]
r
U
citation_refsr
}
r
U
indirect_targetsr
]
r
U
settingsr
(
cdocutils
.
frontend
Values
r
or
}
r
(
U
footnote_backlinksr
K
U
record_dependenciesr
NU
rfc_base_urlr
U
http
:
/
/
tools
.
ietf
.
org
/
html
/
r
U
tracebackr
U
pep_referencesr
NU
strip_commentsr
NU
toc_backlinksr
U
entryr
U
language_coder
U
enr
U
datestampr
NU
report_levelr
K
U
_destinationr
NU
halt_levelr
K
U
strip_classesr
NhQNU
error_encoding_error_handlerr
U
backslashreplacer
U
debugr
NU
embed_stylesheetr
U
output_encoding_error_handlerr
U
strictr
U
sectnum_xformr
K
U
dump_transformsr
NU
docinfo_xformr
K
U
warning_streamr
NU
pep_file_url_templater
U
pep
-
%
04dr
U
exit_status_levelr
K
U
configr
NU
strict_visitorr
NU
cloak_email_addressesr
U
trim_footnote_reference_spacer
U
envr
NU
dump_pseudo_xmlr
NU
expose_internalsr
NU
sectsubtitle_xformr
U
source_linkr
NU
rfc_referencesr
NU
output_encodingr
U
utf
-
8r
U
source_urlr
NU
input_encodingr
U
utf
-
8
-
sigr
U
_disable_configr
NU
id_prefixr
U
U
tab_widthr
K
U
error_encodingr
U
mac
-
romanr
U
_sourcer
U
/
compile
/
mock
/
docs
/
patch
.
txtr
U
gettext_compactr
U
generatorr
NU
dump_internalsr
NU
pep_base_urlr
U
http
:
/
/
www
.
python
.
org
/
dev
/
peps
/
r
U
syntax_highlightr
U
shortr
U
input_encoding_error_handlerr
j
U
auto_id_prefixr
U
idr
U
doctitle_xformr
U
strip_elements_with_classesr
NU
_config_filesr
]
r
U
file_insertion_enabledr
K
U
raw_enabledr
K
U
dump_settingsr
NubU
symbol_footnote_startr
K
U
idsr
}
r
(
h
j
h
(
h3h
#
jt
h
j
h
jS
h
%
j
h
j
&
h
-
jt
h
jk
h
)
j
!
h
+
j
>
h
*
h
h
&
j
h
"
jj
h
j
h
j
h
.
j
h
'
ju
h
/
j
!
uU
substitution_namesr
}
r
h
<
hKh
>
}
r
(
h
]
r
hF
]
r
hD
]
r
U
sourcer
h
:
hB
]
r
hH
]
r
uU
footnotesr
]
r
U
refidsr
}
r
(
h
#
]
r
jj
ah
/
]
r
j
auub
.
