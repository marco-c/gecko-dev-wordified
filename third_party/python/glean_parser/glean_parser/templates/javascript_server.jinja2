{
#
The
final
Javascript
/
Typescript
code
is
autogenerated
but
this
Jinja2
template
is
not
.
Please
file
bugs
!
#
}
/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
/
/
AUTOGENERATED
BY
glean_parser
v
{
{
parser_version
}
}
.
DO
NOT
EDIT
.
DO
NOT
COMMIT
.
/
/
This
requires
uuid
and
mozlog
libraries
to
be
in
the
environment
{
%
if
lang
=
=
"
typescript
"
%
}
/
/
types
/
uuid
and
mozlog
types
definitions
are
required
in
devDependencies
/
/
for
the
latter
see
https
:
/
/
github
.
com
/
mozilla
/
fxa
/
blob
/
85bda71cda376c417b8c850ba82aa14252208c3c
/
types
/
mozlog
/
index
.
d
.
ts
{
%
endif
%
}
import
{
v4
as
uuidv4
}
from
'
uuid
'
;
import
mozlog
{
%
if
lang
=
=
"
typescript
"
%
}
{
Logger
}
{
%
endif
%
}
from
'
mozlog
'
;
const
GLEAN_EVENT_MOZLOG_TYPE
=
'
glean
-
server
-
event
'
;
let
_logger
{
%
if
lang
=
=
"
typescript
"
%
}
:
Logger
{
%
endif
%
}
;
{
%
for
ping
metrics_by_type
in
pings
.
items
(
)
%
}
class
{
{
ping
|
event_class_name
}
}
{
{
%
if
lang
=
=
"
typescript
"
%
}
_applicationId
:
string
;
_appDisplayVersion
:
string
;
_channel
:
string
;
{
%
endif
%
}
/
*
*
*
Create
{
{
ping
|
event_class_name
}
}
instance
.
*
*
param
{
string
}
applicationId
-
The
application
ID
.
*
param
{
string
}
appDisplayVersion
-
The
application
display
version
.
*
param
{
string
}
channel
-
The
channel
.
*
/
{
%
if
lang
=
=
"
typescript
"
%
}
constructor
(
applicationId
:
string
appDisplayVersion
:
string
channel
:
string
logger_options
:
any
)
{
{
%
else
%
}
constructor
(
applicationId
appDisplayVersion
channel
logger_options
)
{
{
%
endif
%
}
this
.
_applicationId
=
applicationId
;
this
.
_appDisplayVersion
=
appDisplayVersion
;
this
.
_channel
=
channel
;
if
(
!
_logger
)
{
/
/
append
'
-
glean
'
to
logger_options
.
app
to
avoid
collision
with
other
loggers
and
double
logging
logger_options
.
app
=
logger_options
.
app
+
'
-
glean
'
;
/
/
set
the
format
to
heka
so
messages
are
properly
ingested
and
decoded
logger_options
.
fmt
=
'
heka
'
;
{
%
if
lang
=
=
"
typescript
"
%
}
/
/
mozlog
types
declaration
requires
a
typePrefix
to
be
passed
when
creating
a
logger
/
/
we
don
'
t
want
a
typePrefix
so
we
pass
undefined
_logger
=
mozlog
(
logger_options
)
(
undefined
)
;
{
%
else
%
}
_logger
=
mozlog
(
logger_options
)
(
)
;
{
%
endif
%
}
}
}
/
*
*
*
Record
and
submit
a
server
event
object
.
*
Event
is
logged
using
internal
mozlog
logger
.
*
{
%
for
metric_type
metrics
in
metrics_by_type
.
items
(
)
%
}
{
%
for
metric
in
metrics
%
}
*
param
{
{
{
-
metric
|
js_metric_type
-
}
}
}
{
{
metric
|
metric_argument_name
}
}
-
{
{
metric
|
metric_argument_description
}
}
.
{
%
endfor
%
}
{
%
endfor
%
}
*
/
record
(
{
{
%
for
metric_type
metrics
in
metrics_by_type
.
items
(
)
%
}
{
%
for
metric
in
metrics
%
}
{
{
metric
|
metric_argument_name
}
}
{
%
endfor
%
}
{
%
endfor
%
}
{
%
if
lang
=
=
"
typescript
"
%
}
}
:
{
{
%
for
metric_type
metrics
in
metrics_by_type
.
items
(
)
%
}
{
%
for
metric
in
metrics
%
}
{
{
metric
|
metric_argument_name
}
}
:
{
{
metric
|
js_metric_type
}
}
;
{
%
endfor
%
}
{
%
endfor
%
}
{
%
endif
%
}
}
)
{
let
timestamp
=
new
Date
(
)
.
toISOString
(
)
;
let
eventPayload
=
{
metrics
:
{
{
%
for
metric_type
metrics
in
metrics_by_type
.
items
(
)
%
}
{
{
metric_type
}
}
:
{
{
%
for
metric
in
metrics
%
}
'
{
{
metric
|
metric_name
}
}
'
:
{
{
metric
|
metric_argument_name
}
}
{
%
endfor
%
}
}
{
%
endfor
%
}
}
ping_info
:
{
seq
:
0
/
/
this
is
required
however
doesn
'
t
seem
to
be
useful
in
server
context
start_time
:
timestamp
end_time
:
timestamp
}
/
/
Unknown
fields
below
are
required
in
the
Glean
schema
however
they
are
not
useful
in
server
context
client_info
:
{
telemetry_sdk_build
:
'
glean_parser
v
{
{
parser_version
}
}
'
first_run_date
:
'
Unknown
'
os
:
'
Unknown
'
os_version
:
'
Unknown
'
architecture
:
'
Unknown
'
app_build
:
'
Unknown
'
app_display_version
:
this
.
_appDisplayVersion
app_channel
:
this
.
_channel
}
}
;
let
eventPayloadSerialized
=
JSON
.
stringify
(
eventPayload
)
;
/
/
This
is
the
message
structure
that
Decoder
expects
:
https
:
/
/
github
.
com
/
mozilla
/
gcp
-
ingestion
/
pull
/
2400
let
ping
=
{
document_namespace
:
this
.
_applicationId
document_type
:
'
{
{
ping
}
}
'
document_version
:
'
1
'
document_id
:
uuidv4
(
)
payload
:
eventPayloadSerialized
}
;
/
/
this
is
similar
to
how
FxA
currently
logs
with
mozlog
:
https
:
/
/
github
.
com
/
mozilla
/
fxa
/
blob
/
4c5c702a7fcbf6f8c6b1f175e9172cdd21471eac
/
packages
/
fxa
-
auth
-
server
/
lib
/
log
.
js
#
L289
_logger
.
info
(
GLEAN_EVENT_MOZLOG_TYPE
ping
)
;
}
}
{
%
endfor
%
}
{
%
for
ping
in
pings
%
}
export
const
{
{
ping
|
factory_method
}
}
=
function
(
{
applicationId
appDisplayVersion
channel
logger_options
{
%
if
lang
=
=
"
typescript
"
%
}
}
:
{
applicationId
:
string
;
appDisplayVersion
:
string
;
channel
:
string
;
logger_options
:
any
;
{
%
endif
%
}
}
)
{
return
new
{
{
ping
|
event_class_name
}
}
(
applicationId
appDisplayVersion
channel
logger_options
)
;
}
;
{
%
endfor
%
}
