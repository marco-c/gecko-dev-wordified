use
once_cell
:
:
sync
:
:
Lazy
;
use
regex
:
:
Captures
;
use
regex
:
:
Regex
;
use
std
:
:
borrow
:
:
Cow
;
static
TRANSFORM_SMALL_MAP
:
&
[
char
]
=
&
[
'
a
'
'
'
'
'
'
'
'
e
'
'
'
'
'
'
'
'
i
'
'
'
'
'
'
'
'
'
'
'
'
o
'
'
'
'
'
'
'
'
'
'
'
'
u
'
'
'
'
'
'
'
'
'
'
'
]
;
static
TRANSFORM_CAPS_MAP
:
&
[
char
]
=
&
[
'
A
'
'
'
'
'
'
'
'
E
'
'
'
'
'
'
'
'
I
'
'
'
'
'
'
'
'
'
'
'
'
O
'
'
'
'
'
'
'
'
'
'
'
'
U
'
'
'
'
'
'
'
'
'
'
'
]
;
static
FLIPPED_SMALL_MAP
:
&
[
char
]
=
&
[
'
'
'
q
'
'
'
'
p
'
'
'
'
'
'
'
'
'
'
'
'
'
'
'
'
'
'
'
'
u
'
'
o
'
'
d
'
'
b
'
'
'
'
s
'
'
'
'
n
'
'
'
'
'
'
x
'
'
'
'
z
'
]
;
static
FLIPPED_CAPS_MAP
:
&
[
char
]
=
&
[
'
'
'
'
'
'
'
'
'
'
'
'
'
'
'
H
'
'
I
'
'
'
'
'
'
'
'
W
'
'
N
'
'
O
'
'
'
'
'
'
'
'
S
'
'
'
'
'
'
'
'
M
'
'
X
'
'
'
'
Z
'
]
;
static
RE_EXCLUDED
:
Lazy
<
Regex
>
=
Lazy
:
:
new
(
|
|
Regex
:
:
new
(
r
"
&
[
#
\
w
]
+
;
|
<
\
s
*
.
+
?
\
s
*
>
"
)
.
unwrap
(
)
)
;
static
RE_AZ
:
Lazy
<
Regex
>
=
Lazy
:
:
new
(
|
|
Regex
:
:
new
(
r
"
[
a
-
zA
-
Z
]
"
)
.
unwrap
(
)
)
;
pub
fn
transform_dom
(
s
:
&
str
flipped
:
bool
elongate
:
bool
with_markers
:
bool
)
-
>
Cow
<
str
>
{
/
/
Exclude
access
-
keys
and
other
single
-
char
messages
if
s
.
len
(
)
=
=
1
{
return
s
.
into
(
)
;
}
/
/
XML
entities
(
&
#
x202a
;
)
and
XML
tags
.
let
mut
result
=
Cow
:
:
from
(
s
)
;
let
mut
pos
=
0
;
let
mut
diff
=
0
;
for
cap
in
RE_EXCLUDED
.
captures_iter
(
s
)
{
let
capture
=
cap
.
get
(
0
)
.
unwrap
(
)
;
let
sub_len
=
capture
.
start
(
)
-
pos
;
let
range
=
pos
.
.
capture
.
start
(
)
;
let
result_range
=
pos
+
diff
.
.
capture
.
start
(
)
+
diff
;
let
sub
=
&
s
[
range
.
clone
(
)
]
;
let
transform_sub
=
transform
(
sub
false
true
)
;
diff
+
=
transform_sub
.
len
(
)
-
sub_len
;
result
.
to_mut
(
)
.
replace_range
(
result_range
.
clone
(
)
&
transform_sub
)
;
pos
=
capture
.
end
(
)
;
}
let
range
=
pos
.
.
s
.
len
(
)
;
let
result_range
=
pos
+
diff
.
.
result
.
len
(
)
;
let
transform_sub
=
transform
(
&
s
[
range
]
flipped
elongate
)
;
result
.
to_mut
(
)
.
replace_range
(
result_range
&
transform_sub
)
;
if
with_markers
{
return
Cow
:
:
from
(
"
[
"
)
+
result
+
"
]
"
;
}
result
}
pub
fn
transform
(
s
:
&
str
flipped
:
bool
elongate
:
bool
)
-
>
Cow
<
str
>
{
let
(
small_map
caps_map
)
=
if
flipped
{
(
FLIPPED_SMALL_MAP
FLIPPED_CAPS_MAP
)
}
else
{
(
TRANSFORM_SMALL_MAP
TRANSFORM_CAPS_MAP
)
}
;
RE_AZ
.
replace_all
(
s
|
caps
:
&
Captures
|
{
let
ch
=
caps
[
0
]
.
chars
(
)
.
next
(
)
.
unwrap
(
)
;
let
cc
=
ch
as
u8
;
if
(
97
.
.
=
122
)
.
contains
(
&
cc
)
{
let
pos
=
cc
-
97
;
let
new_char
=
small_map
[
pos
as
usize
]
;
/
/
duplicate
"
a
"
"
e
"
"
o
"
and
"
u
"
to
emulate
~
30
%
longer
text
if
elongate
&
&
(
cc
=
=
97
|
|
cc
=
=
101
|
|
cc
=
=
111
|
|
cc
=
=
117
)
{
let
mut
s
=
new_char
.
to_string
(
)
;
s
.
push
(
new_char
)
;
s
}
else
{
new_char
.
to_string
(
)
}
}
else
if
(
65
.
.
=
90
)
.
contains
(
&
cc
)
{
let
pos
=
cc
-
65
;
let
new_char
=
caps_map
[
pos
as
usize
]
;
new_char
.
to_string
(
)
}
else
{
ch
.
to_string
(
)
}
}
)
}
#
[
cfg
(
test
)
]
mod
tests
{
use
super
:
:
*
;
#
[
test
]
fn
it_works
(
)
{
let
x
=
transform
(
"
Hello
World
"
false
true
)
;
assert_eq
!
(
x
"
ee
oo
oo
"
)
;
let
x
=
transform
(
"
Hello
World
"
false
false
)
;
assert_eq
!
(
x
"
e
o
o
"
)
;
let
x
=
transform
(
"
Hello
World
"
true
false
)
;
assert_eq
!
(
x
"
H
o
Mo
p
"
)
;
let
x
=
transform
(
"
f
"
false
true
)
;
assert_eq
!
(
x
"
"
)
;
}
#
[
test
]
fn
dom_test
(
)
{
let
x
=
transform_dom
(
"
Hello
<
a
>
World
<
/
a
>
"
false
true
false
)
;
assert_eq
!
(
x
"
ee
oo
<
a
>
oo
<
/
a
>
"
)
;
let
x
=
transform_dom
(
"
Hello
<
a
>
World
<
/
a
>
in
<
b
>
my
<
/
b
>
House
.
"
false
true
false
)
;
assert_eq
!
(
x
"
ee
oo
<
a
>
oo
<
/
a
>
i
<
b
>
<
/
b
>
oouu
ee
.
"
)
;
/
/
Use
markers
.
let
x
=
transform_dom
(
"
Hello
World
within
markers
"
false
false
true
)
;
assert_eq
!
(
x
"
[
e
o
o
i
i
a
e
]
"
)
;
/
/
Don
'
t
touch
single
character
values
.
let
x
=
transform_dom
(
"
f
"
false
true
false
)
;
assert_eq
!
(
x
"
f
"
)
;
}
}
