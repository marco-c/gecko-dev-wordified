;
TeX
output
1995
.
10
.
19
:
1430
?
d
d
N
ff
cmbx12
Strictness
ffAnalysis
I
4a
Grande
Vitesse
:
Rewriting
ffthe
rules
of
the
Ev
aluation
T
fransformers
game
5
X
Q
ff
cmr12
Second
/
draft
:
D
>
Octob
dCer
19
1995
.
Commen
ts
are
w
elcomed
.
=
!
"
cmsy10
y
(
K
y
3
cmr10
Julian
fSew
!
ard
5
)
JDepartmen
!
t
fof
Computer
Science
Univ
ersit
y
of
Manc
hester
M13
9PL
UK
>
?
7
<
x
3
cmtt10
sewardj
cs
.
man
.
ac
.
uk
"
kAH
cmssbx10
Abstract
o
cmr9
This
l
pap
A
er
presen
9ts
the
design
of
a
strictness
analyser
pri
-
marily
u
in
9tended
to
assist
in
the
parallelisation
of
Hask
ell
programs
.
The
q
analyser
generates
detailed
ev
|
raluation
trans
-
former
'
information
suitable
for
use
in
a
parallel
graph
re
-
duction
ssmac
9hine
.
6
By
tuning
the
design
to
handle
common
cases
H
'
rapidly
:
T
w
9e
ac
hiev
e
go
A
o
d
H
'
p
erformance
o
9v
er
a
range
of
realistic
~
test
inputs
.
of
sizes
up
to
a
thousand
lines
.
P
9er
-
formance
/
gures
are
presen
9ted
.
F
:
rom
measuring
the
time
it
!
Stak
9es
Glasgo
w
Hask
ell
0
.
10
to
compile
those
same
pro
-
grams
it
w3is
apparen
9t
that
the
analyser
is
su
cien
tly
quic
k
to
b
A
e
approac
9hing
the
p
oin
9t
where
incorp
orating
it
in
9to
a
Hask
9ell
Tcompiler
is
a
viable
prop
A
osition
.
Our
strictness
analyser
con
9tains
three
ma
jor
inno
v
|
rations
.
Firstly
:
w
9e
emplo
y
a
mixed
forw
ard
and
bac
kw
ards
analy
-
sis
l
whic
9h
'
allo
ws
us
to
do
pro
jection
analysis
ev
en
in
the
presence
Fof
higher
order
functions
.
ESecondly
:
w
9e
solv
e
the
resulting
recursiv
9e
domain
equations
using
a
sophisticated
term
rewriting
system
Nlwhic
9h
as
far
as
w
e
kno
w
Nlhas
abilities
far
9
~
b
A
ey
9ond
previous
rewrite
based
solv
ers
in
abstract
in
ter
-
pretation
systems
.
Finally
:
xw
9e
a
v
oid
man
y
of
the
di
culties
of
|
higher
order
analysis
b
9y
automatically
transforming
out
most
Thigher
order
functions
b
A
efore
analysis
b
egins
.
-
1
Intro
Ffduction
Higher
-
order
Z
non
-
at
dstrictness
analysis
tec
9hniques
ha
v
e
ac
-
quired
a
reputation
for
b
A
eing
to
o
exp
ensiv
9e
for
use
in
pro
-
duction
scompilers
.
This
is
a
pit
9y
:
since
man
y
suc
h
functions
b
A
eha
9v
e
in
relativ
9ely
simple
w
a
ys
~
whic
h
suggests
their
ab
-
stract
Tb
A
eha
9viour
could
b
e
divined
without
m
9uc
h
Tdi
cult
y
:
.
One
of
the
main
themes
whic
9h
c
haracterised
the
past
decade
'
s
adv
|
rances
in
hardw
9are
and
soft
w
are
p
A
erformance
is
5
that
of
measuremen
9t
-
lead
design
.
}
\
This
sc
ho
A
ol
of
though
t
bases
design
on
measuring
what
programs
do
most
often
and
WQmaking
these
common
activities
as
fast
as
p
A
ossible
}
Rev
9en
at
the
exp
A
ense
of
slo
9wing
do
wn
less
common
op
A
erations
.
These
ideas
r
elab
A
orated
in
Hennessy
&
P
9atterson
[
HP90
z
]
ff
_
34
+
b
r
0n
cmsy5
Y
R
cmr7
My
}
^
ap
7
ologies
for
the
dog
-
rough
t
yp
esetting
.
|
This
will
b
e
xed
in
later
v
ersions
of
the
pap
7
er
.
fh
"
pla
9y
ed
a
cen
9tral
role
in
the
RISC
{
rev
olution
Hand
ha
v
e
b
A
een
tak
9en
up
recen
tly
b
y
the
functional
programming
comm
u
-
nit
9y
T
[
PHHP93
#
]
[
P
ar92
]
.
W
:
e
presen
9t
Zin
detail
the
design
of
a
fast
strictness
analyser
for
Hask
9ell
dealing
with
higher
-
order
functions
and
gen
-
erating
v
ev
|
raluation
transformer
information
suitable
for
use
in
Uparallel
graph
reduction
systems
[
Bur87
]
[
Bur91
]
.
sPre
-
liminary
5
exp
A
erimen
9ts
ha
v
e
b
A
een
encouraging
.
}
F
:
or
example
running
in
compiled
Hask
9ell
on
a
Sun
Sparc
-
10
a
618
line
program
}
Xw
9as
analysed
in
44
seconds
.
T
|
Of
this
Yroughly
half
w
9as
dev
oted
to
parsing
U
desugaring
and
t
yp
A
ec
hec
king
U
ex
-
p
A
enses
R
whic
9h
an
y
compiler
w
ould
incur
.
As
a
naiv
e
rst
implemen
9tation
jthere
is
ample
scop
A
e
for
p
erformance
im
-
pro
9v
emen
t
.
This
X
pap
A
er
argues
in
fa
9v
our
X
of
a
measuremen
9t
-
lead
approac
h
for
qthe
implemen
9tation
of
seman
tic
analysis
tec
hniques
for
functional
languages
.
UA
ma
jor
emphasis
is
to
feed
the
anal
-
yser
L
the
kinds
of
programs
p
A
eople
really
write
Z
rather
than
basing
design
decisions
on
the
usual
Mic
9k
ey
Mouse
exam
-
ples
o
A
ccurring
so
frequen
9tly
in
pap
ers
on
the
sub
ject
.
xT
:
o
this
end
test
inputs
ha
9v
e
b
A
een
tak
9en
from
the
b
enc
9hmark
suites
Tof
Hartel
[
HL92
l
]
and
P
9artain
[
P
ar92
]
.
Suc
9h
?
an
approac
h
rev
eals
some
in
teresting
facts
.
~
F
:
or
ex
-
ample
w
9e
cdisco
v
ered
the
main
limitation
on
analyser
p
A
er
-
formance
#
w
9as
not
the
necessit
y
to
iterate
to
and
detect
x
-
p
A
oin
9ts
as
had
b
een
assumed
b
9y
so
man
y
theoretics
.
Rather
it
a
w
9as
the
sheer
size
of
the
terms
generated
during
the
ab
-
stract
cBin
9terpretation
phase
.
;
By
in
tro
A
ducing
a
little
more
in
9telligence
Gin
to
that
phase
8
term
size
is
cut
dramatically
:
giving
Ta
corresp
A
onding
p
erformance
increase
.
Similarly
:
h
p
A
olymorphism
X
is
dealt
with
b
9y
the
crude
mec
ha
-
nism
of
a
monomorphisation
pass
b
A
efore
analysis
.
/
Previous
w
9ork
ers
pincluding
m
yself
assumed
this
w
9as
a
\
bad
thing
"
(
see
[
HH91
>
]
and
[
Sew93
/
]
)
and
put
m
9uc
h
e
ort
in
9to
devising
p
A
olymorphic
analysis
metho
ds
[
Bar91
U
]
.
5Y
:
et
the
feared
co
de
explosion
it
seems
simply
do
A
es
not
happ
en
.
Measuremen
9ts
b
9y
<
Mark
Jones
on
a
13000
line
Hask
ell
program
{
the
source
co
A
de
TDof
this
analyser
{
rev
9eal
that
only
a
v
ery
few
p
A
oly
-
morphic
G
functions
T
for
example
M
N
cmtt9
Mmap
and
Mfoldr
are
used
at
a
large
n
9um
b
A
er
of
instances
.
Certainly
:
monomorphisation
do
A
es
w
not
cause
an
9y
noticeable
p
erformance
problems
for
this
analyser
.
#
A
m
m
9uc
h
m
b
A
etter
reason
for
disliking
monomorphic
analyses
#
is
that
they
signi
can
9tly
complicate
life
when
mo
A
d
-
ules
Tapp
A
ear
on
the
scene
.
*
?
1
.
1
G
Overview
L
of
pap
Ffer
m
The
Iremainder
of
the
in
9tro
A
duction
is
dev
oted
to
an
o
v
erview
of
Tthe
analyser
henceforth
referred
to
as
Nt
:
cmbx9
NAnna
.
Section
2
deals
with
tec
9hnical
preliminaries
.
/
In
particular
w
9e
nexamine
ho
w
t
yp
A
es
in
the
source
program
are
mapp
ed
to
abstract
domains
suitable
for
the
con
9trol
of
parallel
ev
|
ralua
-
tion
.
The
~
abstract
in
9terpretation
used
forms
the
sub
ject
of
sec
-
tion
e
<
3
.
'
A
d
v
|
rarian
9t
of
the
pro
jection
analysis
describ
A
ed
in
section
6
of
[
Hug87
'
]
r
the
tec
9hnique
is
a
mixed
bac
kw
ards
and
forw
9ards
analysis
with
the
aim
of
p
A
erforming
bac
k
-
w
9ards
4analysis
.
By
supplying
just
enough
\
forw
ards
"
infor
-
mation
l
to
turn
functions
in
9to
rst
class
citizens
the
analysis
deals
sensibly
with
higher
-
order
functions
kpartial
applica
-
tions
Tand
functions
inside
data
structures
.
Section
4
presen
9ts
/
in
detail
the
elab
A
orate
term
rewriting
system
lused
to
detect
xed
p
A
oin
9ts
in
the
recursiv
e
domain
equations
Tgenerated
b
9y
the
abstract
in
terpreter
.
F
:
unctional
f
programmers
ha
9v
e
f
long
observ
9ed
that
large
parts
of
z
the
programs
they
write
can
b
A
e
mec
9hanically
transformed
to
e
ha
9v
e
no
higher
-
order
functions
.
(
Anna
exploits
this
to
go
A
o
d
e
ect
transforming
a
9w
a
y
as
man
9y
higher
-
order
func
-
tions
ias
p
A
ossible
b
efore
analysis
.
"
Common
higher
order
func
-
tions
c
|
whic
9h
encapsulate
particular
forms
of
recursion
w
suc
h
as
g
Mfoldr
{
are
trivially
remo
9v
ed
.
Ev
en
g
more
di
cult
forms
lik
9e
P
the
monads
so
b
A
elo
v
ed
in
certain
quarters
[
W
:
ad92
]
are
transformable
.
)
Nev
9ertheless
some
o
di
culties
remain
.
Sec
-
tion
o5
discusses
all
this
in
detail
.
W
:
e
also
lo
A
ok
brie
y
at
the
monomorphiser
.
Finally
:
/
in
9section
6
all
these
go
A
o
dies
9are
dra
9wn
together
with
a
discussion
of
the
system
'
s
p
A
erformance
k
and
of
related
and
Tfurther
w
9ork
.
1
.
2
G
Overview
L
of
the
analyser
'
s
front
end
m
Anna
pis
a
large
Hask
9ell
program
B
consisting
of
more
than
13000
7
lines
.
Op
A
eration
is
simple
.
Anna
reads
a
source
pro
-
gram
Cyon
the
standard
input
O
and
p
A
erforms
extensiv
9e
trans
-
formations
on
the
program
prin
9ting
it
out
at
v
|
rarious
p
A
oin
ts
on
1
the
w
9a
y
:
.
q
Finally
8
the
1
strictness
information
is
generated
and
Tprin
9ted
.
The
y
language
accepted
is
a
subset
of
Hask
9ell
.
IfMissing
fea
-
tures
are
an
9ything
to
do
with
o
v
erloading
C
mo
A
dules
or
arra
ys
.
Because
of
these
+
o
ering
up
arbitrary
Hask
9ell
programs
for
analysis
is
a
di
cult
task
:
Gall
o
9v
erloading
has
to
b
A
e
resolv
9ed
b
9y
hand
*
a
tedious
business
.
The
lac
k
of
mo
A
dule
supp
ort
do
A
es
r
not
pro
9v
e
r
m
uc
h
of
a
problem
(
since
m
ultimo
A
dule
inputs
are
nsimply
concatenated
in
9to
one
massiv
e
program
mo
A
dulo
solving
|
the
o
A
dd
renaming
problem
along
the
w
9a
y
:
.
R
Anna
kno
9ws
Ynothing
ab
A
out
the
Hask
ell
prelude
s
and
the
relev
|
ran
t
parts
of
this
to
A
o
need
to
b
e
inserted
in
9to
the
inputs
.
A
v
ery
few
(
op
A
erations
are
tak
9en
as
primitiv
e
:
A
M
(
+
)
l
M
(
-
)
M
(
*
)
(
and
M
(
/
)
~
all
{
of
t
9yp
A
e
MInt
-
>
Int
-
>
Int
comparisons
{
M
(
<
)
M
(
<
=
)
M
(
=
=
)
n
M
(
/
=
)
M
(
>
)
E
and
M
(
>
=
)
n
of
t
9yp
A
e
MInt
-
>
Int
-
>
Bool
and
con
9v
ersion
=
functions
Mchr
and
Mord
of
t
9yp
A
e
MInt
-
>
Char
=
and
MChar
-
>
Int
resp
A
ectiv
9ely
:
.
A
v
|
ralid
program
m
ust
supply
a
binding
for
Mmain
but
unlik
9e
a
Hask
ell
program
this
ma
y
b
A
e
of
Tan
9y
t
yp
A
e
.
Despite
i
this
meagre
collection
of
primitiv
9es
Anna
kno
ws
ab
A
out
f
most
of
the
built
-
in
Hask
9ell
t
yp
A
es
including
b
o
oleans
c
9haracters
T
strings
lists
G
and
tuples
.
Although
some
imp
A
or
-
tan
9t
features
of
Hask
ell
are
missing
the
subset
allo
ws
Anna
to
:
Cb
A
e
fed
real
-
w
9orld
programs
of
considerable
complexit
y
:
alb
A
eit
Tafter
some
considerable
massaging
.
Probably
g
)
the
b
A
est
w
9a
y
g
)
to
think
of
Anna
is
as
a
framew
9ork
for
Itrying
out
new
analysis
tec
9hniques
.
NHence
Fthe
system
logically
%
consists
of
t
9w
o
%
parts
:
=
the
analysis
prop
A
er
)
and
the
supp
A
orting
u
framew
9ork
.
=
The
in
terface
b
A
et
w
een
the
t
w
o
is
reasonably
Vclean
so
c
9hanging
the
nature
of
the
analysis
can
b
A
e
udone
without
m
9uc
h
uuphea
v
|
ral
.
D
This
section
fo
A
cusses
on
the
Tsupp
A
orting
framew
9ork
.
Because
'
w
9e
w
an
t
to
exercise
the
analyses
on
functional
pro
-
grams
T
'
of
realistic
size
z
the
supp
A
orting
framew
9ork
is
necessar
-
ily
large
and
complex
.
Indeed
the
analysis
part
is
curren
9tly
the
smaller
of
the
t
9w
o
.
The
framew
ork
con
tains
a
go
A
o
dly
part
of
what
one
migh
9t
exp
A
ect
to
nd
in
a
full
-
scale
com
-
piler
Tfor
the
same
language
:
O
P
cmsy9
P
:
F
:
ollo
9wing
=
the
parsing
stage
desugaring
and
pattern
:
matc
9hing
0
transformations
are
carried
out
.
o
These
pro
-
:
duce
y
NCore
O
a
minimal
functional
language
used
as
:
an
-
in
9termediate
form
in
the
Glasgo
w
Hask
ell
com
-
:
piler
[
PHHP93
#
]
\
and
t
9ypical
of
the
in
termediate
forms
:
of
|
v
|
rarious
other
compilers
for
example
the
Chalmers
:
Hask
9ell
-
B
}
Compiler
[
Aug87
'
]
.
hAll
further
transforma
-
:
tions
prior
to
strictness
analysis
prop
A
er
are
Core
-
to
-
:
Core
Ttransformations
.
34
P
:
A
M
dep
A
endancy
N
analysis
phase
splits
the
program
up
:
in
9to
yminimal
m
utually
recursiv
e
groups
and
marks
:
non
-
recursiv
9e
M
>
bindings
as
suc
h
.
.
All
subsequen
t
trans
-
:
formations
B
are
required
to
main
9tain
dep
A
endancy
order
.
P
:
A
zcrude
but
e
ectiv
9e
Core
simpli
cation
pass
remo
v
es
:
un
9used
bindings
and
substitutes
in
constan
t
bindings
:
only
:
used
once
.
This
helps
to
clean
up
the
rather
messy
:
output
-
of
the
desugarer
.
The
former
feature
is
useful
:
for
;
debugging
the
analyser
.
Because
a
binding
for
Mmain
:
m
9ust
b
A
e
supplied
the
simpli
er
will
ev
en
tually
remo
v
e
:
all
bindings
not
reac
9hable
from
Mmain
.
If
the
analyser
is
:
seen
to
malfunction
arbitrary
subsections
of
the
input
:
program
can
b
A
e
discarded
simply
b
9y
c
hanging
the
b
A
o
dy
:
of
Mmain
un
9til
what
remains
is
small
enough
to
mak
e
:
debugging
Tviable
.
P
:
Remo
9ving
.
nested
en
vironmen
ts
mak
es
subsequen
t
:
transformations
i
and
analyses
simpler
.
9T
:
o
this
end
the
:
program
Vis
attened
out
b
9y
a
mo
A
di
ed
Johnsson
-
st
yle
:
lam
9b
A
da
-
lifter
[
Joh85
9
]
!
follo
w
ed
b
y
another
dep
A
endancy
:
analysis
Tpass
.
P
:
The
program
is
no
9w
t
yp
A
ec
hec
k
ed
using
a
standard
:
Milner
-
Hindley
inferencer
deriv
9ed
from
Chapter
9
of
:
P
9eyton
uJones
'
b
A
o
ok
u
[
P
ey87
H
]
.
l
Ev
ery
no
A
de
in
the
Core
:
tree
;
has
a
t
9yp
A
e
expression
attac
hed
.
hAlthough
a
com
-
:
plete
mannotation
is
rather
exp
A
ensiv
9e
it
is
essen
tial
for
:
subsequen
9t
Tpasses
.
P
:
The
Nsingle
most
complicated
transformation
8
higher
-
:
order
function
remo
9v
|
ral
(
also
kno
wn
as
sp
A
ecialisation
:
or
z
rsti
cation
)
no
9w
follo
ws
.
(
The
presen
t
naiv
e
im
-
:
plemen
9tation
|
xdescrib
A
ed
g
in
Section
5
is
slo
9w
but
cor
-
:
rect
.
cMost
if
not
all
of
the
higher
-
orderness
of
t
9ypi
-
:
cal
Q
programs
can
b
A
e
remo
9v
ed
.
>
This
Q
transformation
is
:
complicated
yb
9y
the
need
to
main
tain
t
yp
A
e
annotations
:
correctly
:
.
j
2
?
P
:
Finally
:
Sthe
program
is
monomorphised
.
g
This
pass
is
:
quic
9k
and
relativ
ely
painless
\
ev
en
though
a
third
trip
:
through
the
dep
A
endancy
analyser
is
subsequen
9tly
re
-
:
quired
.
Most
compilers
w
9ould
w
an
t
to
mangle
the
output
of
the
desugarer
5rin
quite
di
eren
9t
w
a
ys
to
generate
go
A
o
d
5rco
de
.
F
:
or
-
tunately
:
it
is
easy
to
see
ho
9w
the
output
of
the
strictness
analyser
prop
A
er
p
ertains
to
the
desugared
program
.
)
Only
t
9w
o
Ttransformations
giv
9e
m
uc
h
trouble
:
P
:
Lam
9b
A
da
-
lifting
psimply
mo
v
es
bindings
from
inner
lev
-
:
els
V
to
the
top
lev
9el
|
and
adds
extra
parameters
.
With
a
:
little
bb
A
o
okk
9eeping
_it
is
p
ossible
to
k
9eep
trac
k
of
where
:
nested
p
bindings
ended
up
rso
that
strictness
informa
-
:
tion
Tcan
b
A
e
related
bac
9k
to
them
.
x
P
:
Higher
-
order
1tfunction
remo
9v
|
ral
will
only
ev
er
remo
v
e
:
higher
-
order
NTfunctions
whic
9h
ha
v
e
b
A
ecome
irrelev
|
ran
t
:
b
A
ecause
G
of
sp
ecialisation
.
All
rst
-
order
functions
are
:
preserv
9ed
.
gwW
:
e
.
Vare
really
only
in
terested
in
deriv
-
:
ing
Xev
|
raluation
transformers
for
the
rst
order
func
-
:
tions
.
This
m
}
is
b
A
ecause
the
demand
propagated
across
:
a
/
higher
-
order
function
largely
dep
A
ends
on
what
the
:
higher
-
order
Eparameter
is
.
kSo
exploiting
demand
prop
-
:
agation
Xacross
higher
-
order
functions
means
run
9time
:
manipulation
of
ev
|
raluation
transformers
|
a
serious
:
complication
Tfor
parallel
graph
reduction
systems
.
Building
and
main
9taining
the
framew
ork
is
a
tiresome
time
consuming
z
task
.
One
could
also
argue
all
that
e
ort
w
9as
un
-
necessarily
:
%
_b
A
ecause
"
*
the
Glasgo
9w
Hask
ell
team
ha
v
e
sp
A
eci
-
cally
designed
their
compiler
as
a
basis
for
exp
A
erimen
9ts
lik
e
this
5and
f
v
|
ralian
9tly
supp
A
orted
those
bra
v
e
enough
to
tak
e
them
up
[
PHHP93
#
]
.
In
retrosp
A
ect
there
are
three
reasons
wh
9y
TAnna
w
as
not
built
in
to
Glasgo
w
Hask
ell
:
1
.
:
A
9t
the
time
w
ork
on
Anna
b
A
egun
in
the
summer
of
:
1991
Glasgo
9w
'
s
compiler
(
v
ersion
0
.
02
)
w
as
in
still
in
:
the
Tpro
A
cess
of
dev
9elopmen
t
.
x
2
.
:
Un
9til
gFrecen
tly
:
the
analyser
w
as
relativ
ely
feeble
so
:
the
need
to
feed
it
realistic
Hask
9ell
programs
has
only
:
recen
9tly
Tarisen
.
3
.
:
The
most
imp
A
ortan
9t
reason
though
is
this
:
Anna
had
:
b
A
een
dev
9elop
ed
using
Mark
Jones
'
marv
9ellous
in
terac
-
:
tiv
9e
?
en
vironmen
t
Gofer
.
iMerging
Anna
in
to
the
Glas
-
:
go
9w
Hask
ell
w
orld
w
ould
ha
v
e
mean
t
compiling
with
:
a
y
Hask
9ell
compiler
and
this
w
ould
easily
ha
v
e
put
an
:
order
m
of
magnitude
on
the
edit
-
compile
-
run
cycle
time
.
As
Anna
b
A
ecomes
more
and
more
p
o
9w
erful
wthe
incen
tiv
e
to
build
'
it
in
9to
a
real
compiler
gro
ws
.
This
is
de
nitely
a
long
term
Tob
jectiv
9e
.
2
T
echnical
L
p
relimina
ries
2
.
1
G
Some
L
terminology
m
The
analyser
'
s
fron
9t
end
pro
A
duces
a
NCore
syn
Ctax
tree
*
in
whic
9h
R
ev
ery
no
A
de
is
decorated
with
its
t
yp
A
e
.
This
is
fed
to
the
o
Nabstract
bin
Cterpreter
prop
A
er
B
whic
9h
translates
to
an
abstract
9
=
form
:
dB
Nrecursiv
Ce
domain
equations
.
The
N
x
-
p
K
oin
Cter
solv
9es
these
equations
b
y
iterating
to
their
greatest
xed
n
p
A
oin
9ts
Ndetecting
equalit
y
of
adjacen
t
appro
ximations
b
9y
reducing
them
to
Nnormal
form
using
the
Nterm
rewrit
-
ing
system
Tand
comparing
those
normal
forms
.
There
Tare
t
9w
o
Tkinds
of
abstract
en
9tit
y
:
.
O
P
:
NCon
Ctexts
e
denote
an
amoun
9t
of
ev
|
raluation
that
should
:
b
A
e
Uapplied
to
a
data
structure
or
function
.
}
sThese
:
are
Dsometimes
referred
to
as
Ndemands
or
Nbac
Ckw
ards
:
v
h
alues
but
w
9e
will
stic
k
with
Ncon
Ctext
where
p
A
os
-
:
sible
.
W
:
e
rlater
in
9tro
A
duce
a
Hask
ell
t
yp
A
e
MContext
to
:
mo
A
del
Tcon
9texts
.
34
P
:
NAbstract
CFv
h
alues
z
amoun
9t
to
some
tric
k
ery
w
e
will
in
-
:
tro
A
duce
to
deal
with
higher
order
functions
.
An
alter
-
:
nativ
9e
name
[
'
whic
h
is
again
a
v
oided
where
p
A
ossible
:
is
"
Nforw
Card
v
h
alue
.
D
*
The
corresp
A
onding
Hask
9ell
t
yp
A
e
is
:
MAbsVal
.
This
?
pap
A
er
is
primarily
concerned
with
disco
9v
ering
?
ho
w
source
(
language
functions
b
A
eha
9v
e
(
viz
-
a
-
viz
con
9texts
.
s
Nev
-
ertheless
gthe
output
of
the
abstract
in
9terpreter
is
one
ab
-
stract
E
v
|
ralue
p
A
er
Core
function
.
GCon
9texts
and
abstract
v
alues
in
9tert
wine
fso
the
MContext
and
MAbsVal
t
9yp
A
es
are
m
utually
recursiv
9e
.
The
abstract
in
terpreter
itself
is
de
ned
as
the
function
T
MZ
in
section
3
.
6
.
1
.
Con
9texts
and
abstract
v
|
ralues
are
Zin
a
sense
strongly
t
9yp
A
ed
.
Eac
9h
Bcon
text
is
a
mem
b
A
er
of
a
particular
Ncon
Ctext
udomain
and
nSmost
op
A
erations
on
con
9texts
are
only
meaningful
if
their
op
A
erands
8are
dra
9wn
from
particular
domains
.
Abstract
v
|
ral
-
ues
z
are
also
strongly
t
9yp
A
ed
.
L
Although
the
domains
for
ab
-
stract
uv
|
ralues
are
[
strictly
sp
A
eaking
di
eren
9t
from
con
text
domains
w
9e
]
will
ignore
abstract
v
|
ralue
domains
.
Instead
w
9e
only
consider
con
9text
domains
henceforth
referred
to
sim
-
ply
Tas
Ndomains
Tand
pretend
that
for
eac
9h
domain
there
is
a
Tfamily
of
con
9texts
and
a
family
of
abstract
v
|
ralues
.
F
:
or
Z
}
eac
9h
Milner
-
Hindley
t
yp
A
e
k
there
is
a
corresp
onding
do
-
main
.
}
+
In
5
general
=
there
ma
9y
b
A
e
man
y
di
eren
t
t
yp
A
es
whic
h
map
to
the
same
domain
.
The
next
section
de
nes
infor
-
mally
:
this
mapping
.
W
e
then
re
ne
the
mapping
sligh
9tly
in
section
T2
.
2
.
4
and
formalise
it
in
section
2
.
2
.
5
.
5
2
.
2
G
Domains
L
fo
r
p
rojection
analysis
m
A
primary
*
aim
of
these
analyses
is
to
generate
information
useful
for
exploiting
a
parallel
mac
9hine
.
RT
:
o
this
end
w
e
use
domains
9
whic
9h
are
b
A
est
view
ed
as
a
generalisation
of
the
ev
|
raluation
transformers
in
9tro
A
duced
b
y
Burn
[
Bur87
]
.
These
are
Tin
9tro
A
duced
b
y
example
.
2
.
2
.
1
Base
L
t
yp
Ffes
m
Base
t
9yp
A
es
MInt
and
MChar
are
mapp
ed
to
a
t
9w
o
p
oin
t
domain
M2
=
{
0
1
}
8with
M0
meaning
\
do
not
ev
|
raluate
this
"
and
M1
meaning
n
\
ev
|
raluate
fully
"
.
In
this
case
only
:
full
ev
aluation
is
the
Usame
as
ev
|
raluation
to
w
9eak
head
normal
form
(
WHNF
)
.
2
.
2
.
2
Non
-
recursive
L
structured
t
yp
Ffes
m
Consider
D
the
in
9terpretation
of
a
familiar
non
-
recursiv
e
struc
-
tured
mBt
9yp
A
e
:
M
M
(
Int
Int
)
.
;
W
:
e
need
to
mo
del
the
ev
|
raluators
for
the
comp
A
onen
9ts
of
the
pair
separately
:
so
there
m
ust
b
A
e
a
pro
A
duct
in
9v
olv
ed
:
w
M
(
2
x
2
)
.
%
An
ev
|
raluator
corresp
onding
j
3
<
?
to
A
an
9y
suc
h
p
A
oin
t
w
ould
rst
ha
v
e
to
ev
|
raluate
the
pair
clo
-
sure
~
to
WHNF
so
it
could
get
its
hands
on
the
individual
comp
A
onen
9ts
.
So
w
e
really
need
a
fth
p
A
oin
t
represen
ting
an
ev
|
raluator
whic
9h
do
A
es
nothing
at
all
.
The
o
v
erall
in
terpreta
-
tion
Tis
MLift
(
2
x
2
)
.
A
9t
F
this
p
A
oin
t
it
is
con
v
enien
t
to
in
tro
A
duce
a
notation
for
p
A
oin
9ts
to
b
e
used
throughout
this
pap
er
.
KThe
b
ottom
p
oin
9t
of
the
ab
A
o
9v
e
domain
is
written
as
an
underscore
U
M_
.
The
other
four
are
written
in
the
form
MU
[
x
y
]
where
the
MU
stands
\
Vfor
\
go
up
the
MLift
"
Vand
the
Mx
and
My
are
the
relev
|
ran
9t
pro
A
duct
comp
onen
9ts
.
5
The
o
v
erall
collection
of
ev
|
raluators
is
th
9us
ZVwritten
M
{
_
U
[
0
0
]
U
[
0
1
]
U
[
1
0
]
U
[
1
1
]
}
ZV
with
the
Tfollo
9wing
ordering
:
O
_
MU
[
1
1
]
Zg
\
/
Y
\
>
U
[
0
1
]
%
U
[
1
0
]
Zg
\
\
Y
/
_
U
[
0
0
]
mM
|
mM
_
Ho
9w
\
do
A
es
this
generalise
to
arbitrary
non
-
recursiv
e
struc
-
tured
%
t
9yp
A
es
?
K
W
:
ell
(
v
ery
simply
:
.
K
A
%
non
-
recursiv
e
structured
t
9yp
A
e
is
mo
delled
b
9y
the
single
lifting
of
the
pro
duct
of
what
-
ev
9er
=
Fits
t
yp
A
e
v
|
rariables
are
b
ound
to
.
GF
:
urther
details
are
ir
-
relev
|
ran
9t
.
3
That
'
s
b
A
ecause
w
e
observ
e
the
guiding
rule
that
all
ob
jects
corresp
A
onding
to
a
particular
t
9yp
e
v
|
rariable
are
treated
6
as
a
single
en
9tit
y
:
.
AThis
6
rule
is
imp
A
osed
for
the
pur
-
p
A
ose
of
k
9eeping
things
reasonably
straigh
tforw
ard
.
k
F
:
or
ex
-
ample
Tgiv
9en
:
Mdata
Foo
a
b
=
MkFoo
a
b
9TB
|
MkA
a
9TB
|
MkB
b
data
Grok
a
b
c
=
MkGrok
a
b
c
G
|
GrokodileDundee
a
a
a
b
b
c
a
~
v
|
ralue
of
M
(
Foo
Int
Int
)
~
is
mapp
A
ed
to
MLift
(
2
x
2
)
and
S
M
(
Grok
Int
Int
Int
)
to
MLift
(
2
x
2
x
2
)
.
|
More
complicated
{
parameterisations
giv
9e
rise
to
more
com
-
plicated
domains
.
Q
The
t
9yp
A
e
M
(
Grok
Int
(
Foo
Int
Int
)
(
Grok
Int
Int
Int
)
)
i
has
a
91
p
A
oin
9t
domain
MLift
(
2
x
Lift
(
2
x
2
)
x
Lift
(
2
x
2
x
2
)
)
.
It
Kis
w
9orth
understanding
that
the
n
um
b
A
er
of
pro
duct
com
-
p
A
onen
9ts
is
equal
to
the
n
um
b
A
er
of
t
yp
A
e
v
|
rariables
and
en
-
tirely
unrelated
to
the
n
9um
b
A
er
of
parameters
of
an
9y
partic
-
ular
g
[
constructor
.
A
gFcon
9text
MU
[
1
0
0
]
applied
to
an
ob
ject
of
t
9yp
A
e
M
(
Grok
Int
Int
Int
)
means
:
)
1ev
|
raluate
the
ob
ject
to
the
|
rst
constructor
.
Then
if
it
is
a
MMkGrok
ev
|
raluate
the
rst
{
5argumen
9t
.
N
Otherwise
it
m
ust
b
A
e
a
MGrokodileDundee
so
&
Eev
|
raluate
the
rst
three
parameters
.
ODW
:
e
treat
the
rst
argumen
9t
to
MMkGrok
and
the
rst
three
of
MGrokodileDundee
as
da
single
en
9tit
y
db
A
ecause
they
all
corresp
ond
to
the
same
t
9yp
A
e
Tv
|
rariable
Ma
in
the
declaration
.
5
2
.
2
.
3
Recursive
L
structured
t
yp
Ffes
m
So
QQfar
Qthings
are
reasonably
straigh
9tforw
ard
.
hBut
QQde
ning
ev
|
raluators
1
for
recursiv
9e
t
yp
A
es
is
a
mine
eld
8
partly
b
ecause
there
exare
so
man
9y
alternativ
e
form
ulations
[
W
:
ad87
]
[
WH87
]
.
As
v
it
happ
A
ens
the
form
9ulation
used
in
Anna
is
a
trivial
v
|
rariation
J
of
the
rule
for
non
-
recursiv
9e
t
yp
A
es
sUbut
justi
cation
is
Tnot
so
easy
:
.
The
#
rule
is
iden
9tical
to
the
non
-
recursiv
e
case
g
;
except
for
the
follo
9wing
mo
A
di
cation
:
the
single
lifting
of
the
pro
duct
written
+
MLift
is
replaced
b
9y
a
double
lifting
MLift2
.
No
9w
giv
9en
Tthe
pseudo
-
declaration
O
Mdata
[
a
]
=
[
]
.
m
|
a
:
[
a
]
it
T
is
easy
to
see
that
the
domain
for
M
[
Int
]
is
MLift2
(
2
)
c
a
four
p
A
oin
9t
domain
corresp
onding
precisely
to
the
in
9terpreta
-
tion
for
that
t
9yp
A
e
made
b
y
W
:
adler
[
W
ad87
]
and
later
justi
-
ed
!
b
9y
Burn
[
Bur87
]
.
Extending
the
notation
of
the
previous
section
Dqw
9e
7write
the
p
A
oin
ts
in
this
domain
as
M
{
_
U_
UU
[
0
]
and
MUU
[
1
]
}
understanding
them
to
denote
the
ev
|
raluators
whic
9h
TBurn
called
M
{
E0
E1
E2
T
and
ME3
}
:
P
:
M_
:
pDo
Tnot
ev
|
raluate
at
all
(
ME0
)
.
34
P
:
MU_
:
Ev
|
raluate
as
far
as
the
rst
constructor
that
is
to
:
w
9eak
Thead
normal
form
(
ME1
)
.
P
:
MUU
[
0
]
:
pEv
|
raluate
Tthe
en
9tire
structure
of
the
list
(
ME2
)
.
P
:
MUU
[
1
]
:
Ev
|
raluate
the
en
9tire
structure
of
the
list
"
and
:
all
Tthe
elemen
9ts
(
ME3
)
.
O
In
T
general
{
!
a
recursiv
9e
t
yp
A
e
of
Mn
parameters
has
ev
|
raluators
of
the
form
M
{
_
U_
and
MUU
[
x1
.
.
.
xn
]
}
.
The
MUU
[
x1
.
.
.
xn
]
p
A
oin
9ts
O
denote
ev
|
raluating
the
en
tire
structure
^
and
then
ap
-
plying
Hev
|
raluator
Mx1
to
eac
9h
ob
ject
corresp
A
onding
to
the
rst
parameter
W
Mx2
to
ob
jects
corresp
A
onding
to
the
second
pa
-
rameter
Cand
zso
on
.
W
:
e
will
see
in
Section
4
that
this
conceptual
partitioning
of
all
recursiv
9e
domain
p
A
oin
ts
in
to
three
#
sections
is
crucial
to
the
w
9orking
of
the
term
rewriting
system
bused
to
detect
xp
A
oin
9ts
.
Similarly
:
the
non
-
recursiv
e
p
A
oin
9ts
ma
y
b
A
e
partitioned
in
to
t
w
o
:
7
M
{
_
and
MU
[
x1
.
.
.
xn
]
}
.
The
guiding
principle
#
>
originally
stated
b
9y
W
:
adler
is
to
mo
A
del
tthe
recursiv
9e
t
yp
A
es
b
y
letting
the
sub
-
ev
|
raluators
in
'
)
MUU
[
.
.
.
]
v
|
ralues
b
A
e
represen
9tativ
e
'
)
of
the
least
de
ned
elemen
9t
of
that
t
yp
A
e
in
the
structure
.
Imagine
w
e
ha
9v
e
a
list
of
t
9yp
A
e
M
[
(
Int
Int
)
]
whic
h
induces
do
-
main
v
MLift2
(
Lift
(
2
x
2
)
)
and
w
9e
kno
w
that
ev
|
raluator
MUU
[
U
[
0
1
]
]
is
the
strongest
that
can
safely
b
A
e
applied
(
that
is
mwithout
danger
of
non
-
termination
)
to
the
list
.
zNo
9w
supp
A
ose
w
9e
obtain
another
list
for
whic
h
MUU
[
U
[
1
0
]
]
is
the
strongest
safe
ev
|
raluator
M
and
app
A
end
it
to
the
original
.
IWhat
is
Hthe
b
A
est
ev
|
raluator
that
can
b
e
applied
to
the
new
list
?
It
O
}
cannot
b
A
e
either
of
the
originals
since
that
risks
non
-
termination
.
'
HThe
nGmost
w
9e
can
ev
|
raluate
an
y
particular
ele
-
men
9t
luwhilst
remaining
safe
is
MU
[
0
0
]
=
so
the
b
A
est
that
can
b
A
e
applied
to
the
list
as
a
whole
is
MUU
[
U
[
0
0
]
]
{
the
great
-
est
f
lo
9w
er
b
A
ound
of
the
v
|
ralues
for
the
original
lists
.
W
:
adler
summarised
Sthis
b
9y
stating
that
a
list
is
c
haracterised
\
b
y
its
least
de
ned
elemen
9t
"
but
w
e
need
to
b
A
e
more
precise
:
a
list
is
c
9haracterised
b
y
the
greatest
ev
|
raluator
that
can
safely
D
b
A
e
applied
to
an
9y
elemen
t
Peev
en
if
a
stronger
ev
|
ralua
-
tor
I
could
b
A
e
applied
to
sp
eci
c
elemen
9ts
.
~
The
same
principle
generalises
S
to
structured
t
9yp
A
es
of
an
y
n
um
b
A
er
of
parameters
with
^
the
greatest
-
lo
9w
er
-
b
A
ound
^
c
haracterisation
o
A
ccurring
in
-
dep
A
enden
9tly
Tfor
eac
h
parameter
.
This
(
abstraction
F
whilst
simple
assumes
that
programs
treat
all
elemen
9ts
of
the
same
t
yp
A
e
inside
a
structure
in
the
same
j
4
[
?
w
9a
y
:
.
F
or
example
[
it
assumes
list
pro
A
cessing
functions
treat
all
elemen
9ts
in
the
list
the
same
w
a
y
:
.
F
unctions
not
pla
ying
along
with
this
ma
9y
induce
bad
but
safe
results
.
^
Consider
:
O
Mtail
(
x
:
xs
)
=
xs
If
^
w
9e
apply
a
MUU
[
1
]
ev
|
raluator
to
M
(
tail
zs
)
what
can
w
e
ev
|
raluate
%
Mzs
with
?
Unfortunately
:
not
MUU
[
1
]
since
the
ele
-
men
9t
"
that
Mtail
thro
ws
a
w
a
y
migh
t
just
ha
v
e
b
A
een
the
one
-
and
-
only
non
-
terminating
MInt
in
the
list
.
mErring
on
the
side
of
safet
9y
th
us
restricts
the
ev
|
raluator
for
Mzs
to
MUU
[
0
]
and
%
loses
all
the
p
A
oten
9tial
parallelism
in
ev
|
raluating
the
ele
-
men
9ts
+
in
the
rest
of
the
list
.
3
One
upshot
of
this
also
noted
b
9y
/
RW
:
adler
u
is
that
de
ning
functions
directly
b
y
pattern
-
matc
9hing
is
essen
tial
to
get
go
A
o
d
results
.
In
the
example
b
A
elo
9w
the
1analyser
giv
es
a
m
uc
h
b
A
etter
result
for
Msum1
than
Msum2
Tdespite
them
ha
9ving
iden
tical
strictness
prop
A
erties
.
O
Msum1
[
]
Y
=
0
sum1
(
x
:
xs
)
s
=
x
+
sum1
xs
sum2
xs
Y
=
if
Xnull
xs
B
nthen
s
0
B
nelse
s
head
xs
+
sum2
(
tail
xs
)
A
related
defect
is
the
inabilit
9y
of
these
domains
to
capture
the
K
notion
of
head
strictness
.
3A
K2head
strict
function
is
one
whic
9h
>
ev
|
raluates
the
rst
item
in
a
list
whenev
er
it
ev
|
raluates
the
'
list
as
far
as
the
rst
constructor
I
and
disco
9v
ers
'
it
to
b
A
e
non
-
nil
.
}
Head
strictness
is
useful
in
a
sequen
9tial
imple
-
men
9tation
so
an
extension
of
the
domains
to
capture
these
prop
A
erties
Tw
9ould
increase
the
useful
scop
e
of
this
analyser
.
5
2
.
2
.
4
Mo
Ffdifying
L
the
notation
m
The
ab
A
o
9v
e
mapping
assigns
domain
MLift
(
)
to
all
en
9umeration
At
yp
A
es
b
:
for
example
the
familiar
t
yp
A
e
Mdata
Bool
=
False
|
True
.
<
<
Observ
9e
that
MLift
(
)
is
iso
-
morphic
to
the
t
9w
o
-
p
A
oin
t
domain
used
for
base
t
9yp
es
and
righ
9tly
Tso
.
pAfter
all
w
e
could
conceptually
:
de
ne
O
Mdata
Int
=
.
.
.
-
3
|
-
2
|
-
1
|
0
|
1
|
2
|
3
.
.
.
and
Tw
9e
'
d
certainly
exp
A
ect
a
t
w
o
-
p
A
oin
t
domain
for
it
!
This
isomorphism
can
b
A
e
used
to
simplify
the
domain
struc
-
ture
~
and
th
9us
the
strictness
analysis
itself
.
W
:
e
forget
ab
A
out
domain
M2
and
instead
map
base
t
9yp
A
es
MInt
and
MChar
to
MLift
(
)
with
8
p
A
oin
9ts
M
{
_
U
[
]
}
replacing
M
{
0
1
}
.
;
Hence
-
forth
Tthe
new
notation
is
used
.
2
.
2
.
5
Summa
ry
m
Let
MD
(
t
)
denote
the
domain
for
some
t
9yp
A
e
Mt
.
-
Let
MtypeName
b
A
e
V5the
name
of
some
structured
t
9yp
e
fmand
Mte1
.
.
.
ten
V5
b
e
some
Tarbitrary
t
9yp
A
e
expressions
.
p
MD
is
de
ned
as
:
O
MD
(
Int
)
=
Lift
(
)
D
(
Char
)
s
=
Lift
(
)
D
(
typeName
te1
.
.
.
ten
)
f
=
Lift
s
(
D
(
te1
)
x
.
.
.
x
D
(
ten
)
)
if
typeName
denotes
a
non
-
recursive
type
f
=
Lift2
(
D
(
te1
)
x
.
.
.
x
D
(
ten
)
)
if
typeName
denotes
a
recursive
type
R
The
mconcept
of
a
function
-
v
|
ralued
con
9text
seems
rather
mean
-
ingless
Tand
is
left
unde
ned
un
9til
section
3
.
2
.
!
2
.
2
.
6
Restrictions
L
on
structured
t
yp
Ffes
m
The
astute
reader
ma
9y
ha
v
e
noticed
the
examples
ab
A
o
v
e
ha
9v
e
6b
A
een
rather
restricted
.
In
particular
none
of
them
had
constan
9t
~
t
yp
A
es
as
an
argumen
t
to
an
y
constructor
.
)
But
this
situation
7is
commonplace
for
example
as
the
MInt
con
9v
eying
balancing
Tinformation
in
the
follo
9wing
tree
declaration
:
k
Mdata
AVLTree
a
b
f
=
ALeaf
f
|
ANode
Int
(
AVLTree
a
b
)
a
b
(
AVLTree
a
b
)
Instead
iof
extending
the
domain
-
generating
rules
to
co
9v
er
suc
9h
cases
zit
is
simpler
to
factorise
out
the
o
ending
MInt
generating
Ta
second
t
9yp
A
e
MAVLTree2
:
Mdata
AVLTree2
i
a
b
f
=
ALeaf2
f
|
ANode2
i
(
AVLTree2
i
a
b
)
a
b
(
AVLTree2
i
a
b
)
(
AVLTree2
Int
a
b
)
(
is
an
isomorphic
t
9yp
A
e
]
to
M
(
AVLTree
a
b
)
at
]
the
same
t
yp
A
e
b
eing
a
t
9yp
e
for
whic
9h
t
w
e
kno
w
ho
w
to
generate
an
abstract
domain
.
Con
v
e
-
nien
9tly
:
Milner
-
Hindley
lt
yp
A
ec
hec
k
ers
are
amenable
to
suc
h
substitutions
.
Finally
:
yNobserv
9e
eOthat
there
are
certain
t
yp
A
es
for
whic
h
it
is
hard
Tto
devise
a
sensible
set
of
ev
|
raluators
for
example
:
Mdata
Foo
a
b
f
=
MkFoo
a
b
(
Foo
(
Foo
a
b
)
(
Foo
a
b
)
)
The
D
solution
adopted
in
Anna
is
simply
to
deem
these
ille
-
gal
.
W
:
e
require
that
in
a
t
9yp
A
e
declaration
argumen
9ts
on
constructors
e
"
are
either
simple
v
|
rariables
(
here
y
Ma
or
Mb
)
or
a
simple
recursiv
9e
instance
of
the
structure
(
here
MFoo
a
b
)
.
These
wrestrictions
seem
inconsequen
9tial
for
real
programs
and
Tha
9v
e
b
A
een
rep
orted
quite
indep
endan
9tly
in
[
KHL91
(
]
.
!
2
.
3
G
The
L
Co
re
datat
yp
Ffe
m
The
5
extensiv
9ely
mangled
source
program
ev
en
tually
passed
to
the
abstract
in
9terpreter
is
a
t
yp
A
e
-
annotated
tree
Vrepre
-
sen
9ting
a
simple
functional
language
.
Eac
h
no
A
de
in
the
tree
carries
Fwith
it
an
annotation
.
GThe
Hask
9ell
data
t
yp
A
e
used
is
parameterised
o
9v
er
b
A
oth
the
t
9yp
e
of
the
annotations
4and
the
Tt
9yp
A
e
of
the
iden
ti
er
names
:
Mtype
AnnExpr
a
b
f
=
(
b
AnnExpr
'
a
b
)
data
AnnExpr
'
a
b
f
=
AVar
a
f
|
AConstr
s
a
f
|
ALit
Int
f
|
AAp
Y
(
AnnExpr
a
b
)
(
AnnExpr
a
b
)
f
|
ALet
Bool
[
AnnBind
a
b
]
(
AnnExpr
a
b
)
j
5
z
?
f
M
|
ACase
X
(
AnnExpr
a
b
)
[
AnnAlt
a
b
]
f
|
ALam
[
a
]
(
AnnExpr
a
b
)
type
AnnBind
a
b
f
=
(
a
AnnExpr
a
b
)
type
AnnAlt
a
b
f
=
(
a
(
[
a
]
AnnExpr
a
b
)
)
The
rst
and
second
parameters
on
an
MAnnExpr
t
9yp
A
e
are
for
the
G
iden
9ti
er
and
annotation
t
yp
A
es
resp
ectiv
9ely
:
.
F
or
G
exam
-
ple
F
if
<
Uthe
t
9yp
A
e
of
iden
ti
ers
is
MId
F
and
that
of
t
yp
A
e
expres
-
sions
J
MTExpr
X
the
t
9yp
A
e
of
the
corresp
onding
Core
expression
is
T
M
(
AnnExpr
Id
TExpr
)
.
Most
cases
are
straigh
9tforw
ard
.
The
MAVar
term
represen
9ts
an
iden
9tifer
!
=
whilst
MAConstr
represen
ts
a
constructor
name
.
Literal
=
v
|
ralues
are
represen
9ted
b
y
MALit
G
and
applications
b
y
MAAp
.
Lam
9b
A
da
S
terms
are
represen
ted
b
y
MALam
zFwhic
h
can
bind
an
Tarbitrary
n
9um
b
A
er
Tof
formal
parameters
.
That
llea
9v
es
the
t
w
o
tric
ky
ones
.
]
A
let
/
rec
expression
is
represen
9ted
c1b
y
MALet
whic
h
has
a
b
A
o
olean
ag
indicating
whether
this
is
a
recursiv
9e
binding
Ka
list
of
bindings
and
a
main
expression
in
whic
9h
those
bindings
can
b
A
e
used
.
DEac
h
binding
S
is
an
iden
9ti
er
paired
with
the
v
|
ralue
it
is
b
A
ound
to
.
_Case
expressions
.
denoted
b
9y
MACase
con
9tain
a
switc
h
expression
Rand
z
a
list
of
alternativ
9es
.
J
Eac
h
z
alternativ
e
is
a
triple
of
constructor
name
constructor
argumen
9ts
and
the
appropriate
vrigh
9t
-
hand
side
.
The
use
of
nested
pairs
is
more
con
9v
enien
t
Tfor
co
A
ding
purp
oses
.
All
7phases
do
9wnstream
of
the
lam
b
A
da
-
lifter
exploit
certain
assumptions
-
ab
A
out
the
form
of
the
program
.
c
The
most
im
-
p
A
ortan
9t
are
that
there
are
no
nested
MALets
[
0that
the
program
is
fin
dep
A
endancy
order
kand
that
no
iden
9ti
er
is
unde
ned
or
Tm
9ultiply
de
ned
in
the
same
scop
A
e
.
yx
2
.
4
G
Compiling
L
pa
rallel
co
Ffde
m
Ev
|
raluation
transformers
are
supp
A
osedly
exploited
b
9y
com
-
piling
m
9ultiple
copies
of
eac
h
function
up
to
one
cop
y
for
eac
9h
kcon
text
in
whic
h
the
result
migh
t
b
A
e
demanded
.
F
:
or
eac
9h
cop
y
:
qcompile
-
time
analysis
indicates
ho
w
m
uc
h
de
-
mand
propagates
to
the
parameters
of
the
function
:
and
th
9us
sho
w
m
uc
h
the
argumen
ts
to
the
call
ma
y
b
A
e
ev
|
raluated
b
A
efore
the
call
.
In
this
manner
2demand
propagation
is
pre
-
serv
9ed
T
as
far
as
this
st
yle
of
static
analysis
mak
es
p
A
ossible
.
Of
course
0all
this
is
done
in
pursuit
of
the
o
9v
erall
goal
:
maximising
a
~
a
9v
|
railable
parallelism
.
An
equally
imp
A
ortan
t
is
-
sue
2
not
discussed
here
is
ho
9w
to
a
v
oid
excessiv
e
ne
-
grain
parallelism
.
All
q
.
w
9ell
and
go
A
o
d
H
#
but
q
.
the
p
A
oten
tial
for
co
A
de
explo
-
sion
x
renders
a
naiv
9e
implemen
tation
impractical
.
FbCon
-
sider
sa
function
deliv
9ering
a
result
of
the
con
triv
ed
t
yp
A
e
M
(
Grok
Int
2
(
Foo
Int
Int
)
(
Grok
Int
Int
Int
)
)
discussed
in
section
2
.
2
.
2
.
>
Since
the
domain
has
91
p
A
oin
9ts
it
w
ould
app
A
ear
rnecessary
to
compile
90
v
9ersions
of
the
co
de
omit
-
ting
the
v
9ersion
for
no
demand
at
all
on
the
output
.
MBurn
'
s
early
w
9ork
simply
ignored
the
problem
b
y
restricting
itself
to
lists
of
MInt
+
Nfor
whic
9h
at
most
3
copies
of
co
A
de
are
re
-
quired
.
7aQuite
what
to
do
ab
A
out
complex
t
9yp
es
whic
h
in
-
duce
.
pro
A
duct
domains
5
or
non
-
trivial
instan
9tiations
of
lists
is
Tnot
clear
.
This
unsatisfactory
state
of
a
airs
can
to
some
exten
9t
b
A
e
alleviated
b
9y
restricting
ourselv
es
to
compiling
just
a
subset
of
"
all
the
p
A
ossible
v
9ersions
of
eac
h
function
.
E
Then
f
=
when
the
output
of
a
function
is
demanded
in
a
con
9text
for
whic
h
no
v
9ersion
has
b
A
een
compiled
the
v
ersion
used
is
that
com
-
piled
kafor
the
greatest
demand
less
than
the
demand
w
9e
re
-
quired
.
Observ
9e
E
that
the
c
hoice
of
alternativ
e
is
not
neces
-
sarily
3
unique
Qbut
pro
9vided
w
e
compiled
in
a
fully
sequen
tial
(
that
4
is
<
WHNF
4
demand
)
v
9ersion
an
alternativ
9e
is
at
least
guaran
9teed
9to
exist
.
Of
course
2some
p
A
oten
tial
parallelism
ma
9y
w
ell
b
A
e
lost
:
!
suc
h
is
the
price
for
restricting
the
co
A
de
explosion
Tto
a
tolerable
magnitude
.
The
F
cen
9tral
question
p
%
then
is
F
whic
h
v
ersions
to
compile
co
A
de
for
.
NoOne
{
Tp
A
erson
who
has
v
9en
tured
{
Tin
to
this
quagmire
is
Min
9tc
hev
.
F
:
or
his
MSc
dissertation
[
Min92
o
]
gMin
9tc
hev
built
a
sim
9ulation
of
a
parallel
graph
reduction
mac
hine
;
whic
h
understands
three
lev
9els
of
demand
:
6none
at
all
w
eak
head
normal
g
form
demand
|
gand
full
demand
.
An
immediate
ad
-
v
|
ran
9tage
lis
that
these
p
A
oin
ts
apply
to
all
structured
t
yp
A
es
including
!
tuples
and
complex
instan
9tiations
of
t
yp
A
es
R
and
are
th
9us
more
widely
applicable
than
Burn
'
s
sc
heme
.
[
Encour
-
agingly
:
ev
9en
with
so
few
ev
|
raluators
Min
9tc
hev
found
that
substan
9tial
amoun
ts
of
parallel
activit
y
w
ere
generated
v
|
ral
-
idating
&
his
approac
9h
.
Recen
tly
&
it
has
b
A
een
suggested
that
a
#
fourth
ev
|
raluator
migh
9t
b
A
e
pro
tably
included
:
9nev
aluation
of
Kthe
en
9tire
structure
of
a
recursiv
e
t
yp
A
e
7Ibut
no
ev
|
ralua
-
tion
M
of
the
comp
A
onen
9ts
.
SThis
mak
es
no
sense
[
of
course
in
a
YTnon
-
recursiv
9e
t
yp
A
e
jTor
alternativ
ely
:
one
YTcan
regard
it
as
equiv
|
ralen
9t
Tto
the
WHNF
ev
aluator
in
this
case
.
A
.
further
/
complication
is
what
to
do
ab
A
out
p
olymor
-
phic
functions
.
s
|
W
:
e
ma
9y
compile
three
v
ersions
of
the
Mreverse
function
:
w
9orking
from
the
ev
|
raluators
of
the
sim
-
plest
instance
but
then
what
do
w
9e
do
giv
en
an
ev
|
raluator
MUU
[
U
[
1
0
]
]
G
*
applied
to
a
use
of
Mreverse
at
non
-
base
instance
M
[
(
Int
Int
)
]
-
>
[
(
Int
Int
)
]
?
a
Su
ce
}
it
to
sa
9y
that
a
p
A
ossible
solution
is
only
to
compile
v
9ersions
of
p
olymorphic
functions
based
on
their
ev
|
raluators
for
simplest
instances
and
ause
safe
appro
9ximation
tec
hniques
based
on
Conc
maps
to
handle
the
non
-
base
instances
.
See
[
HH91
>
]
*
section
5
for
an
in
9tro
A
duction
to
Conc
maps
.
My
MSc
dissertation
[
Sew91
/
]
indicates
#
ho
9w
Conc
maps
are
useful
in
matters
of
p
A
olymor
-
phism
Ta
theme
explored
further
in
[
Sew93
/
]
.
No
9w
if
the
compiler
is
only
going
to
mak
e
co
A
de
for
a
few
of
all
the
p
A
ossible
ev
|
raluators
for
a
function
returning
an
ob
ject
of
)
bcomplex
t
9yp
A
e
.
fwhat
is
the
p
oin
9t
of
doing
strictness
anal
-
ysis
U
with
the
full
complemen
9t
of
ev
|
raluators
?
After
all
e
this
amoun
9ts
ato
doing
a
detailed
analysis
then
thro
wing
a
w
a
y
most
of
the
detail
in
the
nal
answ
9er
.
)
It
w
ould
certainly
b
A
e
J
m
9uc
h
quic
k
er
just
to
w
ork
with
those
few
ev
|
raluators
w
e
are
\
really
in
9terested
in
.
sNev
ertheless
doing
that
risks
losing
in
9termediate
detail
and
ultimately
:
parallelism
compared
with
/
the
exp
A
ensiv
9e
approac
h
.
Building
an
abstract
in
terpre
-
tation
gXfor
the
el
c
9heap
A
o
approac
h
migh
t
also
b
A
e
rather
dif
-
cult
;
and
sthe
in
9terpreter
w
ould
ha
v
e
to
b
A
e
rewritten
ev
ery
time
the
particular
subset
of
in
9teresting
ev
|
raluators
c
hanged
.
A
x
nal
in
9teresting
ca
v
eat
p
A
ertains
to
higher
-
order
functions
.
As
6
explained
to
9w
ards
6
the
end
of
section
1
.
2
=
it
lo
A
oks
dif
-
cult
4to
exploit
parallelism
in
higher
-
order
functions
if
w
9e
do
not
w
9an
t
to
engage
in
complicated
manipulation
of
ev
|
ral
-
uation
transformers
at
run
-
time
.
xOne
can
therefore
rea
-
sonably
argue
that
the
higher
-
order
remo
9v
|
ral
transformation
(
rsti
cation
)
describ
A
ed
in
section
5
enhances
parallelism
.
What
&
rsti
cation
do
A
es
is
to
disco
9v
er
&
statically
some
of
the
functional
parameters
passed
to
higher
-
order
functions
and
sp
A
ecialise
;
them
accordingly
:
Ltgenerating
rst
-
order
replace
-
j
6
?
men
9ts
.
K
These
can
then
b
A
e
parallelised
in
the
normal
w
a
y
:
without
8Vha
9ving
to
resort
to
complicated
run
-
time
mac
hinery
:
.
Ma
9yb
A
e
then
this
ztransformation
should
b
e
incorp
orated
as
a
Tmatter
of
course
in
9to
go
A
o
d
Tparallelising
compilers
.
-
3
The
L
abstract
interp
retation
3
.
1
G
Prelimina
ries
m
3
.
1
.
1
The
L
notion
of
fo
rw
a
rds
L
and
backw
a
rds
Seman
9tic
analyses
of
functional
languages
seem
to
fall
in
to
t
9w
o
vcamps
:
forw
ards
and
bac
kw
ards
.
Y
T
:
o
see
the
in
tuitiv
e
meaning
Tof
this
consider
a
function
application
:
O
M
(
f
x
y
z
)
A
forw
9ard
analysis
generates
information
ab
A
out
Mf
whic
h
tells
M
us
prop
A
erties
of
the
application
M
(
f
x
y
z
)
M
if
w
9e
kno
w
the
eprop
A
erties
of
the
individual
argumen
9ts
)
Mx
My
e
and
Mz
.
In
other
w
9ords
the
analysis
propagates
information
R
j
cmti9
Rforwar
ds
through
functions
.
F
:
orw
9ard
analyses
tend
to
b
A
e
exp
ensiv
9e
b
A
ecause
they
ha
9v
e
to
consider
all
p
ossible
in
9teractions
b
e
-
t
9w
een
argumen
ts
.
[
On
the
other
hand
one
gets
a
v
ery
de
-
tailed
Tpicture
of
what
is
going
on
.
A
bac
9kw
ard
analysis
sXb
y
con
trast
sXgenerates
information
ab
A
out
Mf
whic
9h
tells
us
the
prop
erties
of
the
individual
argu
-
men
9ts
H
Mx
q
My
and
Mz
if
w
e
kno
w
some
prop
A
ert
y
of
the
application
M
(
f
x
y
z
)
.
That
is
Va
bac
9kw
ards
analysis
propagates
prop
-
erties
4
Rb
ackwar
ds
through
functions
.
Bac
9kw
ard
analyses
ma
y
b
A
e
2
c
9heap
er
to
do
_
but
they
ma
9y
also
giv
e
less
detailed
results
.
No
9w
for
reasons
whic
h
will
shortly
b
A
ecome
apparen
t
Anna
do
A
es
ua
com
9bined
forw
ard
and
bac
kw
ard
analysis
.
The
prop
-
erties
\
>
whic
9h
Anna
propagates
forw
ards
through
functions
are
{
the
abstract
v
|
ralues
whilst
those
whic
9h
o
w
bac
kw
ards
are
h
con
9texts
.
T
:
o
set
the
stage
observ
e
critically
that
RA
nna
'
s
main
purp
ose
is
to
determine
the
b
ackwar
ds
b
ehaviour
of
the
sour
c
e
language
functions
.
The
zpresence
of
forw
9ard
(
ab
-
stract
)
v
|
ralues
is
a
necessary
evil
whic
9h
enables
us
to
deal
cleanly
[
with
higher
-
order
functions
.
k
The
discussion
whic
9h
no
9w
s
follo
ws
mak
es
more
sense
if
y
ou
k
eep
a
clear
notion
that
abstract
=
xv
|
ralues
corresp
A
ond
to
a
forw
9ards
o
w
of
information
whilst
Tcon
9texts
corresp
A
ond
to
a
bac
kw
ards
o
w
.
5
3
.
1
.
2
A
L
fundamental
p
roblem
with
backw
a
rds
analysis
m
Bac
9kw
ards
.
strictness
analysis
w
9ould
b
A
e
straigh
tforw
ard
w
9ere
_
it
not
for
the
higher
-
order
nature
of
the
language
under
analysis
.
pT
:
o
Tsee
the
problem
consider
Mapply
:
O
Mapply
f
x
=
f
x
Giv
9en
h
some
demand
on
a
use
of
apply
:
}
M
(
apply
g
y
)
what
demand
[
ma
9y
b
A
e
propagated
to
My
?
Without
kno
wing
ho
w
Mg
8
propagates
demand
to
its
argumen
9t
1the
only
safe
answ
er
is
E
\
none
"
.
Ho
9w
ev
er
kno
wing
what
Mg
is
implies
ha
ving
a
forw
9ard
o
w
of
information
as
w
ell
as
the
bac
kw
ard
o
w
of
demand
Tw
9e
started
with
.
Things
lo
A
ok
grimmer
when
w
9e
put
functions
inside
data
structures
Tthen
sh
them
out
and
apply
them
:
O
M1
+
(
head
xs
(
y
+
1
)
)
where
Mxs
:
:
[
Int
-
>
Int
]
.
There
is
no
w
9a
y
to
tell
what
demand
Tcould
b
A
e
propagated
to
My
.
The
solution
really
lies
in
building
a
com
9bined
bac
kw
ards
and
forw
9ards
analysis
.
W
:
ra
y
[
W
:
ra85
:
C
]
made
a
start
on
the
problem
Y
but
LDit
to
A
ok
the
w
9ork
of
Hughes
[
Hug87
'
]
to
gener
-
alise
O
W
:
ra
9y
'
s
results
to
the
p
A
oin
t
of
general
applicabilit
y
:
.
The
resulting
analysis
is
rather
hard
to
understand
0
)
so
rather
than
attempting
a
head
-
on
assault
w
9e
lo
A
ok
rst
at
under
-
lying
Tissues
starting
o
with
some
new
concepts
.
3
.
2
G
F
unction
L
contexts
m
Dealing
-
with
functions
prop
A
erly
means
turning
them
in
9to
rst
-
class
lcitizens
for
the
purp
A
oses
of
the
abstract
in
9ter
-
preter
.
Section
2
.
2
discussed
the
notion
of
demand
(
or
con
-
text
)
Q
/
on
a
data
structure
.
W
:
e
no
9w
extend
the
notion
of
con
9text
Tto
functions
.
Since
a
con
9text
really
denotes
a
demand
for
ev
|
raluation
the
idea
of
a
function
con
9text
seems
prett
y
meaningless
:
]
after
all
ho
9w
can
a
function
b
A
e
ev
|
raluated
?
But
imagine
w
e
de
-
ned
#
a
function
con
9text
as
a
pair
con
taining
the
abstract
v
|
ralue
R
of
the
argumen
9t
b
<
and
the
con
text
for
the
result
of
an
application
of
the
function
.
By
making
the
analysis
fully
curried
v3from
no
9w
on
kw
e
can
consider
all
functions
as
ha
v
-
ing
;
just
one
argumen
9t
.
Then
for
example
the
con
9text
on
a
function
Tof
t
9w
o
Targumen
ts
suc
h
as
Mapply
lo
A
oks
lik
e
:
Y
M
(
abstract
value
of
first
argument
f
(
abstract
value
of
second
argument
context
on
result
)
)
Suc
9h
Q
a
sc
heme
w
ould
solv
e
the
problem
outlined
ab
A
o
v
e
b
y
supplying
Dthe
v
|
ralue
of
the
rst
parameter
allo
9wing
demand
to
b
A
e
propagated
on
9to
the
second
parameter
.
This
abstract
v
|
ralue
aof
the
rst
parameter
is
just
the
relev
an
9t
con
text
func
-
tion
but
what
of
the
abstract
v
|
ralue
of
the
second
non
-
functional
parameter
?
W
:
ell
w
9e
are
simply
not
in
terested
in
it
Tso
w
9e
map
it
to
the
1
-
p
A
oin
t
domain
.
The
w
9orld
no
w
b
A
ecomes
p
opulated
b
9y
t
w
o
sp
A
ecies
of
v
|
ralues
:
P
:
NCon
Ctexts
(
also
called
bac
9kw
ards
v
|
ralues
ev
aluators
or
:
demands
)
.
Q
In
'
what
follo
9ws
+
}
w
e
'
often
sa
9y
\
con
text
"
or
:
\
con
9text
+
on
"
when
it
w
ould
b
A
e
more
natural
to
sa
y
:
\
demand
"
or
\
demand
on
"
.
This
con
9v
en
tion
has
b
A
een
:
adopted
b
A
ecause
of
a
wish
to
ha
9v
e
just
one
term
for
:
eac
9h
Tconcept
.
:
Con
9texts
rUare
the
rst
kind
of
abstract
en
tit
y
referred
:
to
>
in
section
2
.
1
.
QF
:
or
non
-
function
v
|
ralues
\
they
are
:
as
~
discussed
in
section
2
.
2
.
F
:
or
function
v
|
ralues
they
:
are
H
a
pair
whic
9h
w
e
write
as
M
(
Fnc
a
c
)
where
H
MFnc
:
reminds
that
this
is
a
NF
uNction
}
Con
Ctext
Ma
is
the
:
abstract
3v
|
ralue
of
the
argumen
9t
and
Mc
is
the
con
text
on
:
the
9
result
.
Henceforth
A
v
|
rariables
denoting
con
9texts
or
:
con
9text
Tmaps
ha
v
e
'
c
'
as
their
rst
letter
.
P
:
NAbstract
v
h
alues
(
also
called
forw
9ards
v
|
ralues
)
.
[
These
:
are
the
second
kind
of
abstract
en
9tit
y
describ
A
ed
in
sec
-
:
tion
2
.
1
.
They
are
designed
purely
to
con
9v
ey
con
texts
:
to
=
^
an
9y
place
in
v
olving
a
call
to
an
unkno
wn
function
:
suc
9h
as
in
the
t
w
o
problematic
examples
ab
A
o
v
e
.
zOThe
:
abstract
+
v
|
ralues
of
non
-
function
ob
jects
are
alw
9a
ys
+
irrel
-
:
ev
|
ran
9t
and
are
mapp
A
ed
to
a
1
-
p
oin
9t
domain
whose
sin
-
:
gle
G
p
A
oin
9t
is
denoted
M
#
p
for
the
time
b
eing
.
The
abstract
j
7
7
?
d
l
S4
ff
w
~
ff
32
8
ff
C
ff
fg
ff
33
De
ning
Tequation
"
V
ff
p
Disassem
9bles
Ta
.
.
.
"
ff
pro
A
ducing
Tthe
.
.
.
a
ff
fg
ff
fh
ff
C
ff
fg
ff
h
ff
t
ff
C
ff
fg
ff
ff
fg
ff
33
MFncA
s
(
Fnc
a
c
)
=
a
33
ff
p
functional
Tcon
9text
O
ff
abstract
Tv
|
ralue
of
the
argumen
9t
'
ff
fg
ff
ff
fg
ff
33
MFncC
s
(
Fnc
a
c
)
=
c
33
ff
p
functional
Tcon
9text
O
ff
con
9text
Ton
the
result
PR
ff
fg
ff
ff
fg
ff
33
MFvalA
(
Fval
c
a
)
=
a
ff
p
functional
Tabstract
v
|
ralue
33
ff
abstract
Tv
|
ralue
map
:
pargumen
9t
to
result
33
ff
fg
ff
ff
fg
ff
33
MFvalC
(
Fval
c
a
)
=
c
ff
p
functional
Tabstract
v
|
ralue
33
ff
con
9text
Tmap
:
presult
to
argumen
t
O
ff
fg
ff
ff
fg
ff
h
ff
t
ff
C
ff
fg
ff
ff
C
;
TT
:
able
T1
:
pSelector
functions
for
functional
en
9tities
ff
~
ff
x
ff
Y
d
:
v
|
ralue
2
&
of
a
function
-
v
alued
ob
ject
is
also
a
pair
(
but
:
quite
7
unrelated
to
MFnc
pairs
)
written
M
(
Fval
c
a
)
:
with
J
MFval
reminding
us
this
is
a
NF
unctional
jabstract
:
V
ALue
.
=
The
t
9w
o
comp
A
onen
ts
are
b
A
oth
maps
.
=
The
:
rst
v
comp
A
onen
9t
Mc
maps
the
con
9text
on
the
function
:
to
7
;
con
9text
on
the
argumen
t
c
whilst
Ma
maps
the
abstract
:
v
|
ralue
5
of
the
argumen
9t
to
the
abstract
v
alue
of
the
re
-
:
sult
.
V
:
ariables
N
denoting
abstract
v
|
ralues
or
abstract
:
v
|
ralue
Tmaps
ha
9v
e
T
'
a
'
as
their
rst
letter
.
Notice
n
ho
9w
the
t
w
o
kinds
of
v
|
ralues
are
m
utually
recursiv
e
.
The
o
9v
erall
output
of
the
abstract
in
terpreter
is
one
ab
-
stract
B
}
v
|
ralue
p
A
er
Core
function
.
Eac
9h
abstract
v
alue
con
-
tains
enough
information
to
propagate
demand
from
the
o
9v
erall
result
to
eac
9h
of
the
argumen
ts
uev
en
in
the
presence
of
h
functional
parameters
.
These
concepts
are
confusing
}
so
some
>
2examples
are
in
order
.
First
i9de
ne
four
selectors
MFncA
MFncC
MFvalA
t
and
MFvalC
to
disassem
9ble
MFnc
s
and
MFval
s
with
the
b
A
eha
9viour
sho
wn
in
T
:
able
1
.
Hop
A
efully
their
names
will
serv
9e
Tas
a
reminder
of
their
meaning
.
Let
'
s
start
with
the
simplest
function
imaginable
:
Mid
:
:
Int
-
>
Int
.
The
only
remotely
in
9teresting
thing
w
e
can
sa
9y
ab
A
out
Mid
is
that
it
simply
propagates
the
con
text
on
its
4
result
to
the
con
9text
on
its
argumen
t
.
z
]
So
<
wsupp
A
osing
w
e
no
9w
Xwrite
do
wn
a
mapping
from
the
con
text
on
the
result
to
Tthe
con
9text
on
the
argumen
t
w
e
get
:
y
M
(
\
c
-
>
c
)
Let
'
s
]
b
A
e
clear
what
this
is
.
It
'
s
Rnot
a
con
9text
o
and
it
'
s
also
Rnot
{
an
abstract
v
|
ralue
.
It
'
s
a
map
from
con
9texts
to
con
texts
.
But
that
'
s
not
go
A
o
d
enough
.
a
W
:
e
said
earlier
that
Anna
pro
A
duces
one
abstract
v
|
ralue
p
er
Core
function
.
32So
what
do
w
9e
(
pro
A
duce
for
Mid
?
F
:
or
a
start
since
Mid
is
a
function
w
9e
m
9ust
Wget
a
functional
abstract
v
|
ralue
:
an
MFval
term
.
qIt
m
ust
lo
A
ok
Tlik
9e
:
Mid
=
Fval
context_map
+
'
abstract_value_map
No
9w
the
con
text
map
as
w
e
just
men
tioned
maps
the
con
-
text
]
on
Mid
to
the
con
9text
on
Mid
'
s
argumen
t
.
7And
the
con
text
on
Mid
since
Mid
is
a
function
m
9ust
b
A
e
a
function
con
text
of
the
form
M
(
Fnc
a
c
)
1
where
Mc
is
the
bit
w
9e
'
re
really
after
.
This
&
giv
9es
a
con
text
map
of
M
(
\
c
-
>
FncC
c
)
so
&
w
e
'
v
e
no
w
got
:
Mid
=
Fval
(
\
c
-
>
FncC
c
)
+
'
abstract_value_map
d
What
of
the
abstract
v
|
ralue
map
?
HIt
tells
us
what
the
ab
-
stract
Yv
|
ralue
of
Mid
'
s
result
is
giv
9en
the
abstract
v
alue
of
Mid
'
s
argumen
9t
.
But
;
/
for
ithis
instance
of
Mid
the
result
t
9yp
A
e
is
MInt
.
e
All
non
-
function
t
9yp
A
es
ha
v
e
a
corresp
A
onding
abstract
v
|
ralue
denoted
M
#
in
a
1
-
p
A
oin
9t
domain
.
:
So
w
e
don
'
t
actually
care
what
the
abstract
v
|
ralue
of
Mid
is
{
it
can
only
b
A
e
M
#
an
9y
-
w
9a
y
:
.
oThat
Tmeans
after
installing
the
abstract
v
|
ralue
map
w
9e
Y
could
write
either
of
the
follo
wing
j
although
the
second
is
Ta
little
clearer
:
O
Mid
=
Fval
(
\
c
-
>
FncC
c
)
3
'
(
\
a
-
>
a
)
id
=
Fval
(
\
c
-
>
FncC
c
)
3
'
(
\
a
-
>
#
)
If
&
y
9ou
are
confused
kEgo
no
further
!
Q
It
is
b
A
etter
to
return
to
t
the
start
of
this
section
Kconsider
again
the
meanings
of
con
9texts
6
and
abstract
v
|
ralues
?
9and
iterate
un
til
the
example
mak
9es
Tsense
.
Mo
9ving
Ton
to
M
(
+
)
:
:
Int
-
>
Int
-
>
Int
T
giv
es
:
M
(
+
)
=
Fval
(
\
c1
-
>
FncC
(
FncC
c1
)
)
7
(
\
a1
-
>
Fval
(
\
c2
-
>
FncC
c2
)
uM
(
\
a2
-
>
#
)
)
This
time
currying
comes
in
9to
pla
y
:
.
]
kThat
'
s
wh
y
the
term
whic
9h
Q
maps
the
abstract
v
|
ralue
of
the
rst
argumen
t
to
the
abstract
v
|
ralue
of
the
result
returns
a
MFval
term
:
the
\
re
-
sult
"
o
here
has
t
9yp
A
e
MInt
-
>
Int
.
+
Clearly
:
y
M
(
+
)
o
simply
prop
-
agates
5
con
9text
on
the
o
v
erall
result
to
b
A
oth
argumen
ts
whic
9h
is
wh
y
the
con
text
maps
for
the
t
w
o
argumen
ts
are
%
+
M
(
\
c1
-
>
FncC
(
FncC
c1
)
)
and
M
(
\
c2
-
>
FncC
c2
)
.
K
If
this
seems
a
little
m
9ysterious
*
b
A
ear
in
mind
that
b
oth
M
(
FncC
(
FncC
c1
)
)
X
and
M
(
FncC
c2
)
refer
to
the
con
9text
on
the
Of
nal
result
.
That
'
s
b
A
ecause
Mc1
binds
to
a
con
9text
in
M
MInt
-
>
Int
-
>
Int
whic
9h
is
necessarily
of
the
form
M
(
Fnc
#
(
Fnc
#
cc
)
)
where
Mcc
is
the
con
9text
on
the
nal
result
.
eSimilarly
:
n
Mc2
4
is
a
con
9text
of
t
yp
A
e
MInt
-
>
Int
nha
ving
the
~
;
form
M
(
Fnc
#
cc
)
~
;
where
Mcc
is
again
the
con
9text
on
the
nal
Tresult
.
No
9w
?
for
something
altogether
more
adv
en
turous
:
fthe
famil
-
iar
x
Mapply
function
at
t
9yp
A
e
M
(
Int
-
>
Int
)
-
>
Int
-
>
Int
.
This
example
is
easier
to
follo
9w
if
one
b
A
ears
in
mind
that
M
(
apply
f
x
)
reduces
immediately
to
M
(
f
x
)
so
an
9y
con
text
applied
to
the
former
expression
also
applies
directly
to
the
latter
.
ZWhat
the
rather
formidable
term
b
A
elo
9w
do
es
is
to
route
[
the
con
9text
from
the
result
of
calling
Mapply
to
the
result
Tof
calling
the
higher
-
order
parameter
.
j
8
r
?
Mapply
=
Fval
(
\
c1
-
>
Fnc
(
FncA
(
FncC
c1
)
)
r
J
(
FncC
(
FncC
c1
)
)
)
9TB
(
\
a1
-
>
Fval
(
\
c2
-
>
(
FvalC
a1
)
(
Fnc
(
FncA
c2
)
-
~
(
FncC
c2
)
)
v
(
\
a2
-
>
(
FvalA
a1
)
a2
)
)
j
First
Hfof
all
*
consider
what
the
function
con
9text
Mc1
will
get
3b
A
ound
to
m
9ust
lo
ok
lik
9e
:
-
M
(
Fnc
a_ho
(
Fnc
#
c_final
)
)
where
Ma_ho
us
the
abstract
(
or
forw
9ard
)
v
|
ralue
of
the
func
-
tional
parameter
and
Mc_final
is
the
con
9text
on
the
result
of
applying
this
functional
parameter
to
something
.
4
No
9w
term
N
M
(
\
c1
-
>
Fnc
(
FncA
(
FncC
c1
)
)
(
FncC
(
FncC
c1
)
)
)
maps
;
con
9text
on
Mapply
to
con
text
on
the
rst
parameter
.
As
ythis
is
a
functional
parameter
Bit
mak
9es
sense
that
this
expression
4
is
built
from
a
MFnc
.
XSo
just
what
con
9text
is
propa
-
gated
nto
the
functional
parameter
?
yW
:
ell
6the
abstract
v
|
ralue
m
9ust
b
A
e
the
same
as
the
abstract
v
|
ralue
of
the
second
pa
-
rameter
to
Mapply
and
this
v
|
ralue
(
whic
9h
m
ust
b
A
e
M
#
)
is
ex
-
tracted
qb
9y
the
term
M
(
FncA
(
FncC
c1
)
)
q
Similarly
:
8the
con
-
text
sson
the
result
of
the
functional
parameter
m
9ust
b
A
e
the
same
sas
the
con
9text
on
the
o
v
erall
result
of
Mapply
9giv
en
b
y
M
(
FncC
(
FncC
c1
)
)
.
Ev
9erything
else
is
easier
to
follo
w
.
V
:
ariable
Ma1
will
get
b
A
ound
to
cthe
abstract
v
|
ralue
of
the
functional
parameter
'
whic
9h
m
9ust
"
b
A
e
a
MFval
term
.
So
M
(
FvalC
a1
)
returns
the
map
used
b
9y
dthe
functional
parameter
to
translate
con
text
on
itself
to
con
9text
on
its
rst
argumen
t
.
The
map
is
applied
to
the
same
Yfunction
con
9text
as
w
as
built
in
the
preceding
para
-
graph
;
except
3
that
references
to
M
(
FncC
c1
)
are
replaced
b
9y
Mc2
Twhic
9h
is
the
same
thing
.
Finally
:
the
abstract
v
|
ralue
of
the
result
is
giv
9en
b
y
apply
-
ing
Jthe
abstract
v
|
ralue
map
of
the
functional
parameter
M
(
FvalA
a1
)
to
the
abstract
v
|
ralue
of
the
second
parameter
Ma2
.
Tw
9o
A
impro
v
emen
ts
are
p
A
ossible
.
Firstly
:
L
the
abstract
v
|
ralue
of
+
the
result
m
9ust
simply
b
A
e
M
#
0
~
since
the
result
t
yp
A
e
is
MInt
.
Secondly
:
examination
C
~
of
the
de
nition
of
MFncA
C0
and
MFncC
sho
9ws
u
'
that
M
(
Fnc
(
FncA
c
)
(
FncC
c
)
)
u
'
is
equiv
|
ralen
t
simply
to
T
Mc
.
pThe
impro
9v
ed
Tv
ersion
is
:
j
Mapply
=
Fval
(
\
c1
-
>
FncC
c1
)
9TB
(
\
a1
-
>
Fval
(
\
c2
-
>
(
FvalC
a1
)
c2
)
v
(
\
a2
-
>
#
)
)
The
mec
9hanism
for
dealing
with
functions
and
applications
is
jLthe
hardest
part
of
the
abstract
in
9terpreter
to
understand
.
A
1
little
2
/
time
sp
A
en
9t
making
sense
of
this
last
example
is
a
wise
in
9v
estmen
t
.
Wh
9y
G
is
it
necessary
to
propagate
demand
in
to
functional
parameters
?
pW
:
ell
Tconsider
:
Madd1
x
=
apply
(
+
x
)
1
If
5demand
isn
'
t
propagated
in
9to
Mapply
'
s
functional
parame
-
ter
there
Xwill
b
A
e
no
demand
on
term
M
(
+
x
)
and
none
on
Mx
giving
[
the
impression
that
Madd1
is
not
strict
when
really
it
is
.
e
3
.
3
G
Mo
re
L
ab
Ffout
abstract
values
m
All
:
onon
-
function
expressions
yield
an
abstract
v
|
ralue
in
a
unit
domain
.
3Ho
9w
ev
er
{
v
|
ralue
M
#
used
in
the
examples
ab
A
o
9v
e
{
is
to
A
o
indiscriminating
.
=
The
Hask
9ell
declaration
for
abstract
v
|
ralues
Tlo
A
oks
(
almost
)
lik
9e
this
:
O
Mdata
AbsVal
f
=
ANonRec
s
[
AbsVal
]
f
|
ARec
[
AbsVal
]
f
|
Fval
Context
AbsVal
f
|
AbsVar
Id
f
|
AbsLam
Id
AbsVal
f
|
AbsAp
XAbsVal
AbsVal
f
|
FncA
Context
f
|
FvalA
XAbsVal
f
|
SelA
Int
AbsVal
f
|
AMeet
X
[
AbsVal
]
The
MARec
and
MANonRec
terms
de
ne
abstract
v
|
ralues
for
3recursiv
9e
and
non
-
recursiv
e
t
yp
A
es
resp
ectiv
ely
:
.
In
b
A
oth
cases
the
asso
ciated
list
of
MAbsVal
s
are
the
ab
-
stract
v
|
ralues
of
the
parameters
of
the
t
9yp
A
e
.
F
:
or
ex
-
ample
|
a
term
of
t
9yp
A
e
M
[
(
Int
Int
)
]
has
abstract
v
|
ralue
M
(
Rec
[
NonRec
[
NonRec
[
]
NonRec
[
]
]
]
)
giv
9en
p
that
MInt
is
NFtreated
as
an
en
9umeration
and
th
us
maps
to
M
(
NonRec
[
]
)
.
It
is
imp
A
ortan
9t
to
realise
that
this
v
|
ralue
is
still
unitary
:
Tlik
e
M
#
but
H
has
the
added
adv
|
ran
9tage
that
it
can
b
A
e
disassem
-
bled
~
to
rev
9eal
its
unitary
sub
A
comp
onen
ts
vas
~
necessitated
b
y
the
abstract
in
9terpretation
of
Mcase
statemen
ts
.
Constructor
MSelA
T
is
used
for
this
with
meaning
:
O
MSelA
n
(
ARec
X
[
a1
.
.
.
an
.
.
.
ak
]
)
s
=
an
SelA
n
(
ANonRec
[
a1
.
.
.
an
.
.
.
ak
]
)
s
=
an
Fval
p
MFncA
^
[
and
^
n
MFvalA
w
9ere
in
tro
A
duced
in
the
previous
sec
-
tion
.
MAbsVar
[
MAbsLam
{
and
MAbsAp
allo
9w
references
to
abstract
-
v
|
ralued
qv
ariables
8and
for
the
creation
and
application
of
abstract
-
v
|
ralued
g9mappings
.
Observ
9e
that
w
e
often
omit
MAbsVar
R
and
MAbsAp
when
the
meaning
is
ob
9vious
and
ab
-
breviate
T
M
(
AbsLam
a
e
)
to
M
(
\
a
-
>
e
)
.
Consider
Tagain
O
M1
+
(
head
xs
(
y
+
1
)
)
where
t
Mxs
:
:
[
Int
-
>
Int
]
.
:
W
:
e
exp
A
ect
Mxs
to
ha
9v
e
b
A
een
b
A
ound
*
to
an
abstract
v
|
ralue
whic
9h
can
supply
a
sensible
con
9text
-
mapping
:
function
.
Once
again
CXw
e
c
haracterise
the
list
F0b
9y
the
least
elemen
t
o
this
time
the
least
con
text
function
in
Tit
.
pSo
supp
A
osing
O
Mxs
=
[
id
id
]
where
id
x
=
x
the
Tabstract
v
|
ralue
of
Mxs
will
b
A
e
:
MARec
[
s
Fval
(
\
c1
-
>
FncC
c1
)
ATB
(
\
a1
-
>
ANonRec
[
]
)
s
]
The
e
ect
of
the
Mhead
function
is
to
wrap
MSelA
1
around
this
term
making
the
abstract
v
|
ralue
of
Mid
a
9v
ailable
where
it
Tis
needed
.
pBut
no
9w
if
Mxs
w
ere
de
ned
as
Mxs
=
[
id
const
]
where
id
x
=
x
p
const
x
s
=
42
j
9
?
w
9e
need
to
b
A
e
more
cautious
.
Since
the
abstract
in
terpre
-
tation
ybcannot
distinguish
items
in
lists
ew
9e
m
ust
arrange
that
the
function
whic
9h
emerges
from
the
list
represen
ts
the
w
9eak
er
b
ev
|
raluator
:
Mconst
.
=
That
requires
the
list
as
a
whole
to
Tha
9v
e
v
|
ralue
:
Z
MARec
[
s
Fval
(
\
c1
-
>
_
)
9TB
(
\
a1
-
>
ANonRec
[
]
)
s
]
The
2
upshot
of
all
this
is
that
the
abstract
v
|
ralue
of
a
list
con
9taining
functions
is
c
haracterised
b
y
the
least
function
in
the
list
with
the
principle
extending
analogously
to
all
other
8structures
.
i
In
order
to
carry
that
out
a
greatest
-
lo
9w
er
-
b
A
ound
op
eration
is
needed
for
abstract
v
|
ralues
.
This
is
what
Tthe
MAMeet
term
is
for
.
3
.
4
G
Mo
re
L
ab
Ffout
contexts
m
This
.
is
a
go
A
o
d
.
p
oin
9t
at
whic
h
to
wheel
in
the
Hask
ell
decla
-
ration
0
&
for
con
9texts
.
l
Unfortunately
:
6
it
is
ev
en
more
cum
b
A
er
-
some
Tthan
the
MAbsVal
declaration
.
pNev
9ertheless
:
Mdata
Context
f
=
Stop1
f
|
Up1
Y
[
Context
]
f
|
Stop2
f
|
Up2
f
|
UpUp2
X
[
Context
]
f
|
Fnc
Y
AbsVal
Context
f
|
FncC
Context
f
|
FvalC
XAbsVal
f
|
CJoin
X
[
Context
]
f
|
CMeet
X
[
Context
]
f
|
CtxVar
Id
f
|
CtxLam
Id
Context
f
|
CtxAp
XContext
Context
f
|
SelU
Int
Context
f
|
SelUU
XInt
Context
f
|
CaseU
XContext
Context
Context
f
|
CaseUU
Context
Context
Context
Context
f
|
DefU
Context
f
|
DefUU
XContext
The
S
rst
six
are
for
building
literal
con
9texts
.
MStop1
and
MUp1
yO
p
A
ertain
to
p
oin
9ts
in
MLift
(
D1
x
.
.
.
x
Dn
)
with
yO
MStop1
represen
9ting
the
b
A
ottom
p
oin
9t
M_
Y
|
and
M
(
Up1
[
x1
.
.
.
xn
]
)
represen
9ting
the
p
A
oin
t
MU
[
x1
.
.
.
xn
]
.
Similarly
:
T
MStop2
MUp2
and
u
M
(
UpUp2
[
x1
.
.
.
xn
]
)
represen
9t
the
p
A
oin
ts
M_
h
=
MU_
and
MUU
[
x1
.
.
.
xn
]
&
in
the
domain
MLift2
(
D1
x
.
.
.
x
Dn
)
.
MFnc
is
eused
for
building
function
-
v
|
ralued
con
9texts
/
as
discussed
in
section
Hj3
.
2
.
Finally
:
U0
MDefU
H
]
and
MDefUU
exist
to
help
the
term
rewriting
Tsystem
as
describ
A
ed
in
section
4
.
4
.
MFncC
(
and
)
!
MFvalC
w
9ere
also
discussed
in
section
3
.
2
.
MCJoin
and
MCMeet
]
=
unsurprisingly
denote
the
least
upp
A
er
and
greatest
lo
9w
er
Tb
A
ounds
of
their
resp
ectiv
9e
argumen
t
lists
.
MCtxVar
MCtxLam
L0
and
MCtxAp
are
exact
equiv
|
ralen
9ts
to
the
MAbsVar
"
MAbsLam
and
MAbsAp
discussed
in
section
3
.
3
.
fThey
pro
9vide
a
w
a
y
to
reference
con
text
-
v
|
ralued
v
ariables
and
al
-
lo
9w
8the
creation
and
application
of
con
text
-
v
|
ralued
maps
.
Once
again
note
that
w
9e
often
omit
MCtxVar
and
MCtxAp
when
the
meaning
is
ob
9vious
and
abbreviate
M
(
CtxLam
c
e
)
to
T
M
(
\
c
-
>
e
)
.
F
:
ar
%
and
a
9w
a
y
%
the
most
in
9teresting
constructs
are
the
last
four
.
y
MCaseU
A
and
B
MCaseUU
allo
9w
partial
disassem
bly
of
v
|
ralues
in
6m
MLift
(
D1
x
.
.
.
x
Dn
)
and
MLift2
(
D1
x
.
.
.
x
Dn
)
re
-
sp
A
ectiv
9ely
:
fin
;
the
manner
discussed
in
section
2
.
2
.
3
.
The
exact
Tseman
9tics
are
:
MCaseU
Stop1
x
y
s
=
x
CaseU
(
Up1
_
)
x
y
s
=
y
CaseUU
Stop2
x
y
z
s
=
x
CaseUU
Up2
!
x
y
z
s
=
y
CaseUU
(
UpUp2
_
)
x
y
z
s
=
z
Note
dthat
the
switc
9h
v
|
ralues
are
restricted
to
b
A
eing
in
do
-
mains
MLift
(
D1
x
.
.
.
x
Dn
)
and
MLift2
(
D1
x
.
.
.
x
Dn
)
resp
A
ectiv
9ely
:
.
Switc
h
v
|
ralues
from
an
9y
other
domain
consti
-
tute
an
ill
-
formed
con
9text
.
J
MCaseU
and
MCaseUU
terms
denote
a
mapping
from
their
switc
9h
expressions
to
one
of
the
al
-
ternativ
9es
.
(
As
<
suc
h
C
a
w
ell
-
formed
MCaseU
or
MCaseUU
m
9ust
denote
7aa
monotonic
mapping
so
w
9e
imp
A
ose
the
seman
tic
constrain
9t
Tthat
Mx
Pv
My
"
Pv
Mz
K
\
.
As
~
y
9ou
migh
t
susp
A
ect
a
MSelU
~
and
MSelUU
are
selectors
in
the
spirit
Tof
MSelA
discussed
in
section
3
.
3
.
pSeman
9tics
are
:
MSelU
s
n
(
Up1
[
x1
.
.
.
xn
.
.
.
xk
]
)
=
xn
SelUU
n
(
UpUp2
[
x1
.
.
.
xn
.
.
.
xk
]
)
=
xn
But
there
is
a
v
9ery
strong
seman
tic
constrain
t
here
:
+
it
is
illegal
'
to
apply
MSelU
or
MSelUU
to
a
v
|
ralue
unless
that
v
alue
is
pro
9v
|
rably
E
equiv
alen
t
E
to
an
MUp1
[
.
.
.
]
or
MUpUp2
[
.
.
.
]
v
|
ralue
resp
A
ectiv
9ely
:
.
This
C
means
O
for
some
arbitrary
con
text
Mc
O
the
follo
9wing
Texpressions
are
lik
ely
to
b
A
e
ill
-
formed
:
MSelU
s
n
c
SelUU
n
c
The
>
one
and
only
w
9a
y
>
to
mak
9e
them
w
ell
-
formed
is
to
wrap
the
r
appropriate
sp
A
ecies
of
MCase
term
around
them
lea
9ving
the
T
MSel
in
the
greatest
-
v
|
ralue
arm
:
MCaseU
s
c
(
.
.
.
whatever
.
.
.
)
(
SelU
n
c
)
CaseUU
c
(
.
.
.
whatever
.
.
.
)
(
.
.
.
whatever
.
.
.
)
~
(
SelUU
n
c
)
In
b
A
oth
cases
Rthe
term
M
(
Sel
n
c
)
ma
9y
not
app
ear
in
an
9y
place
mark
9ed
\
M
.
.
.
whatever
.
.
.
"
.
[
]
Note
that
the
MSel
term
ma
9y
2
app
A
ear
an
ywhere
within
the
greatest
-
v
|
ralue
arm
y
and
is
|
not
restricted
to
the
top
lev
9el
as
this
example
seems
to
suggest
.
'
3
.
5
G
Constructo
r
L
functions
and
case
statements
m
The
source
-
language
trappings
of
structured
t
9yp
A
es
giv
e
rise
to
N
some
of
the
more
in
9teresting
parts
of
the
abstract
in
ter
-
preter
NOand
B
w
9arran
t
a
section
to
themselv
es
.
1First
NOthough
some
Tterminology
:
.
pA
structured
t
9yp
A
e
is
de
ned
lik
e
this
:
Mdata
typeName
v1
.
.
.
vk
=
C1
t11
.
.
.
t1m
uM
|
.
.
.
uM
|
Cn
t1n
.
.
.
tnm
10
?
This
de
nes
a
t
9yp
A
e
called
MtypeName
param
terised
b
y
t
yp
A
e
v
|
rariables
Mv1
to
Mvk
xwith
constructors
MC1
to
MCn
.
The
t
9yp
A
e
ex
-
pressions
Mt11
to
Mtnm
whic
9h
form
the
argumen
ts
to
the
con
-
structors
are
hea
9vily
constrained
in
the
manner
discussed
in
1section
2
.
2
.
6
:
*
they
ma
9y
only
b
A
e
either
one
of
the
t
yp
A
e
v
|
rariables
i
Mv1
.
.
.
vk
or
XLa
direct
recursiv
9e
call
to
the
t
yp
A
e
:
M
(
typeName
v1
.
.
.
vk
)
.
Because
of
this
constrain
9t
eac
h
constructor
argumen
9t
in
a
v
|
ralid
&
de
nition
can
b
A
e
classi
ed
either
as
a
recursiv
9e
call
MRec
or
Y
as
one
of
the
t
9yp
A
e
v
|
rariables
j
MVar
n
where
Mn
is
a
n
um
b
A
er
denoting
Twhic
9h
v
|
rariable
.
pF
:
or
example
the
de
nition
O
Mdata
AVLTree
i
a
b
f
=
ALeaf
f
|
ANode
i
(
AVLTree
i
a
b
)
a
b
(
AVLTree
i
a
b
)
can
Tin
principle
b
A
e
rewritten
as
Mdata
AVLTree
(
of
3
type
variables
)
f
=
ALeaf
f
|
ANode
(
Var
1
)
Rec
(
Var
2
)
(
Var
3
)
Rec
W
:
e
)
no
9w
de
ne
t
w
o
strange
functions
-
Margkind
and
Mupdate
to
assist
in
the
discussion
b
A
elo
9w
.
W
Neither
are
mean
t
to
b
A
e
implemen
9table
.
Rather
xthey
serv
e
as
con
v
enien
t
nota
-
tional
Rdevices
and
are
b
A
est
illustrated
b
9y
example
.
jThey
are
b
A
oth
meaningless
unless
the
particular
constructor
ap
-
plication
Tthey
are
asso
A
ciated
with
is
stated
.
Margkind
tells
us
what
part
of
a
data
t
9yp
A
e
a
giv
en
construc
-
tor
argumen
9t
corresp
A
onds
to
:
either
a
certain
t
yp
A
e
v
|
rariable
or
3a
recursiv
9e
instance
of
the
t
yp
A
e
.
eF
:
or
example
b
earing
in
mind
~
the
declaration
ab
A
o
9v
e
Pgiv
en
~
the
constructor
applica
-
tion
T
M
(
ANode
i
l
a
b
r
)
:
Margkind
i
=
Var
1
argkind
l
=
Rec
argkind
a
=
Var
2
argkind
b
=
Var
3
argkind
r
=
Rec
update
G
replaces
a
particular
v
|
ralue
in
a
supplied
list
with
another
v
|
ralue
.
It
nds
out
whic
9h
lo
A
cation
to
up
date
b
9y
using
w
Margkind
J
exp
A
ecting
an
answ
9er
of
the
form
M
(
Var
i
)
whereup
A
on
B
Mi
is
used
as
the
lo
cation
.
It
is
in
9v
|
ralid
to
use
Mupdate
in
a
w
9a
y
whic
h
w
ould
cause
the
call
to
argkind
to
_return
MRec
.
_
Again
F
using
the
constructor
application
M
(
ANode
i
l
a
b
r
)
:
Mupdate
i
"
my
"
[
"
the
"
"
cat
"
"
sat
"
]
f
=
[
"
my
"
s
"
cat
"
"
sat
"
]
update
a
"
dog
"
s
[
"
the
"
"
cat
"
"
sat
"
]
f
=
[
"
the
"
"
dog
"
"
sat
"
]
update
b
"
ran
"
s
[
"
the
"
"
cat
"
"
sat
"
]
Z
=
[
"
the
"
"
cat
"
"
ran
"
]
But
Mupdate
l
x
xs
update
r
x
xs
are
Tb
A
oth
illegal
since
Margkind
l
=
Margkind
r
=
MRec
.
The
example
used
Mupdate
to
replace
w
9ords
in
a
list
thereof
to
emphasise
C6
Mupdate
'
s
p
A
olymorphic
nature
.
Note
that
Mupdate
is
alw
9a
ys
used
with
a
constructor
wrapp
A
ed
round
the
nal
list
argumen
9t
.
<
This
constructor
is
re
-
attac
hed
to
the
result
:
Mupdate
i
"
my
"
(
SomeConstructor
[
"
the
"
"
cat
"
"
sat
"
]
)
f
=
(
SomeConstructor
[
"
my
"
s
"
cat
"
"
sat
"
]
)
F
:
or
the
sak
9e
of
clarit
y
:
r
this
inconsequen
tial
detail
is
hence
-
forth
Tignored
.
Recall
w
from
section
2
.
2
.
5
that
function
MD
wO
returns
the
do
-
main
.
asso
A
ciated
with
a
particular
t
9yp
e
.
F
:
our
more
handy
functions
wcof
similar
ilk
are
Mtop
Mbot
Mtopfv
wc
and
Mwhnf
.
B
The
rst
t
9w
o
simply
generate
the
greatest
and
least
con
texts
in
a
particular
5
domain
.
Mtopfv
(
D
)
5p
generates
the
greatest
abstract
v
|
ralue
Tin
domain
MD
.
Mtop
(
Lift
s
(
D1
x
.
.
.
x
Dn
)
)
f
=
Up1
[
top
(
D1
)
.
.
.
top
(
Dn
)
]
top
(
Lift2
(
D1
x
.
.
.
x
Dn
)
)
f
=
UpUp2
[
top
(
D1
)
.
.
.
top
(
Dn
)
]
top
(
Ds
-
>
Dt
)
f
=
(
\
c
-
>
top
(
Ds
)
)
bot
(
Lift
s
(
D1
x
.
.
.
x
Dn
)
)
f
=
Stop1
bot
(
Lift2
(
D1
x
.
.
.
x
Dn
)
)
f
=
Stop2
bot
(
Ds
-
>
Dt
)
f
=
(
\
c
-
>
bot
(
Ds
)
)
topfv
(
Lift
s
(
D1
x
.
.
.
x
Dn
)
)
f
=
ANonRec
[
topfv
(
D1
)
.
.
.
topfv
(
Dn
)
]
topfv
(
Lift2
(
D1
x
.
.
.
x
Dn
)
)
f
=
ARec
X
[
topfv
(
D1
)
.
.
.
topfv
(
Dn
)
]
topfv
(
Ds
-
>
Dt
)
f
=
Fval
(
\
c
-
>
top
(
Ds
)
)
3
'
(
\
a
-
>
topfv
(
Dt
)
)
whnf
(
D
)
is
the
w
9eak
head
normal
form
ev
|
raluator
for
domain
MD
.
TThis
only
mak
9es
sense
for
certain
v
|
ralues
of
MD
:
Mwhnf
(
Lift
s
(
D1
x
.
.
.
x
Dn
)
)
f
=
Up1
[
bot
(
D1
)
.
.
.
bot
(
Dn
)
]
whnf
(
Lift2
(
D1
x
.
.
.
x
Dn
)
)
f
=
UpUp2
[
bot
(
D1
)
.
.
.
bot
(
Dn
)
]
Finally
:
Tfor
the
record
a
Core
Mcase
expression
lo
A
oks
lik
9e
Mcase
switchExpression
of
fC1
p11
.
.
.
p1m
-
>
rhs1
3
'
.
.
.
fCn
p1n
.
.
.
pnm
-
>
rhsn
where
X
%
it
is
assumed
that
all
constructors
are
presen
9t
.
This
is
Tassured
b
9y
the
pattern
-
matc
hing
phase
of
the
desugarer
.
The
four
follo
9wing
sections
do
A
cumen
t
the
o
w
of
abstract
v
|
ralues
^
and
con
9texts
through
constructor
applications
and
Mcase
'
expressions
.
In
some
w
9a
ys
the
'
t
w
o
are
opp
A
osites
:
con
-
structor
kapplications
build
structures
O1whilst
Mcase
expres
-
sions
Mdisassem
9ble
them
.
~
ZAn
in
teresting
dualit
y
arises
from
this
.
The
o
9w
of
abstract
v
|
ralues
though
case
expressions
is
uncannily
similar
to
the
o
9w
of
con
texts
v
|
ralues
through
constructors
Tand
vice
v
9ersa
.
11
&
?
3
.
5
.
1
Constructo
r
L
functions
:
fhabstract
value
p
ropagation
m
Ho
9w
1do
abstract
v
|
ralues
o
w
through
a
constructor
?
4
The
discussion
of
section
3
.
3
implied
that
the
the
M
(
:
)
function
m
9ust
Tb
A
eha
v
e
something
lik
e
:
eh
M
(
:
)
=
\
x
xs
-
>
AMeet
[
xs
ARec
[
x
]
]
Observ
9e
that
the
apparen
tly
p
A
olymorphic
nature
of
this
def
-
inition
is
inciden
9tal
.
7In
general
giv
en
an
arit
y
-
n
constructor
MC
and
argumen
9ts
Ma1
.
.
.
an
where
M
(
C
a1
.
.
.
an
)
:
:
tau
the
Tforw
9ard
b
A
eha
viour
of
C
is
:
eh
M
\
a1
.
.
.
an
-
>
AMeet
[
e1
.
.
.
en
]
ei
=
ai
if
argkind
ai
=
Rec
f
=
ARec
(
update
ai
ai
topfv
(
D
(
tau
)
)
)
if
argkind
ai
=
=
Var
x
and
s
C
is
from
a
recursive
type
f
=
ANonRec
(
update
ai
ai
topfv
(
D
(
tau
)
)
)
if
argkind
ai
=
=
Var
x
and
s
C
is
from
a
non
-
recursive
type
Nullary
fconstructors
simply
acquire
the
top
abstract
v
|
ralue
of
the
relev
|
ran
9t
domain
(
b
A
ear
in
mind
that
for
a
domain
not
con
9taining
function
spaces
this
is
the
same
as
the
b
A
ottom
p
A
oin
9t
)
.
pThe
T
M
[
]
case
for
M
[
Int
]
for
example
is
:
M
[
]
=
topfv
(
D
(
[
Int
]
)
)
f
=
topfv
(
Lift2
(
Lift
(
)
)
)
f
=
ARec
[
ANonRec
[
]
]
The
3motiv
9e
in
all
this
is
to
ensure
that
the
abstract
v
|
ralue
of
a
constructor
application
is
c
9haracterised
for
eac
h
parame
-
terising
Tt
9yp
A
e
b
y
the
least
v
|
ralue
of
that
t
yp
A
e
.
As
K
[
an
example
consider
an
ob
ject
of
t
9yp
A
e
M
(
AVLTree
Int
Int
Int
)
.
oCon
texts
for
that
t
yp
A
e
are
dra
9wn
from
the
domain
MLift2
(
Lift
(
)
x
Lift
(
)
x
Lift
(
)
)
.
#
W
:
e
exp
A
ect
the
abstract
v
|
ralue
returned
b
9y
b
A
oth
the
MALeaf
and
MANode
constructors
to
b
e
of
the
form
MARec
[
ii
aa
bb
]
where
Mii
represen
9ts
the
least
abstract
v
|
ralue
Q
of
an
9y
ob
ject
corresp
A
onding
to
t
yp
A
e
v
|
rariable
Mi
in
the
t
9yp
A
e
TAde
nition
c
and
similarly
for
Maa
and
Mbb
.
7So
at
this
in
-
stan
9tiation
Wthe
abstract
v
|
ralue
b
A
eha
viour
of
the
constructors
is
:
J
MALeaf
=
ARec
[
ANonRec
[
]
ANonRec
[
]
ANonRec
[
]
]
ANode
=
\
i
l
a
b
r
-
>
Z
AMeet
Z
[
ARec
[
i
/
?
ANonRec
[
]
ANonRec
[
]
]
l
ARec
[
ANonRec
[
]
a
/
?
ANonRec
[
]
]
ARec
[
ANonRec
[
]
ANonRec
[
]
b
*
F
]
r
Z
]
Non
-
recursiv
9e
~
t
yp
A
es
are
dealt
with
in
an
exactly
analogous
manner
.
JF
:
or
6
example
c
the
b
A
eha
9viour
of
the
pairing
construc
-
tor
Tat
t
9yp
A
e
MInt
-
>
Int
-
>
(
Int
Int
)
T
is
M
(
)
=
\
x
y
-
>
Z
AMeet
Z
[
ANonRec
[
x
/
?
ANonRec
[
]
]
ANonRec
[
ANonRec
[
]
y
*
F
]
Z
]
q
If
_
y
9our
instincts
tell
y
ou
this
is
m
uc
h
ado
ab
A
out
nothing
y
ou
are
;
!
correct
.
Since
all
these
examples
build
structures
with
-
out
em
9b
A
edded
function
spaces
the
result
v
|
ralues
are
unitary
:
and
Tma
9y
b
A
e
written
:
M
[
]
s
=
/
?
ARec
[
ANonRec
[
]
]
(
:
)
=
\
x
xs
-
>
ARec
[
ANonRec
[
]
]
(
)
=
\
x
y
-
>
ANonRec
[
ANonRec
[
]
ANonRec
[
]
]
ALeaf
=
ARec
[
ANonRec
[
]
ANonRec
[
]
ANonRec
[
]
]
ANode
=
\
i
l
a
b
r
-
>
)
TARec
[
ANonRec
[
]
ANonRec
[
]
ANonRec
[
]
]
?
3
.
5
.
2
Constructo
r
L
functions
:
fhcontext
p
ropagation
m
The
Qname
of
the
game
here
is
to
sa
9y
what
con
text
propagates
from
Ma
non
-
n
9ullary
constructor
to
its
argumen
ts
.
fZIn
tuiting
rst
Ton
M
[
Int
]
M
(
:
)
exhibits
the
follo
9wing
b
A
eha
viour
:
MDemand
on
(
x
:
xs
)
Y
Demand
on
x
Demand
on
xs
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
.
UU
[
U
[
]
]
F
U
[
]
B
&
4UU
[
U
[
]
]
.
UU
[
_
]
PR
_
K
UU
[
_
]
.
U_
^
_
K
_
.
_
c9N_
K
_
A
MUU
[
U
[
]
]
con
9text
causes
ev
|
raluation
of
the
en
tire
structure
of
pthe
list
27and
all
the
MInt
s
in
it
to
A
o
.
a
So
w
9e
ma
y
propagate
MU
[
]
!
to
Mx
and
MUU
[
U
[
]
]
to
the
tail
of
the
list
.
The
same
reasoning
9
explains
the
propagation
of
a
MUU
[
_
]
con
9text
.
3No
w
what
iof
MU_
?
"
This
ev
|
raluator
simply
ev
aluates
to
WHNF
that
is
the
rst
constructor
and
giv
9es
up
.
So
zero
con
text
ma
y
b
A
e
propagated
to
either
head
or
tail
.
Similarly
:
Bzero
con
9text
propagates
Tfrom
zero
con
9text
on
M
(
x
:
xs
)
.
Is
;
there
a
pattern
here
?
The
con
9text
on
Mxs
is
that
same
as
the
Mcon
9text
on
M
(
x
:
xs
)
except
at
the
WHNF
p
A
oin
t
whilst
the
#
'
con
9text
on
Mx
is
\
My
"
in
the
MUU
[
y
]
cases
&
and
none
other
-
wise
.
This
rlatter
op
A
eration
could
b
e
regarded
as
dropping
the
r
double
-
lifting
*
and
selecting
the
rst
pro
A
duct
comp
o
-
nen
9t
.
W
:
riting
the
con
text
on
M
(
x
:
xs
)
as
Malpha
con
text
on
Mx
and
T
Mxs
resp
A
ectiv
9ely
could
b
e
written
as
:
MDropUU
1
alpha
ZapWHNF
alpha
Implemen
9ting
Z
MDropUU
and
MZapWHNF
directly
causes
ma
jor
problems
in
the
term
-
rewriting
system
.
F
:
ortunately
Jthe
MCaseUU
T
and
MSelUU
primitiv
9es
can
b
A
e
used
instead
:
tx
MDropUU
n
alpha
=
CaseUU
alpha
_
_
(
SelUU
n
alpha
)
txZapWHNF
alpha
s
=
CaseUU
alpha
_
_
alpha
Analogising
the
informal
argumen
9t
leads
to
a
general
rule
.
Giv
9en
an
arit
y
-
Mn
constructor
MC
?
and
argumen
ts
Ma1
.
.
.
an
where
S
M
(
C
a1
.
.
.
an
)
:
:
tau
con
9text
Malpha
on
the
con
-
structor
Tapplication
pro
A
duces
con
9text
on
Mai
as
follo
ws
:
12
=
?
Mai
s
=
ZapWHNF
alpha
A
(
if
argkind
ai
=
=
Rec
=
DropUU
x
alpha
A
(
if
argkind
ai
=
=
Var
x
A
(
and
s
C
is
from
a
recursive
type
=
DropU
x
alpha
A
(
if
argkind
ai
=
=
Var
x
A
(
and
s
C
is
from
a
non
-
recursive
type
'
The
}
i
MAVLTree
example
at
instance
M
(
AVLTree
Int
Int
Int
)
b
A
eha
9v
es
Lqas
follo
9ws
for
a
con
text
Malpha
applied
to
M
(
ANode
i
l
a
b
r
)
:
s
]
MVariable
!
Demand
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
i
B
&
4DropUU
1
alpha
l
B
&
4ZapWHNF
s
alpha
a
B
&
4DropUU
2
alpha
b
B
&
4DropUU
3
alpha
r
B
&
4ZapWHNF
s
alpha
Con
9text
9
%
propagation
for
non
-
recursiv
e
t
yp
A
es
b
eha
9v
es
9
%
in
a
similar
N
manner
]
except
that
it
is
no
longer
p
A
ossible
to
gen
-
erate
)
]
MZapWHNF
and
the
drop
-
select
op
A
erator
only
drops
one
p
A
oin
9t
%
instead
Yof
t
w
o
.
rThis
op
A
erator
%
called
MDropU
is
imple
-
men
9ted
Tas
'
MDropU
n
alpha
s
=
CaseU
alpha
_
(
SelU
n
alpha
)
F
:
or
7a
con
9text
Malpha
applied
to
M
(
x
y
)
:
:
(
Int
Int
)
the
con
9texts
propagated
to
Mx
and
My
are
M
(
DropU
1
alpha
)
and
M
(
DropU
2
alpha
)
T
resp
A
ectiv
9ely
:
.
T
:
ranslation
gvof
MDropU
MDropUU
gJ
and
MZapWHNF
in
9to
the
MCase
and
MSel
primitiv
9es
requires
some
passing
around
of
domains
[
so
that
the
appropriate
kind
of
b
A
ottom
v
|
ralues
can
b
e
man
9ufac
-
tured
.
3
.
5
.
3
Case
L
exp
ressions
:
fhabstract
value
p
ropagation
m
The
Qtask
here
is
to
gure
out
what
abstract
v
|
ralues
to
at
-
tac
9h
to
constructor
v
|
rariables
in
a
case
expression
Ygiv
en
the
abstract
TUv
|
ralue
of
the
switc
9h
expression
.
rThe
solution
is
re
-
mark
|
rably
similar
to
propagation
of
con
9texts
to
constructor
argumen
9ts
^
3and
O
follo
ws
a
theme
whic
h
should
b
A
e
b
ecoming
familiar
.
pGiv
9en
Ta
case
expression
'
Mcase
sw
of
f
.
.
.
fC
a1
.
.
.
an
-
>
rhs
f
.
.
.
and
L
an
abstract
v
|
ralue
asso
A
ciated
with
Msw
of
Mfsw
t
the
abstract
v
|
ralue
Tasso
A
ciated
with
Mai
is
Mai
s
=
fsw
A
(
if
argkind
ai
=
=
Rec
=
SelA
x
fsw
A
(
if
argkind
ai
=
=
Var
x
Let
w
the
abstract
v
|
ralue
of
the
switc
9h
expression
b
A
e
denoted
Mfsw
.
pF
:
or
T
M
[
Int
]
w
9e
ha
v
e
:
Mcase
sw
of
f
[
]
-
>
s
rhs1
f
(
x
:
xs
)
-
>
s
rhs2
giving
Tbindings
of
Mx
s
-
-
-
>
SelA
1
fsw
xs
-
-
-
>
s
fsw
(
AVLTree
Int
Int
Int
)
T
giv
9es
:
Mcase
sw
of
fALeaf
8
-
>
rhs1
fANode
i
l
a
b
r
s
-
>
rhs2
i
s
-
-
-
>
SelA
1
fsw
l
s
-
-
-
>
fsw
a
s
-
-
-
>
SelA
2
fsw
b
s
-
-
-
>
SelA
3
fsw
r
s
-
-
-
>
fsw
Finally
:
T
M
(
Int
Int
)
giv
9es
:
Mcase
sw
of
f
(
x
y
)
s
-
>
rhs1
x
s
-
-
-
>
SelA
1
fsw
y
s
-
-
-
>
SelA
2
fsw
3
.
5
.
4
Case
L
exp
ressions
:
fhcontext
p
ropagation
m
This
section
establishes
ho
9w
con
text
on
a
Mcase
expression
propagates
k
to
con
9text
on
the
switc
h
expression
.
First
a
subsidiary
Tresult
.
F
o
rw
a
rds
L
p
ropagation
of
contexts
though
constructo
rs
m
Giv
9en
5
%
a
constructor
application
M
(
C
a1
.
.
.
an
)
:
:
tau
a
the
metho
A
d
G
of
section
3
.
5
.
2
can
tell
us
ho
9w
con
text
on
this
ap
-
plication
C
maps
to
con
9text
on
Ma1
.
.
.
an
.
Ho
w
ev
er
OQw
e
C
no
w
need
Hgto
run
the
pro
A
cess
in
rev
9erse
.
Giv
en
Hgsome
con
9texts
Mc1
.
.
.
cn
L
on
Ma1
.
.
.
an
w
9e
Lw
an
t
to
nd
the
greatest
con
-
text
Malpha
that
ma
9y
b
A
e
put
on
the
application
constrained
so
that
the
con
9texts
that
section
3
.
5
.
2
indicates
w
ould
then
propagate
to
Ma1
.
.
.
an
are
less
than
or
equal
Mc1
.
.
.
cn
resp
A
ectiv
9ely
:
.
The
follo
9wing
sc
heme
is
o
ered
again
without
justi
cation
.
If
T
MC
is
from
a
recursiv
9e
t
yp
A
e
:
Malpha
=
CJoin
[
Up2
CMeet
[
e1
.
.
.
en
]
]
ei
=
ai
if
argkind
ai
=
=
Rec
f
=
update
ai
ai
top
(
D
(
tau
)
)
if
argkind
ai
=
=
Var
x
If
p
MC
P
is
from
a
non
-
recursiv
9e
t
yp
A
e
6
M
(
argkind
ai
)
cannot
b
e
MRec
Tso
this
simpli
es
to
:
Malpha
=
CMeet
[
e1
.
.
.
en
]
ei
=
update
ai
ai
top
(
D
(
tau
)
)
if
argkind
ai
=
=
Var
x
13
U
?
Finally
:
Tfor
n
9ullary
constructors
lik
e
M
[
]
:
k
Malpha
=
ctop
(
D
(
tau
)
)
Examples
:
pgiv
9en
T
M
(
a1
a2
)
:
:
(
Int
Int
)
w
9e
get
Malpha
=
CMeet
[
Up1
[
c1
XU
[
]
]
G
Up1
[
U
[
]
c2
]
]
(
a1
:
a2
)
:
:
[
Int
]
T
giv
9es
Malpha
=
CJoin
[
Up2
G
CMeet
[
UpUp2
[
c1
]
mM
c2
]
>
]
[
]
:
:
[
Int
]
T
giv
9es
Malpha
=
UpUp2
[
Up1
[
]
]
(
ANode
a1
a2
a3
a4
a5
)
:
:
(
ATree
Int
Int
Int
)
T
giv
9es
Malpha
=
CJoin
!
T
[
Up2
+
'
CMeet
[
UpUp2
[
c1
XU
[
]
U
[
]
]
P
0c2
P
0UpUp2
[
U
[
]
c3
XU
[
]
]
P
0UpUp2
[
U
[
]
U
[
]
c4
s
]
P
0c5
]
!
T
]
Using
L
the
lemma
m
And
ino
9w
to
return
to
the
main
theme
.
A
t
this
p
A
oin
t
it
'
s
necessary
{
to
in
9tro
A
duce
a
function
w
e
will
see
a
lot
more
of
later
.
The
yfunction
MC
M
tells
us
ho
9w
m
uc
h
con
text
is
propa
-
gated
s
]
to
a
v
|
rariable
Mx
when
con
9text
Malpha
is
propagated
to
some
>
arbitrary
expression
Me
.
Of
course
I3if
Mx
do
A
es
not
o
ccur
free
Tin
Me
the
answ
9er
is
none
.
pW
:
e
write
this
as
MC
x
[
e
]
rho
alpha
with
the
Me
in
square
brac
9k
ets
to
emphasise
that
MC
b
regards
it
m
as
a
syn
9tactic
ob
ject
.
%
fAs
b
A
ecomes
apparen
t
later
MC
m
also
requires
an
en
9vironmen
t
Mrho
whic
9h
supplies
abstract
v
|
ralues
for
Tall
free
v
|
rariables
in
Me
.
Recall
Tthat
a
Mcase
expression
lo
A
oks
lik
9e
this
:
Mcase
sw
of
fC1
p11
.
.
.
p1m
-
>
rhs1
f
.
.
.
fCn
p1n
.
.
.
pnm
-
>
rhsn
No
9w
S
giv
en
con
text
Malpha
o
v
erall
S
what
is
the
con
text
on
Msw
?
aThe
rst
step
is
to
nd
the
con
9text
on
Mp11
.
.
.
pnm
.
These
Tcon
9text
are
giv
en
b
y
:
M
(
C
p11
[
rhs1
]
rho1
alpha
)
.
.
.
(
C
p1m
[
rhs1
]
rho1
alpha
)
.
.
.
(
C
p1n
[
rhsn
]
rhon
alpha
)
.
.
.
(
C
pnm
[
rhsn
]
rhon
alpha
)
F
:
or
D
=
eac
9h
particular
constructor
O
the
original
en
viron
-
men
9t
Mrho
is
augmen
ted
with
abstract
v
|
ralue
bindings
for
the
0
v
|
rariables
asso
A
ciated
with
that
constructor
v
generating
Mrho1
.
.
.
rhon
.
These
v
|
ralues
are
deriv
9ed
from
the
abstract
v
|
ralue
of
the
switc
9h
expression
as
describ
A
ed
in
section
3
.
5
.
3
.
The
Hnext
step
is
to
gure
out
what
con
9text
can
b
A
e
safely
applied
w
to
eac
9h
constructor
hkno
wing
the
con
texts
on
their
individual
.
4argumen
9ts
.
g
The
metho
A
d
describ
ed
in
the
lemma
is
}
applied
once
for
eac
9h
constructor
to
the
con
9texts
for
Mp11
.
.
.
pnm
just
computed
TJgiving
Malpha1
.
.
.
alphan
.
These
<
mv
|
ralues
are
com
9bined
to
giv
e
the
o
v
erall
con
text
on
Msw
T
as
:
O
MCMeet
[
alpha1
.
.
.
alphan
]
Using
6u
MCMeet
to
merge
these
v
|
ralues
re
ects
the
fact
that
w
9e
cannot
kno
9w
whic
h
alternativ
e
will
b
A
e
selected
at
compile
time
.
The
b
A
est
safe
v
|
ralue
whic
9h
can
b
e
obtained
is
the
least
of
Tan
9y
of
alternativ
es
.
Unfortunately
:
*
there
?
is
one
sp
A
ecial
case
where
this
form
9u
-
lation
"
is
wrong
.
When
the
switc
9h
expression
is
of
a
re
-
cursiv
9e
t
yp
A
e
lik
e
M
[
Int
]
one
nds
that
propagating
zero
con
9text
on
to
the
Mcase
expression
pro
A
duces
non
-
zero
con
text
on
x
!
the
switc
9h
expression
.
D
This
unsafe
result
can
b
A
e
traced
to
7the
case
for
recursiv
9e
t
yp
A
es
b
eing
of
the
form
Malpha
=
MCJoin
[
Up2
.
.
.
]
swhic
9h
imp
A
oses
a
minim
um
v
|
ralue
of
MUp2
on
the
con
9text
con
tributed
b
y
eac
h
constructor
.
Simply
thro
9wing
o
a
w
a
y
the
MUp2
clamping
bit
causes
more
problems
than
it
solv
9es
.
kA
b
A
etter
solution
is
to
explicitly
imp
ose
the
required
condition
that
zero
o
9v
erall
con
text
pro
A
duces
zero
con
9text
7on
the
switc
h
expression
.
Recalling
that
Malpha
is
the
To
9v
erall
con
text
this
is
done
b
y
writing
O
MCaseU
alpha
_
(
CMeet
[
alpha1
.
.
.
alphan
]
)
or
MCaseUU
alpha
_
(
CMeet
[
alpha1
.
.
.
alphan
]
)
J
n
(
CMeet
[
alpha1
.
.
.
alphan
]
)
dep
A
ending
C
on
the
domain
of
Malpha
.
The
p
ossible
duplication
of
the
M
(
CMeet
[
alpha1
.
.
.
alphan
]
)
term
is
regrettable
and
Ecould
p
A
oten
9tially
cause
ma
jor
p
erformance
problems
.
Section
T6
.
1
sho
9ws
ho
w
these
ma
y
b
A
e
a
v
oided
.
The
complications
in
this
business
seem
endless
.
\
W
:
e
ha
9v
e
just
Tcreated
y
9et
another
problem
.
pConsider
:
Mlet
s
id
y
=
y
in
case
e
of
)
T
[
]
Y
-
>
id
)
T
(
x
:
xs
)
s
-
>
id
This
m
Mcase
expression
returns
a
function
whic
9h
is
p
A
erfectly
legitimate
.
:
But
the
o
9v
erall
con
text
on
it
Malpha
will
b
A
e
a
function
con
9text
Igand
it
is
quite
meaningless
to
scrutinise
suc
9h
a
v
|
ralue
with
MCaseU
or
MCaseUU
.
A
little
though
9t
rev
eals
a
yDsimple
solution
.
H
?
The
Mcase
expression
returns
a
function
whic
9h
^
Cwill
ev
en
tually
:
b
A
e
^
Capplied
to
something
.
jWhat
really
matters
Jis
the
con
9text
on
the
nal
result
of
that
application
:
if
non
-
zero
M
it
means
the
Mcase
expression
will
ev
9en
tually
ha
v
e
to
5b
A
e
en
9tered
in
order
to
generate
a
function
whic
h
in
turn
generates
some
result
to
satisfy
the
demand
.
So
Ball
w
9e
need
do
if
f
Malpha
is
a
function
con
9text
is
test
the
nal
con
9text
14
hp
?
encapsulated
Yin
Malpha
Yrather
than
Malpha
itself
.
Getting
the
nal
x
\
con
9text
out
of
an
Mn
-
arit
y
function
con
text
is
easily
done
b
9y
wrapping
Mn
FncC
V
selectors
round
it
.
B
So
con
text
on
the
switc
9h
Texpression
in
terms
of
Malpha
no
w
lo
A
oks
lik
e
:
MCaseUU
(
FncC
(
FncC
.
.
.
.
.
(
FncC
alpha
)
.
.
.
.
.
)
)
_
(
CMeet
[
alpha1
.
.
.
alphan
]
)
(
CMeet
[
alpha1
.
.
.
alphan
]
)
The
n
9um
b
A
er
of
MFncC
s
is
equal
to
the
arit
y
of
Malpha
lif
Malpha
happ
A
ens
+
to
b
e
a
function
con
9text
.
_
!
Mcase
expressions
return
-
ing
=
functions
seem
to
b
A
e
rarities
h
so
usually
there
will
b
e
zero
MFncC
s
.
The
Zcorresp
A
onding
mo
di
cation
of
the
MCaseU
A
v
9ersion
is
Lob
9vious
and
it
only
remains
to
sa
y
that
c
ho
A
osing
b
et
9w
een
the
.
t
9w
o
no
w
dep
A
ends
on
the
nal
con
text
encapsulated
in
Malpha
T
when
Malpha
is
a
function
con
9text
.
As
lour
long
journey
through
the
forest
of
supp
A
orting
ma
-
c
9hinery
comes
to
a
close
so
the
nal
destination
dra
ws
in
to
sigh
9t
:
the
K
de
nition
of
the
abstract
in
terpreter
prop
A
er
.
W
:
e
pause
Gbut
brie
y
to
tak
9e
respite
in
the
follo
wing
example
then
Tem
9bark
up
A
on
the
nal
straigh
t
:
psection
3
.
6
.
Mcase
vs
of
f
[
]
Y
-
>
0
f
(
x
:
xs
)
s
-
>
x
Clearly
:
k
Mvs
:
:
[
Int
]
and
the
o
9v
erall
t
yp
A
e
is
MInt
.
OSo
a
con
-
text
Malpha
placed
on
the
result
m
9ust
b
A
e
in
domain
MLift
(
)
with
D
the
resulting
con
9text
on
Mvs
in
MLift2
(
Lift
(
)
)
.
Sec
-
tion
3
.
5
.
4
indicates
that
the
M
[
]
case
con
9tributes
con
text
MUpUp2
[
Up1
[
]
]
.
No
9w
Npropagating
Malpha
to
the
M
(
:
)
alter
-
nativ
9e
puts
con
text
Malpha
on
Mx
and
MStop2
(
that
is
'
none
)
on
Mxs
.
Com
9bining
"
these
t
w
o
again
using
section
3
.
5
.
4
sho
9ws
that
Tthe
con
9text
propagated
b
y
this
alternativ
e
is
:
Z
MCJoin
[
Up2
CMeet
[
alpha
Stop2
]
]
=
CJoin
[
Up2
Stop2
]
=
Up2
This
Tgiv
9es
o
v
erall
con
text
on
Mvs
as
:
Z
MCaseU
alpha
Stop2
>
(
CMeet
[
UpUp2
[
Up1
[
]
]
Up2
]
)
=
CaseU
alpha
Stop2
Up2
That
'
s
in
9tuitiv
ely
correct
:
with
no
demand
on
the
resulting
MInt
R
there
'
s
F
no
(
MStop2
)
demand
on
the
incoming
list
.
Oth
-
erwise
w
9e
&
ma
y
ev
|
raluate
the
list
to
WHNF
(
MUp2
)
that
is
to
dthe
rst
constructor
.
uIt
is
a
pit
9y
these
domains
can
'
t
tell
us
w
?
ab
A
out
the
head
-
strictness
here
:
Ggiv
9en
non
-
zero
demand
it
'
s
~
ob
9vious
w
e
can
not
only
ev
|
raluate
to
the
rst
construc
-
tor
but
can
also
ev
|
raluate
the
rst
elemen
9t
of
the
list
if
it
is
non
-
empt
9y
:
.
.
3
.
6
G
De
ning
L
the
abstract
interp
reter
m
Section
J3
.
5
.
4
in
9tro
A
duced
the
con
text
-
nding
function
MC
.
W
:
e
no
9w
augmen
t
this
with
MZ
the
abstract
in
terpreter
itself
.
dP
MC
tak
9es
cJan
y
Core
expression
a
con
text
on
that
expression
and
a
v
|
rariable
and
returns
the
resulting
con
9text
on
the
v
ariable
.
MZ
tak
9es
an
y
Core
expression
pand
returns
the
abstract
v
|
ralue
of
that
expression
.
XSince
the
forw
9ard
and
bac
kw
ard
o
ws
of
information
are
hea
9vily
in
tert
wined
t
MC
and
MZ
are
m
9utually
recursiv
9e
.
pIn
Ta
call
to
MC
or
MZ
C
x
[
e
]
rho
alpha
Z
[
e
]
rho
x
U
is
a
v
|
rariable
Me
is
a
Core
expression
Malpha
is
a
con
9text
and
Mrho
is
an
en
9vironmen
t
binding
all
free
v
|
rariables
in
Me
to
abstract
v
|
ralues
.
1
As
implemen
9ted
Eb
A
oth
functions
carry
an
extra
.
parameter
used
to
help
generate
new
v
|
rariable
names
.
MC
R
also
Tcarries
the
domain
of
Mx
so
it
can
generate
the
appro
-
priate
b
A
ottom
v
|
ralue
when
needed
.
r
Recall
also
that
a
Core
expression
is
a
pair
the
rst
part
of
whic
9h
is
the
t
yp
A
e
of
the
expression
Tand
the
second
the
expression
prop
A
er
.
-
3
.
6
.
1
De
nition
L
of
MZ
m
The
:
abstract
v
|
ralue
of
a
literal
is
a
v
alue
in
the
appropriate
one
-
p
A
oin
9t
Tdomain
.
MZ
(
tau
ALit
n
)
rho
s
=
ANonRec
[
]
V
:
ariables
Tha
9v
e
their
v
|
ralues
lo
A
ok
ed
up
.
MZ
(
tau
AVar
v
)
rho
s
=
rho
v
Applications
are
a
little
more
tric
9ky
:
.
\
YFirst
the
abstract
v
|
ralue
of
the
function
is
created
.
PF
:
rom
that
\
the
abstract
-
v
|
ralue
-
map
0is
extracted
using
MFvalA
and
applied
to
the
ab
-
stract
v
|
ralue
of
the
argumen
9t
to
giv
e
the
abstract
v
|
ralue
of
the
Tresult
.
MZ
(
tau
AAp
f
e
)
rho
f
=
AbsAp
(
FvalA
(
Z
f
rho
)
)
(
Z
e
rho
)
Lam
9b
A
da
yterms
are
a
lot
more
tric
ky
:
.
Let
Ma
and
Mc
denote
new
Tv
|
rariables
.
MZ
(
tau
ALam
[
x
]
e
)
rho
f
=
Fval
(
CtxLam
c
(
C
x
e
rho_c
(
FncC
(
CtxVar
c
)
)
)
)
3
'
(
AbsLam
a
(
Z
e
rho_a
)
)
where
)
Trho_c
=
rho
{
x
-
>
FncA
(
CtxVar
c
)
}
)
Trho_a
=
rho
{
x
-
>
AbsVar
a
}
An
MFval
is
returned
.
!
Its
rst
comp
A
onen
9t
is
a
map
from
the
function
con
9text
Mc
on
M
(
\
x
.
e
)
to
the
con
text
on
parameter
Mx
.
i
>
Bear
in
mind
that
Mc
will
get
b
A
ound
to
a
term
of
the
form
e
M
(
Fnc
aa
cc
)
y
where
Maa
is
the
abstract
v
|
ralue
supplied
for
Mx
and
Mcc
is
the
con
9text
on
Me
.
So
the
con
text
on
Mx
is
found
b
9y
nding
MC
A
of
Mx
in
Me
with
Mrho
augmen
ted
b
y
binding
T
Mx
to
Maa
that
is
to
MFncA
(
CtxVar
c
)
and
Twith
the
con
9text
zon
the
b
A
o
dy
zof
the
function
Me
equal
zto
Mcc
that
is
MFncC
(
CtxVar
c
)
.
The
Jsecond
MFval
comp
A
onen
9t
maps
the
abstract
v
|
ralue
Ma
of
Mx
to
the
abstract
v
|
ralue
of
Me
.
This
is
easily
done
b
9y
computing
MZ
T
of
Me
with
Mrho
mo
A
di
ed
to
bind
Mx
to
MAbsVar
a
.
The
T
MACase
case
is
quite
easy
:
MZ
(
tau
ACase
sw
[
(
cname1
(
pars1
rhs1
)
)
.
.
.
X
0
(
cnamen
(
parsn
rhsn
)
)
]
)
frho
f
=
AMeet
[
Z
rhs1
rho1
.
.
.
Z
rhsn
rhon
]
The
x
augmen
9ted
en
vironmen
ts
Mrhoi
(
1
<
=
i
<
=
n
)
x
are
ob
-
tained
Rb
9y
extending
Mrho
to
pro
vide
bindings
for
Mparsi
in
15
?
view
of
the
v
|
ralue
of
MZ
sw
rho
Susing
the
metho
A
d
of
sec
-
tion
T3
.
5
.
3
.
Finally
:
Pthe
MAConstr
case
.
.
Although
sections
3
.
5
.
1
and
3
.
5
.
2
completely
r
do
A
cumen
9t
abstract
v
|
ralue
and
con
text
o
ws
through
constructors
*
w
9e
as
y
et
ha
v
e
no
w
a
y
of
creating
abstract
b
v
|
ralues
for
constructors
.
fStarting
from
a
general
constructor
Tapplication
\
MC
e1
.
.
.
en
w
9e
Tdesire
to
build
MFval
(
\
c1
-
>
f1
(
FncC
^
n
c1
)
)
(
\
a1
-
>
Fval
(
\
c2
-
>
f2
(
FncC
^
(
n
-
1
)
c2
)
)
(
\
a2
-
>
.
.
.
9TB
.
.
.
9TB
.
.
.
-
>
Fval
(
\
cn
-
>
fn
(
FncC
^
1
cn
)
)
r
J
(
\
an
-
>
aresultant
)
.
.
.
)
)
\
where
-
MFncC
^
i
e
means
MFncC
-
applied
Mi
times
to
Me
.
Observ
9e
that
j
eac
9h
use
of
MFncC
j
here
is
of
the
form
MFncC
^
i
cj
where
Mi
+
j
=
=
n
+
1
Fand
so
all
these
terms
simply
denote
the
con
9text
on
the
result
of
the
constructor
application
.
What
section
P
3
.
5
.
2
pro
9vides
is
a
w
a
y
to
compute
the
Mn
con
text
maps
Mf1
.
.
.
fn
.
-
Section
>
3
.
5
.
1
generates
a
term
of
the
form
M
\
a1
.
.
.
\
an
-
>
aresultant
and
+
b
A
et
9w
een
them
\
that
'
s
all
that
'
s
needed
.
_
As
this
is
rather
confusing
here
'
s
a
couple
of
examples
.
F
:
or
M
(
:
)
:
:
Int
-
>
[
Int
]
-
>
[
Int
]
:
Fval
(
\
c1
-
>
DropUU
1
(
FncC
(
FncC
c1
)
)
)
(
\
a1
-
>
Fval
(
\
c2
-
>
ZapWHNF
(
FncC
c2
)
)
P
0
(
\
a2
-
>
ARec
[
ANonRec
[
]
]
)
)
F
:
or
T
M
(
)
:
:
Int
-
>
Int
-
>
(
Int
Int
)
:
MFval
(
\
c1
-
>
DropU
1
(
FncC
(
FncC
c1
)
)
)
(
\
a1
-
>
Fval
(
\
c2
-
>
DropU
2
(
FncC
c2
)
)
P
0
(
\
a2
-
>
ANonRec
[
ANonRec
[
]
G
&
ANonRec
[
]
]
)
)
3
.
6
.
2
De
nition
L
of
MC
m
Propagation
Tof
a
con
9text
on
to
a
constan
t
has
no
e
ect
:
MC
x
(
tau
ALit
n
)
rho
alpha
f
=
bot
(
domain
-
of
-
x
)
The
Tv
|
rariable
case
is
:
MC
x
(
tau
AVar
v
)
rho
alpha
f
=
if
Xx
=
=
v
then
s
alpha
else
s
bot
(
domain
-
of
-
x
)
As
b
A
efore
9the
application
and
lam
9b
da
cases
are
a
bit
mind
b
A
ending
.
MC
x
(
tau
ALam
[
y
]
e
)
rho
alpha
f
=
C
x
e
rho2
(
FncC
alpha
)
where
!
Trho2
=
rho
{
y
-
>
FncA
alpha
}
Here
9O
Malpha
2
is
a
function
con
9text
b
A
eing
applied
to
M
(
\
y
.
e
)
.
Assuming
that
Mx
and
My
are
not
the
same
v
|
rariable
(
the
lam
9b
A
da
-
lifter
assures
this
)
Icon
text
on
Mx
in
M
(
\
y
.
e
)
can
b
A
e
found
from
the
con
9text
on
Mx
in
Me
.
Since
Malpha
is
a
function
con
9text
MFncA
alpha
k
is
an
abstract
v
|
ralue
whic
h
My
is
b
A
ound
to
Tgenerating
Mrho2
.
FncC
alpha
is
the
con
9text
on
Me
itself
.
O
MC
x
(
tau
AAp
f
e
)
rho
alpha
f
=
CJoin
[
C
x
f
alpha_f
rho
ATBC
x
e
alpha_e
rho
]
where
)
Talpha_f
=
Fnc
(
Z
e
rho
)
alpha
)
Talpha_e
=
CtxAp
(
FvalC
(
Z
f
rho
)
)
alpha_f
T
:
o
deal
with
applications
observ
9e
that
Mx
ma
y
o
A
ccur
in
b
oth
the
function
and
argumen
9t
expressions
so
w
e
need
to
col
-
lect
up
the
con
9texts
from
Mf
and
Me
Uand
\
add
them
together
"
using
MCJoin
.
pThe
only
problem
is
guring
out
what
con
-
text
v
propagates
to
Mf
and
Me
.
~
Recall
that
a
function
con
-
text
consists
of
the
abstract
v
|
ralue
of
the
argumen
9t
and
the
con
9text
x1on
the
result
.
E
Hence
the
con
text
on
Mf
m
ust
b
A
e
MFnc
(
Z
e
rho
)
alpha
.
PThe
d
con
9text
on
Me
is
equal
to
the
con
9text
lythat
Mf
w
ould
propagate
to
its
argumen
t
Band
w
e
kno
9w
that
the
con
text
on
Mf
is
Malpha_f
.
So
C4w
e
build
the
abstract
in
9terpretation
for
Mf
with
MZ
f
rho
extract
the
con
-
text
Umap
using
MFvalC
and
apply
that
to
Malpha_f
.
All
told
that
'
s
T
MCtx
(
FvalC
(
Z
f
rho
)
)
alpha_f
.
Due
Wto
the
heroic
e
orts
of
section
3
.
5
.
4
the
rather
compli
-
cated
T
Mcase
clause
is
stated
quite
succinctly
:
MC
x
(
tau
ACase
sw
[
(
cname1
(
pars1
rhs1
)
)
.
.
.
bg
\
(
cnamen
(
parsn
rhsn
)
)
]
)
rho
alpha
f
=
CJoin
[
C
x
sw
rho
alpha_sw
ATBCMeet
[
C
x
rhs1
rho1
alpha
.
.
.
g
C
x
rhsn
rhon
alpha
]
]
7
]
Here
"
Malpha_sw
is
the
con
9text
on
Msw
giv
en
Malpha
con
text
on
the
Mcase
expression
itself
as
computed
b
9y
the
metho
A
d
of
section
T3
.
5
.
4
.
As
b
A
efore
the
Mrhoi
(
1
<
=
i
<
=
n
)
are
obtained
b
9y
extend
-
ing
Mrho
to
pro
9vide
bindings
for
Mparsi
in
view
of
the
v
|
ralue
of
T
MZ
sw
rho
using
the
metho
A
d
of
section
3
.
5
.
3
.
V
:
ariable
Mx
can
app
A
ear
in
b
oth
the
switc
9h
expression
J
[
and
an
9y
&
of
the
alternativ
es
.
P
T
:
o
deal
with
the
former
con
-
text
on
Msw
is
computed
as
p
A
er
section
3
.
5
.
4
and
this
con
-
text
b0propagated
in
9to
Msw
.
Con
text
for
Mx
in
alterativ
e
Mi
is
MC
x
rhsi
rhoi
alpha
pbut
since
w
9e
can
'
t
sa
y
whic
h
alter
-
ativ
9e
:
will
actually
b
A
e
selected
w
e
m
ust
tak
e
the
greatest
lo
9w
er
'
b
A
ound
o
9v
er
'
all
alternativ
9es
.
Finally
:
the
switc
h
and
alterativ
9e
con
texts
are
once
again
\
added
"
using
MCJoin
.
IAs
with
5
the
MZ
5
clause
for
Mcase
rho
is
extended
to
pro
9vide
bind
-
ings
Tfor
the
v
|
rariables
asso
A
ciated
with
eac
9h
constructor
.
Finally
:
D
the
MAConstr
case
.
All
the
actual
w
9ork
of
dealing
with
con
9text
o
w
through
constructors
is
done
in
the
corre
-
sp
A
onding
?
MZ
?
clause
.
All
w
9e
need
do
here
is
observ
e
that
Mx
is
nev
9er
Tfree
in
an
y
constructor
and
so
return
zero
con
text
:
O
MC
x
(
tau
AConstr
c
)
rho
alpha
f
=
bot
(
domain
-
of
-
x
)
16
?
4
The
L
term
rewriting
system
4
.
1
G
Intro
Ffduction
m
F
:
or
*
eac
9h
Core
function
o
=
the
abstract
in
terpreter
pro
A
duces
an
E
MAbsVal
term
.
Recursiv
9e
groups
of
terms
require
xp
A
oin
t
-
ing
-
jwhic
9h
(
is
done
in
a
straigh
tforw
ard
manner
.
V
>
The
initial
appro
9ximation
v
for
a
function
in
domain
MD
v
is
Matop
(
D
)
so
the
h
xp
A
oin
9ting
pro
duces
the
greatest
xp
oin
9t
.
/
Although
it
migh
9t
seem
a
little
un
usual
to
seek
the
greatest
xed
p
A
oin
t
b
A
ear
in
mind
that
this
approac
9h
represen
ts
starting
o
from
a
)
dangerous
v
|
ralue
Y
Matop
(
D
)
)
and
iterating
one
'
s
w
9a
y
)
to
safet
9y
:
.
In
forw
9ard
analyses
in
the
st
yle
of
[
Sew91
/
]
danger
is
rep
-
resen
9ted
I
:
b
y
the
least
p
A
oin
t
in
the
domains
V3and
xp
A
oin
ting
yields
/
the
least
xed
p
A
oin
9t
.
In
an
y
case
this
discussion
is
rather
W
academic
h
>
since
w
9e
can
claim
to
b
A
e
lo
oking
for
least
xp
A
oin
9ts
Uhere
to
o
simply
b
9y
turning
all
the
domains
upside
-
do
9wn
p
{
as
they
are
nite
complete
lattices
suc
9h
a
tric
k
is
quite
Tallo
9w
able
.
The
)
term
rewriter
exists
b
A
ecause
of
the
need
to
compare
ap
-
pro
9ximations
Xduring
xp
A
oin
ting
.
}
F
:
or
non
-
recursiv
e
terms
there
is
strictly
sp
A
eaking
no
need
to
use
the
rewriter
.
PNev
-
ertheless
b
A
ecause
Rwhat
emerges
from
the
abstract
in
9ter
-
preter
f
is
usually
grossly
redundan
9t
all
terms
are
sub
ject
to
JBrewriting
}
and
the
recursiv
9e
ones
are
subsequen
tly
x
-
p
A
oin
9ted
.
What
the
rewriter
do
A
es
is
to
transform
eac
9h
p
ossible
term
in
9to
}
a
normal
form
suc
h
that
seman
tically
equiv
|
ralen
t
forms
map
9
to
the
same
normal
form
.
EDetection
of
xed
p
A
oin
9ts
is
;
then
a
simple
matter
of
detecting
syn
9tactic
equalit
y
of
the
normal
forms
.
%
F
:
or
higher
order
terms
YLunfortunately
this
x
implies
an
abilit
9y
to
solv
e
the
halting
problem
.
D
W
:
e
therefore
Vdeal
with
higher
order
functions
as
describ
A
ed
in
section
j
5
and
restrict
ourselv
9es
to
generating
unique
normal
forms
)
for
the
abstract
in
9terpretations
of
rst
order
functions
something
Twhic
9h
is
fortunately
:
decidable
.
The
term
rewriter
prop
A
er
is
an
elab
orate
system
whic
9h
gen
-
erates
a
normal
forms
b
9y
applying
man
y
lo
A
cal
transformations
to
v
a
term
.
bWhen
no
more
transformations
can
b
A
e
applied
the
M
term
is
deemed
to
b
A
e
in
normal
form
.
!
Eac
9h
kind
of
al
-
lo
9w
able
j
transformation
is
encapsulated
in
a
so
-
called
rewrite
rule
.
Eac
9h
]
#
rule
m
ust
implemen
t
a
seman
tically
in
v
|
rarian
t
transformation
.
Section
3
.
2
in
9tro
A
duced
a
few
equalities
whic
9h
Twhen
giv
en
a
directionalit
y
:
b
A
ecome
rewrite
rules
:
O
MFncA
(
Fnc
a
c
)
=
=
=
>
a
FncC
(
Fnc
a
c
)
=
=
=
>
c
FvalA
(
Fval
c
a
)
=
=
=
>
a
FvalC
(
Fval
c
a
)
=
=
=
>
c
Most
(
rules
are
complicated
b
9y
the
presence
of
side
-
conditions
:
MFnc
(
FncA
c1
)
(
FncC
c2
)
=
=
=
>
c1
provided
fc1
=
=
c2
These
6yexamples
illustrate
the
problem
of
whether
to
simplify
terms
~
starting
from
the
lea
9v
es
~
(
innermost
-
rst
)
or
from
the
ro
A
ot
M
(
outermost
-
rst
)
.
Since
in
the
second
example
the
rule
F
only
applies
if
subterms
Mc1
and
Mc2
are
pro
9v
|
rably
equal
innermost
-
rst
9rewriting
seems
necessary
:
.
/
But
the
same
strategy
J
applied
to
MFvalC
(
Fval
c
a
)
)
J
could
w
9aste
a
lot
of
e
ort
simplifying
Ma
only
to
thro
9w
it
a
w
a
y
:
7so
outermost
-
rst
Tmigh
9t
giv
e
b
A
etter
p
erformance
.
Pro
9viding
Dthe
rules
are
nitely
con
uen
t
and
terminating
b
A
oth
:
approac
9hes
still
giv
e
the
same
normal
forms
.
Observ
e
ho
9w
ev
er
that
whatev
9er
approac
h
is
used
m
ultiple
passes
o
9v
er
'
the
tree
will
Z
in
general
b
A
e
needed
to
arriv
9e
at
nor
-
mal
form
.
)
The
decision
can
therefore
b
A
e
based
purely
on
whic
9hev
er
sc
heme
giv
es
b
A
etter
p
erformance
.
HExp
erimen
9ta
-
tion
~
"
sho
9w
ed
that
outermost
-
rst
rewriting
w
as
up
to
ten
times
ZDslo
9w
er
than
innermost
-
rst
for
realistically
sized
terms
emitted
?
b
9y
the
abstract
in
terpreter
.
1Although
it
w
ould
b
A
e
fo
A
olish
Boto
claim
that
this
is
alw
9a
ys
Boso
l
the
evidence
suggested
an
b
innermost
-
rst
sc
9heme
w
ould
usually
b
A
e
m
uc
h
quic
k
er
so
an
Tinnermost
-
rst
sc
9heme
-
=
*
Aa
cmr6
1
?
w
as
Tadopted
.
5
4
.
2
G
P
erfo
rming
L
a
single
simpli
cation
pass
m
Because
the
MAbsVal
and
MContext
t
9yp
A
es
are
m
utually
re
-
cursiv
9e
the
term
rewriter
prop
A
er
consists
of
t
w
o
functions
of
Gt
9yp
A
e
MAbsVal
-
>
AbsVal
G
and
MContext
-
>
Context
eac
h
of
q
whic
9h
p
A
erforms
m
ultiple
innermost
-
rst
simpli
cation
passes
N
with
an
auxiliary
function
.
6When
stabilit
9y
is
reac
hed
it
g
means
normal
form
has
b
A
een
ac
9hiev
ed
.
OThis
g
section
dis
-
cusses
Who
9w
those
auxiliary
functions
w
ork
.
nxF
:
or
simplicit
y
:
they
!
are
treated
as
a
single
function
called
Msimp
w
9orking
on
Tthe
union
of
MAbsVal
and
MContext
called
MTerm
.
T
:
o
i
maximise
p
A
erformance
)
eac
9h
pass
of
Msimp
tries
to
do
as
m
9uc
h
as
p
A
ossible
so
as
to
minimise
the
n
9um
b
er
of
passes
required
.
AMeasuremen
9ts
6
sho
w
ed
the
v
|
rast
ma
jorit
y
of
terms
reac
9h
#
normal
form
in
one
pass
and
no
term
has
b
A
een
ob
-
serv
9ed
Tto
require
more
than
three
passes
.
The
L
?
individual
rewrite
rules
are
classi
ed
in
9to
groups
(
rep
-
resen
9ted
as
lists
)
b
y
the
ro
A
ot
sym
b
A
ol
of
the
term
whic
h
they
rewrite
.
The
J
mec
9hanism
whic
h
directs
the
application
of
rewrite
rules
ensures
that
eac
9h
rule
is
only
applied
to
terms
p
A
ossessing
x
the
relev
|
ran
9t
ro
ot
sym
9b
ol
.
F
Eac
h
x
rule
is
imple
-
men
9ted
Tas
a
function
of
t
yp
A
e
MTerm
-
>
Maybe
Term
Twhere
:
O
Mdata
Maybe
a
=
Nothing
|
Just
a
As
b
A
ecomes
clear
shortly
:
"
w
9e
need
to
kno
w
whether
the
ap
-
plication
q
of
a
rewrite
rule
has
had
an
9y
e
ect
.
1VW
:
e
could
mak
9e
6eac
h
rule
ha
v
e
t
yp
A
e
MTerm
-
>
Term
and
compare
the
term
b
A
efore
and
after
application
but
this
seems
ab
om
-
inably
.
ine
cien
9t
t
b
A
ecause
the
rule
itself
\
kno
ws
"
when
it
has
made
a
c
9hange
.
Therefore
cw
e
enco
A
de
that
kno
9wledge
in
Ythe
return
v
|
ralue
b
9y
passing
bac
k
MNothing
if
there
is
no
c
9hange
.
Observ
e
S
^
that
the
returned
MMaybe
Term
v
|
ralue
is
in
-
stan
9tly
disassem
bled
using
a
Hask
ell
case
expression
Sto
nd
out
whether
the
rule
has
succeeded
.
Therefore
>
a
Hask
9ell
implemen
9tation
whic
h
returns
constructors
in
registers
lik
e
Glasgo
9w
Hask
ell
[
PJ92
L
]
:
nev
er
actually
builds
the
MNothing
or
T
MJust
closure
in
the
heap
a
pleasing
little
e
ciency
:
.
Let
9o
Mt
denote
a
term
uand
Mrulesfor
(
t
)
denote
the
list
of
ff
_
r
}
r
Z
cmr5
1
Y
One
5of
the
sharp
7
er
wits
in
the
functional
programming
comm
u
-
nit
y
Z
on
reading
an
early
draft
commen
ted
:
Ho
w
%
could
y
ou
let
suc
h
a
w
onderful
example
of
self
-
reference
A
go
b
y
unremark
ed
?
h
I
A
though
t
it
w
as
absolutely
marv
elous
:
that
y
ou
decided
to
use
an
innermost
-
rst
sc
heme
A
in
the
term
rewriter
whic
h
is
X
after
all
the
whole
p
7
oin
t
of
Anna
'
s
existance
in
the
Real
W
Z
orld
outside
it
-
self
!
17
?
rewrite
rules
relev
|
ran
9t
to
the
ro
A
ot
sym
b
A
ol
of
Mt
.
simp
(
t
)
is
computed
Tas
follo
9ws
:
O
Msimp
(
t
)
f
=
schedule
(
t_inner_simp
)
where
!
Tt_inner_simp
/
=
t
with
simp
applied
to
t
'
s
subterms
schedule
(
t
)
f
=
rewrite_with
(
rulesfor
(
t
)
t
)
rewrite_with
(
[
]
t
)
f
=
t
rewrite_with
(
(
rule
:
rules
)
t
)
f
=
case
(
rule
t
)
of
!
TNothing
-
>
rewrite_with
(
rules
t
)
!
TJust
t2
-
>
schedule
(
t2
)
Firstly
:
6
Mt
'
s
asubterms
are
simpli
ed
giving
Mt_inner_simp
.
This
"
is
passed
to
in
9termediary
Mschedule
f
[
whic
h
examines
the
ro
A
ot
sym
9b
ol
to
determine
the
relev
|
ran
9t
list
of
rewrite
rules
.
)
O
Mschedule
I
passes
the
rules
and
its
argumen
9t
to
Mrewrite_with
whic
9h
z
w
orks
its
w
a
y
through
the
list
of
rules
.
If
2
it
runs
out
of
rules
it
simply
returns
the
term
.
But
if
there
is
a
rule
it
is
applied
to
the
term
.
4This
either
has
no
e
ect
in
whic
9h
case
the
next
rule
is
tried
/
or
it
pro
A
duces
a
new
term
'
e
Mt2
.
R
No
9w
Mt2
ma
y
w
ell
ha
v
e
a
di
eren
t
ro
A
ot
sym
b
A
ol
whic
9h
w
ould
in
v
|
ralidate
all
the
remaining
rules
.
So
rewriting
of
T
Mt2
is
con
9tin
ued
Tb
y
passing
it
bac
k
to
Mschedule
.
The
mnet
e
ect
of
Mschedule
(
t
)
is
th
9us
to
k
eep
applying
rewrite
rules
to
the
ro
A
ot
of
Mt
un
9til
no
applicable
rules
can
b
A
e
5
found
.
}
ZThis
pro
cess
deals
prop
erly
with
c
9hanges
in
the
ro
A
ot
sym
9b
ol
.
Observ
e
that
the
call
to
Mschedule
from
Mrewrite_with
HS
is
not
necessary
for
correctness
.
mW
:
e
could
simply
+
return
Mt2
at
this
p
A
oin
9t
.
What
this
w
ould
mean
is
that
an
9y
8
p
A
ossible
rewrites
of
Mt2
w
ould
b
A
e
dela
y
ed
un
til
the
next
simpli
cation
7
pass
d
rather
than
b
A
eing
done
straigh
9t
a
w
a
y
:
.
So
omitting
~
the
re
-
sc
9hedule
implies
more
simpli
cation
passes
and
Ta
serious
loss
of
e
ciency
:
.
5
4
.
3
G
Dealing
L
with
lamb
Ffdas
and
applications
m
The
presence
of
MAbsLam
^
MAbsAp
and
MAbsVar
terms
in
9tro
-
duces
?
the
need
to
p
A
erform
lam
9b
da
calculus
-
lik
9e
substi
-
tution
.
*
What
follo
9ws
applies
equally
to
the
dual
con
-
structions
MCtxLam
MCtxAp
and
MCtxVar
.
sIn
particular
Msimp
|
U
needs
to
b
A
e
able
to
deal
with
terms
of
the
form
M
(
AbsAp
(
AbsLam
v
e
)
a
)
.
p
Naturally
:
w
9e
can
reac
h
di
-
rectly
B
for
the
blunderbuss
solution
:
w
devise
a
function
Msubst
(
e
v
a
)
X
to
replace
free
o
A
ccurrences
of
Mv
in
Me
with
Ma
and
Templo
9y
it
in
the
rewrite
rule
:
MAbsAp
(
AbsLam
v
e
)
a
=
=
=
>
subst
(
e
v
a
)
Tw
9o
A
defects
are
apparen
t
.
Firstly
:
L
since
Msimp
is
committed
to
8
doing
innermost
-
rst
simpli
cation
d
b
A
oth
function
and
ar
-
gumen
9t
B
are
simpli
ed
extensiv
ely
b
A
efore
substitution
b
egins
.
Our
hands
are
no
9w
tied
:
w
e
cannot
mak
e
the
lam
b
A
da
/
apply
term
ereduction
an
9y
lazier
.
Ine
ciency
is
the
second
com
-
plain
9t
.
0
This
q
]
sc
heme
demands
a
complete
substitution
pass
o
9v
er
T
Me
for
ev
9ery
argumen
t
.
An
R
altogether
nicer
solution
is
to
forget
ab
A
out
Msubst
and
the
rewrite
drule
.
Instead
w
9e
equip
Msimp
with
an
en
vironmen
t
Menv
?
o
whic
9h
binds
MAbs
-
v
|
rariables
to
v
alues
.
No
9w
giv
e
?
o
Msimp
a
couple
of
sp
A
ecial
cases
.
These
omit
the
usual
simpli
ca
-
tion
of
subterms
Oand
b
9ypass
the
general
rewriting
mec
ha
-
nism
.
6In
Athis
w
9a
y
Aw
e
regain
precise
con
trol
o
v
er
the
order
of
rewrites
and
no
separate
substitution
passes
are
needed
.
V
:
ariables
Tare
simply
lo
A
ok
9ed
up
:
O
Msimp
env
(
AbsVar
v
)
=
env
v
On
encoun
9tering
M
(
AbsAp
f
a
)
w
e
need
to
try
and
turn
Mf
in
9to
an
M
(
AbsLam
v
e
)
.
>
The
ob
vious
w
a
y
to
do
this
is
b
y
applying
Msimp
to
Mf
Sbut
this
w
9ould
b
A
e
a
big
w
aste
of
time
if
Mf
is
in
that
form
already
:
.
So
there
is
a
sp
A
ecial
c
9hec
k
for
this
case
.
The
men
9vironmen
t
is
then
augmen
ted
with
a
binding
for
Mv
Rand
simpli
cation
con
9tin
ues
with
Me
.
By
c
9ho
A
osing
to
bind
Mv
to
Ma
or
Msimp
env
a
w
9e
can
again
v
|
rary
the
strictness
of
y
;
the
sc
9heme
.
H
The
latter
c
hoice
giv
es
b
A
etter
p
erformance
so
Tthe
sp
A
ecial
case
for
M
(
AbsAp
f
a
)
T
is
:
O
Msimp
env
(
AbsAp
f
a
)
f
=
let
sa
=
simp
env
a
.
m
sf
=
simp
env
f
in
case
f
of
)
TAbsLam
v
e
7
-
>
simp
env
{
v
:
-
>
sa
}
e
)
Tother
7
-
>
case
sf
of
T
:
AbsLam
v2
e2
bg
\
-
>
simp
env
{
v2
:
-
>
sa
}
e2
T
:
other
bg
\
-
>
AbsAp
sf
sa
If
Mf
simply
refuses
to
b
A
e
rewritten
in
9to
an
MAbsLam
the
term
has
its
subterms
simpli
ed
and
is
then
returned
as
-
is
.
cJThis
is
Dzconsisten
9t
with
ho
w
normal
cases
are
dealt
with
Csince
there
Tare
no
more
MAbsAp
rewrite
rules
.
An
-
MAbsVar
construct
can
refer
not
just
to
v
|
rariables
b
A
ound
b
9y
=
a
surrounding
MAbsLam
but
also
to
the
abstract
v
|
ralues
of
6
/
other
functions
.
T
:
o
deal
with
these
~
fw
9e
\
preload
"
the
MAbs
-
en
9vironmen
t
Fwith
suitable
bindings
b
A
efore
starting
sim
-
pli
cation
.
}
Finally
:
note
*
that
the
dual
MCtx
-
constructions
are
dealt
with
in
the
same
w
9a
y
:
6
so
Msimp
carries
t
9w
o
en
vi
-
ronmen
9ts
H
rather
>
than
just
one
.
The
only
di
erence
is
that
a
MCtxVar
can
only
refer
to
MCtxLam
b
A
ound
v
|
rariables
.
nThese
t
9w
o
r
en
vironmen
ts
are
henceforth
referred
to
as
Maenv
and
Mcenv
T
resp
A
ectiv
9ely
:
.
5
4
.
4
G
Avoiding
L
in
nite
b
ranching
m
4
.
4
.
1
A
L
naive
app
roach
Section
323
.
4
in
9tro
A
duced
the
MCaseU
3
*
and
MCaseUU
constructions
as
yone
of
the
fundamen
9tal
mec
hanisms
for
disassem
bling
con
9texts
.
u
A
serious
8problem
whic
h
b
A
ecomes
apparen
t
as
so
A
on
U
as
one
starts
xp
oin
9ting
is
the
p
oten
9tial
for
in
nite
branc
9hing
.
pFixp
A
oin
ting
Tpro
duces
expressions
lik
9e
MCaseU
e
(
CaseU
e
w
x
)
(
CaseU
e
y
z
)
whic
9h
Tis
equiv
|
ralen
t
to
:
18
?
MCaseU
e
w
z
O
W
:
e
can
get
round
this
b
9y
designing
the
normal
form
so
that
for
a
term
M
(
CaseU
e
a
b
)
neither
subterm
Ma
nor
Mb
ma
9y
do
a
f
MCaseU
f
on
Me
.
T
:
o
ac
9hiev
e
f
this
normalisation
requires
using
partial
fkno
9wledge
ab
A
out
the
v
|
ralue
of
Me
when
simplifying
Ma
and
T
Mb
.
T
:
o
implemen
9t
this
w
e
could
adopt
the
follo
wing
sc
heme
.
Giv
9e
^
#
Msimp
y
et
another
en
vironmen
t
V
Mselenv
whic
h
^
#
maps
switc
9h
expressions
seen
in
surrounding
MCaseU
and
MCaseUUs
to
N
"
partial
information
ab
A
out
their
v
|
ralue
.
When
a
nested
MCase
s
expression
is
encoun
9tered
3lo
A
ok
up
its
switc
h
v
|
ralue
in
Mselenv
.
If
there
is
a
corresp
A
onding
en
9try
:
1
this
MCase
expres
-
sion
m
9ust
b
A
e
examining
a
con
text
whic
h
has
already
b
A
een
lo
A
ok
9ed
at
vso
the
MCase
expression
is
replaced
b
y
whic
hev
er
arm
;
the
table
en
9try
sa
ys
is
correct
.
F
:
or
example
4giv
en
a
call
Msimp
selenv
(
CaseU
e
(
CaseU
e
w
x
)
(
CaseU
e
y
z
)
)
simpli
cation
of
M
(
CaseU
e
w
x
)
is
done
with
Mselenv
binding
Me
/
to
MStop1
]
zand
simpli
cation
of
M
(
CaseU
e
y
z
)
/
is
done
with
Mselenv
L
binding
Me
to
some
v
|
ralue
of
the
form
MUp1
[
.
.
.
]
.
This
partial
_
information
ab
A
out
Me
immediately
allo
9ws
the
system
to
(
reduce
the
t
9w
o
(
subterms
to
Mw
and
Mz
resp
A
ectiv
9ely
:
.
q
Prop
-
agation
of
information
ab
A
out
MCaseUU
selector
v
|
ralues
is
done
analogously
:
.
Mselenv
(
c
is
augmen
9ted
eac
h
time
a
MCaseU
(
^
or
MCaseUU
is
\
gone
past
"
.
?
A
problem
is
what
happ
A
ens
when
w
9e
go
past
a
M
(
CtxLam
v
e
)
J
since
this
w
9ould
in
v
|
ralidate
an
y
k
eys
in
Mselenv
9
con
9taining
free
v
|
rariable
Mv
.
"
Remem
b
A
er
that
the
k
eys
are
arbitrary
expressions
5
rather
than
mere
v
|
rariables
.
An
exp
A
ensiv
9e
Wsolution
is
to
lter
out
all
(
k
ey
:
v
|
ralue
)
pairs
whic
h
refer
to
Mv
nbut
that
'
s
o
9v
erkill
.
~
HIt
is
c
9heap
A
er
to
completely
empt
9y
{
Mselenv
at
ev
ery
MCtxLam
.
O
This
do
A
esn
'
t
lose
informa
-
tion
kb
A
ecause
the
abstract
in
9terpreter
nev
er
builds
con
text
expressions
ewhere
w
9e
need
to
main
tain
selector
information
across
MCtxLam
b
A
oundaries
.
F
:
or
example
Sit
nev
9er
builds
an
y
-
thing
Tlik
9e
:
MCaseU
s1
(
\
c1
-
>
.
.
.
(
CaseU
s2
.
.
.
.
)
)
&
m
(
\
c2
-
>
.
.
.
(
CaseU
s2
.
.
.
.
)
)
5
4
.
4
.
2
Generalising
L
the
scheme
m
A
little
though
9t
sho
ws
our
solution
whilst
p
A
erfectly
w
ork
-
able
Dis
to
A
o
w
9eak
.
iW
:
e
need
a
more
general
w
a
y
to
propagate
so
-
called
\
Mselenv
information
"
around
!
as
can
b
A
e
seen
b
9y
considering
:
MCMeet
[
e
UpUp2
[
Stop1
Stop1
]
]
Initially
:
it
Ulo
A
oks
lik
9e
nothing
more
can
b
e
done
with
this
.
But
if
a
b
9y
lo
A
oking
in
Mselenv
w
9e
can
sho
w
that
Me
has
an
MUpUp2
[
.
.
.
]
T
v
|
ralue
then
:
Z
MCMeet
[
e
UpUp2
[
Stop1
Stop1
]
]
=
UpUp2
[
Stop1
Stop1
]
What
}
tw
9e
really
need
is
a
general
mec
hanism
for
propagat
-
ing
T
Mselenv
information
.
VqT
:
o
b
A
e
fully
general
w
9e
will
ha
v
e
to
W
searc
9h
Mselenv
for
eac
h
term
Msimp
encoun
ters
.
This
pro
-
cess
can
b
A
e
rolled
in
9to
the
general
mec
hanism
of
Msimp
b
y
searc
9hing
Mselenv
after
Msimp
runs
out
of
applicable
rewrite
rules
.
5
W
:
e
exp
A
ect
to
disco
9v
er
nothing
ab
out
the
v
|
rast
ma
-
jorit
9y
X
of
terms
i
in
whic
h
case
Msimp
acts
as
b
A
efore
.
But
i
for
a
luc
9ky
few
?
Mselenv
tells
us
a
little
ab
A
out
the
term
:
it
is
either
>
j
MStop1
MStop2
MUp2
MUp1
[
.
.
.
]
or
MUpUp2
[
.
.
.
]
.
In
the
rst
three
cases
w
9e
can
ob
viously
replace
the
term
with
the
relev
|
ran
9t
v
alue
but
the
other
t
9w
o
are
problematic
.
'
Ho
9w
can
y
w
9e
exploit
partial
information
lik
e
this
?
G
Conceptually
:
w
9e
%
need
to
add
a
fo
A
otnote
to
the
v
|
ralue
sa
ying
for
example
\
P
:
.
S
.
)
This
v
|
ralue
is
kno
9wn
to
b
A
e
MUpUp2
[
.
.
.
]
"
.
and
mo
dify
the
Trewrite
rules
to
tak
9e
accoun
t
of
suc
h
fo
A
otnotes
.
This
LHall
sounds
rather
clumsy
:
Z
but
there
is
a
neat
solution
.
Recall
qsection
3
.
4
in
9tro
A
duced
MDefU
1
and
MDefUU
.
MDef
s
stand
for
g
\
de
nitely
"
and
are
in
9tended
as
a
w
a
y
of
attac
hing
suc
h
a
T
fo
A
otnote
to
a
v
|
ralue
.
-
The
in
9tuitiv
e
T
reading
of
M
(
DefU
e
)
is
\
I
'
m
not
sure
what
the
exact
v
|
ralue
of
Me
is
but
I
do
kno
9w
it
'
s
an
z
MUp1
[
.
.
.
]
v
|
ralue
"
.
MISo
no
9w
Yon
disco
v
ering
from
Mselenv
that
x
a
term
Mc
has
an
MUp1
[
.
.
.
]
or
MUpUp2
[
.
.
.
]
v
|
ralue
w
9e
merely
need
to
wrap
Mc
in
MDefU
~
or
MDefUU
resp
A
ectiv
9ely
:
.
All
that
/
remains
to
do
is
mo
A
dify
rewrite
rules
to
tak
9e
accoun
t
of
MDefU
BH
and
BT
MDefUU
as
appropriate
.
pThis
mec
9hanism
subsumes
the
Tprevious
one
.
pConsider
again
:
Msimp
selenv
(
CaseU
e
(
CaseU
e
w
x
)
(
CaseU
e
y
z
)
)
Ignoring
p
A
ossible
c
9hanges
to
Mw
Mx
My
and
Mz
Msimp
tranforms
this
Tto
:
MCaseU
e
(
CaseU
Stop1
w
x
)
(
CaseU
(
DefU
e
)
y
z
)
Application
Tof
the
rewrite
rules
MCaseU
Stop1
Xa
b
=
=
=
>
a
CaseU
(
DefU
e
)
a
b
=
=
=
>
b
yields
Tthe
desired
result
:
MCaseU
e
w
z
Recall
&
the
other
example
j
in
whic
9h
Mselenv
binds
Me
to
an
MUpUp2
[
.
.
.
]
T
v
|
ralue
:
MCMeet
[
e
UpUp2
[
Stop1
Stop1
]
]
After
}
wrapping
MDefUU
M
around
Me
the
follo
9wing
sequence
of
rewrites
Tis
p
A
ossible
:
Z
MCMeet
[
DefUU
e
UpUp2
[
Stop1
Stop1
]
]
=
UpUp2
[
CMeet
[
SelUU
1
e
Stop1
]
3
'
CMeet
[
SelUU
2
e
Stop1
]
]
=
UpUp2
[
Stop1
Stop1
]
Again
the
/
desired
result
is
obtained
.
5
All
w
9e
had
to
do
is
include
Ta
rewrite
rule
deriv
9ed
from
this
:
MCMeet
[
UpUp2
[
x1
x2
]
s
UpUp2
[
y1
y2
]
]
f
=
=
=
>
UpUp2
[
CMeet
[
x1
y1
]
X
0CMeet
[
x2
y2
]
]
By
\
mo
A
difying
the
rule
so
that
one
of
the
initial
terms
is
M
(
DefUU
e
)
Hand
b
A
earing
in
mind
the
meanings
of
MDefUU
and
MSelUU
T
(
see
section
3
.
4
)
one
can
easily
sho
9w
that
:
19
s
?
MCMeet
[
DefUU
e
s
UpUp2
[
y1
y2
]
]
f
=
=
=
>
UpUp2
[
CMeet
[
SelUU
1
e
y1
]
P
0CMeet
[
SelUU
2
e
y2
]
]
O
All
in
all
a
rather
elegan
9t
solution
to
a
tric
ky
problem
.
There
Tis
just
one
nal
ca
9v
eat
.
pConsider
:
Msimp
selenv
(
CaseU
e
a
b
)
If
Fw
9e
cannot
nd
a
v
|
ralue
for
Me
in
Mselenv
the
MCaseU
?
expres
-
sion
ma
9y
still
b
A
e
remo
v
|
rable
b
y
the
follo
wing
means
.
E
:
Find
in
Mselenv
a
k
9ey
Mk
for
whic
h
w
e
can
pro
v
e
that
Mk
Pv
zg
Me
3
and
(
for
whic
9h
Mk
is
b
A
ound
to
some
MUp1
[
.
.
.
]
v
|
ralue
.
So
Me
m
9ust
&
also
bind
to
some
MUp1
[
.
.
.
]
v
|
ralue
*
Cso
w
e
can
replace
M
(
CaseU
e
a
b
)
b
9y
M
(
CaseU
(
DefU
e
)
a
b
)
.
'
MCaseUU
s
are
as
ev
9er
W
analogous
.
So
Jgw
e
migh
t
b
A
e
able
to
do
just
a
little
bit
b
A
etter
m
9y
taking
monotonicit
y
of
k
eys
in
to
accoun
t
when
searc
9hing
T
Mselenv
.
5
4
.
5
G
Avoiding
L
an
exp
Ffonential
explosion
m
Although
4
w
9e
ha
v
e
a
v
oided
non
-
termination
via
in
nite
branc
9hing
another
insidious
problem
lurks
:
.
terms
whic
h
expand
exp
A
onen
9tially
for
a
while
"
b
efore
shrinking
bac
9k
to
a
#
compact
normal
form
.
Suc
9h
b
A
eha
viour
causes
the
term
rewriter
lto
run
out
of
memory
simplifying
seemingly
in
-
signi
can
9t
expressions
.
yThe
problem
manifests
itself
once
again
n
with
\
MCaseU
\
and
MCaseUU
terms
.
The
normal
form
re
-
quires
that
the
switc
9h
expression
cannot
itself
b
A
e
a
MCaseU
or
MCaseUU
Tgiving
rise
to
some
rules
of
the
form
:
MCaseUU
(
CaseUU
a
b
c
d
)
e
f
g
=
=
=
>
CaseUU
a
(
CaseUU
b
e
f
g
)
&
m
(
CaseUU
c
e
f
g
)
&
m
(
CaseUU
d
e
f
g
)
The
zproblem
o
A
ccurs
b
ecause
of
the
w
9a
y
z
Mrewrite_with
at
-
tempts
5to
apply
rewrite
rules
to
the
ro
A
ot
term
un
9til
no
more
can
b
A
e
found
.
If
Ma
is
itself
a
MCaseUU
term
Dh
Mrewrite_with
will
immediately
reapply
the
rule
Mtrebling
the
expres
-
sion
size
again
.
1rIt
w
9ould
b
A
e
b
etter
to
lo
ok
to
see
if
w
9e
can
do
some
simpli
cations
on
the
M
(
CaseUU
b
e
f
g
)
M
(
CaseUU
c
e
f
g
)
k
and
M
(
CaseUU
d
e
f
g
)
k
terms
Rb
efor
e
k
se
-
lecting
F
another
rewrite
rule
for
the
ro
A
ot
term
.
There
'
s
a
v
9ery
yZgo
A
o
d
c
9hance
w
e
can
b
A
ecause
it
is
lik
ely
that
w
e
already
kno
9w
enough
ab
A
out
Mb
Mc
and
Md
to
eliminate
their
asso
ciated
MCaseUU
s
.
i
It
/
"
ma
9y
also
turn
out
that
Ma
is
the
same
as
Mb
5
Mc
or
Md
Tand
this
is
helpful
to
A
o
.
Implemen
9ting
o
this
is
not
only
easy
:
jbut
essen
tial
.
+
When
Mrewrite_with
I
detects
that
a
rewrite
rule
has
created
a
MCaseUU
3
term
it
4
do
A
es
not
immediately
seek
out
another
rewrite
arule
for
the
ro
A
ot
term
.
}
Instead
it
tries
to
rewrite
the
subterms
as
m
9uc
h
as
p
A
ossible
and
only
then
lo
oks
again
at
3
<
the
ro
A
ot
term
.
v
'
This
minor
mo
di
cation
pro
9v
es
3
<
v
ery
suc
-
cessful
Tat
a
9v
oiding
Texp
A
onen
tial
explosions
.
5
4
.
6
G
T
yp
Ffe
-
sp
eci
c
L
MAbsVal
optimisation
m
The
abstract
v
|
ralues
(
MAbsVals
)
of
all
non
-
function
-
space
ob
-
jects
are
p
A
oin
9ts
in
a
one
p
oin
9t
domain
.
(
Therefore
for
an
y
MAbsVal
X
at
all
if
w
9e
can
determine
that
the
ob
ject
'
s
domain
is
+
non
-
functional
w
9e
can
man
ufacture
an
equiv
|
ralen
t
v
|
ralue
from
)
MARec
and
MANonRec
.
X3This
is
extremely
useful
.
The
def
-
inition
/
cof
MAbsVal
5
presen
9ted
in
section
3
.
3
is
augmen
9ted
so
w
9e
.
can
iden
tify
the
domain
for
an
y
term
.
This
is
done
b
y
tagging
^
eac
9h
MAbsVal
with
a
con
text
domain
v
|
ralue
Jexcept
for
the
T
MARec
and
MANonRec
cases
where
the
domain
is
ob
9vious
.
The
Msimp
action
for
MAbsVal
s
no
9w
b
A
egins
b
y
extracting
the
con
9text
domain
and
building
a
literal
replacemen
t
if
appro
-
priate
.
pLet
T
Mdomainof
(
a
)
b
A
e
the
domain
of
Ma
.
7
Msimp
a
f
=
let
a_ctx_domain
=
domainof
(
a
)
in
if
Xunitary_ctx_domain
(
a_ctx_domain
)
then
s
unit_value
(
a_ctx_domain
)
else
s
(
.
.
.
do
as
before
.
.
.
)
unitary_ctx_domain
(
Lift
s
(
D1
x
.
.
.
x
Dn
)
)
f
=
unitary_ctx_domain
(
D1
)
&
&
.
.
.
&
&
unitary_ctx_domain
(
Dn
)
unitary_ctx_domain
(
Lift2
(
D1
x
.
.
.
x
Dn
)
)
f
=
unitary_ctx_domain
(
D1
)
&
&
.
.
.
&
&
unitary_ctx_domain
(
Dn
)
unitary_ctx_domain
(
Ds
-
>
Dt
)
f
=
False
unit_value
(
Lift
s
(
D1
x
.
.
.
x
Dn
)
)
f
=
ANonRec
[
unit_value
(
D1
)
.
.
.
unit_value
(
Dn
)
]
unit_value
(
Lift2
(
D1
x
.
.
.
x
Dn
)
)
f
=
ARec
X
[
unit_value
(
D1
)
.
.
.
unit_value
(
Dn
)
]
This
T
w
9orks
ne
gbut
as
T
usual
w
e
T
can
do
a
little
b
A
etter
.
Presen
9ted
&
with
a
term
already
comp
A
osed
en
tirely
of
MARec
and
MANonRec
s
qthe
sc
9heme
returns
a
cop
y
of
the
term
qgiving
a
k
p
A
oten
9tial
loss
of
sharing
.
A
j
small
mo
di
cation
detects
suc
9h
Tterms
and
returns
them
as
-
is
.
4
.
7
G
Imp
roving
L
the
rep
resentation
of
contexts
:
fh
MApplyET
m
F
:
or
;
tman
9y
trivial
-
lo
A
oking
functions
D
the
abstract
in
terpreter
emits
w
a
remark
|
rably
cum
9b
A
ersome
and
unin
tuitiv
e
-
lo
A
oking
term
.
Examination
YJof
terms
from
rst
order
functions
sho
9ws
a
sw
9a
y
to
cut
do
wn
their
sizes
.
zSince
all
abstract
v
|
ralues
p
A
er
-
taining
to
the
argumen
9ts
and
result
of
a
rst
order
function
are
H
unitary
:
T
the
only
thing
one
can
ask
ab
A
out
it
is
ho
9w
the
con
9text
on
the
result
propagates
to
eac
h
argumen
t
.
Supp
A
os
-
ing
w
9e
ha
v
e
Mf
a
rst
order
function
of
O5
"
cmmi9
Om
argumen
ts
and
w
e
w
9an
t
^
to
kno
9w
what
con
text
propagates
to
the
On
'
th
argumen
t
if
a
the
result
is
demanded
in
con
9text
Malpha
.
A
t
presen
t
t
w
e
get
Ta
large
term
of
the
form
:
MCtxAp
s
(
FvalC
(
AbsAp
(
GetA
.
.
.
(
AbsAp
(
FvalA
f
)
-
~
a1
)
zv
.
.
.
k
ai
)
)
)
(
Fnc
aj
.
.
.
(
Fnc
am
alpha
)
.
.
.
)
where
Mi
(
=
d
On
b
P
1
and
Mj
=
d
On
b
+
1
.
What
this
do
A
es
it
to
use
the
M
(
AbsAp
(
GetA
.
.
.
)
)
construction
On
6
P
1
times
to
supply
the
w
rst
On
O
P
1
wabstract
v
|
ralue
argumen
9ts
whic
h
wexp
A
oses
the
20
?
i
efg
ff
)
4
0
2
ff
33
MFsqDiff
=
(
Fval
(
\
c1
-
>
(
CJOIN
^
U
(
ApplyET
#
0
F
+
(
ApplyET
#
1
F
*
(
FncC
(
FncC
c1
)
)
)
)
^
U
(
ApplyET
#
0
F
-
(
ApplyET
#
0
F
*
(
FncC
(
FncC
c1
)
)
)
)
)
)
/
y
(
\
a1
-
>
(
Fval
(
\
c2
-
>
(
CJOIN
(
ApplyET
#
1
F
+
(
ApplyET
#
1
F
*
(
FncC
c2
)
)
)
(
ApplyET
#
1
F
-
(
ApplyET
#
0
F
*
(
FncC
c2
)
)
)
)
)
q
(
\
a2
-
>
(
ANonRec
[
]
)
)
)
)
)
33FsqDiff
=
(
Fval
(
\
c1
-
>
(
CJOIN
^
U
{
(
FvalC
F
+
)
c
(
Fnc
(
ANonRec
[
]
)
(
Fnc
(
ANonRec
[
]
)
{
(
FvalC
{
*
(
FvalA
F
*
)
(
ANonRec
[
]
)
*
}
)
(
Fnc
(
ANonRec
[
]
)
(
FncC
(
FncC
c1
)
)
)
}
)
)
}
^
U
{
(
FvalC
F
-
)
c
(
Fnc
(
ANonRec
[
]
)
(
Fnc
(
ANonRec
[
]
)
{
(
FvalC
F
*
)
(
Fnc
(
ANonRec
[
]
)
(
Fnc
(
ANonRec
[
]
)
2
(
FncC
(
FncC
c1
)
)
)
)
}
)
)
}
)
)
/
y
(
\
a1
-
>
(
Fval
(
\
c2
-
>
(
CJOIN
{
(
FvalC
{
*
(
FvalA
F
+
)
(
ANonRec
[
]
)
*
}
)
(
Fnc
(
ANonRec
[
]
)
{
(
FvalC
{
*
(
FvalA
F
*
)
(
ANonRec
[
]
)
*
}
)
A
(
Fnc
(
ANonRec
[
]
)
(
FncC
c2
)
)
}
)
}
{
(
FvalC
{
*
(
FvalA
F
-
)
(
ANonRec
[
]
)
*
}
)
(
Fnc
(
ANonRec
[
]
)
{
(
FvalC
F
*
)
A
(
Fnc
(
ANonRec
[
]
)
(
Fnc
(
ANonRec
[
]
)
(
FncC
c2
)
)
)
}
)
}
)
)
q
(
\
a2
-
>
(
ANonRec
[
]
)
)
)
)
)
^
r
Figure
T1
:
pAbstract
in
9terpretation
of
MsqDiff
with
and
without
using
MApplyET
ff
0
2
ff
*
ff
X
On
'
th
con
9text
map
.
xThis
is
then
applied
to
Malpha
wrapp
A
ed
up
N
in
a
c
9hain
of
M
(
Fnc
.
.
.
)
constructions
whic
h
supply
the
remaining
T
Om
8
P
On
P
1
abstract
v
|
ralue
argumen
9ts
.
This
^
seems
an
enormously
w
9asteful
w
a
y
to
sa
y
what
amoun
ts
to
:
MApplyET
n
f
alpha
That
#
#
is
S
\
extract
the
On
'
th
con
9text
map
from
Mf
and
apply
it
to
the
M
con
9text
Malpha
"
.
W
:
ell
[
almost
.
In
M
fact
Mf
'
s
On
'
th
con
9text
map
Hexp
A
ects
to
b
e
applied
not
directly
to
Malpha
but
to
the
term
M
(
Fnc
aj
.
.
.
(
Fnc
am
alpha
)
.
.
.
)
.
+
It
lo
A
oks
at
rst
lik
9e
~
w
e
need
to
include
the
abstract
v
|
ralues
Maj
to
Mam
in
the
MApplyET
=
term
.
'
F
:
ortunately
that
=
is
a
9v
oidable
:
m
since
=
they
are
9vall
unitary
:
~
w
9e
should
nev
er
need
to
kno
w
what
they
are
.
Instead
w
9e
<
simply
record
in
the
MApplyET
<
term
ho
w
man
9y
8Iof
these
\
trailing
"
argumen
ts
there
are
.
OWhen
the
term
%
rewriter
nally
gets
hold
of
Mf
'
s
On
'
th
con
9text
map
Zit
uses
Tthis
n
9um
b
A
er
Tto
build
a
suitable
\
dumm
9y
term
"
M
(
Fnc
Error
.
.
.
(
Fnc
Error
alpha
)
.
.
.
)
to
~
whic
9h
it
applies
the
relev
|
ran
t
con
text
map
.
YhIn
e
ect
fw
e
a
9v
oided
9
storing
those
trailing
argumen
9ts
and
fak
ed
them
instead
F
using
<
^
MError
terms
b
A
ecause
w
9e
can
guaran
tee
they
will
nev
9er
b
A
e
used
.
JF
:
rom
this
it
follo
ws
that
it
is
an
error
for
T
MError
to
app
A
ear
in
the
normal
form
of
an
9y
term
.
Use
of
MApplyET
w
shrinks
man
9y
terms
dramatically
:
%
and
en
-
hances
the
time
and
space
p
A
erformance
of
the
analyser
.
>
As
an
Texample
Figure
1
sho
9ws
the
abstract
in
terpretation
of
MsqDiff
x
y
=
(
x
+
y
)
*
(
x
-
y
)
with
L
and
without
using
MApplyET
.
Of
course
Z
when
the
de
-
nitions
of
M
(
+
)
v
M
(
-
)
and
M
(
*
)
are
substituted
in
b
A
oth
terms
reduce
'
Zto
the
same
thing
.
R
Note
that
M
(
CtxAp
e1
e2
)
'
Z
and
M
(
AbsAp
e1
e2
)
o
are
written
as
Pf
Me1
e2
Pg
and
Pf
M
*
e1
e2
*
Pg
re
-
sp
A
ectiv
9ely
:
.
5
4
.
8
G
No
rmal
L
fo
rms
and
termination
p
rop
Fferties
m
Sho
9wing
that
the
term
rewriting
system
alw
a
ys
terminates
and
\
pro
A
duces
normal
forms
^
is
imp
ortan
9t
.
F
:
or
a
system
with
as
B
man
9y
rewrite
rules
and
complications
as
this
N
pro
A
ducing
a
correctness
argumen
9t
is
a
formidable
task
.
rW
:
e
hop
A
e
to
include
one
in
a
later
v
9ersion
of
this
pap
A
er
.
fAlso
to
b
e
included
E
will
b
A
e
a
listing
of
the
rewrite
rules
along
with
their
D
asso
A
ciated
pro
ofs
of
correctness
.
There
are
at
presen
9t
in
Tthe
region
of
sixt
9y
rewrite
rules
.
-
5
Firsti
cation
L
and
monomo
rphisation
5
.
1
G
Intro
Ffduction
Although
rst
order
functions
are
easily
handled
b
9y
term
-
rewriting
based
xp
A
oin
9ting
higher
order
recursiv
e
functions
giv
9e
Ttrouble
as
t
ypi
ed
b
y
foldr
:
O
Mfoldr
f
a
[
]
Y
=
a
foldr
f
a
(
x
:
xs
)
s
=
f
x
(
foldr
f
a
xs
)
Naiv
9ely
\
xp
A
oin
ting
this
giv
es
an
series
of
appro
ximations
in
whic
9h
a
term
in
v
olving
functional
parameter
Mf
is
applied
ev
9er
J
(
more
times
to
an
initial
term
.
The
term
rewriter
cannot
21
%
?
sho
9w
that
t
w
o
appro
ximations
are
the
same
so
a
xp
A
oin
t
is
-
apparen
9tly
nev
er
reac
hed
.
eHWhat
'
s
really
going
on
is
that
the
T
xp
A
oin
9t
of
Mfoldr
dep
ends
on
the
xp
oin
9t
of
Mf
.
There
lare
only
t
9w
o
lw
a
ys
round
this
.
=
The
rst
is
to
iter
-
ate
enough
times
to
b
A
e
sure
that
the
xp
oin
9t
is
certainly
reac
9hed
.
W
:
ork
QZb
y
Nielson
and
Nielson
[
NN92
>
]
giv
es
safe
lo
9w
er
b
A
ounds
on
the
n
9um
b
er
of
iterations
needed
.
>
Unfor
-
tunately
:
W
the
exp
A
ense
of
doing
this
mak
9es
it
unattractiv
e
.
Note
Talso
that
this
approac
9h
demands
monomorphisation
.
The
M9second
solution
requires
us
to
supply
a
v
|
ralue
for
Mf
b
A
e
-
fore
%
xp
A
oin
9ting
Mfoldr
so
that
w
e
are
Yin
e
ect
no
longer
dealing
xwith
a
higher
-
order
function
.
There
are
n
9umerous
w
9a
ys
T
to
do
this
d
some
rather
obscure
in
that
they
partially
substitute
g
?
in
functional
parameters
as
part
of
the
xp
A
oin
9t
-
ing
hpro
A
cess
[
N
?
s
]
.
By
con
9trast
Anna
adopts
a
completely
straigh
9tforw
ard
p
approac
h
:
transform
the
source
program
.
Program
vtransformation
is
a
p
A
opular
sub
ject
(
~
and
v
|
rarious
pap
A
ers
describ
e
higher
-
order
function
remo
9v
|
ral
(
also
kno
wn
as
rsti
cation
or
sp
A
ecialisation
)
[
CD91
]
8
[
Nel
]
.
The
sc
9heme
presen
9ted
Tb
A
elo
w
is
based
on
w
ork
b
y
George
Nelan
[
Nel
]
.
Not
all
functional
parameters
can
b
A
e
remo
9v
ed
.
F
:
or
exam
-
ple
recursiv
9e
functions
whic
h
ha
v
e
accum
ulating
functional
parameters
Iare
not
transformable
at
least
with
the
sc
9heme
b
A
elo
9w
:
:
Mf
g
x
=
if
Xx
=
=
0
!
Tthen
s
g
1
!
Telse
s
x
*
f
(
\
y
-
>
g
x
+
y
)
(
x
-
1
)
W
:
e
_justify
this
design
decision
on
the
basis
that
the
v
|
rast
ma
jorit
9y
Y
of
functions
that
p
A
eople
really
write
can
b
e
rsti
-
ed
T
and
G
the
v
|
rast
ma
jorit
9y
of
the
rest
can
b
A
e
handled
b
y
a
secondary
=
mec
9hanism
outlined
in
section
6
.
4
.
jIn
doing
this
w
9e
Yimplicitly
app
A
eal
to
the
measuremen
t
-
lead
approac
h
to
design
discussed
in
the
in
9tro
A
duction
.
Z
W
:
e
only
need
to
re
-
mo
9v
e
P
functional
parameters
for
recursiv
9e
functions
_
but
as
b
A
ecomes
fclear
this
means
rstifying
non
-
recursiv
9e
functions
to
A
o
.
5
.
2
G
Firsti
cation
L
b
y
examples
m
F
:
or
cthe
momen
9t
x
let
'
s
use
Mfoldr
as
a
running
example
.
Giv
9en
Ta
use
of
Mfoldr
lik
e
Msum
xs
=
foldr
(
+
)
0
xs
w
9e
can
unfold
functional
parameter
M
(
+
)
and
iden
tit
y
M0
in
to
Mfoldr
Tgiving
a
new
function
MfoldrSpec
:
Msum
xs
=
foldrSpec
xs
foldrSpec
[
]
Y
=
0
foldrSpec
(
x
:
xs
)
s
=
x
+
foldr
(
+
)
0
xs
And
no
9w
E
%
folding
the
b
A
o
dy
of
MfoldrSpec
giv
es
what
w
e
really
w
9an
t
:
Msum
xs
=
foldrSpec
xs
foldrSpec
[
]
Y
=
0
foldrSpec
(
x
:
xs
)
s
=
x
+
foldrSpec
xs
The
h5k
9ey
to
success
here
is
the
ease
with
whic
h
that
last
fold
4
w
9as
done
.
x
In
general
;
folding
is
a
tric
ky
business
;
with
no
4
guaran
9tee
of
termination
.
y
Ho
w
ev
er
|
"
b
y
restricting
the
functions
s
w
9e
deal
with
w
e
can
guaran
tee
to
mak
e
the
fold
step
terminating
and
trivial
to
carry
out
.
The
restriction
is
Pthat
the
function
m
9ust
pass
along
all
parameters
whic
h
w
9e
w
an
t
to
sp
A
ecialise
in
the
same
p
osition
in
recursiv
9e
calls
as
ythey
app
A
eared
in
the
argumen
9ts
.
+
F
:
or
example
in
Mfoldr
b
A
oth
T
Ma
and
Mf
satisfy
this
.
In
fact
:
w
9e
only
w
an
t
to
substitute
in
functional
parameters
.
So
Tthe
transformation
of
Msum
is
really
:
O
Msum
xs
=
foldrSpec
0
xs
foldrSpec
a
[
]
Y
=
a
foldrSpec
a
(
x
:
xs
)
s
=
x
+
foldrSpec
a
xs
A
little
terminology
:
.
The
function
or
recursiv
9e
group
of
func
-
tions
3
-
for
example
Mfoldr
-
for
whic
9h
functional
parameters
are
b
A
eing
remo
9v
ed
is
called
the
Ntarget
L
group
.
And
a
func
-
tion
Tcon
9taining
a
call
to
a
target
group
is
called
a
Nsource
.
The
Oxrestriction
on
v
|
ralid
targets
seems
to
b
A
e
this
:
the
func
-
tion
m
9ust
pass
along
all
functional
parameters
unc
hanged
in
all
~
recursiv
9e
calls
.
Generalising
this
to
deal
with
m
utually
recursiv
9e
Rtargets
requires
the
notion
of
a
Nconstan
Ct
U
argu
-
men
Ct
set
.
Calling
ga
recursiv
9e
group
in
general
causes
calls
within
'
the
group
and
a
constan
9t
argumen
t
set
gathers
to
-
gether
&
margumen
9ts
whic
h
are
guaran
teed
to
ha
v
e
the
same
v
|
ralue
Tfor
ev
9ery
sub
-
call
.
pF
:
or
example
giv
en
Mf
x
y
z
s
=
f
y
y
z
+
g
z
x
g
a
b
X
=
f
a
b
a
+
g
a
b
a
little
though
9t
sho
ws
Mf
'
s
third
argumen
t
and
Mg
'
s
rst
argu
-
men
9t
sare
alw
a
ys
the
same
{
giving
a
constan
t
argumen
t
set
written
g
M
{
f
.
3
g
.
1
}
.
A
f
group
can
ha
9v
e
g
more
than
one
set
as
Tthe
follo
9wing
trivial
example
sho
ws
:
Mf
x
y
s
=
g
x
y
g
a
b
s
=
f
a
b
Constan
9t
m
argumen
t
sets
can
b
A
e
computed
using
a
simple
abstract
>
in
9terpretation
describ
A
ed
b
elo
9w
.
What
is
imp
ortan
9t
here
Iis
that
for
a
recursiv
9e
target
group
to
b
A
e
sp
ecialisable
all
bfunctional
parameters
in
the
group
m
9ust
b
A
e
constan
t
ar
-
gumen
9ts
.
Certain
other
constrain
ts
also
apply
:
.
W
e
return
to
Tthese
later
.
The
Tfollo
9wing
example
breaks
our
nice
sc
heme
:
Mmap
f
[
]
Y
=
[
]
map
f
(
x
:
xs
)
s
=
f
x
:
map
f
xs
addN
n
xs
=
map
(
+
n
)
xs
F
:
olding
Tand
unfolding
as
ab
A
o
9v
e
Tgiv
es
MaddN
n
xs
=
mapSpec
xs
mapSpec
[
]
Y
=
[
]
mapSpec
(
x
:
xs
)
s
=
(
x
+
n
)
:
mapSpec
xs
whic
9h
is
clearly
wrong
b
A
ecause
Mn
is
unde
ned
in
MmapSpec
.
What
?
jw
9e
need
to
do
is
pass
along
all
free
lam
b
A
da
-
b
ound
v
|
rariables
in
the
sp
A
ecialising
v
alue
M
(
+
n
)
as
new
parameters
in
Ta
st
9yle
reminiscen
t
of
lam
b
A
da
-
lifting
:
22
8
?
MaddN
n
xs
=
mapSpec
n
xs
mapSpec
n
[
]
Y
=
[
]
mapSpec
n
(
x
:
xs
)
s
=
(
x
+
n
)
:
mapSpec
n
xs
Nev
9ertheless
P
this
still
allo
ws
us
to
get
our
knic
k
ers
in
a
t
wist
.
In
d
%
the
follo
9wing
(
admittedly
con
triv
ed
)
example
w
e
ma
y
select
Teither
Minc
or
Mg
as
a
source
to
transform
rst
:
Mapply
f
x
s
=
f
x
g
a
b
Y
=
apply
a
b
inc
y
Y
=
g
(
+
1
)
y
Doing
Tg
rst
giv
9es
:
MapplySpec
x
s
=
a
x
g
a
b
%
=
applySpec
b
inc
y
%
=
g
(
+
1
)
y
No
9w
m
w
e
need
to
in
tro
A
duce
free
v
|
rariables
of
the
sp
ecialising
v
|
ralue
T
Ma
as
a
new
parameter
to
MapplySpec
:
MapplySpec
a
x
s
=
a
x
g
a
b
/
?
=
applySpec
a
b
inc
y
/
?
=
g
(
+
1
)
y
Whereup
A
on
u
it
should
b
e
eminen
9tly
clear
that
w
e
'
v
e
ac
hiev
ed
exactly
nothing
!
Our
mistak
9e
w
as
to
select
a
source
for
whic
9h
the
sp
A
ecialising
v
|
ralue
had
function
-
v
alued
free
v
ari
-
ables
since
}
passing
them
as
new
parameters
to
MapplySpec
means
MapplySpec
is
still
a
higher
-
order
function
.
PThe
moral
is
bTclear
:
qonly
transform
sources
for
whic
9h
the
free
lam
b
A
da
-
b
A
ound
rv
|
rariables
of
the
sp
ecialising
v
|
ralue
are
not
higher
-
order
.
A
second
ob
9vious
constrain
t
on
source
calls
is
that
the
call
should
b
A
e
su
cien
9tly
applied
for
all
function
-
v
|
ralued
parameters
Tto
b
A
e
visible
.
In
5
what
follo
9ws
b
w
e
5
assume
that
naming
issues
are
dealt
with
correctly
:
.
T
=
In
'
particular
the
free
v
|
rariables
in
an
sp
A
ecialising
v
|
ralue
need
to
b
A
e
renamed
b
efore
they
can
b
e
safely
inserted
as
Tnew
parameters
of
the
sp
A
ecialised
target
.
The
4algorithm
b
A
elo
9w
requires
the
program
to
b
e
strati
ed
in
9to
minimal
m
utually
recursiv
e
groups
;
and
top
A
ologically
sorted
.
%
W
:
e
2adopt
the
usual
con
9v
en
tion
2that
the
program
is
bIwritten
top
-
to
-
b
A
ottom
u
with
an
9y
giv
en
function
referring
only
oto
its
o
9wn
group
if
recursiv
e
and
groups
ab
A
o
v
e
it
.
yThe
ro
A
ot
Texpression
is
righ
9t
at
the
b
ottom
.
Sp
A
ecialisation
(
of
target
groups
ma
9y
result
in
some
groups
b
A
ecoming
unreac
9hable
from
Mmain
.
These
groups
should
b
e
remo
9v
ed
.
4A
more
di
cult
problem
is
ho
9w
to
insert
a
new
group
resulting
from
sp
A
ecialisation
of
an
existing
group
in
9to
the
program
so
as
to
main
tain
dep
A
endancy
:
.
7It
turns
out
that
t
9w
o
di
eren
t
b
A
eha
viours
are
p
A
ossible
.
?
EIn
the
usual
case
Tthe
new
group
\
splits
"
a
9w
a
y
Tfrom
the
source
group
:
Mletrec
Xmap
f
[
]
Y
=
[
]
+
'
map
f
(
x
:
xs
)
s
=
f
x
:
map
f
xs
in
let
+
'
square
x
Y
=
x
*
x
in
let
+
'
squareList
xs
=
map
square
xs
in
.
.
.
Since
L
the
sp
A
ecialised
target
MmapSpec
refers
to
Msquare
w
9e
m
9ust
place
it
after
Msquare
.
sKT
:
aking
this
argumen
t
to
its
conclusion
Esho
9ws
w
e
should
place
an
y
\
splitting
"
group
im
-
mediately
Tb
A
efore
the
source
group
:
O
Mlet
!
square
x
%
=
x
*
x
in
letrec
3
'
mapSpec
[
]
Y
=
[
]
3
'
mapSpec
(
x
:
xs
)
s
=
square
x
:
4
mapSpec
xs
in
let
3
'
squarelist
xs
=
mapSpec
xs
in
.
.
.
Sources
Tgiving
rise
to
\
joining
"
sp
A
ecialisations
are
un
9usual
:
Mletrec
Xmap
f
[
]
Y
=
[
]
3
'
map
f
(
x
:
xs
)
s
=
f
x
:
map
f
xs
in
letrec
3
'
squareList
xs
ATB
=
map
(
head
.
squareList
.
unit
)
xs
in
.
.
.
Here
~
the
X8de
nitions
of
M
(
.
)
Mhead
and
Munit
are
unimp
A
ortan
9t
.
Because
the
sp
A
ecialising
v
|
ralue
M
(
head
.
squareList
.
unit
)
refers
z
to
the
source
group
from
whic
9h
it
originates
the
re
-
sulting
sp
A
ecialisation
of
Mmap
will
also
refer
to
MsquareList
and
Kthat
in
turn
means
the
sp
A
ecialisation
should
b
e
merged
in
9to
Tthe
source
group
:
Mletrec
fsquareList
xs
=
mapSpec
xs
fmapSpec
[
]
Y
=
[
]
fmapSpec
(
x
:
xs
)
s
=
(
head
.
squareList
.
unit
)
x
:
g
mapSpec
xs
in
.
.
.
Since
{
only
recursiv
9e
source
groups
can
refer
to
themselv
es
sp
A
ecialisations
Bcorresp
onding
to
sources
in
non
-
recursiv
9e
groups
Tnev
9er
exhibit
this
\
joining
"
b
A
eha
viour
.
5
5
.
3
G
An
L
algo
rithm
m
The
P
pro
A
cedure
b
elo
9w
is
rep
eated
un
9til
no
more
v
|
ralid
(
source
target
)
pairs
can
b
A
e
found
.
T9As
sho
9wn
b
y
Nelan
[
Nel
]
the
order
)
in
whic
9h
these
pairs
are
selected
mak
es
no
di
erence
.
Un
9used
targets
should
b
A
e
deleted
"
but
again
it
do
esn
'
t
mak
9e
an
9y
Tdi
erence
when
.
pAs
a
running
example
w
e
tak
e
:
.
Mletrec
Z
map1
f
g
(
x
:
y
:
xys
)
s
=
f
x
:
g
y
:
map2
g
f
xys
Z
map1
f
g
_
/
?
=
[
]
Z
map2
g
f
(
x
:
y
:
xys
)
s
=
g
x
:
f
y
:
map1
f
g
xys
Z
map2
g
f
_
/
?
=
[
]
.
in
let
Z
addmul
p
q
xs
!
=
map1
(
+
p
)
(
*
q
)
xs
O
1
.
:
Find
&
a
v
|
ralid
target
group
k
and
a
v
alid
source
group
:
whic
9h
Trefers
to
the
target
group
.
g
MTarget
group
=
{
map1
map2
}
g
Source
group
=
{
addmul
}
refers
to
map1
23
R
?
2
.
:
If
dthe
target
group
is
recursiv
9e
compute
its
constan
t
:
argumen
9t
sets
(
see
section
5
.
4
)
.
In
realit
y
:
this
com
-
:
putation
has
to
b
A
e
p
erformed
at
step
(
1
)
.
7
If
non
-
:
recursiv
9e
man
ufacture
i
a
\
fak
9e
"
singleton
set
listing
:
all
Thigher
-
order
parameters
as
constan
9t
.
_
g
MConst
arg
sets
s
=
{
{
map1
.
1
map2
.
2
}
p
\
{
map1
.
2
map2
.
1
}
}
3
.
:
In
9v
en
t
Aa
new
set
of
names
for
the
sp
A
ecialised
target
:
group
.
g
MNew
names
s
=
{
map1Spec
map2Spec
}
4
.
:
Determine
from
lthe
constan
9t
argumen
t
set
whic
h
ar
-
:
gumen
9ts
Yin
the
source
call
site
are
the
sp
A
ecialising
v
|
ral
-
:
ues
.
Extract
G8their
free
lam
9b
A
da
-
b
ound
G8v
|
rariables
and
:
rename
.
g
MOriginal
:
!
:
specialising
values
=
{
(
+
p
)
(
*
q
)
}
!
:
free
variables
Y
=
{
p
q
}
g
Renamed
:
!
:
specialising
values
=
{
(
+
pnew
)
(
*
qnew
)
}
!
:
free
variables
Y
=
{
pnew
qnew
}
5
.
:
Rebuild
the
source
call
b
9y
deleting
the
sp
A
ecialisation
:
v
|
ralues
ninserting
tfree
v
ariables
as
new
parameters
nand
:
c
9hanging
+
the
called
function
to
its
new
name
as
de
-
:
termined
Tin
step
(
3
)
.
g
MRebuilt
source
call
s
=
map1Spec
p
q
xs
6
.
:
Build
2vthe
sp
A
ecialised
target
group
_
starting
with
a
cop
9y
:
of
the
original
target
group
.
JAF
:
or
eac
9h
recursiv
e
call
:
inside
T
the
group
d
mo
A
dify
that
call
in
a
similar
w
9a
y
T
to
:
ho
9w
Tthe
source
call
w
as
mo
A
di
ed
in
step
(
5
)
.
:
MRebuilt
target
group
:
g
map1Spec
pnew
qnew
(
x
:
y
:
xys
)
f
=
(
x
+
pnew
)
:
(
y
*
qnew
)
:
gt0map2Spec
pnew
qnew
rest
g
map1Spec
pnew
qnew
_
f
=
[
]
g
map2Spec
pnew
qnew
(
x
:
y
:
xys
)
f
=
(
x
*
qnew
)
:
(
y
+
pnew
)
:
gt0map1Spec
pnew
qnew
rest
g
map2Spec
pnew
qnew
_
f
=
[
]
7
.
:
Determine
Zgwhether
the
sp
A
ecialised
target
group
should
:
split
or
join
b
9y
nding
out
whether
the
sp
A
ecialisation
:
v
|
ralues
fcon
9tained
an
y
reference
to
the
source
group
.
:
Augmen
9t
Tprogram
appropriately
:
.
g
MSpecialisation
vals
{
(
+
p
)
(
*
q
)
}
don
'
t
g
refer
to
{
addmul
}
so
new
group
splits
.
A
q
v
|
ralid
r
non
-
recursiv
9e
target
group
m
ust
consist
of
a
single
higher
H
order
function
.
A
H
v
|
ralid
recursiv
9e
target
group
satis
-
es
Tall
the
follo
9wing
:
P
:
All
functions
in
the
group
ha
9v
e
at
least
one
functional
:
parameter
.
8
P
:
Eac
9h
lfunctional
parameter
in
the
group
is
a
mem
b
A
er
:
of
s
exactly
one
of
the
group
'
s
constan
9t
argumen
t
sets
.
:
This
|
implies
that
all
in
9tra
-
group
calls
m
ust
b
A
e
su
-
:
cien
9tly
Tapplied
to
exp
A
ose
all
functional
argumen
ts
.
P
:
Eac
9h
constan
t
argumen
t
set
m
ust
men
tion
exactly
one
:
argumen
9t
for
eac
h
function
in
the
group
.
This
disal
-
:
lo
9ws
'
certain
con
triv
ed
pathological
cases
whic
h
w
ould
:
otherwise
Tseriously
complicate
the
algorithm
.
W
A
Tv
|
ralid
source
call
site
satis
es
the
follo
9wing
:
P
:
The
Tsite
is
a
call
to
a
v
|
ralid
target
group
.
P
:
The
Bpapplication
m
9ust
ha
v
e
su
cien
t
argumen
ts
to
sup
-
:
ply
Tall
higher
order
(
sp
A
ecialisable
)
argumen
9ts
.
P
:
F
:
or
7eac
9h
sp
A
ecialisable
argumen
t
none
of
the
free
:
lam
9b
A
da
-
b
ound
&
v
|
rariables
ma
y
b
A
e
jNor
con
tain
jNa
func
-
:
tion
Tspace
.
W
Although
/
it
lo
A
oks
easy
on
pap
er
uqimplemen
9ting
this
algo
-
rithm
s3is
tric
9ky
:
.
6
T
aking
s3in
to
accoun
t
the
mec
hanisms
for
detecting
bconstan
9t
argumen
ts
and
main
taining
t
yp
A
e
anno
-
tations
the
Hask
9ell
implemen
tation
approac
hes
1500
lines
of
Tco
A
de
.
*
5
.
4
G
Computing
L
constant
a
rgument
sets
m
A
simple
abstract
in
9terpretation
is
used
.
Eac
h
function
call
in
k
the
group
is
abstracted
to
exp
A
ose
the
parameters
it
passes
along
:
Mf
x
y
z
s
=
f
y
y
z
+
g
z
x
g
a
b
X
=
f
a
b
a
+
g
a
b
Phrased
Tabstractly
:
this
b
A
ecomes
:
Mf
:
calls
f
[
#
2
#
2
#
3
]
fcalls
g
[
#
3
#
1
]
g
:
calls
f
[
#
1
#
2
#
1
]
fcalls
g
[
#
1
#
2
]
No
9w
;
w
e
iterate
to
a
xed
p
A
oin
t
gathering
a
complete
set
of
the
op
A
ossible
v
|
ralues
of
eac
9h
argumen
t
.
There
is
a
list
for
eac
h
function
and
eac
9h
list
con
tains
a
set
of
p
A
ossible
v
|
ralues
for
eac
9h
Targumen
t
.
pInitially
:
eac
h
argumen
t
can
only
b
A
e
itself
:
MF0
=
[
{
f
.
1
}
{
f
.
2
}
{
f
.
3
}
]
G0
=
[
{
g
.
1
}
{
g
.
2
}
]
A
9t
eac
h
iteration
?
new
appro
ximations
are
computed
b
y
us
-
ing
E
the
abstract
v
9ersions
of
functions
to
lo
A
ok
up
p
ossible
argumen
9t
\
sets
in
the
existing
appro
ximation
.
Also
m
the
ex
-
isting
Tappro
9ximation
is
merged
in
wholesale
:
MF1
=
F0
U
[
{
f
.
2
}
{
f
.
2
}
{
f
.
3
}
]
)
TU
[
{
g
.
1
}
{
g
.
2
}
{
g
.
1
}
]
f
=
[
{
f
.
1
f
.
2
g
.
1
}
{
f
.
2
g
.
2
}
{
f
.
3
g
.
1
}
]
G1
=
G0
U
[
{
f
.
3
}
{
f
.
1
}
]
24
i
?
!
T
MU
[
{
g
.
1
}
{
g
.
2
}
]
f
=
[
{
f
.
3
g
.
1
}
{
f
.
1
g
.
2
}
]
F2
=
F1
U
[
{
f
.
2
g
.
2
}
{
f
.
2
g
.
2
}
{
f
.
3
g
.
1
}
]
+
'
[
{
f
.
3
g
.
1
}
{
f
.
1
g
.
2
}
{
f
.
3
g
.
1
}
]
f
=
[
{
f
.
1
f
.
2
f
.
3
g
.
1
g
.
2
}
{
f
.
1
f
.
2
g
.
2
}
{
f
.
3
g
.
1
}
]
G2
=
G1
U
[
{
f
.
3
g
.
1
}
{
f
.
1
f
.
2
g
.
1
}
]
!
TU
[
{
f
.
3
g
.
1
}
{
f
.
1
g
.
2
}
]
f
=
[
{
f
.
3
g
.
1
}
{
f
.
1
f
.
2
g
.
1
g
.
2
}
]
Y
Ev
9en
tually
g
<
this
pro
A
cess
stabilises
{
giving
the
follo
9wing
p
os
-
sible
Targumen
9t
v
|
ralues
:
Mf
.
1
s
could
have
value
f
.
1
f
.
2
f
.
3
g
.
1
g
.
2
f
.
2
s
could
have
value
f
.
1
f
.
2
f
.
3
g
.
1
g
.
2
f
.
3
s
could
have
value
f
.
3
g
.
1
g
.
1
s
could
have
value
f
.
3
g
.
1
g
.
2
s
could
have
value
f
.
1
f
.
2
f
.
3
g
.
1
g
.
2
So
E3w
9e
ha
v
e
t
w
o
candidate
constan
t
argumen
t
sets
:
M
{
f
.
1
f
.
2
f
.
3
g
.
1
g
.
2
}
and
M
{
f
.
3
g
.
1
}
.
d
{
W
:
e
reject
the
rst
b
A
ecause
it
do
es
not
men
9tion
eac
h
function
exactly
once
.
Deducing
that
M
{
f
.
1
f
.
2
f
.
3
g
.
1
g
.
2
}
is
a
con
-
stan
9t
argumen
t
set
is
correct
but
only
under
the
conditions
that
for
Xthe
initial
call
in
9to
the
group
Mf
.
1
=
=
f
.
2
=
=
f
.
3
if
^
U
Mf
w
9as
called
p
or
Mg
.
1
=
=
g
.
2
^
U
for
an
initial
call
to
Mg
.
sThis
lea
9v
es
M
{
f
.
3
g
.
1
}
as
the
sole
constan
9t
argumen
t
set
for
this
recursiv
9e
Tgroup
.
A
#
glaring
#
a
9w
is
the
inabilit
y
to
abstract
function
calls
whic
h
do
an
9ything
more
than
pass
parameters
unc
hanged
.
ZIn
this
case
a
5sp
A
ecial
v
|
ralue
MUnknown
is
used
to
denote
that
w
9e
can
-
not
b
A
e
sure
what
the
v
|
ralue
of
this
argumen
9t
is
.
F
:
or
example
Mf
x
y
=
f
x
(
y
+
1
)
+
f
y
x
abstracts
Tto
Mf
:
calls
f
[
#
1
Unknown
]
fcalls
f
[
#
2
#
1
]
During
xp
A
oin
9ting
E
MUnknown
annihilates
an
y
other
v
|
ralues
in
a
set
.
F
:
or
;
example
Efa
set
M
{
f
.
1
g
.
2
Unknown
}
;
is
equiv
|
ralen
9t
simply
to
M
{
Unknown
}
.
MUnknown
represen
9ts
an
argumen
t
of
uncertain
\
origin
n
so
w
9e
disallo
w
an
y
constan
t
argumen
t
set
con
9taining
Tit
.
5
.
5
G
Preserving
L
t
yp
Ffe
annotations
m
Since
g
Anna
w
9orks
with
t
yp
A
e
annotated
Core
expressions
w
9e
need
to
go
to
a
little
trouble
to
transform
the
annota
-
tions
-
gto
A
o
.
d
A
9t
rst
glance
3lthis
lo
oks
lik
9e
a
simple
matter
of
mo
A
difying
Fhfunction
t
9yp
es
p
ertaining
to
sp
ecialised
functions
b
9y
deleting
t
yp
A
es
of
sp
ecialised
argumen
9ts
and
inserting
the
t
9yp
A
es
Jof
free
v
|
rariables
b
eing
passed
as
extra
parameters
.
This
.
is
indeed
correct
M
but
there
'
s
more
to
it
.
Recall
the
previous
Tde
nition
of
Mfoldr
.
pThe
t
9yp
A
ec
hec
k
er
Tinfers
:
Mfoldr
:
:
(
a
-
>
b
-
>
b
)
-
>
b
-
>
[
a
]
-
>
b
Giv
9en
[
)
Lthe
usual
Hask
9ell
!
de
nition
of
M
(
+
+
)
:
:
[
c
]
-
>
[
c
]
-
>
[
c
]
d
w
9e
can
de
ne
Mconcat
=
foldr
(
+
+
)
[
]
O
whic
9h
Tsp
A
ecialises
to
:
MfoldrSpec
a
[
]
Y
=
a
foldrSpec
a
(
x
:
xs
)
s
=
x
+
+
foldrSpec
a
xs
concat
=
foldrSpec
[
]
O
Merely
X
adding
and
deleting
argumen
9t
t
yp
A
es
giv
es
MfoldrSpec
an
n
apparen
9t
t
yp
A
e
Mb
-
>
[
a
]
-
>
b
whic
h
n
is
to
A
o
gen
-
eral
.
!
W
:
e
need
to
unify
the
t
9yp
A
e
of
sp
ecialising
v
|
ralue
M
(
+
+
)
M
[
c
]
-
>
[
c
]
-
>
[
c
]
with
the
t
9yp
A
e
of
the
func
-
tional
parameter
it
replaces
B
Ma
-
>
b
-
>
b
and
apply
the
Eresulting
substitution
M
{
a
-
>
[
c
]
b
-
>
[
c
]
}
E
to
the
annotations
on
MfoldrSpec
.
0This
giv
9es
MfoldrSpec
:
:
[
c
]
-
>
[
[
c
]
]
-
>
[
c
]
Tas
required
.
Suc
9h
+
tric
k
ery
should
not
come
as
a
complete
surprise
.
Af
-
ter
all
\
the
Milner
-
Hindley
t
9yp
A
e
rules
for
an
application
of
Mf
:
:
(
T1
-
>
T2
)
-
!
to
Ma
:
:
T3
-
!
require
uni
cation
of
MT1
with
MT3
.
pThat
'
s
Te
ectiv
9ely
what
is
going
on
here
.
The
]
need
to
preserv
9e
t
yp
A
e
annotations
is
a
ma
jor
n
uisance
from
the
implemen
9tation
viewp
A
oin
t
5Gb
ecause
more
time
is
sp
A
en
9t
gqin
xing
up
t
yp
A
es
than
doing
the
transformation
prop
A
er
.
W
:
ork
a
to
impro
9v
e
a
e
ciency
is
a
priorit
9y
.
The
sc
9heme
describ
A
ed
h
ab
o
9v
e
is
a
rst
implemen
tation
in
whic
h
correct
-
ness
Tw
9as
more
imp
A
ortan
t
than
e
ciency
:
.
5
5
.
6
G
Monomo
rphisation
m
By
comparison
with
rsti
cation
\
monomorphisation
is
sim
-
ple
.
;
Monomorphisation
is
a
t
9w
o
-
phase
pro
A
cess
.
The
rst
pass
Jfconducts
what
amoun
9ts
to
a
depth
-
rst
searc
h
from
Mmain
d
to
disco
9v
er
d
all
required
instances
.
nThe
second
pass
clones
co
A
de
c
9hanges
function
names
accordingly
and
re
-
stores
Tdep
A
endancy
order
.
5
.
6
.
1
Collecting
L
the
instances
m
I
am
indebted
to
Mark
Jones
for
suggesting
the
follo
9wing
algorithm
.
GYW
:
e
x
carry
a
set
Minstances
to
accum
9ulate
the
ev
9en
tual
g
|
result
and
a
stac
9k
MtoVisit
recording
places
w
e
need
Lto
visit
.
Elemen
9ts
of
Minstances
and
MtoVisit
are
pairs
of
z
(
function
name
Ct
9yp
A
e
expression
)
sp
ecifying
a
particu
-
lar
C
instance
of
a
function
.
8The
t
9yp
A
e
expressions
are
alw
a
ys
monomorphic
.
Since
B
Mmain
ma
9y
b
A
e
of
an
y
t
yp
A
e
6w
e
trivially
monomor
-
phise
zit
b
9y
substituting
an
y
t
yp
A
e
v
|
rariables
with
MInt
.
This
giv
9es
a
single
initial
v
|
ralue
for
MtoVisit
!
with
Minstances
ini
-
tially
H
b
A
eing
empt
9y
:
.
The
nal
v
|
ralue
of
Minstances
is
then
Msearch
(
instances
toVisit
)
Twhere
:
O
Msearch
(
instances
toVisit
)
=
if
X
[
toVisit
is
empty
]
Z
then
s
instances
Z
else
Z
let
next
=
head
toVisit
Z
in
Xif
next
elem
instances
F
[
We
'
ve
already
been
here
]
Z
then
s
search
(
instances
tail
toVisit
)
Z
else
s
[
Get
the
function
specified
by
next
.
.
m
Find
out
what
instances
of
other
25
~
?
&
m
Mfunctions
are
called
.
s
Add
these
&
m
instances
to
(
tail
toVisit
)
giving
&
m
toVisitAug
and
then
do
]
&
m
search
(
{
next
}
U
instances
toVisitAug
)
z
F
:
or
Texample
giv
9en
Mid
x
s
=
x
f
x
=
id
x
main
s
=
id
42
+
ord
(
f
'
c
'
)
z
the
Talgorithm
runs
through
these
states
:
f
Minstances
Y
"
toVisit
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
{
}
z
<
[
(
main
Int
)
]
{
(
main
Int
)
}
F
[
(
id
Int
-
>
Int
)
v
(
f
XChar
-
>
Char
)
]
{
(
main
Int
)
F
[
(
f
XChar
-
>
Char
)
]
tx
(
id
Int
-
>
Int
)
}
{
(
main
Int
)
F
[
(
id
Char
-
>
Char
)
]
tx
(
id
Int
-
>
Int
)
tx
(
f
XChar
-
>
Char
)
}
{
(
main
Int
)
F
[
]
tx
(
id
Int
-
>
Int
)
tx
(
id
Char
-
>
Char
)
tx
(
f
XChar
-
>
Char
)
}
z
This
giv
9es
t
w
o
instances
for
Mid
.
Because
the
abstract
in
ter
-
pretation
of
t
9yp
A
es
maps
b
oth
MInt
and
MChar
to
the
t
9w
o
p
oin
t
domain
only
.
one
of
those
instances
is
needed
for
analysis
purp
A
oses
.
In
_9general
w
9e
can
exploit
the
fact
that
man
y
di
eren
9t
Rt
yp
A
es
are
assigned
the
same
domain
to
reduce
the
program
expansion
caused
b
9y
monomorphisation
.
F
:
ar
and
a
9w
a
y
the
easiest
w
9a
y
to
do
this
is
to
transform
the
t
9yp
A
e
an
-
notations
nto
domain
annotations
b
A
efore
monomorphisation
using
the
results
of
section
2
.
2
.
5
.
ST
9yp
A
e
v
|
rariables
are
simply
replaced
Tb
9y
domain
v
|
rariables
.
5
.
6
.
2
Cloning
L
co
Ffde
m
This
is
fairly
trivial
.
+
Eac
9h
function
is
duplicated
once
p
A
er
instance
with
appropriate
new
names
.
The
function
b
A
o
d
-
ies
#
\
ha
9v
e
their
call
sites
mo
A
di
ed
to
refer
to
appropriately
named
_2instances
in
previous
groups
q
and
this
one
if
recur
-
siv
9e
.
\
Then
the
b
A
o
dies
ha
v
e
the
t
yp
A
e
v
|
rariables
in
their
anno
-
tations
substituted
appropriately
for
eac
9h
di
eren
t
instance
required
.
eThe
en
9tire
program
can
b
A
e
pro
cessed
in
a
single
top
-
to
-
b
A
ottom
Tpass
.
The
only
sligh
9tly
tric
ky
problem
is
rebuilding
recursiv
e
groups
0so
as
to
main
9tain
dep
A
endancy
:
.
F
or
0non
-
recursiv
e
clones
/
this
is
easy
:
but
b
A
ecause
of
the
existance
of
cer
-
tain
2
con
9triv
ed
recursiv
e
functions
:
main
taining
dep
A
endancy
in
the
recursiv
9e
case
can
b
A
e
complicated
.
vW
:
e
a
v
oid
these
problems
"
db
9y
lumping
all
the
clones
arising
from
a
recursiv
e
function
group
in
9to
a
single
Mletrec
:
and
passing
the
pro
-
gram
Ta
third
time
though
the
dep
A
endancy
analyser
.
Despite
8hthese
complications
the
monomorphiser
is
ex
-
tremely
a
quic
9k
and
do
A
es
not
pro
v
e
a
signi
can
t
limitation
on
Tp
A
erformance
.
6
Discussion
This
section
dra
9ws
together
the
detailed
tec
hnical
threads
exp
A
ounded
in
the
previous
three
sections
b
9y
presen
ting
some
kp
A
erformance
results
1and
lo
oking
at
related
and
fur
-
ther
xw
9ork
.
5
But
w
e
b
A
egin
b
y
lo
A
oking
at
some
p
erformance
issues
.
t
6
.
1
G
Putting
L
it
all
together
m
Thro
9wing
realistically
sized
programs
at
the
analyser
re
-
v
9ealed
psome
p
A
erformance
problems
whic
h
w
ere
traced
to
niceties
X
in
the
in
9terface
b
A
et
w
een
the
abstract
in
terpreter
and
the
Tterm
rewriter
.
P
9erformance
rproblems
app
A
ear
when
the
term
rewriting
sys
-
tem
u
is
fed
a
gigan
9tic
term
to
simplify
:
.
;
Usually
"
suc
h
u
terms
reduce
-
to
something
quite
trivial
.
eHIt
is
imp
A
ortan
9t
to
realise
that
}
0the
abstract
in
9terpreter
will
generate
absolutely
enor
-
mous
Uterms
3
esp
A
ecially
from
source
text
whic
9h
has
deeply
nested
B
function
calls
or
deeply
nested
Mcase
expressions
l
b
A
oth
of
whic
9h
are
quite
common
.
>
F
:
or
example
the
bigger
pro
-
grams
2
men
9tioned
in
section
6
.
2
generated
terms
whic
h
_
when
prett
9y
-
prin
ted
#
in
the
st
9yle
used
in
this
pap
A
er
&
co
v
ered
liter
-
ally
Ttens
of
A4
pages
.
Analysis
of
a
program
pro
A
ceeds
as
follo
9ws
.
First
the
pro
-
gram
L
is
passed
in
its
en
9tiret
y
L
through
the
abstract
in
9ter
-
preter
0
generating
a
corresp
A
onding
collection
of
recursiv
9e
equations
\
(
or
terms
)
.
TThese
equations
are
h
9ugely
redun
-
dan
9t
and
are
simpli
ed
individually
:
without
reference
to
eac
9h
nother
.
Finally
:
the
xp
A
oin
ting
system
tra
v
els
along
the
_
groups
of
equations
accum
9ulating
an
en
vironmen
t
of
\
solv
9ed
"
equations
.
A
solv
ed
equation
is
self
-
con
tained
:
#
_it
do
A
es
2
not
refer
to
the
abstract
in
9terpretation
of
an
y
other
function
.
Solving
gnon
-
recursiv
9e
equations
is
a
simple
matter
of
\
substituting
in
the
abstract
in
9terpretations
of
other
func
-
tions
7and
simplifying
.
F
:
or
recursiv
9e
functions
this
stage
is
follo
9w
ed
Tb
y
xp
A
oin
ting
.
What
really
ruins
p
A
erformance
is
not
xp
oin
9ting
C
.
but
the
initial
simpli
cation
of
terms
whic
9h
emerge
from
the
ab
-
stract
ein
9terpreter
.
This
problem
w
as
largely
alleviated
b
y
giving
w
the
abstract
in
9terpreter
a
little
more
in
telligence
?
in
the
Tform
of
:
t
P
:
The
#
t
9yp
A
e
-
sp
eci
c
MAbsVal
rewrites
describ
ed
in
sec
-
:
tion
T4
.
6
.
BF
P
:
A
kno
9wledge
Iof
k
ey
MContext
rewrite
rules
.
]
PIn
par
-
:
ticular
~
9the
6
rules
for
Mcase
statemen
9ts
generate
large
:
expressions
xin
9v
olving
MCMeet
"
MCJoin
MStop1
and
MStop2
.
:
A
handful
yof
rules
em
9b
A
o
dying
ysimple
facts
suc
h
as
:
MCMeet
[
.
.
.
Stop2
.
.
.
]
=
=
Stop2
T
w
9ere
added
.
#
:
Bet
9w
een
Y
them
gthe
sizes
of
terms
generated
w
9ere
some
-
:
times
cut
b
9y
t
w
o
orders
of
magnitude
J
and
p
A
erfor
-
:
mance
Tw
9as
m
uc
h
impro
v
ed
.
u
A
m
second
m
p
A
erformance
problem
w
9as
traced
to
the
initial
sim
-
pli
cation
M
of
terms
emerging
from
the
abstract
in
9terpreter
.
These
=
terms
are
simpli
ed
without
reference
to
eac
9h
other
.
It
turns
out
to
b
A
e
b
etter
to
simplify
a
term
only
when
w
9e
xkno
w
the
solv
ed
v
|
ralues
of
the
other
terms
it
refers
to
b
A
ecause
V
kno
9wing
these
v
|
ralues
mak
es
the
nal
term
m
uc
h
smaller
.
In
e
ect
pthis
is
ac
9hiev
ed
simply
b
9y
omitting
this
simpli
cation
?
Wpass
altogether
.
zF
:
or
at
least
one
input
I
anal
-
ysis
Ttime
w
9as
cut
b
y
a
factor
of
v
e
.
26
d
?
d
l
S4
ff
ff
32
ff
F
ff
fg
ff
6
ff
X
G
ff
fg
ff
z3
F
:
or
Ta
complete
run
Zw
ff
fg
ff
IAnalysis
Tonly
V
ff
fg
ff
W5
Compiling
Twith
Mghc
-
0
.
10
}
ff
fg
ff
fh
Z
G
ff
r
ff
fg
ff
33
Program
H
ff
>
2
Lines
33
ff
fg
ff
kg
&
Time
33
ff
Claim
33
ff
|
Space
33
ff
fg
ff
Time
33
ff
+
+
SClaim
33
ff
fg
ff
[
FwTime
33
ff
{
%
analysis
Ttime
as
%
33
ff
fg
ff
ff
F
ff
fg
ff
6
ff
X
G
ff
fg
ff
ff
[
ff
ff
fg
ff
s
ff
H
ff
fg
ff
u
K
ff
F
ff
fg
ff
ff
fg
ff
33
concat
0
ff
?
O
<
T
10
33
ff
fg
ff
iL
0
.
42
Ts
33
ff
1
.
485
TM
33
ff
4
47
.
2
Tk
33
ff
fg
ff
w
"
0
.
18
Ts
33
ff
"
0
.
586
TM
33
ff
fg
ff
Y
+
0
.
92
Ts
33
ff
19
T
%
33
ff
fg
ff
ff
fg
ff
33
zip3
ff
?
O
<
T
10
33
ff
fg
ff
iL
0
.
52
Ts
33
ff
1
.
793
TM
33
ff
4
56
.
1
Tk
33
ff
fg
ff
w
"
0
.
17
Ts
33
ff
"
0
.
570
TM
33
ff
fg
ff
Y
+
1
.
00
Ts
33
ff
17
T
%
33
ff
fg
ff
ff
fg
ff
33
w
9ang
ff
E
385
33
ff
fg
ff
d
23
.
62
Ts
33
ff
85
.
396
TM
33
ff
908
.
8
Tk
33
ff
fg
ff
w
"
9
.
15
Ts
33
ff
15
.
861
TM
33
ff
fg
ff
T
43
.
61
Ts
33
ff
21
T
%
33
ff
fg
ff
ff
fg
ff
33
w
9a
v
e4main
ff
E
619
33
ff
fg
ff
d
43
.
40
Ts
33
ff
F
116
.
207
TM
33
ff
2897
.
7
Tk
33
ff
fg
ff
21
.
62
Ts
33
ff
43
.
239
TM
33
ff
fg
ff
O
199
.
29
Ts
33
ff
11
T
%
33
ff
fg
ff
ff
fg
ff
33
ag2hs
:
ff
1047
33
ff
fg
ff
208
.
95
Ts
33
ff
F
275
.
245
TM
33
ff
9653
.
8
Tk
33
ff
fg
ff
7
&
126
.
42
Ts
33
ff
q
135
.
335
TM
33
ff
fg
ff
O
100
.
68
Ts
33
ff
h
126
T
%
33
ff
fg
ff
ff
fg
ff
6
ff
X
G
ff
fg
ff
ff
[
ff
ff
fg
ff
s
ff
H
ff
fg
ff
u
K
ff
F
ff
fg
ff
fh
ff
F
E
/
T
:
able
T2
:
pSome
p
A
erformance
gures
for
NAnna
ff
ff
ff
Y
%
d
6
.
2
G
Absolute
L
p
Fferfo
rmance
results
m
Fiv
9e
Wtest
programs
w
ere
used
.
xThe
rst
t
w
o
9
Mconcat
and
Mzip3
Z
are
utterly
trivial
and
w
9ere
included
as
comparison
against
gures
presen
9ted
in
[
Sew93
/
]
.
p7
Mwang
and
Mwave4main
are
Htak
9en
from
Pieter
Hartel
'
s
b
A
enc
hmark
suite
[
HL92
l
]
.
The
biggest
one
Mag2hs
is
prepro
A
cessor
for
a
dialect
of
Hask
9ell
augmen
9ted
with
attribute
grammar
[
Joh87
9
]
facilities
writ
-
ten
b
9y
Da
vid
Rushall
.
%
The
analyser
w
as
compiled
with
Chalmers
Hask
9ell
-
B
0
.
999
.
4
with
ags
M
-
fpbu
-
O
and
run
using
an
eigh
9t
megab
yte
heap
for
all
except
Mag2hs
whic
h
required
~
a
sixteen
megab
9yte
heap
.
XYA
~
generational
garbage
collector
W
w
9as
emplo
y
ed
.
T
:
ests
w
ere
run
on
a
ligh
tly
loaded
Sun
Sparc
10
/
31
and
eac
9h
test
w
as
p
A
erformed
at
least
three
times
.
pTimes
Tare
user
CPU
seconds
.
Simply
measuring
o
9v
erall
run
times
is
not
particularly
help
-
ful
m
b
A
ecause
[
w
9e
really
w
an
t
to
establish
ho
w
exp
A
ensiv
e
this
analyser
w
9ould
b
A
e
if
emplo
y
ed
in
a
Hask
ell
compiler
.
|
ZIt
seems
v
reasonable
to
consider
the
\
b
A
order
"
b
et
9w
een
v
the
fron
9t
end
and
the
analyser
itself
as
the
p
A
oin
9t
where
the
t
yp
A
e
-
c
9hec
k
er
pro
A
duces
a
t
9yp
e
-
annotated
Core
tree
since
at
least
in
q
Glasgo
9w
Hask
ell
the
compiler
pro
A
duces
this
tree
an
y
-
w
9a
y
:
.
So
w
e
presen
t
gures
not
only
for
a
complete
run
but
also
for
the
analysis
phase
prop
A
er
.
6The
latter
category
co
9v
-
ers
_
rsti
cation
monomorphisation
abstract
in
9terpretation
and
xp
A
oin
9ting
D
all
of
whic
h
are
legitimate
analysis
exp
A
enses
.
T
:
o
assess
whether
or
not
w
9e
are
approac
hing
the
righ
t
ball
-
park
C
w
9e
;
timed
Glasgo
w
Hask
ell
0
.
10
compiling
the
programs
in
9to
*
C
and
compared
those
times
with
the
analysis
phase
time
^
of
Anna
.
The
compiler
options
w
9ere
M
-
O2
-
C
.
Compiler
semispace
sizes
w
9ere
3
megab
ytes
for
the
small
t
w
o
sand
8
megab
9ytes
for
the
big
three
:
c
this
turned
out
to
b
A
e
plen
t
y
:
.
The
times
rep
A
orted
for
Glasgo
9w
Hask
ell
are
for
the
compiler
prop
A
er
(
that
is
that
part
of
the
compiler
whic
9h
is
itself
writ
-
ten
fin
Hask
9ell
and
whic
h
translates
the
output
of
the
Y
:
acc
parser
Tin
9to
C
.
T
:
able
2
presen
9ts
the
gures
.
The
maxim
um
residency
g
-
ures
w
9ere
obtained
using
a
cop
ying
collector
with
heap
sizes
set
only
just
big
enough
.
This
quan
9tit
y
is
omitted
for
the
analysis
-
only
gures
b
A
ecause
of
the
di
culties
of
deciding
on
ho
9w
to
divide
space
exp
A
enses
b
et
9w
een
the
fron
9t
end
and
the
Tanalysis
phase
.
F
:
or
{
the
big
three
times
are
v
9ery
roughly
:
divided
equally
b
A
et
9w
een
the
fron
9t
end
and
analysis
phases
.
Mag2hs
has
a
rel
-
ativ
9ely
large
analysis
time
in
comparison
to
its
size
.
f
This
is
4b
A
ecause
it
mak
9es
considerable
use
of
lazy
pattern
matc
h
-
ing
F
whic
9h
translates
to
a
large
quan
tit
y
of
complex
Core
%
d
expressions
.
These
R
}
in
turn
generate
some
large
complex
sets
(
zof
equations
for
the
xp
A
oin
9ter
to
solv
e
.
U
A
(
3tec
hnique
men
9tioned
9
in
section
6
.
4
migh
t
help
here
.
9F
:
or
the
larger
problems
space
x4consumption
is
of
concern
.
Muc
9h
if
not
the
ma
jorit
9y
:
of
the
space
used
is
related
to
fron
t
-
end
pro
A
cess
-
ing
+
and
fit
seems
lik
9ely
that
the
analysis
itself
is
relativ
ely
c
9heap
on
space
.
F
:
urther
in
v
estigation
with
a
heap
pro
ler
is
Tnecessary
:
.
The
results
of
comparing
analysis
time
with
a
run
of
Glasgo
9w
Hask
9ell
Ueon
the
same
program
are
in
triguing
.
vThe
tests
are
at
least
fair
in
the
sense
that
b
A
oth
Anna
and
the
Hask
9ell
com
-
piler
are
written
in
Hask
9ell
{
so
neither
has
an
unfair
adv
|
ran
-
tage
.
Just
b
9y
themselv
es
-
it
is
a
little
un
usual
that
Mghc
com
-
piled
Mag2hs
in
almost
half
the
time
it
to
A
ok
for
Mwave4main
.
It
+
ma
9y
b
A
e
that
the
hea
vy
use
of
n
umeric
o
v
erloading
in
Mwang
and
Mwave4main
has
slo
9w
ed
do
wn
Mghc
as
it
will
ha
v
e
had
to
generate
and
optimise
large
quan
9tities
of
dictionary
han
-
dling
bdco
A
de
.
Mag2hs
.
b
9y
comparison
is
mostly
string
handling
:
there
is
little
o
9v
erloading
in
it
.
r
Anna
has
a
naiv
9e
view
of
the
KHask
9ell
n
um
b
A
ers
{
it
only
kno
ws
ab
A
out
MInt
so
it
will
not
)
ha
9v
e
seen
an
y
suc
h
n
umeric
o
v
erloading
.
ZQIn
order
to
mak
9e
Anna
accept
these
t
w
o
programs
w
e
had
to
strip
out
the
extensiv
9e
t
yp
A
e
signatures
whic
h
had
b
A
een
placed
there
expressely
vxto
eliminate
n
9umeric
o
v
erloading
.
?
These
factors
ma
9y
8
w
ell
ha
v
e
conspired
to
giv
e
Anna
a
remark
|
rably
go
A
o
d
rel
-
ativ
9e
#
sho
wing
for
Mwang
and
Mwave4main
Walthough
it
is
hard
to
b
A
eliev
9e
they
accoun
t
for
all
the
di
erence
b
A
et
w
een
11
%
(
Mwave4main
)
Tand
126
%
(
Mag2hs
)
.
Because
Mwang
and
Mwave4main
are
mac
9hine
-
generated
Hask
9ell
LJthe
ALexpressions
in
them
are
reasonably
simple
and
small
.
By
8
comparison
A
the
desugared
v
9ersion
of
Mag2hs
con
-
tained
u
some
v
9ery
large
expressions
and
some
quite
compli
-
cated
-
structured
t
9yp
A
es
.
e
W
:
atc
hing
-
the
b
eha
9viour
of
Anna
on
this
example
it
is
clear
that
the
ma
jorit
9y
of
the
analysis
time
J
is
sp
A
en
9t
xp
oin
9ting
a
single
large
group
of
ab
out
t
9w
en
t
y
functions
whic
9h
arose
from
the
extensiv
e
use
of
lazy
pattern
matc
9hing
.
~
It
6
seems
plausible
that
this
particular
group
did
not
cause
an
9y
similar
di
cult
y
to
Mghc
and
it
ma
y
also
b
A
e
p
A
ossible
x
that
Mghc
'
s
desugarer
did
a
b
etter
job
than
Anna
'
s
in
qCtranslating
the
pattern
matc
9hing
.
0
<
Nev
ertheless
>
the
qCdis
-
parit
9y
in
relativ
e
analysis
/
compile
costs
b
A
et
w
een
Mag2hs
and
the
other
t
9w
o
big
examples
is
a
w
9arning
that
w
e
should
not
read
\
to
A
o
m
9uc
h
\
in
to
these
measuremen
ts
b
A
ey
ond
the
p
A
erhaps
heartening
]
conclusion
that
w
9e
are
indeed
approac
hing
the
righ
9t
Tballpark
for
analyser
p
A
erformance
.
27
?
6
.
3
G
Related
L
w
o
rk
m
Mycroft
'
s
original
w
9ork
[
Myc80
|
]
on
applying
abstract
in
ter
-
pretation
to
the
analysis
of
functional
programs
spark
9ed
o
in
9tense
[
w
ork
on
forw
ard
analyses
.
A
[
forw
ard
strictness
anal
-
ysis
kktells
us
the
de
nedness
of
a
function
application
giv
9en
the
de
nedness
of
the
argumen
9ts
.
>
Landmark
pap
A
ers
include
the
*
Burn
-
Hankin
-
Abramsky
w
9ork
[
BHA85
b
]
whic
h
put
higher
order
analysis
on
a
rm
theoretical
fo
A
oting
TPand
W
:
adler
'
s
pap
A
er
[
W
:
ad87
]
whic
9h
sho
w
ed
ho
w
one
migh
t
deal
sensibly
with
.
sum
-
of
-
pro
A
ducts
t
9yp
es
.
Implemen
tors
.
made
m
9uc
h
.
of
nding
xp
A
oin
9ts
using
the
F
:
ron
tiers
algorithm
massaging
it
extensiv
9ely
m
to
deal
with
higher
order
functions
[
HH91
>
]
esum
-
of
-
pro
A
ducts
~
#
t
9yp
es
[
Sew91
/
]
and
p
olymorphism
[
Sew93
/
]
.
V
De
-
spite
this
and
other
tric
9k
ery
[
HH92
>
]
[
Sew92
/
]
Bfron
9tiers
failed
to
deliv
9er
usable
p
A
erformance
for
high
-
de
nition
strictness
analysis
p
for
an
9ything
other
than
trivial
inputs
and
there
are
go
A
o
d
theoretical
reasons
for
b
A
elieving
the
situation
cannot
b
A
e
Timpro
9v
ed
.
Starting
{
at
around
the
same
time
another
sc
9ho
A
ol
of
though
t
w
9as
dev
eloping
bac
kw
ards
Qor
pro
jection
analyses
.
A
bac
9k
-
w
9ards
analysis
sho
ws
ho
w
the
seman
tic
quan
tit
y
in
question
-
Jphere
W
demand
for
ev
|
raluation
-
propagates
from
a
function
application
to
the
individual
argumen
9ts
.
\
Hughes
[
Hug90
'
]
ar
-
gues
that
bac
9kw
ards
analyses
are
inheren
9tly
more
e
cien
t
than
U
[
forw
9ard
ones
e
]
b
A
ecause
the
function
spaces
with
whic
h
the
analyses
deal
are
smaller
in
the
bac
9kw
ards
case
.
Pro
jec
-
tion
analysis
deals
easily
with
sum
-
of
-
pro
A
ducts
t
9yp
es
Gand
captures
Zcertain
prop
A
erties
D
suc
9h
as
head
-
strictness
that
seem
to
elude
forw
9ard
analyses
.
A
go
A
o
d
reference
for
pro
-
jection
analysis
is
[
WH87
]
.
v
Later
w
9ork
sho
w
ed
ho
w
to
do
mak
9e
+
non
-
at
pro
jection
analysis
p
A
olymorphic
[
Hug
+
]
q
and
a
successful
non
-
at
Wp
A
olymorphic
pro
jection
analyser
w
9as
built
Tin
9to
Glasgo
w
Hask
ell
[
KHL91
(
]
.
Despite
these
successes
tpro
jection
analyses
ha
9v
e
a
funda
-
men
9tal
#
inabilit
y
to
deal
with
higher
order
functions
.
F
:
ol
-
lo
9wing
the
lead
of
W
:
ra
y
[
W
:
ra85
:
C
]
.
Hughes
de
ned
a
mixed
analysis
|
whic
9h
w
as
forw
ards
for
the
higher
order
bits
and
bac
9kw
ards
S
for
ev
9erything
else
[
Hug87
'
]
.
Doing
this
giv
es
an
analysis
r
+
whic
9h
deals
with
higher
-
orderness
whilst
retaining
the
inheren
9t
e
ciency
of
bac
kw
ard
analysis
.
KRecen
tly
:
.
other
w
9ork
ers
Qha
v
e
b
A
egun
to
explore
the
relationship
b
et
9w
een
for
-
w
9ard
and
bac
kw
ard
analysis
[
Bur90
]
[
HL90
l
]
[
D
W90
N
]
.
T
The
analysis
describ
A
ed
in
this
pap
er
is
a
mo
di
cation
of
Hughes
'
original
Tmixed
analysis
.
Mean
9while
=
p
A
eople
xha
v
e
b
A
een
lo
oking
at
other
w
9a
ys
of
solv
-
ing
v
recursiv
9e
domain
equations
.
A
There
has
b
A
een
a
discern
-
able
J
shift
to
9w
ards
J
term
orien
9ted
approac
hes
.
F
:
erguson
and
Hughes
#
dev
9elop
A
ed
\
concrete
data
structures
"
(
CDSs
)
[
N
?
s
]
based
7
on
Curien
'
s
w
9ork
on
sequen
tial
algorithms
[
Cur86
]
.
CDSs
deal
with
higher
-
orderness
b
9y
regarding
a
higher
or
-
der
#
%
function
as
con
9taining
a
CDS
#
!
in
terpreter
for
eac
h
func
-
tional
0parameter
.
This
is
really
a
disguised
w
9a
y
0of
substi
-
tuting
in
functional
parameters
b
A
efore
xp
oin
9ting
.
Whether
or
not
CDSs
can
deliv
9er
a
viable
xp
A
oin
ting
mec
hanism
re
-
mains
to
b
A
e
seen
.
mEarly
implemen
9tations
hin
ted
at
space
problems
but
Dthese
ma
9y
no
w
ha
v
e
b
A
een
solv
ed
[
Hug93
'
]
.
CDSs
/
can
also
b
A
e
view
9ed
as
a
higher
-
order
generalisation
of
the
minimal
function
graph
sc
9heme
originally
describ
A
ed
b
9y
E
Neil
Jones
[
JM86
z
]
.
jMinimal
function
graphs
are
used
in
=
the
Seman
9tique
analyser
[
KHL91
(
]
built
in
to
Glasgo
w
Hask
9ell
T
[
PHHP93
#
]
.
The
term
rewriting
based
xp
A
oin
9ter
describ
ed
here
w
9as
in
part
inspired
b
9y
Charles
Consel
'
s
strictness
analyser
in
the
G
Y
:
ale
Hask
9ell
compiler
[
Gro92
P
]
.
Consel
'
s
pap
A
er
[
Con91
]
whic
9h
seems
to
ha
v
e
passed
b
y
almost
unnoticed
describ
A
ed
a
7
#
successful
if
simple
strictness
analyser
solving
xp
A
oin
9t
equations
Yb
9y
term
rewriting
.
In
view
of
ho
w
w
ell
this
and
Consel
'
s
}
system
w
9ork
it
is
p
A
erhaps
a
pit
y
that
P
eyton
Jones
et
;
al
made
disparaging
remarks
ab
A
out
term
-
based
xp
oin
9t
-
ing
Tin
their
seminal
fron
9tiers
pap
A
er
[
PC87
9
]
.
5
6
.
4
G
F
urther
L
w
o
rk
m
Anna
'
s
N
p
A
erformance
is
encouraging
.
Nev
9ertheless
there
'
s
still
a
long
w
9a
y
to
go
b
A
efore
ev
|
raluation
transformer
infor
-
mation
B
can
b
A
e
generated
automatically
in
pro
duction
com
-
pilers
.
pThree
Ta
9v
en
ues
of
dev
elopmen
t
need
to
b
A
e
p
ersued
.
O
P
:
NEnhancemen
Ct
jeof
applicabilit
y
.
]
Anna
'
s
most
w
9orry
-
:
ing
alimitation
is
her
inabilit
9y
to
deal
with
higher
order
:
functions
whic
9h
cannot
b
A
e
rsti
ed
.
A
p
ossible
partial
:
solution
Mis
to
iterate
these
(
or
more
precisely
:
just
the
:
nast
9y
wbits
)
as
man
y
times
as
is
necessary
to
guaran
-
:
tee
G
a
xp
A
oin
9t
.
The
w
ork
of
Nielson
and
Nielson
[
NN92
>
]
:
giv
9es
7ethe
magic
n
um
b
A
er
of
iterations
needed
.
vF
:
or
man
y
:
common
'
forms
[
this
n
9um
b
A
er
'
is
reasonably
lo
9w
and
:
it
Zseems
reasonable
to
exp
A
ect
this
approac
9h
to
yield
:
w
9orth
while
Tresults
.
:
It
eis
also
necessary
to
remo
9v
e
esome
of
the
excessiv
9e
re
-
:
strictions
Jion
user
-
de
ned
data
t
9yp
A
es
discussed
in
sec
-
:
tion
\
2
.
2
.
6
.
QThis
do
A
es
not
app
ear
to
b
e
particularly
:
di
cult
.
Kubiak
\
et
al
[
KHL91
(
]
managed
this
quite
:
successfully
:
.
34
P
:
NEnhancemen
Ct
gof
p
K
erformance
.
The
re
nemen
9ts
of
:
section
=
6
.
1
ha
9v
e
=
done
a
lot
to
impro
9v
e
=
the
system
'
s
:
p
A
erformance
.
Nev
9ertheless
some
A
programs
w
e
tried
:
recen
9tly
-
in
excess
of
a
thousand
lines
-
run
more
:
slo
9wly
than
one
w
ould
lik
e
.
In
v
estigations
are
b
A
eing
:
made
.
:
Fixp
A
oin
9ting
L
large
groups
of
functions
could
conciev
-
:
ably
b
A
e
accelerated
b
9y
reducing
the
group
to
a
\
mini
-
:
mal
Tform
"
rst
.
pF
:
or
example
giv
9en
g
Ma
=
.
.
.
a
.
.
.
b
.
.
.
g
b
=
.
.
.
c
.
.
.
g
c
=
.
.
.
c
.
.
.
d
.
.
.
g
d
=
.
.
.
a
.
.
.
:
w
9e
can
remo
v
e
Mb
and
Md
b
y
substituting
them
in
to
Ma
and
:
Mc
resp
A
ectiv
9ely
:
.
This
halv
es
the
n
um
b
A
er
of
functions
in
:
the
2group
b
A
eing
xp
oin
9ted
.
Once
the
solutions
to
Ma
:
and
l
Mc
ha
9v
e
lb
A
een
generated
4w
9e
obtain
v
|
ralues
for
Mb
and
:
Md
T
b
9y
straigh
tforw
ard
bac
k
-
substitution
.
:
Note
G
that
this
tec
9hnique
ma
y
b
A
e
used
in
an
y
situa
-
:
tion
in
9v
olving
xp
A
oin
ting
m
utually
recursiv
e
groups
of
:
equations
.
The
idea
stems
from
an
analogy
with
the
:
Gauss
-
Jordan
metho
A
d
for
solving
sim
9ultaneous
linear
:
equations
.
z
In
4
this
case
<
a
recursiv
9e
group
can
only
b
A
e
:
reduced
I
to
the
p
A
oin
9t
where
ev
ery
equation
in
the
group
:
refers
directly
to
itself
{
no
further
.
HAfter
that
.
x
-
:
p
A
oin
9ting
x
is
una
v
oidable
.
D
Whether
or
not
this
renders
:
a
sp
A
eedup
dep
ends
on
the
relativ
9e
costs
of
substitution
:
bac
9k
Tsubstitution
and
xp
A
oin
ting
.
28
?
P
:
NDealing
with
mo
K
dules
.
5
Mo
A
dules
Zare
an
unmiti
-
:
gated
n
9uisance
for
man
y
kinds
of
high
p
A
o
w
ered
seman
-
:
tic
xManalyses
and
optimisations
.
E
\
In
particular
mo
A
d
-
:
ules
cause
big
di
culties
for
an
9y
kind
of
what
John
:
Y
:
oung
(
termed
\
collecting
in
9terpretations
"
[
Y
ou89
-
]
.
T
A
:
collecting
Tin
9terpretation
is
essen
tially
a
global
anal
-
:
ysis
.
v
Man
9y
compile
time
optimisations
are
limited
:
b
9y
the
mo
A
dule
structure
.
I
F
:
or
example
hMsome
of
the
:
more
irecen
9t
sc
hemes
for
compiling
o
v
erloading
ef
-
:
cien
9tly
[
Jon93
9
]
[
Aug93
'
]
require
global
analysis
for
:
full
=
applicabilit
9y
:
.
;
The
p
A
oin
t
of
all
this
is
that
the
:
monomorphisation
+
and
rsti
cation
transformations
:
used
Tin
Anna
also
require
a
global
view
.
k
:
There
"
is
an
urgen
9t
need
to
devise
sophisticated
com
-
:
pilation
wsystems
whic
9h
main
tain
enough
in
termo
A
dule
:
comm
9unication
?
to
mak
e
global
analyses
p
A
ossible
.
?
De
-
:
v
9elopmen
t
fof
suc
9h
a
framew
ork
w
ould
b
A
ene
t
not
only
:
strictness
o
analysis
but
man
9y
asp
A
ects
of
compile
time
:
optimisation
.
Suc
9h
a
compiler
migh
t
w
ork
b
y
dump
-
:
ing
^
a
lot
of
information
in
9to
a
mo
A
dule
'
s
in
terface
le
:
enough
A
to
do
whatev
9er
analyses
w
e
need
.
This
w
ould
:
really
just
b
A
e
an
extension
of
the
sc
9hemes
used
al
-
:
ready
a
in
the
Chalmers
and
Glasgo
9w
compilers
s
whic
h
:
dump
{
function
arit
9y
and
rudimen
tary
strictness
infor
-
:
mation
in
9to
in
terface
les
.
The
question
is
not
re
-
:
ally
whether
w
9e
could
construct
suc
h
a
system
but
:
whether
the
quan
9tit
y
of
information
dump
A
ed
in
9to
in
-
:
terface
3
les
could
b
A
e
limited
su
cien
9tly
to
render
the
:
sc
9heme
Tpractical
.
Ackno
wledgements
Thanks
9
to
Bill
Mitc
9hell
for
advice
on
building
term
rewrit
-
ing
systems
and
to
Barney
Hilk
9en
for
an
in
v
|
raluable
insigh
t
regarding
separate
compilation
systems
.
Mark
Jones
pro
-
vided
man
9y
in
teresting
commen
ts
ab
A
out
monomorphisation
and
Oz
rsti
cation
^
and
outlined
the
instance
-
collecting
algo
-
rithm
of
Section
5
.
6
.
1
.
Geo
rey
Burn
and
Denis
Ho
9w
e
w
ere
su
cien
9tly
8
bra
v
e
to
exp
A
erimen
t
with
the
implemen
tation
and
Tpro
9vided
useful
feedbac
k
.
Denis
Ho
9w
e
read
an
early
draft
in
min
ute
detail
.
:
His
exten
-
siv
9e
|
and
sometimes
am
using
-
=
2
#
commen
ts
pro
v
ed
v
ery
helpful
in
Tmaking
the
presen
9tation
clearer
.
References
[
Aug87
]
fL
.
|
Augustsson
.
RCompiling
J
L
azy
F
J
unctional
L
an
-
fguages
l
Part
f
II
.
h
PhD
/
thesis
6WChalmers
/
T
:
eknisk
|
ra
fH
ogsk
9ola
TG
oteb
A
org
Sw
9eden
1987
.
[
Aug93
]
fLennart
Augustsson
.
b
Implemen
9ting
hask
ell
o
v
er
-
floading
.
-
In
RPr
o
c
e
e
dings
AEof
the
F
J
unctional
Pr
o
-
fgr
amming
L
anguages
and
Computer
A
r
chite
ctur
e
fConfer
enc
e
N
<
Cop
enhagen
Denmark
TJune
1993
.
[
Bar91
]
fG
.
Baraki
.
uA
note
on
abstract
in
9terpretation
fof
Qp
A
olymorphic
functions
.
}
In
R
.
J
.
M
.
Hughes
feditor
RPr
o
c
e
e
dings
of
the
fth
A
CM
c
onfer
enc
e
fon
6
F
J
unctional
L
anguages
and
Computer
A
r
chi
-
fte
ctur
e
Fn
9um
b
A
er
:
523
in
Lecture
Notes
in
Com
-
fputer
{
Science
&
pages
367
{
378
Cam
9bridge
Mas
-
fsac
9h
usetts
T26
{
30
August
1991
.
Springer
-
V
:
erlag
.
ff
_
r
}
r
2
Y
See
the
other
fo
7
otnote
.
[
BHA85
]
#
fG
.
L
.
0Burn
C
.
L
.
Hankin
and
S
.
Abramsky
:
.
#
fThe
theory
of
strictness
analysis
for
higher
-
order
#
ffunctions
.
M
In
~
Q
RPr
o
c
e
e
dings
of
the
Workshop
on
#
fPr
o
gr
ams
as
Data
Obje
cts
Fpages
42
{
62
DIKU
#
fCop
A
enhagen
Denmark
17
{
19
Octob
er
1985
.
#
fSpringer
-
V
:
erlag
TLNCS
217
.
V
[
Bur87
]
#
fG
.
L
.
Burn
.
RA
bstr
act
)
)
Interpr
etation
and
the
Par
-
#
fal
x
lel
Evaluation
of
F
J
unctional
L
anguages
.
V
PhD
#
fthesis
Imp
A
erial
7PCollege
Univ
9ersit
y
of
London
#
fMarc
9h
T1987
.
[
Bur90
]
#
fG
.
L
.
}
Burn
.
Q
A
}
relationship
b
A
et
9w
een
}
abstract
in
-
#
fterpretation
k
{
and
pro
jection
analysis
.
In
R17th
)
A
n
-
#
fnual
F
A
CM
F
Symp
osium
on
the
Principles
of
Pr
o
-
#
fgr
amming
kL
anguages
l
pages
[
151
{
156
San
F
:
ran
-
#
fcisco
T17
{
19
Jan
9uary
1990
.
A
CM
.
[
Bur91
]
#
fG
.
L
.
yoBurn
.
RL
azy
F
J
unctional
L
anguages
:
bA
bstr
act
#
fInterpr
etation
<
and
Compilation
.
Researc
9h
I
Mono
-
#
fgraphs
in
P
9arallel
and
Distributed
Computing
.
#
fPitman
in
asso
A
ciation
with
MIT
Press
1991
.
CT
:
o
#
fapp
A
ear
.
[
CD91
]
#
fW
:
ei
-
Ngan
Chin
and
John
Darlington
.
Remo
9ving
#
fhigher
-
order
P
expressions
b
9y
program
transforma
-
#
ftion
.
Chin
zis
at
NUS
Singap
A
ore
and
Darlington
#
fat
<
|
Imp
A
erial
FFLondon
.
P
9ossibly
published
F
:
ebru
-
#
fary
T1991
.
[
Con91
]
#
fCharles
Consel
.
F
:
ast
strictness
analysis
via
#
fsym
9b
A
olic
JU
xp
oin
t
JUiteration
.
Unpublished
.
Y
:
ale
#
fUniv
9ersit
y
:
9
Departmen
t
[
of
Computer
Science
#
fSeptem
9b
A
er
T1991
.
[
Cur86
]
#
fP
:
.
-
L
.
Z
Curien
.
8
RCate
goric
al
Combinators
Se
quen
-
#
ftial
A
lgorithms
A
nd
F
J
unctional
Pr
o
gr
amming
.
#
fResearc
9h
\
Notes
in
Theoretical
Computer
Sci
-
#
fence
series
.
Pitman
Publishing
Limited
London
#
f1986
.
[
D
9W90
]
#
fKei
UDa
9vis
and
Philip
W
:
adler
.
n
Strictness
analysis
#
fin
4d
.
_7In
RIn
pr
o
c
e
e
dings
of
the
1990
Glasgow
Ayr
#
fFP
N
<
Workshop
(
?
?
)
T1990
.
[
Gro92
]
#
fThe
J
Y
:
ale
Hask
9ell
Group
.
WThe
y
ale
hask
ell
users
#
fman
9ual
Tv
ersion
y2
.
0
-
b
A
eta
August
1992
.
[
HH91
]
#
fSebastian
Hun
9t
and
Chris
Hankin
.
#
Fixed
p
A
oin
ts
#
fand
fron
9tiers
:
a
new
p
A
ersp
ectiv
e
.
/
RJournal
of
#
fF
J
unctional
-
Pr
o
gr
amming
01
(
1
)
:
91
&
{
120
Jan
9uary
#
f1991
.
[
HH92
]
#
fSebastian
7Hun
9t
and
Chris
Hankin
.
Appro
ximate
#
f
xed
p
A
oin
9ts
in
abstract
in
terpretation
.
X
In
RF
J
ourth
#
fEur
op
e
an
n
{
Symp
osium
on
Pr
o
gr
amming
v
R
ennes
#
fF
J
r
anc
e
T1992
.
LNCS
582
.
[
HL90
]
#
fR
.
J
.
M
.
5
Hughes
and
J
.
Launc
9h
bury
:
.
z
T
o
9w
ards
5
re
-
#
flating
forw
9ards
and
bac
kw
ards
analyses
.
In
RPr
o
-
#
fc
e
e
dings
Vof
the
Thir
d
A
nnual
Glasgow
Workshop
#
fon
Y
F
J
unctional
Pr
o
gr
amming
%
(
pages
!
145
{
155
Ul
-
#
flap
A
o
ol
TScotland
13
{
15
August
1990
.
[
HL92
]
#
fPieter
W
H
.
Hartel
and
Ko
A
en
G
.
Langendo
en
.
#
fBenc
9hmarking
implemen
tations
of
lazy
func
-
#
ftional
z
languages
.
G
T
:
ec
9hnical
rep
A
ort
Departmen
t
#
fof
FhComputer
Systems
F
:
acult
9y
of
Mathematics
#
fand
Computer
Science
Univ
9ersit
y
of
Amster
-
#
fdam
TDecem
9b
A
er
1992
.
29
?
[
HP90
]
fJohn
S
L
.
Hennessy
and
Da
9vid
A
.
P
atterson
.
RCom
-
fputer
}
A
r
chite
ctur
e
:
A
}
Quantitative
Appr
o
ach
.
fMorgan
36Kaufmann
Publishers
:
Inc
.
San
36Mateo
fCA
T1990
.
34
[
Hug
]
fJohn
3hHughes
.
Pro
jections
for
p
A
olymorphic
strict
-
fness
Q
(
analysis
.
In
RIn
7Springer
V
J
erlag
LNCS
)
389
.
fY
:
ear
Tand
conference
not
established
.
[
Hug87
]
fJohn
Hughes
.
Bac
9kw
ards
analysis
of
functional
fprograms
.
tT
:
ec
9hnical
>
Rep
A
ort
CSC
/
87
/
R3
S
Uni
-
fv
9ersit
y
\
of
Glasgo
9w
Departmen
t
\
of
Computing
fScience
TMarc
9h
1987
.
[
Hug90
]
fJohn
Hughes
.
j
Compile
-
time
analysis
of
func
-
ftional
programs
.
In
Da
9vid
A
.
T
:
urner
edi
-
ftor
KF
RR
ese
ar
ch
f
T
J
opics
in
F
unctional
Pr
o
gr
amming
.
fAddison
-
W
:
esley
A
Publishing
Compan
9y
#
1990
.
fF
:
rom
the
1987
Y
ear
of
Programming
KUniv
9ersit
y
fof
TT
:
exas
Austin
T
exas
.
[
Hug93
]
fJohn
7
Hughes
.
kPriv
|
rate
comm
9unication
regarding
fcdss
T1993
.
[
JM86
]
fNeil
D
.
Jones
and
Alan
Mycroft
.
P
Data
o
9w
anal
-
fysis
of
applicativ
9e
programs
using
minimal
func
-
ftion
graphs
:
Abridged
v
9ersion
.
mIn
RUnknown
6
)
but
fde
nitely
N
<
in
an
A
CM
pr
o
c
e
e
dings
T1986
.
[
Joh85
]
fT
.
7Johnsson
.
ULam
9b
A
da
lifting
:
6T
:
ransform
-
fing
Nprograms
to
recursiv
9e
equations
.
'
In
J
.
-
P
:
.
fJouannaud
8
editor
RPr
o
c
e
e
dings
"
of
the
Confer
-
fenc
e
on
F
J
unctional
Pr
o
gr
amming
L
anguages
and
fComputer
A
r
chite
ctur
e
pages
190
{
203
Nancy
:
fF
:
rance
TSeptem
9b
A
er
1985
.
[
Joh87
]
fT
.
Johnsson
.
dA
9ttribute
grammars
as
a
func
-
ftional
V
#
programming
paradigm
.
In
G
.
Kahn
fVed
-
fitor
RPr
o
c
e
e
dings
of
the
F
J
unctional
Pr
o
gr
amming
fL
anguages
and
Computer
A
r
chite
ctur
e
Confer
-
fenc
e
pages
154
{
173
.
Springer
-
V
:
erlag
LNCS
q274
fSeptem
9b
A
er
T1987
.
[
Jon93
]
fMark
0
Jones
.
f
P
9artial
ev
|
raluation
for
dictionary
-
ffree
_o
9v
erloading
.
Unpublished
draft
.
Y
:
ale
Uni
-
fv
9ersit
y
:
g
Departmen
t
V
of
Computer
Science
April
f1993
.
[
KHL91
]
fR
.
'
Kubiak
W
+
J
.
Hughes
and
J
.
Launc
9h
bury
:
.
VA
'
cpro
-
ftot
9yp
A
e
implemen
tation
of
pro
jection
-
based
rst
-
forder
p
A
olymorphic
strictness
analysis
.
c
In
R
.
Hel
-
fdal
editor
RDr
aft
Pr
o
c
e
e
dings
of
F
J
ourth
A
nnual
fGlasgow
)
Workshop
on
F
J
unctional
Pr
o
gr
amming
fpages
T322
{
343
Sky
9e
August
13
{
15
1991
.
[
Min92
]
fSa
9v
|
ra
Min
tc
hev
.
I
A
}
parallel
stg
-
mac
hine
.
I
Master
'
s
fthesis
6Departmen
9t
<
of
Computer
Science
Uni
-
fv
9ersit
y
Tof
Manc
9hester
UK
Septem
b
A
er
1992
.
[
Myc80
]
fA
.
Mycroft
.
Theory
and
practice
of
transform
-
fing
:
call
-
b
9y
-
need
in
to
call
-
b
y
-
v
|
ralue
.
4In
R4th
o
Inter
-
fnational
Symp
osium
on
Pr
o
gr
amming
Gpages
269
f
{
281
luP
9aris
April
'
1980
.
Springer
-
V
:
erlag
LNCS
f83
.
[
Nel
]
fGeorge
+
FC
.
Nelan
.
[
4Firsti
cation
.
Date
+
Funkno
9wn
fbut
m
9ust
b
A
e
1992
or
after
.
Based
on
Nelan
'
s
PhD
fthesis
.
TArizona
State
Univ
9ersit
y
:
.
[
NN92
]
#
fF
.
Nielson
and
H
.
R
.
Nielson
.
<
Finiteness
condi
-
#
ftions
F
for
xed
p
A
oin
9t
iteration
.
T
:
ec
hnical
rep
A
ort
#
fComputer
Science
Departmen
9t
Aarh
us
Univ
er
-
#
fsit
9y
:
TDenmark
F
ebruary
1992
.
34
[
P
9ar92
]
#
fWill
P
9artain
.
AThe
Mnofib
b
A
enc
hmark
suite
#
fof
hask
9ell
programs
.
D
In
RFifth
A
nnual
Glas
-
#
fgow
{
rWorkshop
on
F
J
unctional
Pr
o
gr
amming
Ayr
#
f1992
.
[
PC87
]
#
fSimon
!
P
9eyton
Jones
and
Chris
Clac
k
.
v
&
Finding
#
f
xp
A
oin
9ts
/
in
abstract
in
terpretation
.
In
S
.
Abram
-
#
fsky
and
C
.
L
.
Hankin
Neditors
RA
bstr
act
4
Interpr
e
-
#
ftation
8Iof
De
clar
ative
8IL
anguages
8Computers
qand
#
fTheir
'
Applications
0
c
9hapter
11
pages
246
{
265
.
#
fEllis
THorw
9o
A
o
d
1987
.
[
P
9ey87
]
#
fS
.
L
.
rDP
9eyton
Jones
.
RThe
eImplementation
of
F
J
unc
-
#
ftional
d
Pr
o
gr
amming
L
anguages
.
{
wPren
9tice
-
Hall
In
-
#
fternational
!
Series
in
Computer
Science
.
Pren
9tice
-
#
fHall
TIn
9ternational
(
UK
)
Ltd
London
1987
.
[
PHHP93
]
#
fS
.
L
.
EP
9eyton
Jones
Cordelia
V
+
Hall
Kevin
Ham
-
#
fmond
and
a
Will
P
9artain
.
The
glasgo
w
hask
ell
#
fcompiler
:
a
tec
9hnical
o
v
erview
.
C
+
In
RPr
o
c
e
e
dings
<
of
#
fthe
DUK
0Join
F
J
r
amework
for
Information
T
e
chol
-
#
fo
gy
N
<
Ke
ele
T1993
.
[
PJ92
]
#
fS
.
L
.
P
9eyton
Jones
.
2
Implemen
ting
lazy
functional
#
flanguages
c
on
sto
A
c
9k
hardw
are
:
the
spineless
tag
-
#
fless
JG
-
Mac
9hine
.
k
RJournal
cof
F
J
unctional
Pr
o
gr
am
-
#
fming
T2
(
2
)
:
127
{
202
April
1992
.
[
Sew91
]
#
fJulian
nSew
9ard
.
GT
:
o
w
ards
a
strictness
analyser
for
#
fhask
9ell
:
#
Putting
theory
in
to
practice
.
T
Master
'
s
#
fthesis
#
Univ
9ersit
y
of
Manc
9hester
Departmen
t
of
#
fComputer
Science
E1991
.
T
Av
|
railable
as
Univ
9ersit
y
#
fof
TManc
9hester
T
:
ec
hnical
Rep
A
ort
UMCS
-
92
-
2
-
2
.
[
Sew92
]
#
fJulian
Sew
9ard
.
e
P
olymorphic
higher
order
strict
-
#
fness
|
ianalysis
using
fron
9tiers
.
Unpublished
pap
A
er
#
f1992
.
[
Sew93
]
#
fJulian
Sew
9ard
.
R
#
P
olymorphic
strictness
analysis
#
fusing
fron
9tiers
.
ZRIn
RPr
o
c
e
e
dings
of
the
Symp
o
-
#
fsium
on
Partial
Evaluation
and
Semantics
b
ase
d
#
fPr
o
gr
am
t
Manipulation
PEPM93
Cop
enhagen
#
fDenmark
TJune
1993
.
[
W
:
ad87
]
#
fP
:
.
L
.
d
W
adler
.
:
Strictness
analysis
on
non
-
at
do
-
#
fmains
(
b
9y
abstract
in
terpretation
o
v
er
nite
do
-
#
fmains
)
.
In
US
.
Abramsky
and
C
.
L
.
Hankin
edi
-
#
ftors
-
RA
bstr
act
SInterpr
etation
of
De
clar
ative
L
an
-
#
fguages
z
c
9hapter
12
pages
266
{
275
.
Ellis
Hor
-
#
fw
9o
A
o
d
s
Ltd
.
sChic
hester
W
:
est
s
Sussex
England
#
f1987
.
[
W
:
ad92
]
#
fPhilip
c
W
:
adler
.
-
The
essence
of
functional
pro
-
#
fgramming
.
=
;
In
x
RPr
o
c
e
e
dings
of
the
19th
A
nnual
#
fSymp
osium
qon
Principles
of
Pr
o
gr
amming
L
an
-
#
fguages
N
<
Santa
F
J
e
New
Mexic
o
T1992
.
[
WH87
]
#
fP
:
.
"
)
W
adler
and
R
.
J
.
M
.
Hughes
.
Pro
jections
for
#
fstrictness
)
analysis
.
U
In
G
.
Kahn
.
;
editor
RPr
o
c
e
e
d
-
#
fings
=
3of
the
F
J
unctional
Pr
o
gr
amming
=
3L
anguages
#
fand
r
~
Computer
A
r
chite
ctur
e
r
~
Confer
enc
e
pages
#
f385
{
407
.
N
Springer
-
V
:
erlag
LNCS
NQ274
\
Septem
9b
A
er
#
f1987
.
30
w
?
[
W
:
ra85
]
fS
.
C
.
W
:
ra
9y
.
~
\
A
new
strictness
detection
algorithm
.
fIn
'
RPr
o
c
e
e
dings
_Rof
the
Workshop
on
Implementa
-
ftions
~
of
F
J
unctional
L
anguages
jAsp
enas
Swe
den
.
fA
vailable
N
<
as
Chalmers
PMG
r
ep
ort
N
<
17
T1985
.
34
[
Y
:
ou89
]
fJ
.
H
.
aY
:
oung
.
n
RThe
The
ory
and
Pr
actic
e
of
Seman
-
ftic
Pr
o
gr
am
A
nalysis
for
Higher
-
Or
der
F
J
unc
-
ftional
%
Pr
o
gr
amming
L
anguages
.
PhD
wthesis
yDe
-
fpartmen
9t
T
of
Computer
Science
djY
:
ale
Univ
ersit
y
:
fMa
9y
T1989
.
31
9
.
;
R
j
cmti9
P
cmsy9
O5
"
cmmi9
Nt
:
cmbx9
M
N
cmtt9
7
<
x
3
cmtt10
*
Aa
cmr6
(
K
y
3
cmr10
N
ff
cmbx12
X
Q
ff
cmr12
o
cmr9
kAH
cmssbx10
!
"
cmsy10
0n
cmsy5
R
cmr7
Z
cmr5
;
