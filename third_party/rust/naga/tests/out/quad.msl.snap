-
-
-
source
:
tests
/
snapshots
.
rs
expression
:
msl
-
-
-
#
include
<
metal_stdlib
>
#
include
<
simd
/
simd
.
h
>
constexpr
constant
float
c_scale
=
1
.
2
;
constexpr
constant
float
const_0f
=
0
.
0
;
constexpr
constant
float
const_1f
=
1
.
0
;
typedef
float
type
;
typedef
metal
:
:
float2
type1
;
typedef
metal
:
:
float4
type2
;
struct
VertexOutput
{
type1
uv
;
type2
position
;
}
;
typedef
metal
:
:
texture2d
<
float
metal
:
:
access
:
:
sample
>
type3
;
typedef
metal
:
:
sampler
type4
;
struct
main1Input
{
type1
pos
[
[
attribute
(
0
)
]
]
;
type1
uv1
[
[
attribute
(
1
)
]
]
;
}
;
struct
main1Output
{
type1
uv
[
[
user
(
loc0
)
]
]
;
type2
position
[
[
position
]
]
;
}
;
vertex
main1Output
main1
(
main1Input
varyings
[
[
stage_in
]
]
)
{
const
auto
pos
=
varyings
.
pos
;
const
auto
uv1
=
varyings
.
uv1
;
VertexOutput
out
;
out
.
uv
=
uv1
;
out
.
position
=
metal
:
:
float4
(
c_scale
*
pos
const_0f
const_1f
)
;
const
auto
_tmp
=
out
;
return
main1Output
{
_tmp
.
uv
_tmp
.
position
}
;
}
struct
main2Input
{
type1
uv2
[
[
user
(
loc0
)
]
]
;
}
;
struct
main2Output
{
type2
member1
[
[
color
(
0
)
]
]
;
}
;
fragment
main2Output
main2
(
main2Input
varyings1
[
[
stage_in
]
]
type3
u_texture
[
[
texture
(
0
)
]
]
type4
u_sampler
[
[
sampler
(
0
)
]
]
)
{
const
auto
uv2
=
varyings1
.
uv2
;
metal
:
:
float4
_expr4
=
u_texture
.
sample
(
u_sampler
uv2
)
;
if
(
_expr4
.
w
=
=
const_0f
)
{
metal
:
:
discard_fragment
(
)
;
}
return
main2Output
{
_expr4
.
w
*
_expr4
}
;
}
