/
*
-
*
-
Mode
:
C
+
+
;
tab
-
width
:
8
;
indent
-
tabs
-
mode
:
nil
;
c
-
basic
-
offset
:
2
-
*
-
*
/
/
*
vim
:
set
sw
=
2
ts
=
8
et
tw
=
80
:
*
/
/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
#
include
"
ParentProcessDocumentChannel
.
h
"
extern
mozilla
:
:
LazyLogModule
gDocumentChannelLog
;
#
define
LOG
(
fmt
)
MOZ_LOG
(
gDocumentChannelLog
mozilla
:
:
LogLevel
:
:
Verbose
fmt
)
namespace
mozilla
{
namespace
net
{
NS_IMPL_ISUPPORTS_INHERITED
(
ParentProcessDocumentChannel
DocumentChannel
nsIAsyncVerifyRedirectCallback
)
ParentProcessDocumentChannel
:
:
ParentProcessDocumentChannel
(
nsDocShellLoadState
*
aLoadState
class
LoadInfo
*
aLoadInfo
nsLoadFlags
aLoadFlags
uint32_t
aCacheKey
)
:
DocumentChannel
(
aLoadState
aLoadInfo
aLoadFlags
aCacheKey
)
{
LOG
(
(
"
ParentProcessDocumentChannel
ctor
[
this
=
%
p
]
"
this
)
)
;
}
ParentProcessDocumentChannel
:
:
~
ParentProcessDocumentChannel
(
)
{
LOG
(
(
"
ParentProcessDocumentChannel
dtor
[
this
=
%
p
]
"
this
)
)
;
}
RefPtr
<
PDocumentChannelParent
:
:
RedirectToRealChannelPromise
>
ParentProcessDocumentChannel
:
:
RedirectToRealChannel
(
nsTArray
<
ipc
:
:
Endpoint
<
extensions
:
:
PStreamFilterParent
>
>
&
&
aStreamFilterEndpoints
uint32_t
aRedirectFlags
uint32_t
aLoadFlags
)
{
LOG
(
(
"
ParentProcessDocumentChannel
RedirectToRealChannel
[
this
=
%
p
]
"
this
)
)
;
nsCOMPtr
<
nsIChannel
>
channel
=
mDocumentLoadListener
-
>
GetChannel
(
)
;
channel
-
>
SetLoadFlags
(
aLoadFlags
)
;
channel
-
>
SetNotificationCallbacks
(
mCallbacks
)
;
if
(
mLoadGroup
)
{
channel
-
>
SetLoadGroup
(
mLoadGroup
)
;
}
mLastVisitInfo
=
mDocumentLoadListener
-
>
LastVisitInfo
(
)
;
mRedirects
=
mDocumentLoadListener
-
>
Redirects
(
)
;
mStreamFilterEndpoints
=
std
:
:
move
(
aStreamFilterEndpoints
)
;
RefPtr
<
PDocumentChannelParent
:
:
RedirectToRealChannelPromise
>
p
=
mPromise
.
Ensure
(
__func__
)
;
nsresult
rv
=
gHttpHandler
-
>
AsyncOnChannelRedirect
(
this
channel
aRedirectFlags
)
;
if
(
NS_FAILED
(
rv
)
)
{
OnRedirectVerifyCallback
(
rv
)
;
}
return
p
;
}
NS_IMETHODIMP
ParentProcessDocumentChannel
:
:
OnRedirectVerifyCallback
(
nsresult
aResult
)
{
LOG
(
(
"
ParentProcessDocumentChannel
OnRedirectVerifyCallback
[
this
=
%
p
"
"
aResult
=
%
d
]
"
this
int
(
aResult
)
)
)
;
MOZ_ASSERT
(
mDocumentLoadListener
)
;
if
(
NS_FAILED
(
aResult
)
)
{
Cancel
(
aResult
)
;
}
else
if
(
mCanceled
&
&
NS_SUCCEEDED
(
aResult
)
)
{
aResult
=
NS_BINDING_ABORTED
;
}
else
{
const
nsCOMPtr
<
nsIChannel
>
channel
=
mDocumentLoadListener
-
>
GetChannel
(
)
;
mLoadGroup
-
>
AddRequest
(
channel
nullptr
)
;
/
/
Adding
the
channel
to
the
loadgroup
could
have
triggered
a
status
/
/
change
with
an
observer
being
called
destroying
the
docShell
resulting
/
/
in
the
PPDC
to
be
canceled
.
if
(
!
mCanceled
)
{
mLoadGroup
-
>
RemoveRequest
(
this
nullptr
NS_BINDING_REDIRECTED
)
;
for
(
auto
&
endpoint
:
mStreamFilterEndpoints
)
{
extensions
:
:
StreamFilterParent
:
:
Attach
(
channel
std
:
:
move
(
endpoint
)
)
;
}
if
(
!
mDocumentLoadListener
-
>
ResumeSuspendedChannel
(
mListener
)
)
{
/
/
We
added
ourselves
to
the
load
group
but
attempting
/
/
to
resume
has
notified
us
that
the
channel
is
already
/
/
finished
.
Better
remove
ourselves
from
the
loadgroup
/
/
again
.
nsresult
status
=
NS_OK
;
channel
-
>
GetStatus
(
&
status
)
;
mLoadGroup
-
>
RemoveRequest
(
channel
nullptr
status
)
;
}
}
}
mLoadGroup
=
nullptr
;
mListener
=
nullptr
;
mCallbacks
=
nullptr
;
mDocumentLoadListener
-
>
DocumentChannelBridgeDisconnected
(
)
;
mDocumentLoadListener
=
nullptr
;
mPromise
.
ResolveIfExists
(
aResult
__func__
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ParentProcessDocumentChannel
:
:
AsyncOpen
(
nsIStreamListener
*
aListener
)
{
LOG
(
(
"
ParentProcessDocumentChannel
AsyncOpen
[
this
=
%
p
]
"
this
)
)
;
nsCOMPtr
<
nsILoadContext
>
loadContext
;
NS_QueryNotificationCallbacks
(
this
loadContext
)
;
mDocumentLoadListener
=
new
DocumentLoadListener
(
GetDocShell
(
)
-
>
GetBrowsingContext
(
)
-
>
Canonical
(
)
loadContext
this
)
;
LOG
(
(
"
Created
PPDocumentChannel
with
listener
=
%
p
"
mDocumentLoadListener
.
get
(
)
)
)
;
gHttpHandler
-
>
OnOpeningDocumentRequest
(
this
)
;
nsresult
rv
=
NS_OK
;
Maybe
<
dom
:
:
ClientInfo
>
initialClientInfo
=
mInitialClientInfo
;
if
(
!
mDocumentLoadListener
-
>
Open
(
mLoadState
mLoadFlags
mCacheKey
mChannelId
mAsyncOpenTime
mTiming
std
:
:
move
(
initialClientInfo
)
GetDocShell
(
)
-
>
GetOuterWindowID
(
)
GetDocShell
(
)
-
>
GetBrowsingContext
(
)
-
>
HasValidTransientUserGestureActivation
(
)
&
rv
)
)
{
MOZ_ASSERT
(
NS_FAILED
(
rv
)
)
;
mDocumentLoadListener
-
>
DocumentChannelBridgeDisconnected
(
)
;
mDocumentLoadListener
=
nullptr
;
return
rv
;
}
mListener
=
aListener
;
if
(
mLoadGroup
)
{
mLoadGroup
-
>
AddRequest
(
this
nullptr
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
ParentProcessDocumentChannel
:
:
Cancel
(
nsresult
aStatus
)
{
LOG
(
(
"
ParentProcessDocumentChannel
Cancel
[
this
=
%
p
]
"
this
)
)
;
if
(
mCanceled
)
{
return
NS_OK
;
}
mCanceled
=
true
;
mDocumentLoadListener
-
>
Cancel
(
aStatus
)
;
ShutdownListeners
(
aStatus
)
;
return
NS_OK
;
}
}
/
/
namespace
net
}
/
/
namespace
mozilla
#
undef
LOG
